////////////////////////////////////////////
;(function (packageFunction) {
  /* istanbul ignore next */
  var p = window.AmazonUIPageJS || window.P;
  /* istanbul ignore next */
  var attribute = p._namespace || p.attributeErrors;
  /* istanbul ignore next */
  var namespacedP = attribute ? attribute("ACICAssets", "") : p;

  /* istanbul ignore next */
  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET ACICAssets - 1.0
/////////////////////////
// BEGIN FILE js/acic.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@amzn/katal-logger/dist/helper/metrics-aggregator.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/dist/helper/metrics-aggregator.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.MetricsAggregator = void 0;
var MetricsAggregator = /** @class */ (function () {
    function MetricsAggregator(filterFunction) {
        var _this = this;
        this.filterFunction = filterFunction;
        this.aggregatedMetrics = {};
        window.addEventListener('katal.metrics.publish', function (event) {
            _this.aggregateMetric(event);
        });
    }
    MetricsAggregator.prototype.aggregateMetric = function (event) {
        var _a = event.detail, metric = _a.metric, context = _a.context;
        var serviceName = context.serviceName, methodName = context.methodName;
        if (this.filterFunction && !this.filterFunction(metric, context)) {
            return;
        }
        this.aggregatedMetrics[serviceName] =
            this.aggregatedMetrics[serviceName] || {};
        this.aggregatedMetrics[serviceName][methodName] =
            this.aggregatedMetrics[serviceName][methodName] || {};
        this.aggregatedMetrics[serviceName][methodName][metric.name] =
            this.aggregatedMetrics[serviceName][methodName][metric.name] || [];
        this.aggregatedMetrics[serviceName][methodName][metric.name].push(metric.value);
    };
    return MetricsAggregator;
}());
exports.MetricsAggregator = MetricsAggregator;
//# sourceMappingURL=metrics-aggregator.js.map

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/dist/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Level = void 0;
var promise_polyfill_1 = __importDefault(__webpack_require__(/*! promise-polyfill */ "./node_modules/@amzn/katal-logger/node_modules/promise-polyfill/src/index.js"));
var stacktrace_js_1 = __importDefault(__webpack_require__(/*! stacktrace-js */ "./node_modules/@amzn/katal-logger/node_modules/stacktrace-js/stacktrace.js"));
var katal_metrics_1 = __webpack_require__(/*! ./metrics/katal-metrics */ "./node_modules/@amzn/katal-logger/dist/metrics/katal-metrics.js");
var metrics_aggregator_1 = __webpack_require__(/*! ./helper/metrics-aggregator */ "./node_modules/@amzn/katal-logger/dist/helper/metrics-aggregator.js");
var Level;
(function (Level) {
    Level["DEBUG"] = "debug";
    Level["INFO"] = "info";
    Level["WARN"] = "warn";
    Level["ERROR"] = "error";
    Level["FATAL"] = "fatal";
})(Level = exports.Level || (exports.Level = {}));
var LOG_LEVELS = [
    Level.DEBUG,
    Level.INFO,
    Level.WARN,
    Level.ERROR,
    Level.FATAL,
];
var DEFAULT_MAX_LOG_LINE_SIZE = 10000; // 10 kilobytes default
var DEFAULT_BATCH_TIMEOUT_DURATION = 5000;
var DEFAULT_MAX_LOGS_PER_BATCH = 25;
var CONFIG_DEFAULTS = {
    logThreshold: Level.DEBUG,
    maxLogLineSize: DEFAULT_MAX_LOG_LINE_SIZE,
    batchTimeoutDuration: DEFAULT_BATCH_TIMEOUT_DURATION,
    decodeStackTrace: false,
    recordMetrics: true,
    context: {},
    headers: {},
    logToConsole: false,
    maxLogsPerBatch: DEFAULT_MAX_LOGS_PER_BATCH,
    useXMLHttpRequest: false,
};
// obtained from https://developer.mozilla.org/en-US/docs/Web/API/Event
var EVENT_PROPERTIES = [
    'bubbles',
    'cancelBubble',
    'cancelable',
    'composed',
    'currentTarget',
    'deepPath',
    'defaultPrevented',
    'eventPhase',
    'explicitOriginalTarget',
    'originalTarget',
    'returnValue',
    'srcElement',
    'target',
    'timeStamp',
    'type',
    'isTrusted',
];
var ERROR_EVENT_PROPERTIES = __spreadArrays(EVENT_PROPERTIES, ['message']);
var KatalLogger = /** @class */ (function () {
    /**
     * Construct a KatalLogger
     *
     * @param config
     */
    function KatalLogger(config) {
        var _this = this;
        this.resourceTimingLogged = false;
        this.sendLogsToBackend = function () {
            var logsToSend = _this.logLineQueue;
            if (logsToSend.length === 0) {
                return;
            }
            _this.logLineQueue = [];
            _this.currentLogBatchSize = 0;
            var logs = {
                logs: logsToSend,
            };
            _this.sendLogToBackend(_this.toJSON(logs));
            _this.queueTimerId = undefined;
        };
        var configWithDefaults = __assign(__assign({}, CONFIG_DEFAULTS), config);
        this.url = configWithDefaults.url;
        this.logThreshold = configWithDefaults.logThreshold;
        this.maxLogLineSize = configWithDefaults.maxLogLineSize;
        this.context = configWithDefaults.context;
        this.logToConsole = configWithDefaults.logToConsole;
        this.headers = configWithDefaults.headers;
        this.recordMetrics = configWithDefaults.recordMetrics;
        this.batchTimeoutDuration = configWithDefaults.batchTimeoutDuration;
        this.decodeStackTrace = configWithDefaults.decodeStackTrace;
        this.maxLogsPerBatch = configWithDefaults.maxLogsPerBatch;
        // Some teams are setting maxLogsPerBatch as 0 for unit test cases which is making maxLogBatchSize as 0
        // and due to which this check `this.maxLogBatchSize < this.maxLogLineSize` is failing
        // and throwing an error during build time.
        // https://code.amazon.com/search?term=%22maxLogsPerBatch%3A+0%22
        this.maxLogBatchSize =
            config.maxLogBatchSize ||
                this.maxLogLineSize * (this.maxLogsPerBatch || 1);
        this.currentLogBatchSize = 0;
        this.xhrWithCredentials = configWithDefaults.xhrWithCredentials;
        this.useXMLHttpRequest = configWithDefaults.useXMLHttpRequest;
        this.logLineQueue = [];
        this.unregisterFns = [];
        this.unloaded = false;
        this.logThresholdIndex = Math.max(LOG_LEVELS.indexOf(Level.DEBUG), LOG_LEVELS.indexOf(this.logThreshold));
        if (this.maxLogBatchSize < this.maxLogLineSize) {
            throw new Error("maxLogBatchSize(" + this.maxLogBatchSize + ") must be greater than maxLogLineSize(" + this.maxLogLineSize + ")");
        }
        if (configWithDefaults.sendToBackendOverride &&
            typeof configWithDefaults.sendToBackendOverride === 'function') {
            this.sendLogToBackend = configWithDefaults.sendToBackendOverride;
        }
        if (this.recordMetrics) {
            this.metricsPublisher = katal_metrics_1.createMetricsPublisher('KatalLogger:Loaded');
            this.metricsPublisher.publishCounterMonitor('KatalLogger:construct', 1);
        }
        this.registerUnloadAction(function () {
            _this.unloaded = true;
            _this.sendLogsToBackend();
        });
        /**
         * Set this.unloaded to false to continue queueing the logs
         */
        this.registerBackToPageAction(function () {
            _this.unloaded = false;
        });
    }
    /**
     * Cover all of the unload cases:
     * https://www.igvita.com/2015/11/20/dont-lose-user-and-app-state-use-page-visibility/
     */
    KatalLogger.prototype.registerUnloadAction = function (callback) {
        this.registerEvent('pagehide', callback);
        this.registerEvent('beforeunload', callback);
        this.registerEvent('visibilitychange', function () {
            if (document.visibilityState === 'hidden') {
                callback();
            }
        });
    };
    /**
     * Check if the user comes back to the page
     * https://t.corp.amazon.com/D69927460
     */
    KatalLogger.prototype.registerBackToPageAction = function (callback) {
        this.registerEvent('pageshow', callback);
        this.registerEvent('visibilitychange', function () {
            if (document.visibilityState === 'visible') {
                callback();
            }
        });
    };
    /**
     * Log a copy of Katal Metrics emitted on this page
     * @param filterFunction: an optional function to filter metrics before publishing
     */
    KatalLogger.prototype.addMetricsListener = function (filterFunction) {
        var _this = this;
        var aggregator = new metrics_aggregator_1.MetricsAggregator(filterFunction);
        var unloadedAlready = false;
        this.registerUnloadAction(function () {
            if (unloadedAlready)
                return;
            unloadedAlready = true;
            _this.info('Katal Metrics', aggregator.aggregatedMetrics);
        });
    };
    /**
     * Adds a formatted version of Performance API logs.
     * Uses https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries
     * to determine resource and paint timings.
     */
    KatalLogger.prototype.addPerformanceListener = function () {
        var _this = this;
        this.registerUnloadAction(function () {
            _this.logResourceTiming();
        });
    };
    KatalLogger.prototype.logResourceTiming = function () {
        var _a, _b;
        if (this.resourceTimingLogged) {
            return;
        }
        this.resourceTimingLogged = true;
        var resource = window.performance
            .getEntriesByType('resource')
            .reduce(function (acc, resourceTiming) {
            var _a;
            var _b = resourceTiming, name = _b.name, initiatorType = _b.initiatorType, duration = _b.duration;
            var resource = name.split('/').pop();
            acc[initiatorType] = (_a = acc[initiatorType]) !== null && _a !== void 0 ? _a : {};
            acc[initiatorType][resource] = Math.round(duration);
            return acc;
        }, {});
        var paint = window.performance
            .getEntriesByType('paint')
            .reduce(function (acc, _a) {
            var name = _a.name, startTime = _a.startTime;
            acc[name] = Math.round(startTime);
            return acc;
        }, {});
        var navigation = Object.entries((_b = (_a = window.performance.getEntriesByType('navigation')[0]) === null || _a === void 0 ? void 0 : _a.toJSON()) !== null && _b !== void 0 ? _b : {}).reduce(function (acc, _a) {
            var key = _a[0], value = _a[1];
            acc[key] = typeof value === 'number' ? Math.round(value) : value;
            return acc;
        }, {});
        this.info("Performance Timing", { resource: resource, paint: paint, navigation: navigation });
    };
    /**
     * Adds an event listener for errors. Will log the error if the filter callback returns true
     *
     * @param filterCallback function that takes an error object and returns whether it should be logged
     */
    KatalLogger.prototype.addErrorListener = function (filterCallback) {
        var _this = this;
        ['error', 'unhandledrejection'].map(function (listener) {
            _this.registerEvent(listener, 
            /* istanbul ignore next - this.eventListener tested seperately */
            function (e) {
                return _this.eventListener(e, filterCallback);
            }, true);
        });
    };
    /**
     * Removes the registered error event listeners
     * Normal applications need not call this.
     * This is required for multitenant SPAs to avoid memory leaks.
     */
    KatalLogger.prototype.removeErrorListener = function () {
        this.unregisterFns.forEach(function (fn) { return fn(); });
    };
    KatalLogger.prototype.registerEvent = function (event, cb, capture) {
        window.addEventListener(event, cb, capture);
        this.unregisterFns.push(function () {
            window.removeEventListener(event, cb, capture);
        });
    };
    KatalLogger.prototype.eventListener = function (e, filterCallback) {
        var errorMessage;
        var error;
        // e is an ErrorEvent
        if (e.error) {
            errorMessage = e.error.message;
            error = e.error;
        }
        // e is PromiseRejectionEvent
        else if (e.reason) {
            if (isError(e.reason)) {
                errorMessage = e.reason.message;
                error = e.reason;
            }
            else {
                errorMessage = e.reason;
            }
        }
        else if (isError(e)) {
            errorMessage = e.message;
            error = e;
        }
        else {
            errorMessage = "An unknown error occurred: " + this.toStringObject(e);
            // Capture a stack trace
            error = new Error('Unknown error');
        }
        if (errorMessage !== 'KatalLogger error' &&
            (!filterCallback || filterCallback(error))) {
            try {
                return this.error(errorMessage, error);
            }
            catch (_) {
                // Prevent infinite loops by swallowing errors that occur while logging errors
            }
        }
    };
    KatalLogger.prototype.createJsonStringifyReplacer = function () {
        var cache = new Map();
        return function (key, value) {
            if (typeof value === 'object' && value != null) {
                if (cache.has(value)) {
                    return "reference-loop, also referenced from '" + cache.get(value) + "'";
                }
                cache.set(value, key);
            }
            return value;
        };
    };
    /**
     * Event objects are hard to serialize (see https://stackoverflow.com/questions/11547672/how-to-stringify-event-object) so we need a helper method
     */
    KatalLogger.prototype.toStringObject = function (object) {
        var constructorName = object.constructor.name;
        if (object instanceof Event) {
            var objectProperties = EVENT_PROPERTIES;
            var eventObject = {};
            /** if error event, we need to capture the error message */
            if (object instanceof ErrorEvent) {
                objectProperties = ERROR_EVENT_PROPERTIES;
            }
            for (var _i = 0, objectProperties_1 = objectProperties; _i < objectProperties_1.length; _i++) {
                var prop = objectProperties_1[_i];
                /** ignore serializing and logging the entire window log
                 */
                if (object[prop] !== window) {
                    eventObject[prop] = object[prop];
                }
            }
            object = eventObject;
        }
        return constructorName + ':' + this.toJSON(object);
    };
    /**
     * JSON.stringify can throw but we really don't want to error when logging error
     * so use our own error-safe serialization
     */
    KatalLogger.prototype.toJSON = function (data) {
        var stringified;
        try {
            stringified = JSON.stringify(data, this.createJsonStringifyReplacer());
        }
        catch (error) {
            stringified = "{ \"KatalLogger\": \"Failed to serialize!\", \"data\": \"" + data + "\", \"error\": \"" + error + "\" }";
        }
        return stringified;
    };
    KatalLogger.prototype.debug = function (message, error, context) {
        var _this = this;
        return this.extractArgs(Level.DEBUG, message, error, context).then(function (args) {
            return _this.sendRequest(args);
        });
    };
    KatalLogger.prototype.info = function (message, error, context) {
        var _this = this;
        return this.extractArgs(Level.INFO, message, error, context).then(function (args) {
            return _this.sendRequest(args);
        });
    };
    KatalLogger.prototype.warn = function (message, error, context) {
        var _this = this;
        return this.extractArgs(Level.WARN, message, error, context).then(function (args) {
            return _this.sendRequest(args);
        });
    };
    KatalLogger.prototype.error = function (message, error, context) {
        var _this = this;
        return this.extractArgs(Level.ERROR, message, error, context).then(function (args) {
            return _this.sendRequest(args);
        });
    };
    KatalLogger.prototype.fatal = function (message, error, context) {
        var _this = this;
        return this.extractArgs(Level.FATAL, message, error, context).then(function (args) {
            return _this.sendRequest(args);
        });
    };
    KatalLogger.prototype.extractArgs = function (level, message, error, context) {
        var errorInfo = isError(error)
            ? {
                errorMessage: error.message,
                errorName: error.name,
                errorStackTrace: '',
            }
            : undefined;
        var logPayload = {
            level: level,
            message: message,
            error: errorInfo,
            context: __assign(__assign(__assign({}, this.context), (errorInfo ? context : error)), { logTime: Date.now() }),
        };
        if (logPayload.error) {
            return this.getStackTraceFromError(error).then(function (trace) {
                logPayload.error.errorStackTrace = trace;
                return logPayload;
            });
        }
        return promise_polyfill_1.default.resolve(logPayload);
    };
    KatalLogger.prototype.getStackTraceFromError = function (error) {
        if (!this.decodeStackTrace) {
            return promise_polyfill_1.default.resolve(String(error.stack));
        }
        return promise_polyfill_1.default.resolve(stacktrace_js_1.default.fromError(error)
            .then(function (stackframes) {
            return stackframes.map(function (sf) { return sf.toString(); }).join('\n');
        })
            .catch(function (err) {
            // we failed to decode it, just output raw
            return String(error.stack) +
                '\n\nFailed to decode stacktrace:\n' +
                String(err);
        }));
    };
    KatalLogger.prototype.sendRequest = function (payload) {
        this.queueLogLine(payload);
        if (this.logToConsole) {
            this.sendLogToConsole(payload);
        }
    };
    KatalLogger.prototype.sendLogToConsole = function (data) {
        var level = data.level;
        if (!LOG_LEVELS.includes(data.level) || data.level === Level.FATAL) {
            level = Level.ERROR;
        }
        console[level](data);
    };
    KatalLogger.prototype.queueLogLine = function (payload) {
        if (this.payloadIsValid(payload)) {
            var payloadSize = this.getPayloadSize(payload);
            if (this.currentLogBatchSize + payloadSize > this.maxLogBatchSize) {
                this.sendLogsToBackend();
            }
            this.appendToQueue(payload);
            this.currentLogBatchSize += payloadSize;
            if (this.unloaded || this.logLineQueue.length >= this.maxLogsPerBatch) {
                this.sendLogsToBackend();
            }
            else if (!this.queueTimerId) {
                this.queueTimerId = window.setTimeout(this.sendLogsToBackend, this.batchTimeoutDuration);
            }
        }
    };
    KatalLogger.prototype.appendToQueue = function (payload) {
        this.logLineQueue.push(payload);
    };
    KatalLogger.prototype.doCallBeacon = function () {
        return ((navigator === null || navigator === void 0 ? void 0 : navigator.sendBeacon) &&
            !(Object.keys(this.headers).length || this.useXMLHttpRequest));
    };
    KatalLogger.prototype.sendLogToBackend = function (dataString) {
        if (this.url) {
            if (this.doCallBeacon()) {
                navigator.sendBeacon(this.url, dataString);
            }
            else {
                var xhr_1 = new XMLHttpRequest();
                // xhr request is set to async.
                // In case this needs to be changed to sync, it should be noted that xhr.withCredentials with sync request is not supported since Firefox 11.
                // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#browser_compatibility
                xhr_1.open('POST', this.url, true);
                if (this.xhrWithCredentials) {
                    xhr_1.withCredentials = this.xhrWithCredentials;
                }
                Object.entries(this.headers).forEach(function (_a) {
                    var headerName = _a[0], headerValue = _a[1];
                    xhr_1.setRequestHeader(headerName, headerValue);
                });
                xhr_1.send(dataString);
            }
        }
    };
    KatalLogger.prototype.payloadIsValid = function (data) {
        var a = LOG_LEVELS.indexOf(data.level);
        var b = this.logThresholdIndex;
        var passesLogLevelCheck = a >= b;
        if (passesLogLevelCheck) {
            var payloadSize = this.getPayloadSize(data);
            if (payloadSize <= this.maxLogLineSize) {
                return true;
            }
        }
        return false;
    };
    KatalLogger.prototype.getPayloadSize = function (data) {
        var dataString = this.toJSON(data);
        return dataString.length;
    };
    return KatalLogger;
}());
exports.default = KatalLogger;
function isError(object) {
    /* istanbul ignore next - in node (unit tests) there is no error.constructor. In ie, there is no error.stack */
    return ((object === null || object === void 0 ? void 0 : object.name) && object.message && (object.stack || !!object.constructor));
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/dist/metrics/katal-metrics.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/dist/metrics/katal-metrics.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* istanbul ignore file */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createMetricsPublisher = void 0;
var metrics_publisher_singleton_1 = __webpack_require__(/*! ./metrics-publisher-singleton */ "./node_modules/@amzn/katal-logger/dist/metrics/metrics-publisher-singleton.js");
exports.createMetricsPublisher = function (methodName) {
    return metrics_publisher_singleton_1.MetricsPublisherSingleton.getInstance().newChildActionPublisherForMethod(methodName);
};
//# sourceMappingURL=katal-metrics.js.map

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/dist/metrics/metrics-publisher-singleton.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/dist/metrics/metrics-publisher-singleton.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetricsPublisherSingleton = void 0;
var KatalMetrics = __importStar(__webpack_require__(/*! @amzn/katal-metrics */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/index.js"));
var katal_metrics_driver_sushi_1 = __importDefault(__webpack_require__(/*! @amzn/katal-metrics-driver-sushi */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics-driver-sushi/dist/index.js"));
var MetricsPublisherSingleton = /** @class */ (function () {
    /* istanbul ignore next - Private constructor to prevent initializing the singleton */
    function MetricsPublisherSingleton() {
    }
    MetricsPublisherSingleton.getInstance = function () {
        if (!MetricsPublisherSingleton.instance) {
            /* istanbul ignore next - This is invoked by the metrics driver */
            var metricsErrorHandler = function (err) {
                console.error(err);
            };
            var metricsDriver = this.getMetricsDriver(metricsErrorHandler);
            var metricsContext = this.getMetricsContext();
            MetricsPublisherSingleton.instance = new KatalMetrics.Publisher(metricsDriver, metricsErrorHandler, metricsContext);
        }
        return MetricsPublisherSingleton.instance;
    };
    MetricsPublisherSingleton.getMetricsContext = function () {
        var urlMatch = /([^?]+)/.exec(window.location.href);
        var urlMetric = new KatalMetrics.Metric.String('url', 
        /* istanbul ignore next - This is invoked by the metrics context */
        urlMatch ? urlMatch[1] : window.location.href);
        urlMetric.truncate = true;
        return new KatalMetrics.Context.Builder()
            .withSite('KatalLoggerInternalMetrics')
            .withServiceName('KatalLogger')
            .addRelatedMetrics(urlMetric)
            .build();
    };
    MetricsPublisherSingleton.getMetricsDriver = function (metricsErrorHandler) {
        return new katal_metrics_driver_sushi_1.default.Builder()
            .withDomainRealm('prod', 'USAmazon')
            .withErrorHandler(metricsErrorHandler)
            .build();
    };
    return MetricsPublisherSingleton;
}());
exports.MetricsPublisherSingleton = MetricsPublisherSingleton;
//# sourceMappingURL=metrics-publisher-singleton.js.map

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics-driver-sushi/dist/KatalMetricsDriverSushi.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics-driver-sushi/dist/KatalMetricsDriverSushi.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KatalMetricsDriverSushi = void 0;

var _objectSpread2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/objectSpread */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/objectSpread.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/assertThisInitialized.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/inherits.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js"));

var _KatalMetricsDriver2 = _interopRequireDefault(__webpack_require__(/*! @amzn/katal-metrics/lib/driver/KatalMetricsDriver */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/driver/KatalMetricsDriver.js"));

var _KatalMetricType = _interopRequireDefault(__webpack_require__(/*! @amzn/katal-metrics/lib/metricObject/KatalMetricType */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricType.js"));

var _katalSushiClient = _interopRequireDefault(__webpack_require__(/*! @amzn/katal-sushi-client */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-sushi-client/dist/SushiClient.js"));

var _temp;

var KAT_STANDALONE_NEXUS_PRODUCER_ID = 'katal';
var KAT_STANDALONE_DEFAULT_SOURCE_GROUPS = {
  test: 'com.amazon.eel.katal.metrics.core.nexus.gamma',
  prod: 'com.amazon.eel.katal.metrics.core.nexus'
};

var KatalMetricsDriverSushi =
/*#__PURE__*/
function (_KatalMetricsDriver) {
  (0, _inherits2.default)(KatalMetricsDriverSushi, _KatalMetricsDriver);

  function KatalMetricsDriverSushi(options) {
    var _this;

    (0, _classCallCheck2.default)(this, KatalMetricsDriverSushi);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(KatalMetricsDriverSushi).call(this));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "sushi", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "producerId", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "sourceGroupId", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "errorHandler", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "combinedErrorHandler", function (err) {
      if (_this.errorHandler) {
        try {
          _this.errorHandler(err); // Return to avoid falling through to default error handler


          return;
        } catch (nextErr) {
          console.error("Error handling error publishing metrics:");
          console.error(nextErr); // Fall through
        }
      }

      _this.defaultErrorHandler(err);
    });
    var domain = options.domain,
        realm = options.realm,
        errorHandler = options.errorHandler,
        sushiClient = options.sushiClient,
        _options$sushiProduce = options.sushiProducer,
        producerId = _options$sushiProduce === void 0 ? KAT_STANDALONE_NEXUS_PRODUCER_ID : _options$sushiProduce,
        sushiClientOptions = options.sushiClientOptions,
        sushiClientTransportOverride = options.sushiClientTransportOverride; // custom source group always overrides defaults

    var sourceGroupId = options.sourceGroupId || KAT_STANDALONE_DEFAULT_SOURCE_GROUPS[domain] || KAT_STANDALONE_DEFAULT_SOURCE_GROUPS['test'];
    _this.sushi = sushiClient || _this.buildSushiClient(domain, realm, sourceGroupId, sushiClientOptions, sushiClientTransportOverride);
    _this.errorHandler = errorHandler;
    _this.producerId = producerId;
    _this.sourceGroupId = sourceGroupId;
    return _this;
  }

  (0, _createClass2.default)(KatalMetricsDriverSushi, [{
    key: "beforeUnload",

    /**
     * Register a callback to be called right before the page unloads. This
     * allows for any final metrics, such as page visit duration, to be sent
     * before the user navigates away from the page or closes the tab.
     * NOTE: This is an experimental API and may change in the future.
     * @param cb The callback to call.
     */
    value: function beforeUnload(cb) {
      this.sushi.onSushiUnload(cb);
    }
    /**
     * Default error handler if the user-supplied error handler fails or is unset.  Should never be called unless
     * user-provided error handler misbehaves.
     *
     * @param err Unhandled error object
     */

  }, {
    key: "defaultErrorHandler",
    value: function defaultErrorHandler(err) {
      console.error("Error publishing metrics:");
      console.error(err);
    }
    /**
     * Call the error-handler supplied by the user when this object was constructed; if that is unset or itself throws
     * an exception, calls the default error handler as a fallback, which will just log the error to the console.
     *
     * @param err Error object to handle
     */

  }, {
    key: "withErrorHandling",

    /**
     * Helper method to wrap a function in the error handler.
     *
     * @param doTheThing Function to run under the wrapper
     * @return Return value from called function
     */
    value: function withErrorHandling(doTheThing) {
      try {
        return doTheThing();
      } catch (err) {
        this.combinedErrorHandler(err);
      }
    }
  }, {
    key: "buildSushiClient",
    value: function buildSushiClient(domain, realm, sourceGroupId, sushiClientOptions, sushiClientTransportOverride) {
      if (!domain || !realm) {
        throw new Error('KatalMetricsDriverSushi requires a domain and realm to build a sushi client.');
      }

      return new _katalSushiClient.default(KatalMetricsDriverSushi.getRealmName(realm), sourceGroupId, this.combinedErrorHandler, sushiClientOptions, sushiClientTransportOverride);
    }
  }, {
    key: "publish",
    // TODO: errorHandler in this method is deprecated and is not referenced.
    // Tech debt: https://issues.amazon.com/issues/KAT-875
    value: function publish(metricObject, errorHandler, context) {
      var _this2 = this;

      // Support for new 2-argument form of publish, which does not pass the unused errorHandler object (KAT-875)
      var metricsContext = arguments.length < 3 ? arguments[1] : arguments[2];
      this.withErrorHandling(function () {
        // TODO: This logic is now moved into KatalMetricsPublisher, once everybody has that update we can remove this.
        // Tech debt: https://issues.amazon.com/issues/KAT-876
        if (_KatalMetricType.default.List === metricObject.type) {
          metricObject.metricList.forEach(function (metric) {
            _this2.publish(metric, metricsContext);
          });
          return;
        }

        var nexusSchema = _this2.mapObjectTypeToNexusSchema(metricObject.type);

        var fields = (0, _objectSpread2.default)({}, metricsContext.context, {
          metricKey: metricObject.name,
          value: metricObject.value
        });

        if (metricObject.isMonitor) {
          fields.isMonitor = true;
        } // Reset the event count back to 0, otherwise Sushi will stop publishing after 1K items (https://issues.amazon.com/issues/KAT-1534)


        _this2.sushi.reset();

        _this2.sushi.event(fields, _this2.producerId, nexusSchema, {
          "ssd": 1
        });
      });
    }
  }, {
    key: "mapObjectTypeToNexusSchema",
    value: function mapObjectTypeToNexusSchema(objectType) {
      switch (objectType) {
        case _KatalMetricType.default.String:
          return 'katal.client.metrics.String.2';

        case _KatalMetricType.default.Counter:
          return 'katal.client.metrics.Counter.3';

        case _KatalMetricType.default.Timer:
          return 'katal.client.metrics.Timer.2';

        default:
          throw new Error("Unknown type ".concat(objectType, " when publishing metric object."));
      }
    }
  }], [{
    key: "getRealmName",
    value: function getRealmName(realm) {
      switch (realm) {
        case 'NAAmazon':
        case 'USAmazon':
          return _katalSushiClient.default.REGIONS.NA;

        case 'EUAmazon':
          return _katalSushiClient.default.REGIONS.EU;

        case 'FEAmazon':
        case 'JPAmazon':
          return _katalSushiClient.default.REGIONS.FE;

        case 'CNAmazon':
          return _katalSushiClient.default.REGIONS.CN;

        default:
          // Let the SushiClient decide if this is bogus or not.
          return realm;
      }
    }
  }]);
  return KatalMetricsDriverSushi;
}(_KatalMetricsDriver2.default);

exports.KatalMetricsDriverSushi = KatalMetricsDriverSushi;
(0, _defineProperty2.default)(KatalMetricsDriverSushi, "Builder", (_temp =
/*#__PURE__*/
function () {
  function _temp() {
    (0, _classCallCheck2.default)(this, _temp);
    (0, _defineProperty2.default)(this, "context", {});
  }

  (0, _createClass2.default)(_temp, [{
    key: "withSushiClient",
    value: function withSushiClient(sushiClient) {
      this.context.sushiClient = sushiClient;
      return this;
    }
  }, {
    key: "withDomainRealm",
    value: function withDomainRealm(domain, realm) {
      this.context.domain = domain;
      this.context.realm = realm;
      return this;
    }
  }, {
    key: "withCustomProducer",
    value: function withCustomProducer(sushiProducerId) {
      this.context.sushiProducer = sushiProducerId;
      return this;
    }
  }, {
    key: "withCustomSourceGroup",
    value: function withCustomSourceGroup(sourceGroupId) {
      this.context.sourceGroupId = sourceGroupId;
      return this;
    }
  }, {
    key: "withErrorHandler",
    value: function withErrorHandler(errorHandler) {
      this.context.errorHandler = errorHandler;
      return this;
    }
  }, {
    key: "withSushiClientOptions",
    value: function withSushiClientOptions(sushiClientOptions) {
      this.context.sushiClientOptions = sushiClientOptions;
      return this;
    }
  }, {
    key: "withSushiClientTransportOverride",
    value: function withSushiClientTransportOverride(sushiClientTransportOverride) {
      this.context.sushiClientTransportOverride = sushiClientTransportOverride;
      return this;
    }
  }, {
    key: "build",
    value: function build() {
      return new KatalMetricsDriverSushi(this.context);
    }
  }]);
  return _temp;
}(), _temp));

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics-driver-sushi/dist/index.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics-driver-sushi/dist/index.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

__webpack_require__(/*! ./nodejsShims */ 0);

var _KatalMetricsDriverSushi = __webpack_require__(/*! ./KatalMetricsDriverSushi */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics-driver-sushi/dist/KatalMetricsDriverSushi.js");

/* istanbul ignore file */
var _default = _KatalMetricsDriverSushi.KatalMetricsDriverSushi;
exports.default = _default;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/KatalMetricsContext.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/KatalMetricsContext.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _objectSpread2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/objectSpread */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/objectSpread.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js"));

var _ValidateSimpleString = _interopRequireDefault(__webpack_require__(/*! ./helper/ValidateSimpleString */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleString.js"));

var _FirstMap = _interopRequireDefault(__webpack_require__(/*! ./helper/FirstMap */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/FirstMap.js"));

var _mergeLists = __webpack_require__(/*! ./helper/mergeLists */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/mergeLists.js");

var _embedRequestId = __webpack_require__(/*! ./helper/embedRequestId */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/embedRequestId.js");

var _temp;

var REQUIRED_FIELDS = ['site', 'serviceName', 'methodName'];

var KatalMetricsContext =
/*#__PURE__*/
function () {
  /**
   * Create a new metrics context with the given fields.
   *
   * @param contextFields Context fields value (default empty)
   */
  function KatalMetricsContext() {
    var contextFields = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, KatalMetricsContext);
    // Copy fields so this is immutable
    this.context = (0, _objectSpread2.default)({}, contextFields);
  }
  /**
   * Return a new KatalMetricsContext which is a copy of this context, with values added or overridden from
   * the given context.
   *
   * If the given context is null or empty, this method may return the original object as an optimization.
   *
   * @param thatContext Context to merge values from
   * @return New context with default values from this context, and values overridden or added by the given context.
   */


  (0, _createClass2.default)(KatalMetricsContext, [{
    key: "merge",
    value: function merge(thatContext) {
      if (!thatContext) return this; // Check for a common error

      if (thatContext instanceof KatalMetricsContext.Builder) {
        throw new Error("KatalMetricsContext.Builder object passed instead of KatalMetricsContext.  Try calling .build() method.");
      }

      var context = thatContext instanceof KatalMetricsContext ? thatContext.context : thatContext;
      var newContext = (0, _objectSpread2.default)({}, this.context, context, {
        relatedMetrics: (0, _mergeLists.mergeLists)(this.context.relatedMetrics, context.relatedMetrics),
        relatedMetricsSingleAction: (0, _mergeLists.mergeLists)(this.context.relatedMetricsSingleAction, context.relatedMetricsSingleAction)
      });
      return new KatalMetricsContext(newContext);
    }
    /**
     * Return a new context which is a copy of this context with relatedMetricsSingleAction removed.
     *
     * This is intended to be called when creating a new child publisher.
     *
     * @return Copy of this context, with relatedMetricsSingleAction removed
     */

  }, {
    key: "withoutRelatedMetricsSingleAction",
    value: function withoutRelatedMetricsSingleAction() {
      return new KatalMetricsContext((0, _objectSpread2.default)({}, this.context, {
        relatedMetricsSingleAction: undefined
      }));
    }
    /**
     * Get a context suitable for publication to the driver.
     *
     * This method strips out any private fields, and leaves only fields from the schema that the driver should publish.
     *
     * @return Context suitable for driver publication
     */

  }, {
    key: "driverContext",
    value: function driverContext() {
      // Don't publish relatedMetrics to the driver
      var newContextFields = (0, _objectSpread2.default)({}, this.context);
      delete newContextFields["relatedMetrics"];
      delete newContextFields["relatedMetricsSingleAction"];
      delete newContextFields["requestId"];

      if (this.context.requestId) {
        newContextFields.actionId = (0, _embedRequestId.embedRequestId)(newContextFields.actionId, this.context.requestId);
      }

      return new KatalMetricsContext(newContextFields);
    }
    /**
     * Get a simple JavaScript object with a copy of the fields for this context.
     *
     * @return Simple Javascript object with a copy of the fields for this context
     */

  }, {
    key: "getFields",
    value: function getFields() {
      // Copy fields so this remains immutable
      return (0, _objectSpread2.default)({}, this.context);
    }
    /**
     * Check for a validation error on this context.
     *
     * Returns the first validation error encountered if one is found, otherwise undefined.
     *
     * @returns Errors found with this context
     */

  }, {
    key: "validationError",
    value: function validationError() {
      var _this = this;

      var err; // Fields site, serviceName, methodName, and metricKey are required.

      err = (0, _FirstMap.default)(REQUIRED_FIELDS, function (field) {
        if (_this.context[field] == undefined) {
          return new Error("Field ".concat(field, " is required, but it is ").concat(_this.context[field]));
        }
      });
      if (err) return err;
      return (0, _FirstMap.default)(Object.keys(this.context), function (field) {
        return _this.validateField(field);
      });
    }
    /**
     * Validate an individual context field.
     *
     * @param field Name of field to validate
     * @returns Error found with this field, or undefined
     */

  }, {
    key: "validateField",
    value: function validateField(field) {
      var val = this.context[field];
      var nameForError = "field ".concat(field);

      switch (field) {
        // Strings which could be used as partition keys ("site" and "serviceName") cannot contain slashes, in
        // addition to the other restictions below.
        case 'site':
        case 'serviceName':
          if (val.indexOf('/') > -1) return new Error("Expected ".concat(nameForError, " to contain only valid characters, but it was ").concat(val, ".  It cannot contain a slash."));
        // Else fall through
        // Strings for fields site, serviceName, methodName, metricKey must match be valid PMET field names:
        // maximum length of 256, only letters, numbers, and the dot, colon, at-sign, underscore, forward-slash,
        // and slash characters (in short the regex ^[A-Za-z0-9.:@_/-]+$).

        case 'methodName':
        case 'actionId':
          return (0, _ValidateSimpleString.default)(val, nameForError);
      } // No error found, implicitly return undefined

    }
    /**
     * Builder class for KatalMetricsContext
     */

  }]);
  return KatalMetricsContext;
}();

exports.default = KatalMetricsContext;
(0, _defineProperty2.default)(KatalMetricsContext, "Builder", (_temp =
/*#__PURE__*/
function () {
  function _temp() {
    (0, _classCallCheck2.default)(this, _temp);
    (0, _defineProperty2.default)(this, "context", {});
  }

  (0, _createClass2.default)(_temp, [{
    key: "withSite",
    value: function withSite(site) {
      this.context.site = site;
      return this;
    }
  }, {
    key: "withServiceName",
    value: function withServiceName(serviceName) {
      this.context.serviceName = serviceName;
      return this;
    }
  }, {
    key: "withMethodName",
    value: function withMethodName(methodName) {
      this.context.methodName = methodName;
      return this;
    }
  }, {
    key: "withActionId",
    value: function withActionId(actionId) {
      this.context.actionId = actionId;
      return this;
    }
  }, {
    key: "withRequestId",
    value: function withRequestId(requestId) {
      this.context.requestId = requestId;
      return this;
    }
    /**
     * Replace any related metrics with the given list (see addRelatedMetrics to add instead of replace).
     *
     * Related metrics are metrics that are published whenever a new action is started.  They are used to relate the
     * action back to the context where it is happening, for example a request ID or a user identity.
     *
     * @param relatedMetrics Related metrics to publish when a new action is started for this context
     * @returns This builder object to continue building
     */

  }, {
    key: "withRelatedMetrics",
    value: function withRelatedMetrics() {
      for (var _len = arguments.length, relatedMetrics = new Array(_len), _key = 0; _key < _len; _key++) {
        relatedMetrics[_key] = arguments[_key];
      }

      this.context.relatedMetrics = relatedMetrics;
      return this;
    }
    /**
     * Add additional related metrics to this builder.  See withRelatedMetrics for more information.
     *
     * @param relatedMetrics Additional related metrics to publish when a new action is started for this context
     * @returns This builder object to continue building
     */

  }, {
    key: "addRelatedMetrics",
    value: function addRelatedMetrics() {
      for (var _len2 = arguments.length, relatedMetrics = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        relatedMetrics[_key2] = arguments[_key2];
      }

      this.context.relatedMetrics = (0, _mergeLists.mergeLists)(this.context.relatedMetrics, relatedMetrics);
      return this;
    }
    /**
     * Replace single-action related metrics with the given list (see addRelatedMetricsSingleAction to add instead of replace,
     * and withRelatedMetrics for more information about related metrics).
     *
     * Single-action related metrics are published when a new child metric publisher is created, but not included as
     * related metrics for the new child metric publisher, so are not published again if the child metric publisher
     * creates grandchild published metrics.
     *
     * @param metrics Related metrics
     * @returns This builder object to continue building
     */

  }, {
    key: "withRelatedMetricsSingleAction",
    value: function withRelatedMetricsSingleAction() {
      for (var _len3 = arguments.length, metrics = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        metrics[_key3] = arguments[_key3];
      }

      this.context.relatedMetricsSingleAction = metrics;
      return this;
    }
    /**
     * Add additional single-action related metrics to this builder.  See addRelatedMetricsSingleAction for more information.
     *
     * @param metrics Related metrics
     * @returns This builder object to continue building
     */

  }, {
    key: "addRelatedMetricsSingleAction",
    value: function addRelatedMetricsSingleAction() {
      for (var _len4 = arguments.length, metrics = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        metrics[_key4] = arguments[_key4];
      }

      this.context.relatedMetricsSingleAction = (0, _mergeLists.mergeLists)(this.context.relatedMetricsSingleAction, metrics);
      return this;
    }
    /**
     * Take the fields set in this builder and use them to create a new KatalMetricsContext.
     *
     * @return KatalMetricsContext object built with the parameters given to this builder
     */

  }, {
    key: "build",
    value: function build() {
      return new KatalMetricsContext(this.context);
    }
  }]);
  return _temp;
}(), _temp));

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/KatalMetricsPublisher.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/KatalMetricsPublisher.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js"));

var _v = _interopRequireDefault(__webpack_require__(/*! uuid/v4 */ "./node_modules/@amzn/katal-logger/node_modules/uuid/v4.js"));

var _KatalMetricsContext = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricsContext */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/KatalMetricsContext.js"));

var _KatalMetricObject = _interopRequireDefault(__webpack_require__(/*! ./metricObject/KatalMetricObject */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js"));

var KatalMetrics = _interopRequireWildcard(__webpack_require__(/*! . */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/index.js"));

var _KatalMetricString = _interopRequireDefault(__webpack_require__(/*! ./metricObject/KatalMetricString */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricString.js"));

var _mergeLists = __webpack_require__(/*! ./helper/mergeLists */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/mergeLists.js");

var _metricsExtension = __webpack_require__(/*! ./helper/metricsExtension */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/metricsExtension.js");

var _embedRequestId = __webpack_require__(/*! ./helper/embedRequestId */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/embedRequestId.js");

var INITIALIZATION_METHOD_NAME = 'Initialization';

/**
 * Default error handler if the user-supplied error handler fails or is unset.
 * Should never be called unless user-provided error handler misbehaves.
 */
var DEFAULT_ERROR_HANDLER = function DEFAULT_ERROR_HANDLER(err) {
  console.error("Error publishing metrics:");
  console.error(err);
};

var PARENT_ACTION_ID_NAME = 'parentActionId';

var getContextFields = function getContextFields(context) {
  if (context.context) {
    return context.context;
  } else {
    return context;
  }
};
/**
 * Class used for publishing metrics to Katal.  Contains a driver and a context.
 *
 * This class knows how to publish metrics, and how to create new publishers with a modified context.
 */


var KatalMetricsPublisher =
/*#__PURE__*/
function () {
  /**
   * Create a new metrics publisher with the given driver and context
   *
   * @param driver Subclass of KatalMetricsDriver used to publish the metrics
   * @param errorHandler Handler for errors that occur while using this publisher
   * @param context Context for this metrics publisher; contains data to be included with every
   *     metric published using this publisher object.  Default is an empty context.
   */
  function KatalMetricsPublisher(driver) {
    var _this = this;

    var errorHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_ERROR_HANDLER;
    var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new _KatalMetricsContext.default();
    (0, _classCallCheck2.default)(this, KatalMetricsPublisher);
    (0, _defineProperty2.default)(this, "combinedErrorHandler", function (err) {
      try {
        _this.errorHandler(err);
      } catch (nextErr) {
        console.error("Error handling error publishing metrics:");
        console.error(nextErr);
        DEFAULT_ERROR_HANDLER(err);
      }
    });

    // Check for a common error
    if (context instanceof _KatalMetricsContext.default.Builder) {
      throw new Error("KatalMetricsContext.Builder object passed instead of KatalMetricsContext.  Try calling .build() method.");
    }

    this.driver = driver;
    this.errorHandler = errorHandler;
    this.context = !(context instanceof _KatalMetricsContext.default) ? new _KatalMetricsContext.default(context) : context;
  }
  /**
   * Call the error-handler supplied by the user when this object was constructed; if that is unset or itself throws
   * an exception, calls the default error handler as a fallback, which will just log the error to the console.
   *
   * @param err Error object to handle
   */


  (0, _createClass2.default)(KatalMetricsPublisher, [{
    key: "withErrorHandling",

    /**
     * Helper method to wrap a function in the error handler.
     *
     * @param doTheThing Function to run under the wrapper
     * @return Return value from called function
     */
    value: function withErrorHandling(doTheThing) {
      try {
        return doTheThing();
      } catch (err) {
        this.combinedErrorHandler(err);
      }
    }
    /**
     * Helper method to return all the related metrics of base publisher and additionalContext.
     *
     * @param additionalContext Additional context to be included in the new publisher
     * @return Return all related metrics from base publisher and additionalContext.
     */

  }, {
    key: "getAdditionalRelatedMetrics",
    value: function getAdditionalRelatedMetrics(additionalContext) {
      var newContext = additionalContext instanceof _KatalMetricsContext.default ? additionalContext.context : additionalContext;
      var baseRelatedMetrics = this.getBaseRelatedMetrics();
      return (0, _mergeLists.mergeLists)(baseRelatedMetrics, newContext.relatedMetrics);
    }
    /**
     * Helper method to return all the related metrics of base publisher.
     *
     * @return Return all related metrics from the base publisher.
     */

  }, {
    key: "getBaseRelatedMetrics",
    value: function getBaseRelatedMetrics() {
      return (0, _mergeLists.mergeLists)(this.context.context.relatedMetrics, this.context.context.relatedMetricsSingleAction);
    }
    /**
     * Publish the given metric object.
     *
     * This method is guaranteed never to throw an exception.  If the metric object or context are invalid,
     * or any other exception is thrown while publishing, the publisher's error handler is called.  If the
     * publisher's error handler is unset or fails, the default error handler is called (see defaultErrorHandler).
     *
     * @param katalMetricObject Metric object to publish
     */

  }, {
    key: "publish",
    value: function publish(katalMetricObject) {
      var _this2 = this;

      this.withErrorHandling(function () {
        if (!katalMetricObject) {
          throw new Error("Cannot publish undefined/null metric object");
        }

        if (_KatalMetricObject.default.Types.List === katalMetricObject.type) {
          katalMetricObject.metricList.forEach(function (metric) {
            _this2.publish(metric);
          });
        } else {
          var driverContext = _this2.context.driverContext();

          var contextError = driverContext.validationError();
          if (contextError) throw contextError;
          var objectError = katalMetricObject.validationError();
          if (objectError) throw objectError;
          (0, _metricsExtension.dispatchMetricEvent)(katalMetricObject, driverContext);

          _this2.driver.publish(katalMetricObject, _this2.combinedErrorHandler, driverContext);
        }
      });
    }
    /**
     * Create a new publisher which is identical to this publisher, but with the given context fields merged into
     * the new publisher's context.
     *
     * @param additionalContext Additional context to be included in the new publisher
     * @returns New publisher identical to this one, but with an updated context
     */

  }, {
    key: "newChildPublisher",
    value: function newChildPublisher(additionalContext) {
      return new KatalMetricsPublisher(this.driver, this.errorHandler, this.context.merge(additionalContext));
    }
    /**
     * Begin a new action, and return a new publisher for metrics related to that action.
     *
     * Beginning a new action involves the following steps:
     *   1. Generate a new actionId for the action, randomly in the browser
     *   2. If there are any related metrics in the context, publish them
     *   3. Create and return a new publisher with this object's context, merged with any additional context given,
     *      merged with the actionId generated above.
     *
     * @param additionalContext Additional context to be included in the new publisher
     * @returns New publisher identical to this one, but with an updated context
     */

  }, {
    key: "newChildActionPublisher",
    value: function newChildActionPublisher(additionalContext) {
      var actionId = this._generateActionid(additionalContext);

      var newContext = this.context.withoutRelatedMetricsSingleAction().merge({
        actionId: actionId
      }).merge(additionalContext);
      var newPublisher = new KatalMetricsPublisher(this.driver, this.errorHandler, newContext);
      var allRelatedMetrics = additionalContext && !(additionalContext instanceof _KatalMetricsContext.default.Builder) ? this.getAdditionalRelatedMetrics(additionalContext) : this.getBaseRelatedMetrics();

      if (allRelatedMetrics) {
        allRelatedMetrics.forEach(function (metric) {
          newPublisher.publish(metric);
        });
      }

      return newPublisher;
    }
    /**
     * Begin a new chained child action, and return a new publisher for metrics related to that action.
     *
     * A chained action is handled the same way as in newChildActionPublisher, but additionally,
     * the returned publisher has a relatedMetricNoInherit named "parentActionId", with the newly
     * generated actionId as its value.
     *
     * The effect of this is that any further chained child actions can be connected back to this
     * action through the parentActionId, and so on recursively.
     *
     * @param additionalContext Additional context to be included in the new publisher
     * @returns New publisher identical to this one, but with an updated context
     */

  }, {
    key: "newChildActionPublisherChained",
    value: function newChildActionPublisherChained(additionalContext) {
      var actionId = this._generateActionid(additionalContext);

      var parentActionId = (0, _embedRequestId.embedRequestId)(actionId, this.context.context.requestId);
      var relatedMetricsSingleAction = [new _KatalMetricString.default(PARENT_ACTION_ID_NAME, parentActionId)];
      var newContext = new _KatalMetricsContext.default({
        actionId: actionId,
        relatedMetricsSingleAction: relatedMetricsSingleAction
      }).merge(additionalContext);
      return this.newChildActionPublisher(newContext);
    }
    /**
     * Helper method to create a new chained child action publisher with the given value for methodName.
     *
     * Apart from setting the methodName in the child context, this method is identical to newChildActionPublisherChained.
     *
     * @param methodName Method name for new publisher context
     * @param additionalContext Additional context to supply (optional)
     * @returns New publisher identical to this one, but with an updated context
     */

  }, {
    key: "newChildActionPublisherChainedForMethod",
    value: function newChildActionPublisherChainedForMethod(methodName, additionalContext) {
      return this.newChildActionPublisherChained(new _KatalMetricsContext.default({
        methodName: methodName
      }).merge(additionalContext));
    }
    /**
     * Helper method to create a new action publisher with the given value for methodName.
     *
     * Apart from setting the methodName in the child context, this method is identical to newChildActionPublisherForMethod.
     * @param methodName Method name for new publisher context
     * @param additionalContext Additional context to supply (optional)
     * @returns New publisher identical to this one, but with an updated context
     */

  }, {
    key: "newChildActionPublisherForMethod",
    value: function newChildActionPublisherForMethod(methodName, additionalContext) {
      return this.newChildActionPublisher(new _KatalMetricsContext.default({
        methodName: methodName
      }).merge(additionalContext));
    }
    /**
     * Helper method to create a new action for application initialization.  It will always have a methodName
     * of "Initialization"; otherwise this method is identical to newChildActionPublisherForMethod.
     *
     * @param additionalContext Additional context to be included in the new publisher
     * @returns New publisher identical to this one, but with an updated context
     */

  }, {
    key: "newChildActionPublisherForInitialization",
    value: function newChildActionPublisherForInitialization(additionalContext) {
      return this.newChildActionPublisherForMethod(INITIALIZATION_METHOD_NAME, additionalContext);
    }
    /**
     * Helper method to publish a string with the given name and value.
     *
     * @param name Metric name
     * @param value String value
     */

  }, {
    key: "publishString",
    value: function publishString(name, value) {
      this.publish(new KatalMetrics.Metric.String(name, value));
    }
    /**
     * Helper method to publish a string with the given name and value, truncated to the maximum size allowed by the
     * schema.
     *
     * @param name Metric name
     * @param value String value
     */

  }, {
    key: "publishStringTruncate",
    value: function publishStringTruncate(name, value) {
      var object = new KatalMetrics.Metric.String(name, value);
      object.truncate = true;
      this.publish(object);
    }
    /**
     * Helper method to publish a counter with the given name and value.
     *
     * @param name Metric name
     * @param value Counter value
     */

  }, {
    key: "publishCounter",
    value: function publishCounter(name, value) {
      this.publish(new KatalMetrics.Metric.Counter(name, value));
    }
    /**
     * Helper method to publish a timer with the given name and value.
     *
     * @param name Metric name
     * @param value Timer value
     */

  }, {
    key: "publishTimer",
    value: function publishTimer(name, value) {
      this.publish(new KatalMetrics.Metric.Timer(name, value));
    }
    /**
     * Helper method to publish a counter with the isMonitor flag set, and the given name and value.
     *
     * @param name Metric name
     * @param value Counter value
     */

  }, {
    key: "publishCounterMonitor",
    value: function publishCounterMonitor(name, value) {
      this.publish(new KatalMetrics.Metric.Counter(name, value).withMonitor());
    }
    /**
     * Helper method to publish a timer with the isMonitor flag set, and the given name and value.
     *
     * @param name Metric name
     * @param value Timer value
     */

  }, {
    key: "publishTimerMonitor",
    value: function publishTimerMonitor(name, value) {
      this.publish(new KatalMetrics.Metric.Timer(name, value).withMonitor());
    }
    /**
     * Private helper method to extract an actionId from a context if one is provided, and otherwise generate a new one.
     *
     * @returns Action ID string
     */

  }, {
    key: "_generateActionid",
    value: function _generateActionid(context) {
      if (context) {
        var fields = getContextFields(context);

        if (fields.actionId) {
          return fields.actionId;
        }
      }

      return (0, _v.default)();
    }
  }]);
  return KatalMetricsPublisher;
}();

exports.default = KatalMetricsPublisher;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/driver/ErrorHandler.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/driver/ErrorHandler.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_ERROR_HANDLER = void 0;

var DEFAULT_ERROR_HANDLER = function DEFAULT_ERROR_HANDLER(err) {
  throw err;
};

exports.DEFAULT_ERROR_HANDLER = DEFAULT_ERROR_HANDLER;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/driver/KatalMetricsDriver.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/driver/KatalMetricsDriver.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

/**
 * Abstract base class for a Katal metrics driver.
 */
var KatalMetricsDriver =
/*#__PURE__*/
function () {
  function KatalMetricsDriver() {
    (0, _classCallCheck2.default)(this, KatalMetricsDriver);
  }

  (0, _createClass2.default)(KatalMetricsDriver, [{
    key: "publish",

    /**
     * Publish the given metric object with the given error handler and context.
     *
     * @param metricObject Metric object to publish.  Contains metricKey, isMonitor, type, and value.
     * @param errorHandler Callback function for handling any asynchronous errors that occur in the driver
     *     (the driver should just throw an exception for a synchronous error).
     * @param context Context for publishing this metric.  Contains all other fields to be published.
     */
    value: function publish(metricObject, errorHandler, context) {
      throw new Error('KatalMetricsDriver is an abstract class, please choose a driver and use that instead');
    }
  }]);
  return KatalMetricsDriver;
}();

exports.default = KatalMetricsDriver;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/FirstMap.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/FirstMap.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = firstMap;

/**
 * Returns the first non-undefined value that results from running each value
 * in the given array through the mapper function.
 * @param array An array of values.
 * @param mapper A mapper function that should return a value or undefined.
 * @returns The first non-undefined value from the mapper function.
 */
function firstMap(array, mapper) {
  var toReturn = undefined;
  array.some(function (val) {
    toReturn = mapper(val);
    return toReturn != null;
  });
  return toReturn;
}

;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/ObjectValuesPonyfill.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/ObjectValuesPonyfill.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var objectValues = Object.values ? Object.values : function (object) {
  return Object.keys(object).map(function (key) {
    return object[key];
  });
};
var _default = objectValues;
exports.default = _default;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleInt.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleInt.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = validateSimpleInt;

var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/typeof.js"));

/**
 * Number.isInteger is not in IE11, and letting Babel polyfill it added too much weight.
 * Adapted from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
 */
var isInteger = function isInteger(val) {
  return isFinite(val) && Math.floor(val) === val;
};
/**
 * Check if the given value is valid to be published to KatalMetrics as an integer (Counter or Timer),
 * and return either undefined (no error), or an Error object describing the problem.
 *
 * @param val Value to check
 * @param nameForError Name to use when constructing the error message, if necessary
 * @returns Error, or undefined if no error
 */


function validateSimpleInt(val, nameForError) {
  if (typeof val !== 'number') {
    return new Error("Expected ".concat(nameForError, " to have type 'number', but it was type '").concat((0, _typeof2.default)(val), "'"));
  }

  if (val < 0) {
    return new Error("Expected ".concat(nameForError, " to be positive, but it was ").concat(val));
  } // This will also catch NaN and Infinity


  if (!isInteger(val)) {
    return new Error("Expected ".concat(nameForError, " to be an integer, but it was ").concat(val));
  } // Couldn't find anything wrong, implicitly return undefined

}

;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleString.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleString.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = validateSimpleString;

var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/typeof.js"));

var SIMPLE_STRING_PAT = /^[A-Za-z0-9.:@_/-]+$/;
var SIMPLE_STRING_MAX_LEN = 127;
/**
 * Check if the given value is valid to be published to KatalMetrics as a field value,
 * such as site, serviceName, methodName, or actionId (note this is not used to check values for string metrics).
 * It returns either undefined (no error), or an Error object describing the problem.
 *
 * To be published, it must be a non-empty string, less than 256 characters, containing only ASCII
 * letters, numbers, or these characters: .:@_/- (those are the PMET field value requirements).
 *
 * @param val String value to check
 * @param nameForError Name to use in the error message, if one is generated
 * @returns Error, or undefined if no error
 */

function validateSimpleString(val, nameForError) {
  if (typeof val !== "string") {
    return new Error("Expected ".concat(nameForError, " to be a string, but it was a ").concat((0, _typeof2.default)(val)));
  }

  if (val.length > SIMPLE_STRING_MAX_LEN) {
    return new Error("Expected ".concat(nameForError, " to be less than ").concat(SIMPLE_STRING_MAX_LEN, " characters, but it was ").concat(val.length, " characters"));
  }

  if (val.length < 1) {
    return new Error("Expected ".concat(nameForError, " to be non-blank"));
  }

  if (!SIMPLE_STRING_PAT.test(val)) {
    return new Error("Expected ".concat(nameForError, " to contain only valid characters, but it was ").concat(val, ".  It can only contain letters, numbers, and these symbols: .:@_/-"));
  } // Couldn't find anything wrong, implicitly return undefined

}

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/embedRequestId.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/embedRequestId.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.embedRequestId = embedRequestId;

// until we can add a requestId field to the andes schema we will embed it in the actionId
function embedRequestId(actionId, requestId) {
  if (requestId) {
    return [requestId, actionId].join("::");
  }

  return actionId;
}

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/mergeLists.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/mergeLists.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeLists = mergeLists;

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/toConsumableArray.js"));

// Helper method to merge two lists which could be undefined
// Returns merged lists if either is defined, otherwise returns undefined
function mergeLists(list1, list2) {
  if (list1 || list2) {
    return [].concat((0, _toConsumableArray2.default)(list1 || []), (0, _toConsumableArray2.default)(list2 || []));
  } else {
    return undefined;
  }
}

;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/metricsExtension.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/metricsExtension.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dispatchMetricEvent = dispatchMetricEvent;

/**
 * Publish to external parties that are 
 * listening for katal.metrics.publish Custom Events
 */
function dispatchMetricEvent(metric, context) {
  if (typeof window === 'undefined') {
    return;
  }

  dispatchCustomEvent(metric, context); // for legacy purposes, also publish to __KATAL_METRICS_EXTENSION__

  publishToMetricsExtension(metric, context);
}

function dispatchCustomEvent(metric, context) {
  if (typeof CustomEvent !== "function") {
    return;
  }

  var event = new CustomEvent('katal.metrics.publish', {
    detail: {
      metric: metric,
      context: context.getFields()
    }
  });
  window.dispatchEvent(event);
}
/**
 * @Deprecated
 * Publish to https://code.amazon.com/packages/KatalMetricsExtension
 * The extension injects a global __KATAL_METRICS_EXTENSION__ object with a
 * `publish` method.
 */


function publishToMetricsExtension(metric, context) {
  var extension = window.__KATAL_METRICS_EXTENSION__;

  if (extension) {
    extension.publish(metric, context.getFields());
  }
}

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/index.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/index.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Publisher", {
  enumerable: true,
  get: function get() {
    return _KatalMetricsPublisher.default;
  }
});
Object.defineProperty(exports, "Context", {
  enumerable: true,
  get: function get() {
    return _KatalMetricsContext.default;
  }
});
Object.defineProperty(exports, "MetricsDriver", {
  enumerable: true,
  get: function get() {
    return _KatalMetricsDriver.default;
  }
});
Object.defineProperty(exports, "ErrorHandler", {
  enumerable: true,
  get: function get() {
    return _ErrorHandler.ErrorHandler;
  }
});
exports.Metric = void 0;

var Metric = _interopRequireWildcard(__webpack_require__(/*! ./metricObject */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/index.js"));

exports.Metric = Metric;

var _KatalMetricsPublisher = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricsPublisher */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/KatalMetricsPublisher.js"));

var _KatalMetricsContext = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricsContext */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/KatalMetricsContext.js"));

var _KatalMetricsDriver = _interopRequireDefault(__webpack_require__(/*! ./driver/KatalMetricsDriver */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/driver/KatalMetricsDriver.js"));

var _ErrorHandler = __webpack_require__(/*! ./driver/ErrorHandler */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/driver/ErrorHandler.js");

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricCounter.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricCounter.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/get.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/inherits.js"));

var _KatalMetricObject2 = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricObject */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js"));

var _ValidateSimpleInt = _interopRequireDefault(__webpack_require__(/*! ../helper/ValidateSimpleInt */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleInt.js"));

/**
 * Counter type.
 *
 * Can be used to count the number of times an event happened on a page, or as a simple 1/0 counter to track
 * success and failure.
 */
var KatalMetricCounter =
/*#__PURE__*/
function (_KatalMetricObject) {
  (0, _inherits2.default)(KatalMetricCounter, _KatalMetricObject);

  /**
   * Create a new counter with the given name and value.
   *
   * @param name Counter name
   * @param value Counter value
   */
  function KatalMetricCounter(name) {
    var _this;

    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    (0, _classCallCheck2.default)(this, KatalMetricCounter);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(KatalMetricCounter).call(this, name));
    _this.value = value;
    return _this;
  }
  /**
   * Get the value for this counter
   *
   * @return Counter value
   */


  (0, _createClass2.default)(KatalMetricCounter, [{
    key: "add",

    /**
     * Add a number to this counter.
     *
     * Can also be negative to subtract.
     *
     * @param addValue Amount to add to this counter
     */
    value: function add(addValue) {
      this.value += addValue;
    }
  }, {
    key: "validationError",
    value: function validationError() {
      var superError = (0, _get2.default)((0, _getPrototypeOf2.default)(KatalMetricCounter.prototype), "validationError", this).call(this);
      if (superError) return superError;
      return (0, _ValidateSimpleInt.default)(this.value, "field value in Counter metrics object '".concat(this.name, "'"));
    }
  }, {
    key: "value",
    get: function get() {
      return this._value;
    }
    /**
     * Set a new value for this counter
     *
     * @param value New value for this counter
     */
    ,
    set: function set(value) {
      // Math.round will also coerce from a string if necessary, and return NaN if invalid
      this._value = Math.round(value);
    }
    /**
     * Gets the type for this counter.
     *
     * @return Always returns "Counter".
     */

  }, {
    key: "type",
    get: function get() {
      return _KatalMetricObject2.default.Types.Counter;
    }
  }, {
    key: "canMonitor",
    get: function get() {
      return true;
    }
  }]);
  return KatalMetricCounter;
}(_KatalMetricObject2.default);

exports.default = KatalMetricCounter;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricHttpRequest.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricHttpRequest.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/inherits.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js"));

var _KatalMetricTimedAttempt = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimedAttempt */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimedAttempt.js"));

var _KatalMetricString = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricString */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricString.js"));

/**
 * Standardized metric for instrumenting HTTP requests.
 *
 * Under the hood it is a KatalMetricTimedAttempt with the name you provide prefixed with "HTTPRequest.".
 * That object will contain a metric suffixed with ".Latency" for the latency of this request, and a metric suffixed
 * with ".Failure" to record the failure or success of this request.
 *
 * By default the request will be tracked as a failure; to mark it as a success call the "setSuccess()" method.
 *
 * It has additional properties which will be emitted if set; see url, statusCode, and statusText.
 *
 * For example, if you gave the name "Search", these metrics will be created:
 *   HTTPRequest.Search.Latency - Latency for this request
 *   HTTPRequest.Search.Failure - Failure for this request (1 for failure, 0 for success)
 */
var KatalMetricHttpRequest =
/*#__PURE__*/
function (_KatalMetricTimedAtte) {
  (0, _inherits2.default)(KatalMetricHttpRequest, _KatalMetricTimedAtte);

  /** The prefix for this metric. */

  /** The suffix for URL metrics of this class. */

  /** The suffix for HTTP response code metrics of this class. */

  /** The suffix for HTTP response text metrics of this class. */

  /**
   * Create a new HTTP Request timed attempt metric incorporating the given name.
   *
   * The name you give will be used to create a KatalMetricTimedAttempt with the provided name prefixed with "HTTPRequest.".
   *
   * @param name Name of this metric; resulting metrics will prefix this name with "HTTPRequest."
   */
  function KatalMetricHttpRequest(name) {
    (0, _classCallCheck2.default)(this, KatalMetricHttpRequest);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(KatalMetricHttpRequest).call(this, "".concat(KatalMetricHttpRequest.HTTP_REQUEST_PREFIX, ".").concat(name)));
  }
  /**
   * Set the url for this metric.
   *
   * A string metric will be added to the list of objects that will be published for this metric.  Its name will
   * be this metrics name suffixed with '.URL', and its value will be the URL value given here.
   *
   * @param value URL for this metric
   */


  (0, _createClass2.default)(KatalMetricHttpRequest, [{
    key: "url",
    set: function set(value) {
      this.setOrDeleteNamedMetricValue(KatalMetricHttpRequest.URL_SUFFIX, _KatalMetricString.default, value);
    }
    /**
     * Get the URL for this metric, if defined.
     *
     * @return The URL for this metric, or undefined
     */
    ,
    get: function get() {
      return this.getNamedMetricValue(KatalMetricHttpRequest.URL_SUFFIX);
    }
    /**
     * Get the URL metric object associated with this metric, if defined.
     *
     * @return Associated URL metric object, or undefined
     */

  }, {
    key: "urlMetric",
    get: function get() {
      return this.getNamedMetric(KatalMetricHttpRequest.URL_SUFFIX);
    }
    /**
     * Set the HTTP response status code for this metric.
     *
     * A string metric will be added to the list of objects that will be published for this metric.  Its name will
     * be this metrics name suffixed with '.StatusCode', and its value will be the status code value given here.
     *
     * @param value HTTP response status code for this metric
     */

  }, {
    key: "statusCode",
    set: function set(value) {
      this.setOrDeleteNamedMetricValue(KatalMetricHttpRequest.STATUS_CODE_SUFFIX, _KatalMetricString.default, value);
    }
    /**
     * Get the HTTP response status code for this metric, if defined.
     *
     * @return Associated HTTP response status code metric object, or undefined
     */
    ,
    get: function get() {
      return this.getNamedMetricValue(KatalMetricHttpRequest.STATUS_CODE_SUFFIX);
    }
    /**
     * Get the HTTP response status code metric object associated with this metric, if defined.
     *
     * @return HTTP response status code metric object, or undefined
     */

  }, {
    key: "statusCodeMetric",
    get: function get() {
      return this.getNamedMetric(KatalMetricHttpRequest.STATUS_CODE_SUFFIX);
    }
    /**
     * Set the HTTP response status text for this metric.
     *
     * A string metric will be added to the list of objects that will be published for this metric.  Its name will
     * be this metrics name suffixed with '.StatusText', and its value will be the status text value given here.
     *
     * @param statusText HTTP response status text for this metric, or undefined to remove
     */

  }, {
    key: "statusText",
    set: function set(value) {
      this.setOrDeleteNamedMetricValue(KatalMetricHttpRequest.STATUS_TEXT_SUFFIX, _KatalMetricString.default, value);
    }
    /**
     * Get the HTTP response status text for this metric, if defined.
     *
     * @return Associated HTTP response status text metric object, or undefined
     */
    ,
    get: function get() {
      return this.getNamedMetricValue(KatalMetricHttpRequest.STATUS_TEXT_SUFFIX);
    }
    /**
     * Get the HTTP response status text for this metric, if defined.
     *
     * @return Associated HTTP response status text metric object, or undefined
     */

  }, {
    key: "statusTextMetric",
    get: function get() {
      return this.getNamedMetric(KatalMetricHttpRequest.STATUS_TEXT_SUFFIX);
    }
  }]);
  return KatalMetricHttpRequest;
}(_KatalMetricTimedAttempt.default);

exports.default = KatalMetricHttpRequest;
(0, _defineProperty2.default)(KatalMetricHttpRequest, "HTTP_REQUEST_PREFIX", 'HTTPRequest');
(0, _defineProperty2.default)(KatalMetricHttpRequest, "URL_SUFFIX", 'URL');
(0, _defineProperty2.default)(KatalMetricHttpRequest, "STATUS_CODE_SUFFIX", 'StatusCode');
(0, _defineProperty2.default)(KatalMetricHttpRequest, "STATUS_TEXT_SUFFIX", 'StatusText');

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricInitialization.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricInitialization.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/inherits.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js"));

var _KatalMetricTimedAttempt = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimedAttempt */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimedAttempt.js"));

/**
 * Standardized metric for instrumenting application initialization.
 *
 * Under the hood it is a KatalMetricTimedAttempt with the name "Initialization".
 * That object will contain a metric suffixed with ".Latency" for the latency of this request, and a metric suffixed
 * with ".Failure" to record the failure or success of this request.
 *
 * By default the request will be tracked as a failure; to mark it as a success call the "setSuccess()" method.
 *
 * By default, these metrics will be created:
 *   Initialization.Latency - Latency for application initialization
 *   Initialization.Failure - Failure for this application initialization (1 for failure, 0 for success)
 */
var KatalMetricInitialization =
/*#__PURE__*/
function (_KatalMetricTimedAtte) {
  (0, _inherits2.default)(KatalMetricInitialization, _KatalMetricTimedAtte);

  /** The name for this metric. */

  /**
   * Create a new timed attempt metric named "Initialization", for recording latency and failure information about
   * your application's initialization.
   */
  function KatalMetricInitialization() {
    (0, _classCallCheck2.default)(this, KatalMetricInitialization);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(KatalMetricInitialization).call(this, KatalMetricInitialization.INITIALIZE_METRIC_NAME));
  }

  return KatalMetricInitialization;
}(_KatalMetricTimedAttempt.default);

exports.default = KatalMetricInitialization;
(0, _defineProperty2.default)(KatalMetricInitialization, "INITIALIZE_METRIC_NAME", 'Initialization');

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricNamedObjectList.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricNamedObjectList.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/inherits.js"));

var _KatalMetricObjectList = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricObjectList */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObjectList.js"));

var _ObjectValuesPonyfill = _interopRequireDefault(__webpack_require__(/*! ../helper/ObjectValuesPonyfill */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/ObjectValuesPonyfill.js"));

/**
 * Metric object list that tracks metrics by name, and generates metrics prefixed with the name of this object.
 */
var KatalMetricNamedObjectList =
/*#__PURE__*/
function (_KatalMetricObjectLis) {
  (0, _inherits2.default)(KatalMetricNamedObjectList, _KatalMetricObjectLis);

  /**
   * Create a new named object list.
   *
   * The name given here will be used to prefix all metrics.
   *
   * @param name Name of this metric
   */
  function KatalMetricNamedObjectList(name) {
    var _this;

    (0, _classCallCheck2.default)(this, KatalMetricNamedObjectList);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(KatalMetricNamedObjectList).call(this, name));
    _this.namedMetrics = {};
    return _this;
  }

  (0, _createClass2.default)(KatalMetricNamedObjectList, [{
    key: "setNamedMetric",

    /**
     * Replace the metric with the given name with a new metric generated by the given function.
     *
     * If the newly created metric supports monitoring, its isMonitor flag will be set to the value of the
     * isMonitor flag for this containing object.
     *
     * @param subName Name of this sub-metric
     * @param metricCreator Function which takes the full name for this metric
     *        and returns a newly constructed KatalMetricObject with this name and an appropriate value
     */
    value: function setNamedMetric(subName, metricCreator) {
      var fullName = this.getNameForSubMetric(subName);
      var metric = metricCreator(fullName);

      if (metric.canMonitor) {
        metric.isMonitor = this.isMonitor;
      }

      this.namedMetrics[subName] = metric;
    }
    /**
     * If the given value is undefined or null, delete the metric with the give name; otherwise if the given named
     * metric already exists update its value; otherwise create a new metric of the given type and set its value.
     *
     * This specialized helper method is designed to deal with the common case of a value setter in a more complex
     * metric.  Outside of subclasses, other methods will probably prove more useful.
     *
     * If the value is null the metric will also be deleted.
     *
     * @param subName Name of metric to create or delete
     * @param newValueClass Class of new metric to create
     * @param newValue New value for this metric (or undefined to delete the metric)
     */

  }, {
    key: "setOrDeleteNamedMetricValue",
    value: function setOrDeleteNamedMetricValue(subName, newValueClass, newValue) {
      if (newValue == undefined) {
        this.deleteNamedMetric(subName);
      } else {
        var metric = this.getOrCreateNamedMetric(subName, function (name) {
          return new newValueClass(name, newValue);
        });
        metric.value = newValue;
      }
    }
    /**
     * Get the sub-metric with the given name if it exists, otherwise use the given function to create a new metric and
     * store and return that.
     *
     * @param subName Name of this sub-metric
     * @param metricCreator Function which takes the full name for this metric
     *        and returns a newly constructed KatalMetricObject with this name and an appropriate value
     * @return Metric object which was retrieved or created
     */

  }, {
    key: "getOrCreateNamedMetric",
    value: function getOrCreateNamedMetric(subName, metricCreator) {
      if (!this.namedMetrics[subName]) {
        this.setNamedMetric(subName, metricCreator);
      }

      return this.namedMetrics[subName];
    }
    /**
     * Return the given named sub-metric, if it exists.
     *
     * @param {string} subName Name of this sub-metric
     * @return {KatalMetricObject | undefined} Metric object with this name if it exists, otherwise undefined
     */

  }, {
    key: "getNamedMetric",
    value: function getNamedMetric(subName) {
      return this.namedMetrics[subName];
    }
    /**
     * Delete the given named sub-metric.
     *
     * @param subName Name of this sub-metric
     */

  }, {
    key: "deleteNamedMetric",
    value: function deleteNamedMetric(subName) {
      delete this.namedMetrics[subName];
    }
    /**
     * Get the value for the given metric, or undefined if the metric does not exist.
     *
     * @param subName Name of this sub-metric
     * @return Value for the given metric, or undefined if the metric does not exist
     */

  }, {
    key: "getNamedMetricValue",
    value: function getNamedMetricValue(subName) {
      var metric = this.getNamedMetric(subName);
      if (!metric) return undefined;
      return metric.value;
    }
    /**
     * Generate a name for the given sub-metric.
     *
     * @param subName Name of this sub-metric
     * @return Full name for this sub-metric
     */

  }, {
    key: "getNameForSubMetric",
    value: function getNameForSubMetric(subName) {
      return "".concat(this.name, ".").concat(subName);
    }
  }, {
    key: "metricList",
    get: function get() {
      return (0, _ObjectValuesPonyfill.default)(this.namedMetrics);
    }
  }]);
  return KatalMetricNamedObjectList;
}(_KatalMetricObjectList.default);

exports.default = KatalMetricNamedObjectList;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/typeof.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js"));

var _ValidateSimpleString = _interopRequireDefault(__webpack_require__(/*! ../helper/ValidateSimpleString */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleString.js"));

var _KatalMetricType = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricType */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricType.js"));

/**
 * Abstract base class for a single metric in Katal.
 *
 * A single metric contains the name (metricKey), value, type, and the isMonitor flag; everything else is in the
 * KatalMetricsContext it is published to.
 */
var KatalMetricObject =
/*#__PURE__*/
function () {
  /**
   * Metric types.
   */

  /**
   * Create a new KatalMetricObject with the given name.
   *
   * @param name Name for this metric; published as metricKey field
   */
  function KatalMetricObject(name) {
    (0, _classCallCheck2.default)(this, KatalMetricObject);
    this._name = name;
    this._isMonitor = false;
  }
  /**
   * Get the name for this metric.
   *
   * Note that the name is immutable, and this cannot be set.
   *
   * @returns Name for this metric
   */


  (0, _createClass2.default)(KatalMetricObject, [{
    key: "withMonitor",

    /**
     * Set the isMonitor flag for this metric, and returns this object for continued use.
     *
     * This flag determines if the metric can be used for dashboards and alarms (i.e. if it will be published to PMET)
     * @param isMonitor New value for the isMonitor flag; defaults to true
     * @returns This object
     */
    value: function withMonitor() {
      var isMonitor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      this.isMonitor = isMonitor;
      return this;
    }
    /**
     * Set the isMonitor flag for this metric.
     *
     * The value is forced to a boolean based on its truthiness.
     *
     * @param isMonitor New value for the isMonitor flag
     */

  }, {
    key: "validationError",

    /**
     * Check for a validation error on this object.
     *
     * Returns the first validation error encountered if one is found, otherwise undefined.
     *
     * @returns {Error | undefined} Error found with this object, or undefined if no error is found
     */
    value: function validationError() {
      if (this.isMonitor !== undefined && typeof this.isMonitor !== 'boolean') {
        return new Error("Field isMonitor should be a boolean, but it was a ".concat((0, _typeof2.default)(this.isMonitor)));
      }

      return (0, _ValidateSimpleString.default)(this.name, 'field name');
    }
  }, {
    key: "name",
    get: function get() {
      return this._name;
    }
    /**
     * Alias for name.
     *
     * @returns Name for this metric
     */

  }, {
    key: "metricKey",
    get: function get() {
      return this._name;
    }
  }, {
    key: "isMonitor",
    set: function set(isMonitor) {
      this._isMonitor = !!isMonitor;
    }
    /**
     * Get the isMonitor flag for this metric.
     *
     * @returns isMonitor flag for this metric.
     */
    ,
    get: function get() {
      return this._isMonitor;
    }
    /**
     * Check if this metric can be meaningfully monitored.
     *
     * Subclasses must override this.
     *
     * @return Whether this metric can be meaningfully monitored
     */

  }, {
    key: "canMonitor",
    get: function get() {
      throw new Error('Subclass of KatalMetricObject must implement canMonitor');
    }
    /**
     * Get the type of this metric.
     *
     * @return Type of this metric (one of: String, Counter, Timer, List)
     */

  }, {
    key: "type",
    get: function get() {
      throw new Error('Subclass of KatalMetricObject must implement type getter');
    }
  }]);
  return KatalMetricObject;
}();

exports.default = KatalMetricObject;
(0, _defineProperty2.default)(KatalMetricObject, "Types", _KatalMetricType.default);

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObjectList.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObjectList.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/get.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _set2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/set */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/set.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/inherits.js"));

var _KatalMetricObject2 = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricObject */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js"));

var _FirstMap = _interopRequireDefault(__webpack_require__(/*! ../helper/FirstMap */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/FirstMap.js"));

/**
 * Abstract metric that contains a list of other metrics; when it is published, the list of metrics is retrieved, and all
 * are published.
 */
var KatalMetricObjectList =
/*#__PURE__*/
function (_KatalMetricObject) {
  (0, _inherits2.default)(KatalMetricObjectList, _KatalMetricObject);

  /**
   * Create a new KatalMetricObjectList.
   *
   * @param name Name for this metric.  Not really used, but present for consistency with other metrics.
   */
  function KatalMetricObjectList(name) {
    (0, _classCallCheck2.default)(this, KatalMetricObjectList);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(KatalMetricObjectList).call(this, name));
  }
  /**
   * Get the list of for this object
   *
   * @returns Array of metrics for this object
   */


  (0, _createClass2.default)(KatalMetricObjectList, [{
    key: "validationError",

    /**
     * If any of the contained metrics are invalid, return the first validation error encountered; otherwise return
     * undefined.
     *
     * Note that this isn't called by the publisher; it validates each sub-metric on its own.
     *
     * @returns Error found with submetric, if any; else undefined
     */
    value: function validationError() {
      // Doesn't make sense to check superclass error here, since it is the contained metrics that matter.
      return (0, _FirstMap.default)(this.metricList, function (metric) {
        return metric.validationError();
      });
    }
  }, {
    key: "metricList",
    get: function get() {
      throw new Error('Subclass of KatalMetricObjectList must implement metricList getter');
    }
  }, {
    key: "isMonitor",
    set: function set(isMonitor) {
      (0, _set2.default)((0, _getPrototypeOf2.default)(KatalMetricObjectList.prototype), "isMonitor", isMonitor, this, true);
      this.metricList.forEach(function (metric) {
        if (metric.canMonitor) {
          metric.isMonitor = isMonitor;
        }
      });
    } // This just delegates to the superclass, but if we override the setter without overriding the getter
    // getting the property will always return undefined.
    ,
    get: function get() {
      return (0, _get2.default)((0, _getPrototypeOf2.default)(KatalMetricObjectList.prototype), "isMonitor", this);
    }
  }, {
    key: "canMonitor",
    get: function get() {
      return true;
    }
  }, {
    key: "type",
    get: function get() {
      return _KatalMetricObject2.default.Types.List;
    }
  }]);
  return KatalMetricObjectList;
}(_KatalMetricObject2.default);

exports.default = KatalMetricObjectList;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricString.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricString.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/typeof.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/assertThisInitialized.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/get.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/inherits.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js"));

var _KatalMetricObject2 = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricObject */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js"));

/**
 * String type.
 *
 * Can be used to store arbitrary strings of data.
 */
var KatalMetricString =
/*#__PURE__*/
function (_KatalMetricObject) {
  (0, _inherits2.default)(KatalMetricString, _KatalMetricObject);

  /**
   * Create a string with the given name and value.
   *
   * @param name String name
   * @param value String value
   */
  function KatalMetricString(name, value) {
    var _this;

    (0, _classCallCheck2.default)(this, KatalMetricString);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(KatalMetricString).call(this, name));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "truncate", false);
    _this.value = value;
    return _this;
  }
  /**
   * Get the value for this string metric.
   *
   * @return Value for this metric
   */


  (0, _createClass2.default)(KatalMetricString, [{
    key: "validationError",
    value: function validationError() {
      var superError = (0, _get2.default)((0, _getPrototypeOf2.default)(KatalMetricString.prototype), "validationError", this).call(this);
      if (superError) return superError;

      if (typeof this.value !== 'string') {
        return new Error("Expected field value in String metrics object '".concat(this.name, "' to be type string, but it was ").concat((0, _typeof2.default)(this.value)));
      }

      if (this.value.length > KatalMetricString.MAX_SIZE) {
        if (this.truncate) {
          this.value = this.value.substring(0, KatalMetricString.MAX_SIZE);
        } else {
          return new Error("Expected field value in String metrics object '".concat(this.name, "' to be ").concat(KatalMetricString.MAX_SIZE, " characters or less, but it was ").concat(this.value.length, " characters."));
        }
      } // Didn't find anything wrong, implicitly return undefined

    }
  }, {
    key: "value",
    get: function get() {
      return this._value;
    }
    /**
     * Set the value for this string metric.
     *
     * The new value should be a string, but number and boolean types will be automatically converted to strings.
     * For other types, including undefined and null, the value will be accepted, but will fail validation when publishing.
     *
     * @param value New value for this metric
     */
    ,
    set: function set(value) {
      if (typeof value === "number" || typeof value === "boolean") {
        value = value.toString();
      }

      this._value = value;
    }
    /**
     * Truncation flag for this string metric.
     *
     * If set, the value here will be automatically truncated to the maximum size allowed by the current schema.
     * Otherwise, sending a value larger than allowed will result in a failure.
     *
     * @param value True to automatically truncate metrics, otherwise false
     */

  }, {
    key: "type",

    /**
     * Gets the type for this metric.
     *
     * @return Always returns "String".
     */
    get: function get() {
      return _KatalMetricObject2.default.Types.String;
    }
  }, {
    key: "canMonitor",
    get: function get() {
      return false;
    }
  }]);
  return KatalMetricString;
}(_KatalMetricObject2.default);

exports.default = KatalMetricString;
(0, _defineProperty2.default)(KatalMetricString, "MAX_SIZE", 256);

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimedAttempt.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimedAttempt.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/inherits.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js"));

var _KatalMetricNamedObjectList = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricNamedObjectList */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricNamedObjectList.js"));

var _KatalMetricTimerStopwatch = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimerStopwatch */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimerStopwatch.js"));

var _KatalMetricCounter = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricCounter */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricCounter.js"));

/**
 * Metric that pairs a timer and a failure counter to record the time and status of an attempt to do something.
 */
var KatalMetricTimedAttempt =
/*#__PURE__*/
function (_KatalMetricNamedObje) {
  (0, _inherits2.default)(KatalMetricTimedAttempt, _KatalMetricNamedObje);

  /** The sub-metric name for latency. */

  /** The sub-metric name for failure count. */

  /**
   * Create a new timed attempt with the given name
   *
   * This will create two inner metrics, a KatalMetricCounter that has the given name with ".Failure" appended,
   * and a KatalMetricTimerStopwatch that has the given name with ".Latency" appended.
   *
   * @param name Name of this attempt
   */
  function KatalMetricTimedAttempt(name) {
    var _this;

    (0, _classCallCheck2.default)(this, KatalMetricTimedAttempt);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(KatalMetricTimedAttempt).call(this, name));

    _this.setNamedMetric(KatalMetricTimedAttempt.LATENCY_SUFFIX, function (name) {
      return new _KatalMetricTimerStopwatch.default(name);
    });

    _this.setNamedMetric(KatalMetricTimedAttempt.FAILURE_SUFFIX, function (name) {
      return new _KatalMetricCounter.default(name, 1);
    });

    return _this;
  }
  /**
   * Set the failure counter metric based on the given failure status.
   *
   * If failure is true the counter will have a value of 1; if it is false the counter will have a value of 0.
   *
   * @param failure Whether this is a failure or not; default true
   */


  (0, _createClass2.default)(KatalMetricTimedAttempt, [{
    key: "setFailure",
    value: function setFailure() {
      var failure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var failureCount = failure ? 1 : 0;
      var metric = this.failureMetric;
      metric.value = failureCount;
    }
    /**
     * Set the failure status to false.
     */

  }, {
    key: "setSuccess",
    value: function setSuccess() {
      this.setFailure(false);
    }
    /**
     * Set the latency metric to the given value, in milliseconds.
     *
     * Note you don't normally have to set this, the underlying metric is a KatalMetricTimerStopwatch that will start
     * and stop automatically.
     *
     * @param latencyMs Latency in milliseconds
     */

  }, {
    key: "setLatency",
    value: function setLatency(latencyMs) {
      var metric = this.latencyMetric;
      metric.value = latencyMs;
    }
    /**
     * Get the timer stopwatch metric for this attempt.
     *
     * @return Timer stopwatch metric for this attempt
     */

  }, {
    key: "latencyMetric",
    get: function get() {
      return this.getNamedMetric(KatalMetricTimedAttempt.LATENCY_SUFFIX);
    }
    /**
     * Get the failure counter metric for this attempt.
     *
     * @return Failure counter metric for this event
     */

  }, {
    key: "failureMetric",
    get: function get() {
      return this.getNamedMetric(KatalMetricTimedAttempt.FAILURE_SUFFIX);
    }
  }]);
  return KatalMetricTimedAttempt;
}(_KatalMetricNamedObjectList.default);

exports.default = KatalMetricTimedAttempt;
(0, _defineProperty2.default)(KatalMetricTimedAttempt, "LATENCY_SUFFIX", 'Latency');
(0, _defineProperty2.default)(KatalMetricTimedAttempt, "FAILURE_SUFFIX", 'Failure');

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimer.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimer.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/get.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/inherits.js"));

var _KatalMetricObject2 = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricObject */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js"));

var _ValidateSimpleInt = _interopRequireDefault(__webpack_require__(/*! ../helper/ValidateSimpleInt */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleInt.js"));

/**
 * Timer type.
 *
 * Can be used to record a time.  This class requires explicit value; see KatalMetricTimerStopwatch for automatic
 * timing.
 */
var KatalMetricTimer =
/*#__PURE__*/
function (_KatalMetricObject) {
  (0, _inherits2.default)(KatalMetricTimer, _KatalMetricObject);

  /**
   * Create a new timer metric.
   *
   * @param name Name for the metric
   * @param value Timer value in milliseconds
   */
  function KatalMetricTimer(name, value) {
    var _this;

    (0, _classCallCheck2.default)(this, KatalMetricTimer);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(KatalMetricTimer).call(this, name));
    _this.value = value;
    return _this;
  }
  /**
   * Get the value for this timer
   *
   * @return Timer value in milliseconds
   */


  (0, _createClass2.default)(KatalMetricTimer, [{
    key: "validationError",
    value: function validationError() {
      var superError = (0, _get2.default)((0, _getPrototypeOf2.default)(KatalMetricTimer.prototype), "validationError", this).call(this);
      if (superError) return superError;
      return (0, _ValidateSimpleInt.default)(this.value, "field value in Timer metrics object '".concat(this.name, "'"));
    }
  }, {
    key: "value",
    get: function get() {
      return this._value;
    }
    /**
     * Set the value for this timer
     *
     * @param value New timer value in milliseconds
     */
    ,
    set: function set(value) {
      if (value == undefined) {
        this._value = value;
        return;
      } // Math.round will also coerce from a string if necessary, and return NaN if invalid


      this._value = Math.round(value);
    }
    /**
     * Get the type for this timer.
     *
     * @return Always returns "Timer".
     */

  }, {
    key: "type",
    get: function get() {
      return _KatalMetricObject2.default.Types.Timer;
    }
  }, {
    key: "canMonitor",
    get: function get() {
      return true;
    }
  }]);
  return KatalMetricTimer;
}(_KatalMetricObject2.default);

exports.default = KatalMetricTimer;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimerStopwatch.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimerStopwatch.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _set2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/set */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/set.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/get.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/inherits.js"));

var _KatalMetricTimer2 = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimer */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimer.js"));

/**
 * Subclass of KatalMetricTimer that can be started and stopped, and will record the elapsed time between starting and
 * stopping.  By default it will start when the object is created, and stopped when the value is retrieved with
 * the getter "value".
 */
var KatalMetricTimerStopwatch =
/*#__PURE__*/
function (_KatalMetricTimer) {
  (0, _inherits2.default)(KatalMetricTimerStopwatch, _KatalMetricTimer);

  /**
   * Create a new timer with the given name and starting time.  If no starting time is given, the current time is used.
   *
   * @param name Name for this timer
   * @param startTime Millisecond epoch time for the start time; defaults to now
   */
  function KatalMetricTimerStopwatch(name, startTime) {
    var _this;

    (0, _classCallCheck2.default)(this, KatalMetricTimerStopwatch);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(KatalMetricTimerStopwatch).call(this, name, undefined));

    _this.start(startTime);

    _this._value = undefined;
    return _this;
  }
  /**
   * Re-start timer with the given start time, or the current time if none is given.
   *
   * @param startTime When the timer was started, in epoch milliseconds; defaults to now
   */


  (0, _createClass2.default)(KatalMetricTimerStopwatch, [{
    key: "start",
    value: function start(startTime) {
      this._startTime = startTime || this.now();
    }
    /**
     * Stop the timer and record the elapsed time.
     *
     * @param stopTime When the timer was stopped, in epoch milliseconds; defaults to now
     */

  }, {
    key: "stop",
    value: function stop(stopTime) {
      return this._stopTime = stopTime || this.now();
    }
    /**
     * Check if the timer has been stopped.
     *
     * @returns Whether the timer has been stopped yet
     */

  }, {
    key: "now",
    value: function now() {
      return performance.now();
    }
  }, {
    key: "isStopped",
    get: function get() {
      return this._stopTime !== undefined;
    }
    /**
     * Get the elapsed time between when the timer was started and stopped; if the timer has not yet been stopped,
     * stop it first.
     *
     * @returns Elapsed time between when timer was started and stopped
     */

  }, {
    key: "value",
    get: function get() {
      if ((0, _get2.default)((0, _getPrototypeOf2.default)(KatalMetricTimerStopwatch.prototype), "value", this) === undefined) {
        if (!this.isStopped) {
          this.stop();
        } // Rely on super.value setter to round


        (0, _set2.default)((0, _getPrototypeOf2.default)(KatalMetricTimerStopwatch.prototype), "value", this.stopTime - this.startTime, this, true);
      }

      return (0, _get2.default)((0, _getPrototypeOf2.default)(KatalMetricTimerStopwatch.prototype), "value", this);
    }
    /**
     * Get when this timer was started.
     *
     * @return Start time, in epoch milliseconds
     */
    ,

    /**
     * Set the value for this metric.  Note this will override the stopwatch behavior and just use the given value.
     *
     * @param value Value for this metric
     */
    set: function set(value) {
      (0, _set2.default)((0, _getPrototypeOf2.default)(KatalMetricTimerStopwatch.prototype), "value", value, this, true);
    }
  }, {
    key: "startTime",
    get: function get() {
      return this._startTime;
    }
    /**
     * Get when this timer was stopped (or undefined if it is still running)
     *
     * @return Stop time, in epoch millseconds, or undefined if the stopwatch is still running
     */

  }, {
    key: "stopTime",
    get: function get() {
      return this._stopTime;
    }
  }]);
  return KatalMetricTimerStopwatch;
}(_KatalMetricTimer2.default);

exports.default = KatalMetricTimerStopwatch;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricType.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricType.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * Metric types.
 */
var KatalMetricType;

(function (KatalMetricType) {
  KatalMetricType["String"] = "String";
  KatalMetricType["Counter"] = "Counter";
  KatalMetricType["Timer"] = "Timer";
  KatalMetricType["List"] = "List";
})(KatalMetricType || (KatalMetricType = {}));

;
var _default = KatalMetricType;
exports.default = _default;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/index.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/index.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Object", {
  enumerable: true,
  get: function get() {
    return _KatalMetricObject.default;
  }
});
Object.defineProperty(exports, "String", {
  enumerable: true,
  get: function get() {
    return _KatalMetricString.default;
  }
});
Object.defineProperty(exports, "Counter", {
  enumerable: true,
  get: function get() {
    return _KatalMetricCounter.default;
  }
});
Object.defineProperty(exports, "Timer", {
  enumerable: true,
  get: function get() {
    return _KatalMetricTimer.default;
  }
});
Object.defineProperty(exports, "TimerStopwatch", {
  enumerable: true,
  get: function get() {
    return _KatalMetricTimerStopwatch.default;
  }
});
Object.defineProperty(exports, "TimedAttempt", {
  enumerable: true,
  get: function get() {
    return _KatalMetricTimedAttempt.default;
  }
});
Object.defineProperty(exports, "Initialization", {
  enumerable: true,
  get: function get() {
    return _KatalMetricInitialization.default;
  }
});
Object.defineProperty(exports, "HttpRequest", {
  enumerable: true,
  get: function get() {
    return _KatalMetricHttpRequest.default;
  }
});

var _KatalMetricObject = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricObject */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js"));

var _KatalMetricString = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricString */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricString.js"));

var _KatalMetricCounter = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricCounter */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricCounter.js"));

var _KatalMetricTimer = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimer */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimer.js"));

var _KatalMetricTimerStopwatch = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimerStopwatch */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimerStopwatch.js"));

var _KatalMetricTimedAttempt = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimedAttempt */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimedAttempt.js"));

var _KatalMetricInitialization = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricInitialization */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricInitialization.js"));

var _KatalMetricHttpRequest = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricHttpRequest */ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricHttpRequest.js"));

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-sushi-client/dist/SushiClient.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@amzn/katal-sushi-client/dist/SushiClient.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * This class encapsulates two IIFEs that the Sushi library contains. A fake CSM and Window object are created and provided
 * to the functions so that they actually execute in a controlled environment away from any CSM code that might be executing
 * at the platform level within the page.
 *
 * The basic run order is the following:
 * 1. Build the mock CSM object, then build a mock Window object that references the CSM object as ue_csm
 * 2. Run the transportation-clients.js Script from SushiJavascriptClient providing the mocks. It will modify globals on the mock objects.
 * 3. Run the sushi-client.js script from SushiJavaScriptClient providing the mocks. It will create an instance of the sushi client and inject it into the CSM globals in the mocks.
 * 4. whenever event() is called, refer to the encapsulated csm object to add the event to the queue.
 */
var SushiClient =
/*#__PURE__*/
function () {
  (0, _createClass2.default)(SushiClient, null, [{
    key: "createSushiUrl",
    value: function createSushiUrl(region, sourceGroup) {
      if (!sourceGroup) {
        throw new Error("Sushi Driver was not provided with a source group.");
      }

      var domain;

      switch (region) {
        case SushiClient.REGIONS.NA:
          domain = "unagi-na";
          break;

        case SushiClient.REGIONS.EU:
          domain = "unagi-eu";
          break;

        case SushiClient.REGIONS.FE:
          domain = "unagi-fe";
          break;

        case SushiClient.REGIONS.CN:
          domain = "unagi-cn";
          break;

        default:
          throw new Error("Unrecognized region '".concat(region, "' provided to SushiClient."));
      }

      return "https://".concat(domain, ".amazon.com/1/events/").concat(sourceGroup);
    }
  }, {
    key: "createCsmUserContext",
    value: function createCsmUserContext(sushiUrl) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return _objectSpread({
        hiPriFlushInterval: 1000,
        lowPriFlushInterval: 10000,
        requestId: "1",
        errorChannel: "jserr",
        sessionStorageWrapper: undefined,
        errorHandlerFunction: console.log,
        sushiUrl: sushiUrl
      }, options);
    }
    /**
     * Create a Sushi Client for a region and source group
     *
     * @param region Region in SushiClient.REGIONS
     * @param sourceGroup Sushi Eel source group
     * @param errorHandler Error handler function
     * @param options Additional CSM context overrides
     * @param clientOverride An optional transportation client for overriding the default clients (navigator.sendBeacon and XDomainRequest or XMLHttpRequest)
     */

  }, {
    key: "REGIONS",
    get: function get() {
      return {
        NA: "NA",
        EU: "EU",
        FE: "FE",
        CN: "CN"
      };
    }
  }]);

  function SushiClient() {
    var region = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SushiClient.REGIONS.NA;
    var sourceGroup = arguments.length > 1 ? arguments[1] : undefined;
    var errorHandler = arguments.length > 2 ? arguments[2] : undefined;
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var clientOverride = arguments.length > 4 ? arguments[4] : undefined;
    (0, _classCallCheck2.default)(this, SushiClient);
    var sushiUrl = SushiClient.createSushiUrl(region, sourceGroup);
    var csmUserContext = SushiClient.createCsmUserContext(sushiUrl, options);
    this.ue_csm = this.setupMockCSMObject(csmUserContext);
    this.encapsulatedWindow = this.setupMockWindow(this.ue_csm);
    this.transportationClientCode(this.ue_csm, window);

    if (clientOverride) {
      this.ue_csm.ue._sBcn = {
        isSupported: true,
        send: function send(endpoint, payload) {
          clientOverride(endpoint, payload);
          return true;
        }
      };
    }

    this.clientCode(this.ue_csm, this.encapsulatedWindow);
    this.errorHandler = errorHandler;
  }

  (0, _createClass2.default)(SushiClient, [{
    key: "event",
    value: function event(data, producerId, schemaId, options) {
      var debug = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

      if (debug) {
        console.log("SushiClient wrapper publishing the following:", {
          data: data,
          producerId: producerId,
          schemaId: schemaId,
          options: options
        });
      }

      return this.ue_csm.ue.event(data, producerId, schemaId, options);
    }
    /**
     * If you plan to emit 1000 or more events per instantiated client,
     * call reset after calling event to allow the CSM client to continue sending events.
     */

  }, {
    key: "reset",
    value: function reset() {
      this.ue_csm.ue.event.reset();
    }
    /**
     * Register a callback that will be called just before each time metrics are
     * flushed to the network.
     * @param callback A function that sushi will call before flushes.
     */

  }, {
    key: "onSushiFlush",
    value: function onSushiFlush(callback) {
      this.ue_csm.ue.onSushiFlush(callback);
    }
    /**
     * Register a callback that will be called just before the page unloads.
     * This can be used to send any final metrics to sushi, such as page visit
     * duration or batched counters.
     * @param callback A function that sushi will call before unload.
     */

  }, {
    key: "onSushiUnload",
    value: function onSushiUnload(callback) {
      this.ue_csm.ue.onSushiUnload(callback);
    }
  }, {
    key: "setupMockCSMObject",
    value: function setupMockCSMObject(csmUserContext) {
      var _this = this;

      var execStub = function execStub(callback, attribution) {
        return callback;
      };

      var eventStub = function eventStub(log, producer, eventType) {
        console.warn("SushiClient CSM stub called in unsupported manner: event()");
      };

      var errorHandler = function errorHandler(logEvent, channel) {
        if (_this.errorHandler) {
          _this.errorHandler(logEvent);
        } else {
          console.log("An error has occurred in SushiClient channel " + channel, logEvent);
        }
      };

      var attachHandler = function attachHandler(evt, handler, container) {
        //TODO might be able to just use window.ue.attach?
        container = container || window; //ok to use real window global here.

        if (window.EventTarget && window.EventTarget.prototype && window.EventTarget.prototype.addEventListener) {
          window.EventTarget.prototype.addEventListener.call(container, evt, handler, !!window.ue_clf);
        } else if (container.addEventListener) {
          container.addEventListener(evt, handler, !!window.ue_clf);
        } else if (container.attachEvent) {
          container.attachEvent("on" + evt, handler);
        }
      };

      return {
        ue_hpsi: csmUserContext.hiPriFlushInterval,
        ue_lpsi: csmUserContext.lowPriFlushInterval,
        ue: {
          ssw: csmUserContext.sessionStorageWrapper,
          log: errorHandler,
          exec: execStub,
          event: eventStub,
          attach: attachHandler
        },
        ueLogError: csmUserContext.errorHandlerFunction,
        ue_surl: csmUserContext.sushiUrl,
        ue_id: csmUserContext.requestId,
        ue_err_chan: csmUserContext.errorChannel
      };
    }
  }, {
    key: "setupMockWindow",
    value: function setupMockWindow(ue_csm) {
      //apparently cannot ref the setTimeout function directly in some browsers so we have to wrap it.
      var timeoutWrapper = function timeoutWrapper(fn, timeout) {
        return window.setTimeout(fn, timeout);
      };

      return {
        ue_csm: ue_csm,
        ueLogError: ue_csm.ueLogError,
        ue: ue_csm.ue,
        setTimeout: timeoutWrapper
      };
    }
    /**
     * Code within function pulled directly from
     * https://code.amazon.com/packages/SushiJavaScriptClient/blobs/mainline/--/javascript/sushi-client.js
     */

  }, {
    key: "clientCode",
    value: function clientCode(ue_csm, window) {
      ue_csm.ue.exec(function (b, k) {
        function A() {
          for (var a = 0; a < arguments.length; a++) {
            var c = arguments[a];

            try {
              var h;

              if (c.isSupported) {
                var b = t.buildPayload(l, e);
                h = c.send(J, b);
              } else throw dummyException;

              return h;
            } catch (d) {}
          }

          B({
            m: "All supported clients failed",
            attribution: "CSMSushiClient_TRANSPORTATION_FAIL",
            f: "sushi-client.js",
            logLevel: "ERROR"
          }, k.ue_err_chan || "jserr");
        }

        function m() {
          if (e.length) {
            for (var a = 0; a < n.length; a++) {
              n[a]();
            }

            A(d._sBcn || {}, d._ajx || {});
            e = [];
            f = {};
            l = {};
            u = v = q = w = 0;
          }
        }

        function K() {
          var a = new Date(),
              c = function c(a) {
            return 10 > a ? "0" + a : a;
          };

          return Date.prototype.toISOString ? a.toISOString() : a.getUTCFullYear() + "-" + c(a.getUTCMonth() + 1) + "-" + c(a.getUTCDate()) + "T" + c(a.getUTCHours()) + ":" + c(a.getUTCMinutes()) + ":" + c(a.getUTCSeconds()) + "." + String((a.getUTCMilliseconds() / 1E3).toFixed(3)).slice(2, 5) + "Z";
        }

        function x(a) {
          try {
            return JSON.stringify(a);
          } catch (c) {}

          return null;
        }

        function C(a, c, h, g) {
          var p = !1;
          g = g || {};
          r++;
          r == D && B({
            m: "Max number of Sushi Logs exceeded",
            f: "sushi-client.js",
            logLevel: "ERROR",
            attribution: "CSMSushiClient_MAX_CALLS"
          }, k.ue_err_chan || "jserr");
          var f;
          if (f = !(r >= D)) (f = a && -1 < a.constructor.toString().indexOf("Object") && c && -1 < c.constructor.toString().indexOf("String") && h && -1 < h.constructor.toString().indexOf("String")) || L++;
          f && (d.count && d.count("Event:" + h, 1), a.producerId = a.producerId || c, a.schemaId = a.schemaId || h, a.timestamp = K(), c = Date.now ? Date.now() : +new Date(), h = Math.random().toString().substring(2, 12), a.messageId = b.ue_id + "-" + c + "-" + h, g && !g.ssd && (a.sessionId = a.sessionId || b.ue_sid, a.requestId = a.requestId || b.ue_id, a.obfuscatedMarketplaceId = a.obfuscatedMarketplaceId || b.ue_mid), (c = x(a)) ? (c = c.length, (e.length == M || q + c > N) && m(), q += c, a = {
            data: t.compressEvent(a)
          }, e.push(a), (g || {}).n ? 0 === E ? m() : u || (u = k.setTimeout(m, E)) : v || (v = k.setTimeout(m, O)), p = !0) : p = !1);
          !p && b.ue_int && console.error("Invalid JS Nexus API call");
          return p;
        }

        function F() {
          if (!G) {
            for (var a = 0; a < y.length; a++) {
              y[a]();
            }

            for (a = 0; a < n.length; a++) {
              n[a]();
            }

            e.length && (b.ue_sbuimp && b.ue && b.ue.ssw && (a = x({
              dct: l,
              evt: e
            }), b.ue.ssw("eeldata", a), b.ue.ssw("eelsts", "unk")), A(d._sBcn || {}));
            G = !0;
          }
        }

        function H(a) {
          y.push(a);
        }

        function I(a) {
          n.push(a);
        }

        var D = 1E3,
            M = 499,
            N = 524288,
            s = function s() {},
            d = b.ue || {},
            B = d.log || s,
            P = b.uex || s;

        (b.uet || s)("bb", "ue_sushi_v1", {
          wb: 1
        });

        var J = b.ue_surl || "https://unagi-na.amazon.com/1/events/com.amazon.csm.nexusclient.gamma",
            Q = ["messageId", "timestamp"],
            z = "#",
            e = [],
            f = {},
            l = {},
            q = 0,
            w = 0,
            L = 0,
            r = 0,
            y = [],
            n = [],
            G = !1,
            u,
            v,
            E = void 0 === b.ue_hpsi ? 1E3 : b.ue_hpsi,
            O = void 0 === b.ue_lpsi ? 1E4 : b.ue_lpsi,
            t = function () {
          function a(a) {
            f[a] = z + w++;
            l[f[a]] = a;
            return f[a];
          }

          function c(b) {
            if (!(b instanceof Function)) {
              if (b instanceof Array) {
                for (var g = [], d = b.length, e = 0; e < d; e++) {
                  g[e] = c(b[e]);
                }

                return g;
              }

              if (b instanceof Object) {
                g = {};

                for (d in b) {
                  b.hasOwnProperty(d) && (g[f[d] ? f[d] : a(d)] = -1 === Q.indexOf(d) ? c(b[d]) : b[d]);
                }

                return g;
              }

              return "string" === typeof b && (b.length > (z + w).length || b.charAt(0) === z) ? f[b] ? f[b] : a(b) : b;
            }
          }

          return {
            compressEvent: c,
            buildPayload: function buildPayload() {
              return x({
                cs: {
                  dct: l
                },
                events: e
              });
            }
          };
        }();

        (function () {
          if (d.event && d.event.isStub) {
            if (b.ue_sbuimp && b.ue && b.ue.ssw) {
              var a = b.ue.ssw("eelsts").val;

              if (a && "unk" === a && (a = b.ue.ssw("eeldata").val)) {
                var c;

                a: {
                  try {
                    c = JSON.parse(a);
                    break a;
                  } catch (f) {}

                  c = null;
                }

                c && c.evt instanceof Array && c.dct instanceof Object && (e = c.evt, l = c.dct, e && l && (m(), b.ue.ssw("eeldata", "{}"), b.ue.ssw("eelsts", "scs")));
              }
            }

            d.event.replay(function (a) {
              a[3] = a[3] || {};
              a[3].n = 1;
              C.apply(this, a);
            });
            d.onSushiUnload.replay(function (a) {
              H(a[0]);
            });
            d.onSushiFlush.replay(function (a) {
              I(a[0]);
            });
          }
        })();

        d.attach("beforeunload", F);
        d.attach("pagehide", F);
        d._cmps = t;
        d.event = C;

        d.event.reset = function () {
          r = 0;
        };

        d.onSushiUnload = H;
        d.onSushiFlush = I;

        try {
          k.P && k.P.register && k.P.register("sushi-client", s);
        } catch (R) {
          b.ueLogError(R, {
            logLevel: "WARN"
          });
        }

        P("ld", "ue_sushi_v1", {
          wb: 1
        });
      }, "Nxs-JS-Client")(ue_csm, window);
    }
    /**
     * The code in this function is pulled directly from:
     * https://code.amazon.com/packages/SushiJavaScriptClient/blobs/mainline/--/javascript/transportation-clients.js
     */

  }, {
    key: "transportationClientCode",
    value: function transportationClientCode(ue_csm, window) {
      ue_csm.ue.exec(function (b, c) {
        var e = function e() {},
            f = function () {
          return {
            send: function send(b, d) {
              if (d && b) {
                var a;
                if (c.XDomainRequest) a = new XDomainRequest(), a.onerror = e, a.ontimeout = e, a.onprogress = e, a.onload = e, a.timeout = 0;else if (c.XMLHttpRequest) {
                  if (a = new XMLHttpRequest(), !("withCredentials" in a)) throw "";
                } else a = void 0;
                if (!a) throw "";
                a.open("POST", b, !0);
                a.setRequestHeader && a.setRequestHeader("Content-type", "text/plain");
                a.send(d);
              }
            },
            isSupported: !0
          };
        }(),
            g = function () {
          return {
            send: function send(c, d) {
              if (c && d) if (navigator.sendBeacon(c, d)) b.ue_sbuimp && b.ue && b.ue.ssw && b.ue.ssw("eelsts", "scs");else throw "";
            },
            isSupported: !!navigator.sendBeacon && !(c.cordova && c.cordova.platformId && "ios" == c.cordova.platformId)
          };
        }();

        b.ue._ajx = f;
        b.ue._sBcn = g;
      }, "Transportation-clients")(ue_csm, window);
    }
  }]);
  return SushiClient;
}();

exports.default = SushiClient;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/arrayLikeToArray.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/arrayWithoutHoles.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/arrayWithoutHoles.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/arrayLikeToArray.js");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/assertThisInitialized.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/assertThisInitialized.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/createClass.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/get.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/get.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var superPropBase = __webpack_require__(/*! ./superPropBase.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/superPropBase.js");

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    module.exports = _get = Reflect.get;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _get = function _get(target, property, receiver) {
      var base = superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }

  return _get(target, property, receiver || target);
}

module.exports = _get;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/inherits.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/inherits.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/setPrototypeOf.js");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireWildcard.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/interopRequireWildcard.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/typeof.js")["default"];

function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}

function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache(nodeInterop);

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

module.exports = _interopRequireWildcard;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/iterableToArray.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/iterableToArray.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

module.exports = _iterableToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/nonIterableSpread.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/nonIterableSpread.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/objectSpread.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/objectSpread.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(/*! ./defineProperty.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js");

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? Object(arguments[i]) : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      defineProperty(target, key, source[key]);
    });
  }

  return target;
}

module.exports = _objectSpread;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/typeof.js")["default"];

var assertThisInitialized = __webpack_require__(/*! ./assertThisInitialized.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/assertThisInitialized.js");

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/set.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/set.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var superPropBase = __webpack_require__(/*! ./superPropBase.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/superPropBase.js");

var defineProperty = __webpack_require__(/*! ./defineProperty.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/defineProperty.js");

function set(target, property, value, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.set) {
    set = Reflect.set;
  } else {
    set = function set(target, property, value, receiver) {
      var base = superPropBase(target, property);
      var desc;

      if (base) {
        desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.set) {
          desc.set.call(receiver, value);
          return true;
        } else if (!desc.writable) {
          return false;
        }
      }

      desc = Object.getOwnPropertyDescriptor(receiver, property);

      if (desc) {
        if (!desc.writable) {
          return false;
        }

        desc.value = value;
        Object.defineProperty(receiver, property, desc);
      } else {
        defineProperty(receiver, property, value);
      }

      return true;
    };
  }

  return set(target, property, value, receiver);
}

function _set(target, property, value, receiver, isStrict) {
  var s = set(target, property, value, receiver || target);

  if (!s && isStrict) {
    throw new Error('failed to set property');
  }

  return value;
}

module.exports = _set;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/superPropBase.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/superPropBase.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getPrototypeOf = __webpack_require__(/*! ./getPrototypeOf.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/getPrototypeOf.js");

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

module.exports = _superPropBase;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/toConsumableArray.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/toConsumableArray.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(/*! ./arrayWithoutHoles.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/arrayWithoutHoles.js");

var iterableToArray = __webpack_require__(/*! ./iterableToArray.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/iterableToArray.js");

var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");

var nonIterableSpread = __webpack_require__(/*! ./nonIterableSpread.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/nonIterableSpread.js");

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/typeof.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/typeof.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }

  return _typeof(obj);
}

module.exports = _typeof;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray.js */ "./node_modules/@amzn/katal-logger/node_modules/@babel/runtime/helpers/arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/error-stack-parser/error-stack-parser.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/error-stack-parser/error-stack-parser.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! stackframe */ "./node_modules/@amzn/katal-logger/node_modules/stackframe/stackframe.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function ErrorStackParser(StackFrame) {
    'use strict';

    var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+:\d+/;
    var CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+:\d+|\(native\))/m;
    var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code])?$/;

    return {
        /**
         * Given an Error object, extract the most information from it.
         *
         * @param {Error} error object
         * @return {Array} of StackFrames
         */
        parse: function ErrorStackParser$$parse(error) {
            if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {
                return this.parseOpera(error);
            } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {
                return this.parseV8OrIE(error);
            } else if (error.stack) {
                return this.parseFFOrSafari(error);
            } else {
                throw new Error('Cannot parse given Error object');
            }
        },

        // Separate line and column numbers from a string of the form: (URI:Line:Column)
        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {
            // Fail-fast but return locations like "(native)"
            if (urlLike.indexOf(':') === -1) {
                return [urlLike];
            }

            var regExp = /(.+?)(?::(\d+))?(?::(\d+))?$/;
            var parts = regExp.exec(urlLike.replace(/[()]/g, ''));
            return [parts[1], parts[2] || undefined, parts[3] || undefined];
        },

        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !!line.match(CHROME_IE_STACK_REGEXP);
            }, this);

            return filtered.map(function(line) {
                if (line.indexOf('(eval ') > -1) {
                    // Throw away eval information until we implement stacktrace.js/stackframe#8
                    line = line.replace(/eval code/g, 'eval').replace(/(\(eval at [^()]*)|(\),.*$)/g, '');
                }
                var sanitizedLine = line.replace(/^\s+/, '').replace(/\(eval code/g, '(');

                // capture and preseve the parenthesized location "(/foo/my bar.js:12:87)" in
                // case it has spaces in it, as the string is split on \s+ later on
                var location = sanitizedLine.match(/ (\((.+):(\d+):(\d+)\)$)/);

                // remove the parenthesized location from the line, if it was matched
                sanitizedLine = location ? sanitizedLine.replace(location[0], '') : sanitizedLine;

                var tokens = sanitizedLine.split(/\s+/).slice(1);
                // if a location was matched, pass it to extractLocation() otherwise pop the last token
                var locationParts = this.extractLocation(location ? location[1] : tokens.pop());
                var functionName = tokens.join(' ') || undefined;
                var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];

                return new StackFrame({
                    functionName: functionName,
                    fileName: fileName,
                    lineNumber: locationParts[1],
                    columnNumber: locationParts[2],
                    source: line
                });
            }, this);
        },

        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !line.match(SAFARI_NATIVE_CODE_REGEXP);
            }, this);

            return filtered.map(function(line) {
                // Throw away eval information until we implement stacktrace.js/stackframe#8
                if (line.indexOf(' > eval') > -1) {
                    line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ':$1');
                }

                if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {
                    // Safari eval frames only have function names and nothing else
                    return new StackFrame({
                        functionName: line
                    });
                } else {
                    var functionNameRegex = /((.*".+"[^@]*)?[^@]*)(?:@)/;
                    var matches = line.match(functionNameRegex);
                    var functionName = matches && matches[1] ? matches[1] : undefined;
                    var locationParts = this.extractLocation(line.replace(functionNameRegex, ''));

                    return new StackFrame({
                        functionName: functionName,
                        fileName: locationParts[0],
                        lineNumber: locationParts[1],
                        columnNumber: locationParts[2],
                        source: line
                    });
                }
            }, this);
        },

        parseOpera: function ErrorStackParser$$parseOpera(e) {
            if (!e.stacktrace || (e.message.indexOf('\n') > -1 &&
                e.message.split('\n').length > e.stacktrace.split('\n').length)) {
                return this.parseOpera9(e);
            } else if (!e.stack) {
                return this.parseOpera10(e);
            } else {
                return this.parseOpera11(e);
            }
        },

        parseOpera9: function ErrorStackParser$$parseOpera9(e) {
            var lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
            var lines = e.message.split('\n');
            var result = [];

            for (var i = 2, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(new StackFrame({
                        fileName: match[2],
                        lineNumber: match[1],
                        source: lines[i]
                    }));
                }
            }

            return result;
        },

        parseOpera10: function ErrorStackParser$$parseOpera10(e) {
            var lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
            var lines = e.stacktrace.split('\n');
            var result = [];

            for (var i = 0, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(
                        new StackFrame({
                            functionName: match[3] || undefined,
                            fileName: match[2],
                            lineNumber: match[1],
                            source: lines[i]
                        })
                    );
                }
            }

            return result;
        },

        // Opera 10.65+ Error.stack very similar to FF/Safari
        parseOpera11: function ErrorStackParser$$parseOpera11(error) {
            var filtered = error.stack.split('\n').filter(function(line) {
                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
            }, this);

            return filtered.map(function(line) {
                var tokens = line.split('@');
                var locationParts = this.extractLocation(tokens.pop());
                var functionCall = (tokens.shift() || '');
                var functionName = functionCall
                    .replace(/<anonymous function(: (\w+))?>/, '$2')
                    .replace(/\([^)]*\)/g, '') || undefined;
                var argsRaw;
                if (functionCall.match(/\(([^)]*)\)/)) {
                    argsRaw = functionCall.replace(/^[^(]+\(([^)]*)\)$/, '$1');
                }
                var args = (argsRaw === undefined || argsRaw === '[arguments not available]') ?
                    undefined : argsRaw.split(',');

                return new StackFrame({
                    functionName: functionName,
                    args: args,
                    fileName: locationParts[0],
                    lineNumber: locationParts[1],
                    columnNumber: locationParts[2],
                    source: line
                });
            }, this);
        }
    };
}));


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/promise-polyfill/src/finally.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/promise-polyfill/src/finally.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @this {Promise}
 */
function finallyConstructor(callback) {
  var constructor = this.constructor;
  return this.then(
    function(value) {
      // @ts-ignore
      return constructor.resolve(callback()).then(function() {
        return value;
      });
    },
    function(reason) {
      // @ts-ignore
      return constructor.resolve(callback()).then(function() {
        // @ts-ignore
        return constructor.reject(reason);
      });
    }
  );
}

/* harmony default export */ __webpack_exports__["default"] = (finallyConstructor);


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/promise-polyfill/src/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/promise-polyfill/src/index.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(setImmediate) {/* harmony import */ var _finally__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./finally */ "./node_modules/@amzn/katal-logger/node_modules/promise-polyfill/src/finally.js");


// Store setTimeout reference so promise-polyfill will be unaffected by
// other code modifying setTimeout (like sinon.useFakeTimers())
var setTimeoutFunc = setTimeout;

function isArray(x) {
  return Boolean(x && typeof x.length !== 'undefined');
}

function noop() {}

// Polyfill for Function.prototype.bind
function bind(fn, thisArg) {
  return function() {
    fn.apply(thisArg, arguments);
  };
}

/**
 * @constructor
 * @param {Function} fn
 */
function Promise(fn) {
  if (!(this instanceof Promise))
    throw new TypeError('Promises must be constructed via new');
  if (typeof fn !== 'function') throw new TypeError('not a function');
  /** @type {!number} */
  this._state = 0;
  /** @type {!boolean} */
  this._handled = false;
  /** @type {Promise|undefined} */
  this._value = undefined;
  /** @type {!Array<!Function>} */
  this._deferreds = [];

  doResolve(fn, this);
}

function handle(self, deferred) {
  while (self._state === 3) {
    self = self._value;
  }
  if (self._state === 0) {
    self._deferreds.push(deferred);
    return;
  }
  self._handled = true;
  Promise._immediateFn(function() {
    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
    if (cb === null) {
      (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
      return;
    }
    var ret;
    try {
      ret = cb(self._value);
    } catch (e) {
      reject(deferred.promise, e);
      return;
    }
    resolve(deferred.promise, ret);
  });
}

function resolve(self, newValue) {
  try {
    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
    if (newValue === self)
      throw new TypeError('A promise cannot be resolved with itself.');
    if (
      newValue &&
      (typeof newValue === 'object' || typeof newValue === 'function')
    ) {
      var then = newValue.then;
      if (newValue instanceof Promise) {
        self._state = 3;
        self._value = newValue;
        finale(self);
        return;
      } else if (typeof then === 'function') {
        doResolve(bind(then, newValue), self);
        return;
      }
    }
    self._state = 1;
    self._value = newValue;
    finale(self);
  } catch (e) {
    reject(self, e);
  }
}

function reject(self, newValue) {
  self._state = 2;
  self._value = newValue;
  finale(self);
}

function finale(self) {
  if (self._state === 2 && self._deferreds.length === 0) {
    Promise._immediateFn(function() {
      if (!self._handled) {
        Promise._unhandledRejectionFn(self._value);
      }
    });
  }

  for (var i = 0, len = self._deferreds.length; i < len; i++) {
    handle(self, self._deferreds[i]);
  }
  self._deferreds = null;
}

/**
 * @constructor
 */
function Handler(onFulfilled, onRejected, promise) {
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
  this.promise = promise;
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, self) {
  var done = false;
  try {
    fn(
      function(value) {
        if (done) return;
        done = true;
        resolve(self, value);
      },
      function(reason) {
        if (done) return;
        done = true;
        reject(self, reason);
      }
    );
  } catch (ex) {
    if (done) return;
    done = true;
    reject(self, ex);
  }
}

Promise.prototype['catch'] = function(onRejected) {
  return this.then(null, onRejected);
};

Promise.prototype.then = function(onFulfilled, onRejected) {
  // @ts-ignore
  var prom = new this.constructor(noop);

  handle(this, new Handler(onFulfilled, onRejected, prom));
  return prom;
};

Promise.prototype['finally'] = _finally__WEBPACK_IMPORTED_MODULE_0__["default"];

Promise.all = function(arr) {
  return new Promise(function(resolve, reject) {
    if (!isArray(arr)) {
      return reject(new TypeError('Promise.all accepts an array'));
    }

    var args = Array.prototype.slice.call(arr);
    if (args.length === 0) return resolve([]);
    var remaining = args.length;

    function res(i, val) {
      try {
        if (val && (typeof val === 'object' || typeof val === 'function')) {
          var then = val.then;
          if (typeof then === 'function') {
            then.call(
              val,
              function(val) {
                res(i, val);
              },
              reject
            );
            return;
          }
        }
        args[i] = val;
        if (--remaining === 0) {
          resolve(args);
        }
      } catch (ex) {
        reject(ex);
      }
    }

    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};

Promise.resolve = function(value) {
  if (value && typeof value === 'object' && value.constructor === Promise) {
    return value;
  }

  return new Promise(function(resolve) {
    resolve(value);
  });
};

Promise.reject = function(value) {
  return new Promise(function(resolve, reject) {
    reject(value);
  });
};

Promise.race = function(arr) {
  return new Promise(function(resolve, reject) {
    if (!isArray(arr)) {
      return reject(new TypeError('Promise.race accepts an array'));
    }

    for (var i = 0, len = arr.length; i < len; i++) {
      Promise.resolve(arr[i]).then(resolve, reject);
    }
  });
};

// Use polyfill for setImmediate for performance gains
Promise._immediateFn =
  // @ts-ignore
  (typeof setImmediate === 'function' &&
    function(fn) {
      // @ts-ignore
      setImmediate(fn);
    }) ||
  function(fn) {
    setTimeoutFunc(fn, 0);
  };

Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
  if (typeof console !== 'undefined' && console) {
    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
  }
};

/* harmony default export */ __webpack_exports__["default"] = (Promise);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/array-set.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/source-map/lib/array-set.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(/*! ./util */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/util.js");
var has = Object.prototype.hasOwnProperty;

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
  this._array = [];
  this._set = Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
  return Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = util.toSetString(aStr);
  var isDuplicate = has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    this._set[sStr] = idx;
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
  var sStr = util.toSetString(aStr);
  return has.call(this._set, sStr);
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  var sStr = util.toSetString(aStr);
  if (has.call(this._set, sStr)) {
    return this._set[sStr];
  }
  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.ArraySet = ArraySet;


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/base64-vlq.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/source-map/lib/base64-vlq.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = __webpack_require__(/*! ./base64 */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/base64.js");

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/base64.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/source-map/lib/base64.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
exports.decode = function (charCode) {
  var bigA = 65;     // 'A'
  var bigZ = 90;     // 'Z'

  var littleA = 97;  // 'a'
  var littleZ = 122; // 'z'

  var zero = 48;     // '0'
  var nine = 57;     // '9'

  var plus = 43;     // '+'
  var slash = 47;    // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return (charCode - bigA);
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return (charCode - littleA + littleOffset);
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return (charCode - zero + numberOffset);
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/binary-search.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/source-map/lib/binary-search.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  }
  else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  }
  else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    }

    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
    return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }
    --index;
  }

  return index;
};


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/mapping-list.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/source-map/lib/mapping-list.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(/*! ./util */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/util.js");

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

exports.MappingList = MappingList;


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/quick-sort.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/source-map/lib/quick-sort.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}

/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
function randomIntInRange(low, high) {
  return Math.round(low + (Math.random() * (high - low)));
}

/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.

  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.

    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;

    swap(ary, pivotIndex, r);
    var pivot = ary[r];

    // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1;

    // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */
exports.quickSort = function (ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/source-map-consumer.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/source-map/lib/source-map-consumer.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(/*! ./util */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/util.js");
var binarySearch = __webpack_require__(/*! ./binary-search */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/binary-search.js");
var ArraySet = __webpack_require__(/*! ./array-set */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/array-set.js").ArraySet;
var base64VLQ = __webpack_require__(/*! ./base64-vlq */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/base64-vlq.js");
var quickSort = __webpack_require__(/*! ./quick-sort */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/quick-sort.js").quickSort;

function SourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  return sourceMap.sections != null
    ? new IndexedSourceMapConsumer(sourceMap)
    : new BasicSourceMapConsumer(sourceMap);
}

SourceMapConsumer.fromSourceMap = function(aSourceMap) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
}

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});

SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator =
  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping =
  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

    var mappings;
    switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
    }

    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      if (source != null && sourceRoot != null) {
        source = util.join(sourceRoot, source);
      }
      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: Optional. the column number in the original source.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor =
  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');

    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0)
    };

    if (this.sourceRoot != null) {
      needle.source = util.relative(this.sourceRoot, needle.source);
    }
    if (!this._sources.has(needle.source)) {
      return [];
    }
    needle.source = this._sources.indexOf(needle.source);

    var mappings = [];

    var index = this._findMapping(needle,
                                  this._originalMappings,
                                  "originalLine",
                                  "originalColumn",
                                  util.compareByOriginalPositions,
                                  binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.
        while (mapping &&
               mapping.originalLine === line &&
               mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  };

exports.SourceMapConsumer = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The only parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources');
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  sources = sources
    .map(String)
    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util.normalize)
    // Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function (source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
        ? util.relative(sourceRoot, source)
        : source;
    });

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);

  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap =
  function SourceMapConsumer_fromSourceMap(aSourceMap) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);

    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                            smc.sourceRoot);
    smc.file = aSourceMap._file;

    // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.

    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping;
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

    return smc;
  };

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._sources.toArray().map(function (s) {
      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
    }, this);
  }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
BasicSourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;

    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      }
      else if (aStr.charAt(index) === ',') {
        index++;
      }
      else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;

        // Because each offset is encoded relative to the previous one,
        // many segments often have the same encoding. We can exploit this
        // fact by caching the parsed variable length fields of each segment,
        // allowing us to avoid a second parse if we encounter the same
        // segment again.
        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);

        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }

          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }

          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }

          cachedSegments[str] = segment;
        }

        // Generated column.
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;

        if (segment.length > 1) {
          // Original source.
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];

          // Original line.
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          // Lines are stored 0-based
          mapping.originalLine += 1;

          // Original column.
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;

          if (segment.length > 4) {
            // Original name.
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }

        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }

    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;

    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping =
  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                         aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.

    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got '
                          + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got '
                          + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans =
  function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];

      // Mappings do not contain a field for the last generated columnt. We
      // can come up with an optimistic estimate, however, by assuming that
      // mappings are contiguous (i.e. given two consecutive mappings, the
      // first mapping ends where the second one starts).
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];

        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }

      // The last mapping for each line spans the entire line.
      mapping.lastGeneratedColumn = Infinity;
    }
  };

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor =
  function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      util.compareByGeneratedPositionsDeflated,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._generatedMappings[index];

      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);
        if (source !== null) {
          source = this._sources.at(source);
          if (this.sourceRoot != null) {
            source = util.join(this.sourceRoot, source);
          }
        }
        var name = util.getArg(mapping, 'name', null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
  function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() &&
      !this.sourcesContent.some(function (sc) { return sc == null; });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor =
  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    if (this.sourceRoot != null) {
      aSource = util.relative(this.sourceRoot, aSource);
    }

    if (this._sources.has(aSource)) {
      return this.sourcesContent[this._sources.indexOf(aSource)];
    }

    var url;
    if (this.sourceRoot != null
        && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
      if (url.scheme == "file"
          && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
      }

      if ((!url.path || url.path == "/")
          && this._sources.has("/" + aSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + aSource)];
      }
    }

    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor =
  function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    if (this.sourceRoot != null) {
      source = util.relative(this.sourceRoot, source);
    }
    if (!this._sources.has(source)) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }
    source = this._sources.indexOf(source);

    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util.compareByOriginalPositions,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };

exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The only parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();

  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }
    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line ||
        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }
    lastOffset = offset;

    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'))
    }
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];
    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor =
  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(needle, this._sections,
      function(needle, section) {
        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }

        return (needle.generatedColumn -
                section.generatedOffset.generatedColumn);
      });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine -
        (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn -
        (section.generatedOffset.generatedLine === needle.generatedLine
         ? section.generatedOffset.generatedColumn - 1
         : 0),
      bias: aArgs.bias
    });
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor =
  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor =
  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      // Only consider this section if the requested source is in the list of
      // sources of the consumer.
      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line +
            (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column +
            (section.generatedOffset.generatedLine === generatedPosition.line
             ? section.generatedOffset.generatedColumn - 1
             : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings =
  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);
        if (section.consumer.sourceRoot !== null) {
          source = util.join(section.consumer.sourceRoot, source);
        }
        this._sources.add(source);
        source = this._sources.indexOf(source);

        var name = section.consumer._names.at(mapping.name);
        this._names.add(name);
        name = this._names.indexOf(name);

        // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.
        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine +
            (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn +
            (section.generatedOffset.generatedLine === mapping.generatedLine
            ? section.generatedOffset.generatedColumn - 1
            : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };

exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/source-map-generator.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/source-map/lib/source-map-generator.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = __webpack_require__(/*! ./base64-vlq */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/base64-vlq.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/util.js");
var ArraySet = __webpack_require__(/*! ./array-set */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/array-set.js").ArraySet;
var MappingList = __webpack_require__(/*! ./mapping-list */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/mapping-list.js").MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source)
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                              aName) {
    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    }
    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) {
      // Cases 2 and 3.
      return;
    }
    else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = ''

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      }
      else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

SourceMapGenerator.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
  function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
  function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

exports.SourceMapGenerator = SourceMapGenerator;


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/source-node.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/source-map/lib/source-node.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var SourceMapGenerator = __webpack_require__(/*! ./source-map-generator */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator;
var util = __webpack_require__(/*! ./util */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/util.js");

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
SourceNode.fromStringWithSourceMap =
  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode();

    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are removed from this array, by calling `shiftNextLine`.
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var shiftNextLine = function() {
      var lineContents = remainingLines.shift();
      // The last line of a file might not have a newline.
      var newLine = remainingLines.shift() || "";
      return lineContents + newLine;
    };

    // We need to remember the position of "remainingLines"
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    var lastMapping = null;

    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) {
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
          // The remaining code is added without mapping
        } else {
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          var nextLine = remainingLines[0];
          var code = nextLine.substr(0, mapping.generatedColumn -
                                        lastGeneratedColumn);
          remainingLines[0] = nextLine.substr(mapping.generatedColumn -
                                              lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          // No more remaining code, continue
          lastMapping = mapping;
          return;
        }
      }
      // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[0];
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[0] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLines.length > 0) {
      if (lastMapping) {
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      // and add the remaining lines without any mapping
      node.add(remainingLines.join(""));
    }

    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });

    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath
          ? util.join(aRelativePath, mapping.source)
          : mapping.source;
        node.add(new SourceNode(mapping.originalLine,
                                mapping.originalColumn,
                                source,
                                code,
                                mapping.name));
      }
    }
  };

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length-1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;
  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];
    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    }
    else {
      if (chunk !== '') {
        aFn(chunk, { source: this.source,
                     line: this.line,
                     column: this.column,
                     name: this.name });
      }
    }
  }
};

/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;
  if (len > 0) {
    newChildren = [];
    for (i = 0; i < len-1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }
    newChildren.push(this.children[i]);
    this.children = newChildren;
  }
  return this;
};

/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];
  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  }
  else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  }
  else {
    this.children.push(''.replace(aPattern, aReplacement));
  }
  return this;
};

/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
SourceNode.prototype.setSourceContent =
  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };

/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walkSourceContents =
  function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };

/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};

/**
 * Returns the string representation of this source node along with a source
 * map.
 */
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;
    if (original.source !== null
        && original.line !== null
        && original.column !== null) {
      if(lastOriginalSource !== original.source
         || lastOriginalLine !== original.line
         || lastOriginalColumn !== original.column
         || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }
      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }
    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0;
        // Mappings end at eol
        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });

  return { code: generated.code, map: map };
};

exports.SourceNode = SourceNode;


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/util.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/source-map/lib/util.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);

  var parts = path.split(/\/+/);
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
}
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/'
    ? aPath
    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = (function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}());

function identity (s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
    return false;
  }

  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    return false;
  }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
      return false;
    }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = mappingA.source - mappingB.source;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return mappingA.name - mappingB.name;
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = mappingA.source - mappingB.source;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return mappingA.name - mappingB.name;
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/source-map/source-map.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/source-map/source-map.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = __webpack_require__(/*! ./lib/source-map-generator */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator;
exports.SourceMapConsumer = __webpack_require__(/*! ./lib/source-map-consumer */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/source-map-consumer.js").SourceMapConsumer;
exports.SourceNode = __webpack_require__(/*! ./lib/source-node */ "./node_modules/@amzn/katal-logger/node_modules/source-map/lib/source-node.js").SourceNode;


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/stack-generator/stack-generator.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/stack-generator/stack-generator.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! stackframe */ "./node_modules/@amzn/katal-logger/node_modules/stackframe/stackframe.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function(StackFrame) {
    return {
        backtrace: function StackGenerator$$backtrace(opts) {
            var stack = [];
            var maxStackSize = 10;

            if (typeof opts === 'object' && typeof opts.maxStackSize === 'number') {
                maxStackSize = opts.maxStackSize;
            }

            var curr = arguments.callee;
            while (curr && stack.length < maxStackSize && curr['arguments']) {
                // Allow V8 optimizations
                var args = new Array(curr['arguments'].length);
                for (var i = 0; i < args.length; ++i) {
                    args[i] = curr['arguments'][i];
                }
                if (/function(?:\s+([\w$]+))+\s*\(/.test(curr.toString())) {
                    stack.push(new StackFrame({functionName: RegExp.$1 || undefined, args: args}));
                } else {
                    stack.push(new StackFrame({args: args}));
                }

                try {
                    curr = curr.caller;
                } catch (e) {
                    break;
                }
            }
            return stack;
        }
    };
}));


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/stackframe/stackframe.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/stackframe/stackframe.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function() {
    'use strict';
    function _isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }

    function _capitalize(str) {
        return str.charAt(0).toUpperCase() + str.substring(1);
    }

    function _getter(p) {
        return function() {
            return this[p];
        };
    }

    var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];
    var numericProps = ['columnNumber', 'lineNumber'];
    var stringProps = ['fileName', 'functionName', 'source'];
    var arrayProps = ['args'];
    var objectProps = ['evalOrigin'];

    var props = booleanProps.concat(numericProps, stringProps, arrayProps, objectProps);

    function StackFrame(obj) {
        if (!obj) return;
        for (var i = 0; i < props.length; i++) {
            if (obj[props[i]] !== undefined) {
                this['set' + _capitalize(props[i])](obj[props[i]]);
            }
        }
    }

    StackFrame.prototype = {
        getArgs: function() {
            return this.args;
        },
        setArgs: function(v) {
            if (Object.prototype.toString.call(v) !== '[object Array]') {
                throw new TypeError('Args must be an Array');
            }
            this.args = v;
        },

        getEvalOrigin: function() {
            return this.evalOrigin;
        },
        setEvalOrigin: function(v) {
            if (v instanceof StackFrame) {
                this.evalOrigin = v;
            } else if (v instanceof Object) {
                this.evalOrigin = new StackFrame(v);
            } else {
                throw new TypeError('Eval Origin must be an Object or StackFrame');
            }
        },

        toString: function() {
            var fileName = this.getFileName() || '';
            var lineNumber = this.getLineNumber() || '';
            var columnNumber = this.getColumnNumber() || '';
            var functionName = this.getFunctionName() || '';
            if (this.getIsEval()) {
                if (fileName) {
                    return '[eval] (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';
                }
                return '[eval]:' + lineNumber + ':' + columnNumber;
            }
            if (functionName) {
                return functionName + ' (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';
            }
            return fileName + ':' + lineNumber + ':' + columnNumber;
        }
    };

    StackFrame.fromString = function StackFrame$$fromString(str) {
        var argsStartIndex = str.indexOf('(');
        var argsEndIndex = str.lastIndexOf(')');

        var functionName = str.substring(0, argsStartIndex);
        var args = str.substring(argsStartIndex + 1, argsEndIndex).split(',');
        var locationString = str.substring(argsEndIndex + 1);

        if (locationString.indexOf('@') === 0) {
            var parts = /@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(locationString, '');
            var fileName = parts[1];
            var lineNumber = parts[2];
            var columnNumber = parts[3];
        }

        return new StackFrame({
            functionName: functionName,
            args: args || undefined,
            fileName: fileName,
            lineNumber: lineNumber || undefined,
            columnNumber: columnNumber || undefined
        });
    };

    for (var i = 0; i < booleanProps.length; i++) {
        StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);
        StackFrame.prototype['set' + _capitalize(booleanProps[i])] = (function(p) {
            return function(v) {
                this[p] = Boolean(v);
            };
        })(booleanProps[i]);
    }

    for (var j = 0; j < numericProps.length; j++) {
        StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);
        StackFrame.prototype['set' + _capitalize(numericProps[j])] = (function(p) {
            return function(v) {
                if (!_isNumber(v)) {
                    throw new TypeError(p + ' must be a Number');
                }
                this[p] = Number(v);
            };
        })(numericProps[j]);
    }

    for (var k = 0; k < stringProps.length; k++) {
        StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);
        StackFrame.prototype['set' + _capitalize(stringProps[k])] = (function(p) {
            return function(v) {
                this[p] = String(v);
            };
        })(stringProps[k]);
    }

    return StackFrame;
}));


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/stacktrace-gps/stacktrace-gps.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/stacktrace-gps/stacktrace-gps.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! source-map */ "./node_modules/@amzn/katal-logger/node_modules/source-map/source-map.js"), __webpack_require__(/*! stackframe */ "./node_modules/@amzn/katal-logger/node_modules/stackframe/stackframe.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function(SourceMap, StackFrame) {
    'use strict';

    /**
     * Make a X-Domain request to url and callback.
     *
     * @param {String} url
     * @returns {Promise} with response text if fulfilled
     */
    function _xdr(url) {
        return new Promise(function(resolve, reject) {
            var req = new XMLHttpRequest();
            req.open('get', url);
            req.onerror = reject;
            req.onreadystatechange = function onreadystatechange() {
                if (req.readyState === 4) {
                    if ((req.status >= 200 && req.status < 300) ||
                        (url.substr(0, 7) === 'file://' && req.responseText)) {
                        resolve(req.responseText);
                    } else {
                        reject(new Error('HTTP status: ' + req.status + ' retrieving ' + url));
                    }
                }
            };
            req.send();
        });

    }

    /**
     * Convert a Base64-encoded string into its original representation.
     * Used for inline sourcemaps.
     *
     * @param {String} b64str Base-64 encoded string
     * @returns {String} original representation of the base64-encoded string.
     */
    function _atob(b64str) {
        if (typeof window !== 'undefined' && window.atob) {
            return window.atob(b64str);
        } else {
            throw new Error('You must supply a polyfill for window.atob in this environment');
        }
    }

    function _parseJson(string) {
        if (typeof JSON !== 'undefined' && JSON.parse) {
            return JSON.parse(string);
        } else {
            throw new Error('You must supply a polyfill for JSON.parse in this environment');
        }
    }

    function _findFunctionName(source, lineNumber/*, columnNumber*/) {
        var syntaxes = [
            // {name} = function ({args}) TODO args capture
            /['"]?([$_A-Za-z][$_A-Za-z0-9]*)['"]?\s*[:=]\s*function\b/,
            // function {name}({args}) m[1]=name m[2]=args
            /function\s+([^('"`]*?)\s*\(([^)]*)\)/,
            // {name} = eval()
            /['"]?([$_A-Za-z][$_A-Za-z0-9]*)['"]?\s*[:=]\s*(?:eval|new Function)\b/,
            // fn_name() {
            /\b(?!(?:if|for|switch|while|with|catch)\b)(?:(?:static)\s+)?(\S+)\s*\(.*?\)\s*\{/,
            // {name} = () => {
            /['"]?([$_A-Za-z][$_A-Za-z0-9]*)['"]?\s*[:=]\s*\(.*?\)\s*=>/
        ];
        var lines = source.split('\n');

        // Walk backwards in the source lines until we find the line which matches one of the patterns above
        var code = '';
        var maxLines = Math.min(lineNumber, 20);
        for (var i = 0; i < maxLines; ++i) {
            // lineNo is 1-based, source[] is 0-based
            var line = lines[lineNumber - i - 1];
            var commentPos = line.indexOf('//');
            if (commentPos >= 0) {
                line = line.substr(0, commentPos);
            }

            if (line) {
                code = line + code;
                var len = syntaxes.length;
                for (var index = 0; index < len; index++) {
                    var m = syntaxes[index].exec(code);
                    if (m && m[1]) {
                        return m[1];
                    }
                }
            }
        }
        return undefined;
    }

    function _ensureSupportedEnvironment() {
        if (typeof Object.defineProperty !== 'function' || typeof Object.create !== 'function') {
            throw new Error('Unable to consume source maps in older browsers');
        }
    }

    function _ensureStackFrameIsLegit(stackframe) {
        if (typeof stackframe !== 'object') {
            throw new TypeError('Given StackFrame is not an object');
        } else if (typeof stackframe.fileName !== 'string') {
            throw new TypeError('Given file name is not a String');
        } else if (typeof stackframe.lineNumber !== 'number' ||
            stackframe.lineNumber % 1 !== 0 ||
            stackframe.lineNumber < 1) {
            throw new TypeError('Given line number must be a positive integer');
        } else if (typeof stackframe.columnNumber !== 'number' ||
            stackframe.columnNumber % 1 !== 0 ||
            stackframe.columnNumber < 0) {
            throw new TypeError('Given column number must be a non-negative integer');
        }
        return true;
    }

    function _findSourceMappingURL(source) {
        var sourceMappingUrlRegExp = /\/\/[#@] ?sourceMappingURL=([^\s'"]+)\s*$/mg;
        var lastSourceMappingUrl;
        var matchSourceMappingUrl;
        // eslint-disable-next-line no-cond-assign
        while (matchSourceMappingUrl = sourceMappingUrlRegExp.exec(source)) {
            lastSourceMappingUrl = matchSourceMappingUrl[1];
        }
        if (lastSourceMappingUrl) {
            return lastSourceMappingUrl;
        } else {
            throw new Error('sourceMappingURL not found');
        }
    }

    function _extractLocationInfoFromSourceMapSource(stackframe, sourceMapConsumer, sourceCache) {
        return new Promise(function(resolve, reject) {
            var loc = sourceMapConsumer.originalPositionFor({
                line: stackframe.lineNumber,
                column: stackframe.columnNumber
            });

            if (loc.source) {
                // cache mapped sources
                var mappedSource = sourceMapConsumer.sourceContentFor(loc.source);
                if (mappedSource) {
                    sourceCache[loc.source] = mappedSource;
                }

                resolve(
                    // given stackframe and source location, update stackframe
                    new StackFrame({
                        functionName: loc.name || stackframe.functionName,
                        args: stackframe.args,
                        fileName: loc.source,
                        lineNumber: loc.line,
                        columnNumber: loc.column
                    }));
            } else {
                reject(new Error('Could not get original source for given stackframe and source map'));
            }
        });
    }

    /**
     * @constructor
     * @param {Object} opts
     *      opts.sourceCache = {url: "Source String"} => preload source cache
     *      opts.sourceMapConsumerCache = {/path/file.js.map: SourceMapConsumer}
     *      opts.offline = True to prevent network requests.
     *              Best effort without sources or source maps.
     *      opts.ajax = Promise returning function to make X-Domain requests
     */
    return function StackTraceGPS(opts) {
        if (!(this instanceof StackTraceGPS)) {
            return new StackTraceGPS(opts);
        }
        opts = opts || {};

        this.sourceCache = opts.sourceCache || {};
        this.sourceMapConsumerCache = opts.sourceMapConsumerCache || {};

        this.ajax = opts.ajax || _xdr;

        this._atob = opts.atob || _atob;

        this._get = function _get(location) {
            return new Promise(function(resolve, reject) {
                var isDataUrl = location.substr(0, 5) === 'data:';
                if (this.sourceCache[location]) {
                    resolve(this.sourceCache[location]);
                } else if (opts.offline && !isDataUrl) {
                    reject(new Error('Cannot make network requests in offline mode'));
                } else {
                    if (isDataUrl) {
                        // data URLs can have parameters.
                        // see http://tools.ietf.org/html/rfc2397
                        var supportedEncodingRegexp =
                            /^data:application\/json;([\w=:"-]+;)*base64,/;
                        var match = location.match(supportedEncodingRegexp);
                        if (match) {
                            var sourceMapStart = match[0].length;
                            var encodedSource = location.substr(sourceMapStart);
                            var source = this._atob(encodedSource);
                            this.sourceCache[location] = source;
                            resolve(source);
                        } else {
                            reject(new Error('The encoding of the inline sourcemap is not supported'));
                        }
                    } else {
                        var xhrPromise = this.ajax(location, {method: 'get'});
                        // Cache the Promise to prevent duplicate in-flight requests
                        this.sourceCache[location] = xhrPromise;
                        xhrPromise.then(resolve, reject);
                    }
                }
            }.bind(this));
        };

        /**
         * Creating SourceMapConsumers is expensive, so this wraps the creation of a
         * SourceMapConsumer in a per-instance cache.
         *
         * @param {String} sourceMappingURL = URL to fetch source map from
         * @param {String} defaultSourceRoot = Default source root for source map if undefined
         * @returns {Promise} that resolves a SourceMapConsumer
         */
        this._getSourceMapConsumer = function _getSourceMapConsumer(sourceMappingURL, defaultSourceRoot) {
            return new Promise(function(resolve) {
                if (this.sourceMapConsumerCache[sourceMappingURL]) {
                    resolve(this.sourceMapConsumerCache[sourceMappingURL]);
                } else {
                    var sourceMapConsumerPromise = new Promise(function(resolve, reject) {
                        return this._get(sourceMappingURL).then(function(sourceMapSource) {
                            if (typeof sourceMapSource === 'string') {
                                sourceMapSource = _parseJson(sourceMapSource.replace(/^\)\]\}'/, ''));
                            }
                            if (typeof sourceMapSource.sourceRoot === 'undefined') {
                                sourceMapSource.sourceRoot = defaultSourceRoot;
                            }

                            resolve(new SourceMap.SourceMapConsumer(sourceMapSource));
                        }, reject);
                    }.bind(this));
                    this.sourceMapConsumerCache[sourceMappingURL] = sourceMapConsumerPromise;
                    resolve(sourceMapConsumerPromise);
                }
            }.bind(this));
        };

        /**
         * Given a StackFrame, enhance function name and use source maps for a
         * better StackFrame.
         *
         * @param {StackFrame} stackframe object
         * @returns {Promise} that resolves with with source-mapped StackFrame
         */
        this.pinpoint = function StackTraceGPS$$pinpoint(stackframe) {
            return new Promise(function(resolve, reject) {
                this.getMappedLocation(stackframe).then(function(mappedStackFrame) {
                    function resolveMappedStackFrame() {
                        resolve(mappedStackFrame);
                    }

                    this.findFunctionName(mappedStackFrame)
                        .then(resolve, resolveMappedStackFrame)
                        // eslint-disable-next-line no-unexpected-multiline
                        ['catch'](resolveMappedStackFrame);
                }.bind(this), reject);
            }.bind(this));
        };

        /**
         * Given a StackFrame, guess function name from location information.
         *
         * @param {StackFrame} stackframe
         * @returns {Promise} that resolves with enhanced StackFrame.
         */
        this.findFunctionName = function StackTraceGPS$$findFunctionName(stackframe) {
            return new Promise(function(resolve, reject) {
                _ensureStackFrameIsLegit(stackframe);
                this._get(stackframe.fileName).then(function getSourceCallback(source) {
                    var lineNumber = stackframe.lineNumber;
                    var columnNumber = stackframe.columnNumber;
                    var guessedFunctionName = _findFunctionName(source, lineNumber, columnNumber);
                    // Only replace functionName if we found something
                    if (guessedFunctionName) {
                        resolve(new StackFrame({
                            functionName: guessedFunctionName,
                            args: stackframe.args,
                            fileName: stackframe.fileName,
                            lineNumber: lineNumber,
                            columnNumber: columnNumber
                        }));
                    } else {
                        resolve(stackframe);
                    }
                }, reject)['catch'](reject);
            }.bind(this));
        };

        /**
         * Given a StackFrame, seek source-mapped location and return new enhanced StackFrame.
         *
         * @param {StackFrame} stackframe
         * @returns {Promise} that resolves with enhanced StackFrame.
         */
        this.getMappedLocation = function StackTraceGPS$$getMappedLocation(stackframe) {
            return new Promise(function(resolve, reject) {
                _ensureSupportedEnvironment();
                _ensureStackFrameIsLegit(stackframe);

                var sourceCache = this.sourceCache;
                var fileName = stackframe.fileName;
                this._get(fileName).then(function(source) {
                    var sourceMappingURL = _findSourceMappingURL(source);
                    var isDataUrl = sourceMappingURL.substr(0, 5) === 'data:';
                    var defaultSourceRoot = fileName.substring(0, fileName.lastIndexOf('/') + 1);

                    if (sourceMappingURL[0] !== '/' && !isDataUrl && !(/^https?:\/\/|^\/\//i).test(sourceMappingURL)) {
                        sourceMappingURL = defaultSourceRoot + sourceMappingURL;
                    }

                    return this._getSourceMapConsumer(sourceMappingURL, defaultSourceRoot)
                        .then(function(sourceMapConsumer) {
                            return _extractLocationInfoFromSourceMapSource(stackframe, sourceMapConsumer, sourceCache)
                                .then(resolve)['catch'](function() {
                                    resolve(stackframe);
                                });
                        });
                }.bind(this), reject)['catch'](reject);
            }.bind(this));
        };
    };
}));


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/stacktrace-js/stacktrace.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/stacktrace-js/stacktrace.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! error-stack-parser */ "./node_modules/@amzn/katal-logger/node_modules/error-stack-parser/error-stack-parser.js"), __webpack_require__(/*! stack-generator */ "./node_modules/@amzn/katal-logger/node_modules/stack-generator/stack-generator.js"), __webpack_require__(/*! stacktrace-gps */ "./node_modules/@amzn/katal-logger/node_modules/stacktrace-gps/stacktrace-gps.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function StackTrace(ErrorStackParser, StackGenerator, StackTraceGPS) {
    var _options = {
        filter: function(stackframe) {
            // Filter out stackframes for this library by default
            return (stackframe.functionName || '').indexOf('StackTrace$$') === -1 &&
                (stackframe.functionName || '').indexOf('ErrorStackParser$$') === -1 &&
                (stackframe.functionName || '').indexOf('StackTraceGPS$$') === -1 &&
                (stackframe.functionName || '').indexOf('StackGenerator$$') === -1;
        },
        sourceCache: {}
    };

    var _generateError = function StackTrace$$GenerateError() {
        try {
            // Error must be thrown to get stack in IE
            throw new Error();
        } catch (err) {
            return err;
        }
    };

    /**
     * Merge 2 given Objects. If a conflict occurs the second object wins.
     * Does not do deep merges.
     *
     * @param {Object} first base object
     * @param {Object} second overrides
     * @returns {Object} merged first and second
     * @private
     */
    function _merge(first, second) {
        var target = {};

        [first, second].forEach(function(obj) {
            for (var prop in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, prop)) {
                    target[prop] = obj[prop];
                }
            }
            return target;
        });

        return target;
    }

    function _isShapedLikeParsableError(err) {
        return err.stack || err['opera#sourceloc'];
    }

    function _filtered(stackframes, filter) {
        if (typeof filter === 'function') {
            return stackframes.filter(filter);
        }
        return stackframes;
    }

    return {
        /**
         * Get a backtrace from invocation point.
         *
         * @param {Object} opts
         * @returns {Array} of StackFrame
         */
        get: function StackTrace$$get(opts) {
            var err = _generateError();
            return _isShapedLikeParsableError(err) ? this.fromError(err, opts) : this.generateArtificially(opts);
        },

        /**
         * Get a backtrace from invocation point.
         * IMPORTANT: Does not handle source maps or guess function names!
         *
         * @param {Object} opts
         * @returns {Array} of StackFrame
         */
        getSync: function StackTrace$$getSync(opts) {
            opts = _merge(_options, opts);
            var err = _generateError();
            var stack = _isShapedLikeParsableError(err) ? ErrorStackParser.parse(err) : StackGenerator.backtrace(opts);
            return _filtered(stack, opts.filter);
        },

        /**
         * Given an error object, parse it.
         *
         * @param {Error} error object
         * @param {Object} opts
         * @returns {Promise} for Array[StackFrame}
         */
        fromError: function StackTrace$$fromError(error, opts) {
            opts = _merge(_options, opts);
            var gps = new StackTraceGPS(opts);
            return new Promise(function(resolve) {
                var stackframes = _filtered(ErrorStackParser.parse(error), opts.filter);
                resolve(Promise.all(stackframes.map(function(sf) {
                    return new Promise(function(resolve) {
                        function resolveOriginal() {
                            resolve(sf);
                        }

                        gps.pinpoint(sf).then(resolve, resolveOriginal)['catch'](resolveOriginal);
                    });
                })));
            }.bind(this));
        },

        /**
         * Use StackGenerator to generate a backtrace.
         *
         * @param {Object} opts
         * @returns {Promise} of Array[StackFrame]
         */
        generateArtificially: function StackTrace$$generateArtificially(opts) {
            opts = _merge(_options, opts);
            var stackFrames = StackGenerator.backtrace(opts);
            if (typeof opts.filter === 'function') {
                stackFrames = stackFrames.filter(opts.filter);
            }
            return Promise.resolve(stackFrames);
        },

        /**
         * Given a function, wrap it such that invocations trigger a callback that
         * is called with a stack trace.
         *
         * @param {Function} fn to be instrumented
         * @param {Function} callback function to call with a stack trace on invocation
         * @param {Function} errback optional function to call with error if unable to get stack trace.
         * @param {Object} thisArg optional context object (e.g. window)
         */
        instrument: function StackTrace$$instrument(fn, callback, errback, thisArg) {
            if (typeof fn !== 'function') {
                throw new Error('Cannot instrument non-function object');
            } else if (typeof fn.__stacktraceOriginalFn === 'function') {
                // Already instrumented, return given Function
                return fn;
            }

            var instrumented = function StackTrace$$instrumented() {
                try {
                    this.get().then(callback, errback)['catch'](errback);
                    return fn.apply(thisArg || this, arguments);
                } catch (e) {
                    if (_isShapedLikeParsableError(e)) {
                        this.fromError(e).then(callback, errback)['catch'](errback);
                    }
                    throw e;
                }
            }.bind(this);
            instrumented.__stacktraceOriginalFn = fn;

            return instrumented;
        },

        /**
         * Given a function that has been instrumented,
         * revert the function to it's original (non-instrumented) state.
         *
         * @param {Function} fn to de-instrument
         */
        deinstrument: function StackTrace$$deinstrument(fn) {
            if (typeof fn !== 'function') {
                throw new Error('Cannot de-instrument non-function object');
            } else if (typeof fn.__stacktraceOriginalFn === 'function') {
                return fn.__stacktraceOriginalFn;
            } else {
                // Function not instrumented, return original
                return fn;
            }
        },

        /**
         * Given an error message and Array of StackFrames, serialize and POST to given URL.
         *
         * @param {Array} stackframes
         * @param {String} url
         * @param {String} errorMsg
         * @param {Object} requestOptions
         */
        report: function StackTrace$$report(stackframes, url, errorMsg, requestOptions) {
            return new Promise(function(resolve, reject) {
                var req = new XMLHttpRequest();
                req.onerror = reject;
                req.onreadystatechange = function onreadystatechange() {
                    if (req.readyState === 4) {
                        if (req.status >= 200 && req.status < 400) {
                            resolve(req.responseText);
                        } else {
                            reject(new Error('POST to ' + url + ' failed with status: ' + req.status));
                        }
                    }
                };
                req.open('post', url);

                // Set request headers
                req.setRequestHeader('Content-Type', 'application/json');
                if (requestOptions && typeof requestOptions.headers === 'object') {
                    var headers = requestOptions.headers;
                    for (var header in headers) {
                        if (Object.prototype.hasOwnProperty.call(headers, header)) {
                            req.setRequestHeader(header, headers[header]);
                        }
                    }
                }

                var reportPayload = {stack: stackframes};
                if (errorMsg !== undefined && errorMsg !== null) {
                    reportPayload.message = errorMsg;
                }

                req.send(JSON.stringify(reportPayload));
            });
        }
    };
}));


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/uuid/lib/bytesToUuid.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/uuid/lib/bytesToUuid.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]]
  ]).join('');
}

module.exports = bytesToUuid;


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/uuid/lib/rng-browser.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/uuid/lib/rng-browser.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}


/***/ }),

/***/ "./node_modules/@amzn/katal-logger/node_modules/uuid/v4.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@amzn/katal-logger/node_modules/uuid/v4.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(/*! ./lib/rng */ "./node_modules/@amzn/katal-logger/node_modules/uuid/lib/rng-browser.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "./node_modules/@amzn/katal-logger/node_modules/uuid/lib/bytesToUuid.js");

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ }),

/***/ "./node_modules/@amzn/katal-metrics-driver-sushi/dist/KatalMetricsDriverSushi.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics-driver-sushi/dist/KatalMetricsDriverSushi.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KatalMetricsDriverSushi = void 0;

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));

var _KatalMetricsDriver2 = _interopRequireDefault(__webpack_require__(/*! @amzn/katal-metrics/lib/driver/KatalMetricsDriver */ "./node_modules/@amzn/katal-metrics/lib/driver/KatalMetricsDriver.js"));

var _KatalMetricType = _interopRequireDefault(__webpack_require__(/*! @amzn/katal-metrics/lib/metricObject/KatalMetricType */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricType.js"));

var _katalSushiClient = _interopRequireDefault(__webpack_require__(/*! @amzn/katal-sushi-client */ "./node_modules/@amzn/katal-sushi-client/dist/SushiClient.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var KAT_STANDALONE_NEXUS_PRODUCER_ID = 'katal';
var KAT_STANDALONE_DEFAULT_SOURCE_GROUPS = {
  test: 'com.amazon.eel.katal.metrics.core.nexus.gamma',
  prod: 'com.amazon.eel.katal.metrics.core.nexus'
};

var KatalMetricsDriverSushiBuilder = /*#__PURE__*/function () {
  function KatalMetricsDriverSushiBuilder() {
    (0, _classCallCheck2.default)(this, KatalMetricsDriverSushiBuilder);
    (0, _defineProperty2.default)(this, "context", {});
  }

  (0, _createClass2.default)(KatalMetricsDriverSushiBuilder, [{
    key: "withSushiClient",
    value: function withSushiClient(sushiClient) {
      console.log('withSushi client...');
      this.context.sushiClient = sushiClient;
      return this;
    }
  }, {
    key: "withDomainRealm",
    value: function withDomainRealm(domain, realm) {
      this.context.domain = domain;
      this.context.realm = realm;
      return this;
    }
  }, {
    key: "withCustomProducer",
    value: function withCustomProducer(sushiProducerId) {
      this.context.sushiProducer = sushiProducerId;
      return this;
    }
  }, {
    key: "withCustomSourceGroup",
    value: function withCustomSourceGroup(sourceGroupId) {
      this.context.sourceGroupId = sourceGroupId;
      return this;
    }
  }, {
    key: "withErrorHandler",
    value: function withErrorHandler(errorHandler) {
      this.context.errorHandler = errorHandler;
      return this;
    }
  }, {
    key: "withSushiClientOptions",
    value: function withSushiClientOptions(sushiClientOptions) {
      this.context.sushiClientOptions = sushiClientOptions;
      return this;
    }
  }, {
    key: "withSushiClientTransportOverride",
    value: function withSushiClientTransportOverride(sushiClientTransportOverride) {
      this.context.sushiClientTransportOverride = sushiClientTransportOverride;
      return this;
    }
  }, {
    key: "build",
    value: function build() {
      return new KatalMetricsDriverSushi(this.context);
    }
  }]);
  return KatalMetricsDriverSushiBuilder;
}();

var KatalMetricsDriverSushi = /*#__PURE__*/function (_KatalMetricsDriver) {
  (0, _inherits2.default)(KatalMetricsDriverSushi, _KatalMetricsDriver);

  var _super = _createSuper(KatalMetricsDriverSushi);

  function KatalMetricsDriverSushi(options) {
    var _this;

    (0, _classCallCheck2.default)(this, KatalMetricsDriverSushi);
    _this = _super.call(this);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "sushi", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "producerId", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "sourceGroupId", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "errorHandler", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "combinedErrorHandler", function (err) {
      if (_this.errorHandler) {
        try {
          _this.errorHandler(err); // Return to avoid falling through to default error handler


          return;
        } catch (nextErr) {
          console.error("Error handling error publishing metrics:");
          console.error(nextErr); // Fall through
        }
      }

      _this.defaultErrorHandler(err);
    });
    var domain = options.domain,
        realm = options.realm,
        errorHandler = options.errorHandler,
        sushiClient = options.sushiClient,
        _options$sushiProduce = options.sushiProducer,
        producerId = _options$sushiProduce === void 0 ? KAT_STANDALONE_NEXUS_PRODUCER_ID : _options$sushiProduce,
        sushiClientOptions = options.sushiClientOptions,
        sushiClientTransportOverride = options.sushiClientTransportOverride; // custom source group always overrides defaults

    var sourceGroupId = options.sourceGroupId || KAT_STANDALONE_DEFAULT_SOURCE_GROUPS[domain] || KAT_STANDALONE_DEFAULT_SOURCE_GROUPS['test'];
    _this.sushi = sushiClient || _this.buildSushiClient(domain, realm, sourceGroupId, sushiClientOptions, sushiClientTransportOverride);
    _this.errorHandler = errorHandler;
    _this.producerId = producerId;
    _this.sourceGroupId = sourceGroupId;
    return _this;
  }

  (0, _createClass2.default)(KatalMetricsDriverSushi, [{
    key: "beforeUnload",
    value:
    /**
     * Register a callback to be called right before the page unloads. This
     * allows for any final metrics, such as page visit duration, to be sent
     * before the user navigates away from the page or closes the tab.
     * NOTE: This is an experimental API and may change in the future.
     * @param cb The callback to call.
     */
    function beforeUnload(cb) {
      this.sushi.onSushiUnload(cb);
    }
    /**
     * Default error handler if the user-supplied error handler fails or is unset.  Should never be called unless
     * user-provided error handler misbehaves.
     *
     * @param err Unhandled error object
     */

  }, {
    key: "defaultErrorHandler",
    value: function defaultErrorHandler(err) {
      console.error("Error publishing metrics:");
      console.error(err);
    }
    /**
     * Call the error-handler supplied by the user when this object was constructed; if that is unset or itself throws
     * an exception, calls the default error handler as a fallback, which will just log the error to the console.
     *
     * @param err Error object to handle
     */

  }, {
    key: "withErrorHandling",
    value:
    /**
     * Helper method to wrap a function in the error handler.
     *
     * @param doTheThing Function to run under the wrapper
     * @return Return value from called function
     */
    function withErrorHandling(doTheThing) {
      try {
        return doTheThing();
      } catch (err) {
        this.combinedErrorHandler(err);
      }
    }
  }, {
    key: "buildSushiClient",
    value: function buildSushiClient(domain, realm, sourceGroupId, sushiClientOptions, sushiClientTransportOverride) {
      if (!domain || !realm) {
        throw new Error('KatalMetricsDriverSushi requires a domain and realm to build a sushi client.');
      }

      return new _katalSushiClient.default(KatalMetricsDriverSushi.getRealmName(realm), sourceGroupId, this.combinedErrorHandler, sushiClientOptions, sushiClientTransportOverride);
    }
  }, {
    key: "publish",
    value: // TODO: errorHandler in this method is deprecated and is not referenced.
    // Tech debt: https://issues.amazon.com/issues/KAT-875
    function publish(metricObject, errorHandler, context) {
      var _this2 = this;

      // Support for new 2-argument form of publish, which does not pass the unused errorHandler object (KAT-875)
      var metricsContext = arguments.length < 3 ? arguments[1] : arguments[2];
      this.withErrorHandling(function () {
        // TODO: This logic is now moved into KatalMetricsPublisher, once everybody has that update we can remove this.
        // Tech debt: https://issues.amazon.com/issues/KAT-876
        if (_KatalMetricType.default.List === metricObject.type) {
          metricObject.metricList.forEach(function (metric) {
            _this2.publish(metric, metricsContext);
          });
          return;
        }

        var nexusSchema = _this2.mapObjectTypeToNexusSchema(metricObject.type);

        var fields = _objectSpread(_objectSpread({}, metricsContext.context), {}, {
          metricKey: metricObject.name,
          value: metricObject.value
        });

        if (metricObject.isMonitor) {
          fields.isMonitor = true;
        } // Deleting cloudWatchDimensions field if exists as it applies only for KatalMonitoringAWSDriver.


        if (fields.cloudWatchDimensions) {
          delete fields.cloudWatchDimensions;
        } // Reset the event count back to 0, otherwise Sushi will stop publishing after 1K items (https://issues.amazon.com/issues/KAT-1534)


        _this2.sushi.reset();

        _this2.sushi.event(fields, _this2.producerId, nexusSchema, {
          "ssd": 1
        });
      });
    }
  }, {
    key: "mapObjectTypeToNexusSchema",
    value: function mapObjectTypeToNexusSchema(objectType) {
      switch (objectType) {
        case _KatalMetricType.default.String:
          return 'katal.client.metrics.String.2';

        case _KatalMetricType.default.Counter:
          return 'katal.client.metrics.Counter.3';

        case _KatalMetricType.default.Timer:
          return 'katal.client.metrics.Timer.2';

        default:
          throw new Error("Unknown type ".concat(objectType, " when publishing metric object."));
      }
    }
  }], [{
    key: "getRealmName",
    value: function getRealmName(realm) {
      switch (realm) {
        case 'NAAmazon':
        case 'USAmazon':
          return _katalSushiClient.default.REGIONS.NA;

        case 'EUAmazon':
          return _katalSushiClient.default.REGIONS.EU;

        case 'FEAmazon':
        case 'JPAmazon':
          return _katalSushiClient.default.REGIONS.FE;

        case 'CNAmazon':
          return _katalSushiClient.default.REGIONS.CN;

        default:
          // Let the SushiClient decide if this is bogus or not.
          return realm;
      }
    }
  }]);
  return KatalMetricsDriverSushi;
}(_KatalMetricsDriver2.default);

exports.KatalMetricsDriverSushi = KatalMetricsDriverSushi;
(0, _defineProperty2.default)(KatalMetricsDriverSushi, "Builder", KatalMetricsDriverSushiBuilder);

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics-driver-sushi/dist/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics-driver-sushi/dist/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

__webpack_require__(/*! ./nodejsShims */ 1);

var _KatalMetricsDriverSushi = __webpack_require__(/*! ./KatalMetricsDriverSushi */ "./node_modules/@amzn/katal-metrics-driver-sushi/dist/KatalMetricsDriverSushi.js");

/* istanbul ignore file */
var _default = _KatalMetricsDriverSushi.KatalMetricsDriverSushi;
exports.default = _default;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/KatalMetricsContext.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/KatalMetricsContext.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));

var _ValidateSimpleString = _interopRequireDefault(__webpack_require__(/*! ./helper/ValidateSimpleString */ "./node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleString.js"));

var _validateCloudWatchDimensions = _interopRequireDefault(__webpack_require__(/*! ./helper/validateCloudWatchDimensions */ "./node_modules/@amzn/katal-metrics/lib/helper/validateCloudWatchDimensions.js"));

var _FirstMap = _interopRequireDefault(__webpack_require__(/*! ./helper/FirstMap */ "./node_modules/@amzn/katal-metrics/lib/helper/FirstMap.js"));

var _mergeLists = __webpack_require__(/*! ./helper/mergeLists */ "./node_modules/@amzn/katal-metrics/lib/helper/mergeLists.js");

var _embedRequestId = __webpack_require__(/*! ./helper/embedRequestId */ "./node_modules/@amzn/katal-metrics/lib/helper/embedRequestId.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var REQUIRED_FIELDS = ['site', 'serviceName', 'methodName'];

var KatalMetricsContext = /*#__PURE__*/function () {
  /**
   * Create a new metrics context with the given fields.
   *
   * @param contextFields Context fields value (default empty)
   */
  function KatalMetricsContext() {
    var contextFields = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, KatalMetricsContext);
    // Copy fields so this is immutable
    this.context = _objectSpread({}, contextFields);
  }
  /**
   * Return a new KatalMetricsContext which is a copy of this context, with values added or overridden from
   * the given context.
   *
   * If the given context is null or empty, this method may return the original object as an optimization.
   *
   * @param thatContext Context to merge values from
   * @return New context with default values from this context, and values overridden or added by the given context.
   */


  (0, _createClass2.default)(KatalMetricsContext, [{
    key: "merge",
    value: function merge(thatContext) {
      if (!thatContext) return this; // Check for a common error

      if (thatContext instanceof KatalMetricsContext.Builder) {
        throw new Error("KatalMetricsContext.Builder object passed instead of KatalMetricsContext.  Try calling .build() method.");
      }

      var context = thatContext instanceof KatalMetricsContext ? thatContext.context : thatContext;

      var newContext = _objectSpread(_objectSpread(_objectSpread({}, this.context), context), {}, {
        relatedMetrics: (0, _mergeLists.mergeLists)(this.context.relatedMetrics, context.relatedMetrics),
        relatedMetricsSingleAction: (0, _mergeLists.mergeLists)(this.context.relatedMetricsSingleAction, context.relatedMetricsSingleAction),
        // Combines the dimensions from base publisher with any child publisher.
        cloudWatchDimensions: (0, _mergeLists.mergeLists)(this.context.cloudWatchDimensions, context.cloudWatchDimensions)
      });

      return new KatalMetricsContext(newContext);
    }
    /**
     * Return a new context which is a copy of this context with relatedMetricsSingleAction removed.
     *
     * This is intended to be called when creating a new child publisher.
     *
     * @return Copy of this context, with relatedMetricsSingleAction removed
     */

  }, {
    key: "withoutRelatedMetricsSingleAction",
    value: function withoutRelatedMetricsSingleAction() {
      return new KatalMetricsContext(_objectSpread(_objectSpread({}, this.context), {}, {
        relatedMetricsSingleAction: undefined
      }));
    }
    /**
     * Get a context suitable for publication to the driver.
     *
     * This method strips out any private fields, and leaves only fields from the schema that the driver should publish.
     *
     * @return Context suitable for driver publication
     */

  }, {
    key: "driverContext",
    value: function driverContext() {
      // Don't publish relatedMetrics to the driver
      var newContextFields = _objectSpread({}, this.context);

      delete newContextFields["relatedMetrics"];
      delete newContextFields["relatedMetricsSingleAction"];
      delete newContextFields["requestId"];

      if (this.context.requestId) {
        newContextFields.actionId = (0, _embedRequestId.embedRequestId)(newContextFields.actionId, this.context.requestId);
      }

      return new KatalMetricsContext(newContextFields);
    }
    /**
     * Get a simple JavaScript object with a copy of the fields for this context.
     *
     * @return Simple Javascript object with a copy of the fields for this context
     */

  }, {
    key: "getFields",
    value: function getFields() {
      // Copy fields so this remains immutable
      return _objectSpread({}, this.context);
    }
    /**
     * Check for a validation error on this context.
     *
     * Returns the first validation error encountered if one is found, otherwise undefined.
     *
     * @returns Errors found with this context
     */

  }, {
    key: "validationError",
    value: function validationError() {
      var _this = this;

      var err; // Fields site, serviceName, methodName, and metricKey are required.

      err = (0, _FirstMap.default)(REQUIRED_FIELDS, function (field) {
        if (_this.context[field] == undefined) {
          return new Error("Field ".concat(field, " is required, but it is ").concat(_this.context[field]));
        }
      });
      if (err) return err;
      return (0, _FirstMap.default)(Object.keys(this.context), function (field) {
        return _this.validateField(field);
      });
    }
    /**
     * Validate an individual context field.
     *
     * @param field Name of field to validate
     * @returns Error found with this field, or undefined
     */

  }, {
    key: "validateField",
    value: function validateField(field) {
      var val = this.context[field];
      var nameForError = "field ".concat(field);

      switch (field) {
        // Strings which could be used as partition keys ("site" and "serviceName") cannot contain slashes, in
        // addition to the other restictions below.
        case 'site':
        case 'serviceName':
          if (val.indexOf('/') > -1) return new Error("Expected ".concat(nameForError, " to contain only valid characters, but it was ").concat(val, ".  It cannot contain a slash."));
        // Else fall through
        // Strings for fields site, serviceName, methodName, metricKey must match be valid PMET field names:
        // maximum length of 256, only letters, numbers, and the dot, colon, at-sign, underscore, forward-slash,
        // and slash characters (in short the regex ^[A-Za-z0-9.:@_/-]+$).

        case 'methodName':
        case 'actionId':
          return (0, _ValidateSimpleString.default)(val, nameForError);

        case 'cloudWatchDimensions':
          return (0, _validateCloudWatchDimensions.default)(val || []);
      } // No error found, implicitly return undefined

    }
    /**
     * Builder class for KatalMetricsContext
     */

  }]);
  return KatalMetricsContext;
}();

exports.default = KatalMetricsContext;
(0, _defineProperty2.default)(KatalMetricsContext, "Builder", /*#__PURE__*/function () {
  function _class2() {
    (0, _classCallCheck2.default)(this, _class2);
    (0, _defineProperty2.default)(this, "context", {});
  }

  (0, _createClass2.default)(_class2, [{
    key: "withSite",
    value: function withSite(site) {
      this.context.site = site;
      return this;
    }
  }, {
    key: "withServiceName",
    value: function withServiceName(serviceName) {
      this.context.serviceName = serviceName;
      return this;
    }
  }, {
    key: "withMethodName",
    value: function withMethodName(methodName) {
      this.context.methodName = methodName;
      return this;
    }
  }, {
    key: "withActionId",
    value: function withActionId(actionId) {
      this.context.actionId = actionId;
      return this;
    }
  }, {
    key: "withRequestId",
    value: function withRequestId(requestId) {
      this.context.requestId = requestId;
      return this;
    }
  }, {
    key: "withCloudWatchDimensions",
    value: function withCloudWatchDimensions(dimensions) {
      this.context.cloudWatchDimensions = dimensions;
      return this;
    }
    /**
     * Replace any related metrics with the given list (see addRelatedMetrics to add instead of replace).
     *
     * Related metrics are metrics that are published whenever a new action is started.  They are used to relate the
     * action back to the context where it is happening, for example a request ID or a user identity.
     *
     * @param relatedMetrics Related metrics to publish when a new action is started for this context
     * @returns This builder object to continue building
     */

  }, {
    key: "withRelatedMetrics",
    value: function withRelatedMetrics() {
      for (var _len = arguments.length, relatedMetrics = new Array(_len), _key = 0; _key < _len; _key++) {
        relatedMetrics[_key] = arguments[_key];
      }

      this.context.relatedMetrics = relatedMetrics;
      return this;
    }
    /**
     * Add additional related metrics to this builder.  See withRelatedMetrics for more information.
     *
     * @param relatedMetrics Additional related metrics to publish when a new action is started for this context
     * @returns This builder object to continue building
     */

  }, {
    key: "addRelatedMetrics",
    value: function addRelatedMetrics() {
      for (var _len2 = arguments.length, relatedMetrics = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        relatedMetrics[_key2] = arguments[_key2];
      }

      this.context.relatedMetrics = (0, _mergeLists.mergeLists)(this.context.relatedMetrics, relatedMetrics);
      return this;
    }
    /**
     * Replace single-action related metrics with the given list (see addRelatedMetricsSingleAction to add instead of replace,
     * and withRelatedMetrics for more information about related metrics).
     *
     * Single-action related metrics are published when a new child metric publisher is created, but not included as
     * related metrics for the new child metric publisher, so are not published again if the child metric publisher
     * creates grandchild published metrics.
     *
     * @param metrics Related metrics
     * @returns This builder object to continue building
     */

  }, {
    key: "withRelatedMetricsSingleAction",
    value: function withRelatedMetricsSingleAction() {
      for (var _len3 = arguments.length, metrics = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        metrics[_key3] = arguments[_key3];
      }

      this.context.relatedMetricsSingleAction = metrics;
      return this;
    }
    /**
     * Add additional single-action related metrics to this builder.  See addRelatedMetricsSingleAction for more information.
     *
     * @param metrics Related metrics
     * @returns This builder object to continue building
     */

  }, {
    key: "addRelatedMetricsSingleAction",
    value: function addRelatedMetricsSingleAction() {
      for (var _len4 = arguments.length, metrics = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        metrics[_key4] = arguments[_key4];
      }

      this.context.relatedMetricsSingleAction = (0, _mergeLists.mergeLists)(this.context.relatedMetricsSingleAction, metrics);
      return this;
    }
    /**
     * Take the fields set in this builder and use them to create a new KatalMetricsContext.
     *
     * @return KatalMetricsContext object built with the parameters given to this builder
     */

  }, {
    key: "build",
    value: function build() {
      return new KatalMetricsContext(this.context);
    }
  }]);
  return _class2;
}());

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/KatalMetricsPublisher.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/KatalMetricsPublisher.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));

var _v = _interopRequireDefault(__webpack_require__(/*! uuid/v4 */ "./node_modules/uuid/v4.js"));

var _KatalMetricsContext = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricsContext */ "./node_modules/@amzn/katal-metrics/lib/KatalMetricsContext.js"));

var _metricObject = __webpack_require__(/*! ./metricObject */ "./node_modules/@amzn/katal-metrics/lib/metricObject/index.js");

var _mergeLists = __webpack_require__(/*! ./helper/mergeLists */ "./node_modules/@amzn/katal-metrics/lib/helper/mergeLists.js");

var _metricsExtension = __webpack_require__(/*! ./helper/metricsExtension */ "./node_modules/@amzn/katal-metrics/lib/helper/metricsExtension.js");

var _embedRequestId = __webpack_require__(/*! ./helper/embedRequestId */ "./node_modules/@amzn/katal-metrics/lib/helper/embedRequestId.js");

var INITIALIZATION_METHOD_NAME = 'Initialization';

/**
 * Default error handler if the user-supplied error handler fails or is unset.
 * Should never be called unless user-provided error handler misbehaves.
 */
var DEFAULT_ERROR_HANDLER = function DEFAULT_ERROR_HANDLER(err) {
  console.error("Error publishing metrics:");
  console.error(err);
};

var PARENT_ACTION_ID_NAME = 'parentActionId';

var getContextFields = function getContextFields(context) {
  if (context.context) {
    return context.context;
  } else {
    return context;
  }
};
/**
 * Class used for publishing metrics to Katal.  Contains a driver and a context.
 *
 * This class knows how to publish metrics, and how to create new publishers with a modified context.
 */


var KatalMetricsPublisher = /*#__PURE__*/function () {
  /**
   * Create a new metrics publisher with the given driver and context
   *
   * @param driver Subclass of KatalMetricsDriver used to publish the metrics
   * @param errorHandler Handler for errors that occur while using this publisher
   * @param context Context for this metrics publisher; contains data to be included with every
   *     metric published using this publisher object.  Default is an empty context.
   */
  function KatalMetricsPublisher(driver) {
    var _this = this;

    var errorHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_ERROR_HANDLER;
    var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new _KatalMetricsContext.default();
    (0, _classCallCheck2.default)(this, KatalMetricsPublisher);
    (0, _defineProperty2.default)(this, "combinedErrorHandler", function (err) {
      try {
        _this.errorHandler(err);
      } catch (nextErr) {
        console.error("Error handling error publishing metrics:");
        console.error(nextErr);
        DEFAULT_ERROR_HANDLER(err);
      }
    });

    // Check for a common error
    if (context instanceof _KatalMetricsContext.default.Builder) {
      throw new Error("KatalMetricsContext.Builder object passed instead of KatalMetricsContext.  Try calling .build() method.");
    }

    this.driver = driver;
    this.errorHandler = errorHandler;
    this.context = !(context instanceof _KatalMetricsContext.default) ? new _KatalMetricsContext.default(context) : context;
  }
  /**
   * Call the error-handler supplied by the user when this object was constructed; if that is unset or itself throws
   * an exception, calls the default error handler as a fallback, which will just log the error to the console.
   *
   * @param err Error object to handle
   */


  (0, _createClass2.default)(KatalMetricsPublisher, [{
    key: "withErrorHandling",
    value:
    /**
     * Helper method to wrap a function in the error handler.
     *
     * @param doTheThing Function to run under the wrapper
     * @return Return value from called function
     */
    function withErrorHandling(doTheThing) {
      try {
        return doTheThing();
      } catch (err) {
        this.combinedErrorHandler(err);
      }
    }
    /**
     * Helper method to return all the related metrics of base publisher and additionalContext.
     *
     * @param additionalContext Additional context to be included in the new publisher
     * @return Return all related metrics from base publisher and additionalContext.
     */

  }, {
    key: "getAdditionalRelatedMetrics",
    value: function getAdditionalRelatedMetrics(additionalContext) {
      var newContext = additionalContext instanceof _KatalMetricsContext.default ? additionalContext.context : additionalContext;
      var baseRelatedMetrics = this.getBaseRelatedMetrics();
      return (0, _mergeLists.mergeLists)(baseRelatedMetrics, newContext.relatedMetrics);
    }
    /**
     * Helper method to return all the related metrics of base publisher.
     *
     * @return Return all related metrics from the base publisher.
     */

  }, {
    key: "getBaseRelatedMetrics",
    value: function getBaseRelatedMetrics() {
      return (0, _mergeLists.mergeLists)(this.context.context.relatedMetrics, this.context.context.relatedMetricsSingleAction);
    }
    /**
     * Publish the given metric object.
     *
     * This method is guaranteed never to throw an exception.  If the metric object or context are invalid,
     * or any other exception is thrown while publishing, the publisher's error handler is called.  If the
     * publisher's error handler is unset or fails, the default error handler is called (see defaultErrorHandler).
     *
     * @param katalMetricObject Metric object to publish
     */

  }, {
    key: "publish",
    value: function publish(katalMetricObject) {
      var _this2 = this;

      this.withErrorHandling(function () {
        if (!katalMetricObject) {
          throw new Error("Cannot publish undefined/null metric object");
        }

        if (_metricObject.Object.Types.List === katalMetricObject.type) {
          katalMetricObject.metricList.forEach(function (metric) {
            _this2.publish(metric);
          });
        } else {
          var driverContext = _this2.context.driverContext();

          var contextError = driverContext.validationError();
          if (contextError) throw contextError;
          var objectError = katalMetricObject.validationError();
          if (objectError) throw objectError;
          (0, _metricsExtension.dispatchMetricEvent)(katalMetricObject, driverContext);

          _this2.driver.publish(katalMetricObject, driverContext);
        }
      });
    }
    /**
     * Create a new publisher which is identical to this publisher, but with the given context fields merged into
     * the new publisher's context.
     *
     * @param additionalContext Additional context to be included in the new publisher
     * @returns New publisher identical to this one, but with an updated context
     */

  }, {
    key: "newChildPublisher",
    value: function newChildPublisher(additionalContext) {
      return new KatalMetricsPublisher(this.driver, this.errorHandler, this.context.merge(additionalContext));
    }
    /**
     * Begin a new action, and return a new publisher for metrics related to that action.
     *
     * Beginning a new action involves the following steps:
     *   1. Generate a new actionId for the action, randomly in the browser
     *   2. If there are any related metrics in the context, publish them
     *   3. Create and return a new publisher with this object's context, merged with any additional context given,
     *      merged with the actionId generated above.
     *
     * @param additionalContext Additional context to be included in the new publisher
     * @returns New publisher identical to this one, but with an updated context
     */

  }, {
    key: "newChildActionPublisher",
    value: function newChildActionPublisher(additionalContext) {
      var actionId = this._generateActionid(additionalContext);

      var newContext = this.context.withoutRelatedMetricsSingleAction().merge({
        actionId: actionId
      }).merge(additionalContext);
      var newPublisher = new KatalMetricsPublisher(this.driver, this.errorHandler, newContext);
      var allRelatedMetrics = additionalContext && !(additionalContext instanceof _KatalMetricsContext.default.Builder) ? this.getAdditionalRelatedMetrics(additionalContext) : this.getBaseRelatedMetrics();

      if (allRelatedMetrics) {
        allRelatedMetrics.forEach(function (metric) {
          newPublisher.publish(metric);
        });
      }

      return newPublisher;
    }
    /**
     * Begin a new chained child action, and return a new publisher for metrics related to that action.
     *
     * A chained action is handled the same way as in newChildActionPublisher, but additionally,
     * the returned publisher has a relatedMetricNoInherit named "parentActionId", with the newly
     * generated actionId as its value.
     *
     * The effect of this is that any further chained child actions can be connected back to this
     * action through the parentActionId, and so on recursively.
     *
     * @param additionalContext Additional context to be included in the new publisher
     * @returns New publisher identical to this one, but with an updated context
     */

  }, {
    key: "newChildActionPublisherChained",
    value: function newChildActionPublisherChained(additionalContext) {
      var actionId = this._generateActionid(additionalContext);

      var parentActionId = (0, _embedRequestId.embedRequestId)(actionId, this.context.context.requestId);
      var relatedMetricsSingleAction = [new _metricObject.String(PARENT_ACTION_ID_NAME, parentActionId)];
      var newContext = new _KatalMetricsContext.default({
        actionId: actionId,
        relatedMetricsSingleAction: relatedMetricsSingleAction
      }).merge(additionalContext);
      return this.newChildActionPublisher(newContext);
    }
    /**
     * Helper method to create a new chained child action publisher with the given value for methodName.
     *
     * Apart from setting the methodName in the child context, this method is identical to newChildActionPublisherChained.
     *
     * @param methodName Method name for new publisher context
     * @param additionalContext Additional context to supply (optional)
     * @returns New publisher identical to this one, but with an updated context
     */

  }, {
    key: "newChildActionPublisherChainedForMethod",
    value: function newChildActionPublisherChainedForMethod(methodName, additionalContext) {
      return this.newChildActionPublisherChained(new _KatalMetricsContext.default({
        methodName: methodName
      }).merge(additionalContext));
    }
    /**
     * Helper method to create a new action publisher with the given value for methodName.
     *
     * Apart from setting the methodName in the child context, this method is identical to newChildActionPublisherForMethod.
     * @param methodName Method name for new publisher context
     * @param additionalContext Additional context to supply (optional)
     * @returns New publisher identical to this one, but with an updated context
     */

  }, {
    key: "newChildActionPublisherForMethod",
    value: function newChildActionPublisherForMethod(methodName, additionalContext) {
      return this.newChildActionPublisher(new _KatalMetricsContext.default({
        methodName: methodName
      }).merge(additionalContext));
    }
    /**
     * Helper method to create a new action for application initialization.  It will always have a methodName
     * of "Initialization"; otherwise this method is identical to newChildActionPublisherForMethod.
     *
     * @param additionalContext Additional context to be included in the new publisher
     * @returns New publisher identical to this one, but with an updated context
     */

  }, {
    key: "newChildActionPublisherForInitialization",
    value: function newChildActionPublisherForInitialization(additionalContext) {
      return this.newChildActionPublisherForMethod(INITIALIZATION_METHOD_NAME, additionalContext);
    }
    /**
     * Helper method to publish a string with the given name and value.
     *
     * @param name Metric name
     * @param value String value
     */

  }, {
    key: "publishString",
    value: function publishString(name, value) {
      this.publish(new _metricObject.String(name, value));
    }
    /**
     * Helper method to publish a string with the given name and value, truncated to the maximum size allowed by the
     * schema.
     *
     * @param name Metric name
     * @param value String value
     */

  }, {
    key: "publishStringTruncate",
    value: function publishStringTruncate(name, value) {
      var object = new _metricObject.String(name, value);
      object.truncate = true;
      this.publish(object);
    }
    /**
     * Helper method to publish a counter with the given name and value.
     *
     * @param name Metric name
     * @param value Counter value
     */

  }, {
    key: "publishCounter",
    value: function publishCounter(name, value) {
      this.publish(new _metricObject.Counter(name, value));
    }
    /**
     * Helper method to publish a timer with the given name and value.
     *
     * @param name Metric name
     * @param value Timer value
     */

  }, {
    key: "publishTimer",
    value: function publishTimer(name, value) {
      this.publish(new _metricObject.Timer(name, value));
    }
    /**
     * Helper method to publish a counter with the isMonitor flag set, and the given name and value.
     *
     * @param name Metric name
     * @param value Counter value
     */

  }, {
    key: "publishCounterMonitor",
    value: function publishCounterMonitor(name, value) {
      this.publish(new _metricObject.Counter(name, value).withMonitor());
    }
    /**
     * Helper method to publish a timer with the isMonitor flag set, and the given name and value.
     *
     * @param name Metric name
     * @param value Timer value
     */

  }, {
    key: "publishTimerMonitor",
    value: function publishTimerMonitor(name, value) {
      this.publish(new _metricObject.Timer(name, value).withMonitor());
    }
    /**
     * Private helper method to extract an actionId from a context if one is provided, and otherwise generate a new one.
     *
     * @returns Action ID string
     */

  }, {
    key: "_generateActionid",
    value: function _generateActionid(context) {
      if (context) {
        var fields = getContextFields(context);

        if (fields.actionId) {
          return fields.actionId;
        }
      }

      return (0, _v.default)();
    }
  }]);
  return KatalMetricsPublisher;
}();

exports.default = KatalMetricsPublisher;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/driver/ErrorHandler.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/driver/ErrorHandler.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_ERROR_HANDLER = void 0;

var DEFAULT_ERROR_HANDLER = function DEFAULT_ERROR_HANDLER(err) {
  throw err;
};

exports.DEFAULT_ERROR_HANDLER = DEFAULT_ERROR_HANDLER;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/driver/KatalMetricsDriver.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/driver/KatalMetricsDriver.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

/**
 * Abstract base class for a Katal metrics driver.
 */
var KatalMetricsDriver = /*#__PURE__*/function () {
  function KatalMetricsDriver() {
    (0, _classCallCheck2.default)(this, KatalMetricsDriver);
  }

  (0, _createClass2.default)(KatalMetricsDriver, [{
    key: "publish",
    value:
    /**
     * Publish the given metric object with the given error handler and context.
     *
     * @param metricObject Metric object to publish.  Contains metricKey, isMonitor, type, and value.
     * @param context Context for publishing this metric.  Contains all other fields to be published.
     */
    function publish(metricObject, context) {
      throw new Error('KatalMetricsDriver is an abstract class, please choose a driver and use that instead');
    }
  }]);
  return KatalMetricsDriver;
}();

exports.default = KatalMetricsDriver;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/helper/FirstMap.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/helper/FirstMap.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = firstMap;

/**
 * Returns the first non-undefined value that results from running each value
 * in the given array through the mapper function.
 * @param array An array of values.
 * @param mapper A mapper function that should return a value or undefined.
 * @returns The first non-undefined value from the mapper function.
 */
function firstMap(array, mapper) {
  var toReturn = undefined;
  array.some(function (val) {
    toReturn = mapper(val);
    return toReturn != null;
  });
  return toReturn;
}

;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/helper/ObjectValuesPonyfill.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/helper/ObjectValuesPonyfill.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var objectValues = Object.values ? Object.values : function (object) {
  return Object.keys(object).map(function (key) {
    return object[key];
  });
};
var _default = objectValues;
exports.default = _default;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleInt.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleInt.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = validateSimpleInt;

var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js"));

/**
 * Number.isInteger is not in IE11, and letting Babel polyfill it added too much weight.
 * Adapted from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
 */
var isInteger = function isInteger(val) {
  return isFinite(val) && Math.floor(val) === val;
};
/**
 * Check if the given value is valid to be published to KatalMetrics as an integer (Counter or Timer),
 * and return either undefined (no error), or an Error object describing the problem.
 *
 * @param val Value to check
 * @param nameForError Name to use when constructing the error message, if necessary
 * @returns Error, or undefined if no error
 */


function validateSimpleInt(val, nameForError) {
  if (typeof val !== 'number') {
    return new Error("Expected ".concat(nameForError, " to have type 'number', but it was type '").concat((0, _typeof2.default)(val), "'"));
  }

  if (val < 0) {
    return new Error("Expected ".concat(nameForError, " to be positive, but it was ").concat(val));
  } // This will also catch NaN and Infinity


  if (!isInteger(val)) {
    return new Error("Expected ".concat(nameForError, " to be an integer, but it was ").concat(val));
  } // Couldn't find anything wrong, implicitly return undefined

}

;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleString.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleString.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = validateSimpleString;

var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js"));

var SIMPLE_STRING_PAT = /^[A-Za-z0-9.:@_/-]+$/;
var SIMPLE_STRING_MAX_LEN = 127;
/**
 * Check if the given value is valid to be published to KatalMetrics as a field value,
 * such as site, serviceName, methodName, or actionId (note this is not used to check values for string metrics).
 * It returns either undefined (no error), or an Error object describing the problem.
 *
 * To be published, it must be a non-empty string, less than 256 characters, containing only ASCII
 * letters, numbers, or these characters: .:@_/- (those are the PMET field value requirements).
 *
 * @param val String value to check
 * @param nameForError Name to use in the error message, if one is generated
 * @returns Error, or undefined if no error
 */

function validateSimpleString(val, nameForError) {
  if (typeof val !== "string") {
    return new Error("Expected ".concat(nameForError, " to be a string, but it was a ").concat((0, _typeof2.default)(val)));
  }

  if (val.length > SIMPLE_STRING_MAX_LEN) {
    return new Error("Expected ".concat(nameForError, " to be less than ").concat(SIMPLE_STRING_MAX_LEN, " characters, but it was ").concat(val.length, " characters"));
  }

  if (val.length < 1) {
    return new Error("Expected ".concat(nameForError, " to be non-blank"));
  }

  if (!SIMPLE_STRING_PAT.test(val)) {
    return new Error("Expected ".concat(nameForError, " to contain only valid characters, but it was ").concat(val, ".  It can only contain letters, numbers, and these symbols: .:@_/-"));
  } // Couldn't find anything wrong, implicitly return undefined

}

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/helper/embedRequestId.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/helper/embedRequestId.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.embedRequestId = embedRequestId;

// until we can add a requestId field to the andes schema we will embed it in the actionId
function embedRequestId(actionId, requestId) {
  if (requestId) {
    return [requestId, actionId].join("::");
  }

  return actionId;
}

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/helper/mergeLists.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/helper/mergeLists.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeLists = mergeLists;

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/toConsumableArray.js"));

// Helper method to merge two lists which could be undefined
// Returns merged lists if either is defined, otherwise returns undefined
function mergeLists(list1, list2) {
  if (list1 || list2) {
    return [].concat((0, _toConsumableArray2.default)(list1 || []), (0, _toConsumableArray2.default)(list2 || []));
  } else {
    return undefined;
  }
}

;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/helper/metricsExtension.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/helper/metricsExtension.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dispatchMetricEvent = dispatchMetricEvent;

/**
 * Publish to external parties that are 
 * listening for katal.metrics.publish Custom Events
 */
function dispatchMetricEvent(metric, context) {
  if (typeof window === 'undefined') {
    return;
  }

  dispatchCustomEvent(metric, context); // for legacy purposes, also publish to __KATAL_METRICS_EXTENSION__

  publishToMetricsExtension(metric, context);
}

function dispatchCustomEvent(metric, context) {
  if (typeof CustomEvent !== "function") {
    return;
  }

  var event = new CustomEvent('katal.metrics.publish', {
    detail: {
      metric: metric,
      context: context.getFields()
    }
  });
  window.dispatchEvent(event);
}
/**
 * @Deprecated
 * Publish to https://code.amazon.com/packages/KatalMetricsExtension
 * The extension injects a global __KATAL_METRICS_EXTENSION__ object with a
 * `publish` method.
 */


function publishToMetricsExtension(metric, context) {
  var extension = window.__KATAL_METRICS_EXTENSION__;

  if (extension) {
    extension.publish(metric, context.getFields());
  }
}

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/helper/validateCloudWatchDimensions.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/helper/validateCloudWatchDimensions.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = validateCloudWatchDimensions;

var _FirstMap = _interopRequireDefault(__webpack_require__(/*! ./FirstMap */ "./node_modules/@amzn/katal-metrics/lib/helper/FirstMap.js"));

var PRINTABLE_ASCII_PATTERN = /^[\x20-\x7E]+$/;
var AT_LEAST_ONE_NON_WHITESPACE_PATTERN = /^.*\S+.*$/;
var DIMENSION_NAME_STRING_MAX_LEN = 255;
var DIMENSION_VALUE_STRING_MAX_LEN = 1024;
/**
 * Check if the given dimensions are valid to be published to KatalMonitoring back-end.
 * It returns either undefined (no error), or an Error object describing the problem.
 *
 * To be published, name and value of string metrics must follow restrictions as described by
 * CloudWatch Dimension API Documentation:
 * https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_Dimension.html
 *
 * @param dimensions Array of string metrics to check
 * @returns Error, or undefined if no error
 */

function validateCloudWatchDimensions(dimensions) {
  return (0, _FirstMap.default)(dimensions, function (dimension) {
    var name = dimension.name,
        value = dimension.value;
    return validateCloudWatchDimension(name, value);
  });
}
/**
 * Check if the given dimension is valid as described by CloudWatch documentation.
 * https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_Dimension.html
 *
 * @param name CloudWatch Dimension Name String to check
 * @param value CloudWatch Dimension Value String to check
 * @returns Error, or undefined if no error
 */


function validateCloudWatchDimension(name, value) {
  if (name.length > DIMENSION_NAME_STRING_MAX_LEN) {
    return new Error("Expected Dimension name for value ".concat(value, " to be ").concat(DIMENSION_NAME_STRING_MAX_LEN, " characters or less, but it was ").concat(name.length, " characters"));
  }

  if (name.length < 1) {
    return new Error("Expected Dimension name for value ".concat(value, " to be non-blank"));
  }

  if (!PRINTABLE_ASCII_PATTERN.test(name)) {
    return new Error("Expected Dimension name for value ".concat(value, " to contain only ASCII characters, but it was ").concat(name));
  }

  if (!AT_LEAST_ONE_NON_WHITESPACE_PATTERN.test(name)) {
    return new Error("Expected Dimension name for value ".concat(value, " to contain at least one non whitespace character, but it was ").concat(name));
  }

  if (name.startsWith(":")) {
    return new Error("Expected Dimension name for value ".concat(value, " to not start with a colon (\":\"), but it was ").concat(name));
  }

  if (value.length > DIMENSION_VALUE_STRING_MAX_LEN) {
    return new Error("Expected Dimension value for name ".concat(name, " to be ").concat(DIMENSION_VALUE_STRING_MAX_LEN, " characters or less, but it was ").concat(value.length, " characters"));
  }

  if (value.length < 1) {
    return new Error("Expected Dimension value for name ".concat(name, " to be non-blank"));
  }

  if (!PRINTABLE_ASCII_PATTERN.test(value)) {
    return new Error("Expected Dimension value for name ".concat(name, " to contain only ASCII characters, but it was ").concat(value));
  }

  if (!AT_LEAST_ONE_NON_WHITESPACE_PATTERN.test(value)) {
    return new Error("Expected Dimension value for name ".concat(name, " to contain at least one non whitespace character, but it was ").concat(value, "}"));
  } // Couldn't find anything wrong, implicitly return undefined

}

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "CloudWatchDimensions", {
  enumerable: true,
  get: function get() {
    return _CloudWatchDimensions.CloudWatchDimensions;
  }
});
Object.defineProperty(exports, "Context", {
  enumerable: true,
  get: function get() {
    return _KatalMetricsContext.default;
  }
});
Object.defineProperty(exports, "ErrorHandler", {
  enumerable: true,
  get: function get() {
    return _ErrorHandler.ErrorHandler;
  }
});
exports.Metric = void 0;
Object.defineProperty(exports, "MetricsDriver", {
  enumerable: true,
  get: function get() {
    return _KatalMetricsDriver.default;
  }
});
Object.defineProperty(exports, "Publisher", {
  enumerable: true,
  get: function get() {
    return _KatalMetricsPublisher.default;
  }
});

var Metric = _interopRequireWildcard(__webpack_require__(/*! ./metricObject */ "./node_modules/@amzn/katal-metrics/lib/metricObject/index.js"));

exports.Metric = Metric;

var _KatalMetricsPublisher = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricsPublisher */ "./node_modules/@amzn/katal-metrics/lib/KatalMetricsPublisher.js"));

var _KatalMetricsContext = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricsContext */ "./node_modules/@amzn/katal-metrics/lib/KatalMetricsContext.js"));

var _KatalMetricsDriver = _interopRequireDefault(__webpack_require__(/*! ./driver/KatalMetricsDriver */ "./node_modules/@amzn/katal-metrics/lib/driver/KatalMetricsDriver.js"));

var _ErrorHandler = __webpack_require__(/*! ./driver/ErrorHandler */ "./node_modules/@amzn/katal-metrics/lib/driver/ErrorHandler.js");

var _CloudWatchDimensions = __webpack_require__(/*! ./types/CloudWatchDimensions */ "./node_modules/@amzn/katal-metrics/lib/types/CloudWatchDimensions.js");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricCounter.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricCounter.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _KatalMetricObject2 = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricObject */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js"));

var _ValidateSimpleInt = _interopRequireDefault(__webpack_require__(/*! ../helper/ValidateSimpleInt */ "./node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleInt.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Counter type.
 *
 * Can be used to count the number of times an event happened on a page, or as a simple 1/0 counter to track
 * success and failure.
 */
var KatalMetricCounter = /*#__PURE__*/function (_KatalMetricObject) {
  (0, _inherits2.default)(KatalMetricCounter, _KatalMetricObject);

  var _super = _createSuper(KatalMetricCounter);

  /**
   * Create a new counter with the given name and value.
   *
   * @param name Counter name
   * @param value Counter value
   */
  function KatalMetricCounter(name) {
    var _this;

    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    (0, _classCallCheck2.default)(this, KatalMetricCounter);
    _this = _super.call(this, name);
    _this.value = value;
    return _this;
  }
  /**
   * Get the value for this counter
   *
   * @return Counter value
   */


  (0, _createClass2.default)(KatalMetricCounter, [{
    key: "value",
    get: function get() {
      return this._value;
    }
    /**
     * Set a new value for this counter
     *
     * @param value New value for this counter
     */
    ,
    set: function set(value) {
      // Math.round will also coerce from a string if necessary, and return NaN if invalid
      this._value = Math.round(value);
    }
    /**
     * Gets the type for this counter.
     *
     * @return Always returns "Counter".
     */

  }, {
    key: "type",
    get: function get() {
      return _KatalMetricObject2.default.Types.Counter;
    }
    /**
     * Add a number to this counter.
     *
     * Can also be negative to subtract.
     *
     * @param addValue Amount to add to this counter
     */

  }, {
    key: "add",
    value: function add(addValue) {
      this.value += addValue;
    }
  }, {
    key: "canMonitor",
    get: function get() {
      return true;
    }
  }, {
    key: "validationError",
    value: function validationError() {
      var superError = (0, _get2.default)((0, _getPrototypeOf2.default)(KatalMetricCounter.prototype), "validationError", this).call(this);
      if (superError) return superError;
      return (0, _ValidateSimpleInt.default)(this.value, "field value in Counter metrics object '".concat(this.name, "'"));
    }
  }]);
  return KatalMetricCounter;
}(_KatalMetricObject2.default);

exports.default = KatalMetricCounter;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricHttpRequest.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricHttpRequest.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));

var _KatalMetricTimedAttempt = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimedAttempt */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimedAttempt.js"));

var _KatalMetricString = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricString */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricString.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Standardized metric for instrumenting HTTP requests.
 *
 * Under the hood it is a KatalMetricTimedAttempt with the name you provide prefixed with "HTTPRequest.".
 * That object will contain a metric suffixed with ".Latency" for the latency of this request, and a metric suffixed
 * with ".Failure" to record the failure or success of this request.
 *
 * By default the request will be tracked as a failure; to mark it as a success call the "setSuccess()" method.
 *
 * It has additional properties which will be emitted if set; see url, statusCode, and statusText.
 *
 * For example, if you gave the name "Search", these metrics will be created:
 *   HTTPRequest.Search.Latency - Latency for this request
 *   HTTPRequest.Search.Failure - Failure for this request (1 for failure, 0 for success)
 */
var KatalMetricHttpRequest = /*#__PURE__*/function (_KatalMetricTimedAtte) {
  (0, _inherits2.default)(KatalMetricHttpRequest, _KatalMetricTimedAtte);

  var _super = _createSuper(KatalMetricHttpRequest);

  /** The prefix for this metric. */

  /** The suffix for URL metrics of this class. */

  /** The suffix for HTTP response code metrics of this class. */

  /** The suffix for HTTP response text metrics of this class. */

  /**
   * Create a new HTTP Request timed attempt metric incorporating the given name.
   *
   * The name you give will be used to create a KatalMetricTimedAttempt with the provided name prefixed with "HTTPRequest.".
   *
   * @param name Name of this metric; resulting metrics will prefix this name with "HTTPRequest."
   */
  function KatalMetricHttpRequest(name) {
    (0, _classCallCheck2.default)(this, KatalMetricHttpRequest);
    return _super.call(this, "".concat(KatalMetricHttpRequest.HTTP_REQUEST_PREFIX, ".").concat(name));
  }
  /**
   * Set the url for this metric.
   *
   * A string metric will be added to the list of objects that will be published for this metric.  Its name will
   * be this metrics name suffixed with '.URL', and its value will be the URL value given here.
   *
   * @param value URL for this metric
   */


  (0, _createClass2.default)(KatalMetricHttpRequest, [{
    key: "url",
    get:
    /**
     * Get the URL for this metric, if defined.
     *
     * @return The URL for this metric, or undefined
     */
    function get() {
      return this.getNamedMetricValue(KatalMetricHttpRequest.URL_SUFFIX);
    }
    /**
     * Get the URL metric object associated with this metric, if defined.
     *
     * @return Associated URL metric object, or undefined
     */
    ,
    set: function set(value) {
      this.setOrDeleteNamedMetricValue(KatalMetricHttpRequest.URL_SUFFIX, _KatalMetricString.default, value);
    }
  }, {
    key: "urlMetric",
    get: function get() {
      return this.getNamedMetric(KatalMetricHttpRequest.URL_SUFFIX);
    }
    /**
     * Set the HTTP response status code for this metric.
     *
     * A string metric will be added to the list of objects that will be published for this metric.  Its name will
     * be this metrics name suffixed with '.StatusCode', and its value will be the status code value given here.
     *
     * @param value HTTP response status code for this metric
     */

  }, {
    key: "statusCode",
    get:
    /**
     * Get the HTTP response status code for this metric, if defined.
     *
     * @return Associated HTTP response status code metric object, or undefined
     */
    function get() {
      return this.getNamedMetricValue(KatalMetricHttpRequest.STATUS_CODE_SUFFIX);
    }
    /**
     * Get the HTTP response status code metric object associated with this metric, if defined.
     *
     * @return HTTP response status code metric object, or undefined
     */
    ,
    set: function set(value) {
      this.setOrDeleteNamedMetricValue(KatalMetricHttpRequest.STATUS_CODE_SUFFIX, _KatalMetricString.default, value);
    }
  }, {
    key: "statusCodeMetric",
    get: function get() {
      return this.getNamedMetric(KatalMetricHttpRequest.STATUS_CODE_SUFFIX);
    }
    /**
     * Set the HTTP response status text for this metric.
     *
     * A string metric will be added to the list of objects that will be published for this metric.  Its name will
     * be this metrics name suffixed with '.StatusText', and its value will be the status text value given here.
     *
     * @param statusText HTTP response status text for this metric, or undefined to remove
     */

  }, {
    key: "statusText",
    get:
    /**
     * Get the HTTP response status text for this metric, if defined.
     *
     * @return Associated HTTP response status text metric object, or undefined
     */
    function get() {
      return this.getNamedMetricValue(KatalMetricHttpRequest.STATUS_TEXT_SUFFIX);
    }
    /**
     * Get the HTTP response status text for this metric, if defined.
     *
     * @return Associated HTTP response status text metric object, or undefined
     */
    ,
    set: function set(value) {
      this.setOrDeleteNamedMetricValue(KatalMetricHttpRequest.STATUS_TEXT_SUFFIX, _KatalMetricString.default, value);
    }
  }, {
    key: "statusTextMetric",
    get: function get() {
      return this.getNamedMetric(KatalMetricHttpRequest.STATUS_TEXT_SUFFIX);
    }
  }]);
  return KatalMetricHttpRequest;
}(_KatalMetricTimedAttempt.default);

exports.default = KatalMetricHttpRequest;
(0, _defineProperty2.default)(KatalMetricHttpRequest, "HTTP_REQUEST_PREFIX", 'HTTPRequest');
(0, _defineProperty2.default)(KatalMetricHttpRequest, "URL_SUFFIX", 'URL');
(0, _defineProperty2.default)(KatalMetricHttpRequest, "STATUS_CODE_SUFFIX", 'StatusCode');
(0, _defineProperty2.default)(KatalMetricHttpRequest, "STATUS_TEXT_SUFFIX", 'StatusText');

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricInitialization.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricInitialization.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));

var _KatalMetricTimedAttempt = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimedAttempt */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimedAttempt.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Standardized metric for instrumenting application initialization.
 *
 * Under the hood it is a KatalMetricTimedAttempt with the name "Initialization".
 * That object will contain a metric suffixed with ".Latency" for the latency of this request, and a metric suffixed
 * with ".Failure" to record the failure or success of this request.
 *
 * By default the request will be tracked as a failure; to mark it as a success call the "setSuccess()" method.
 *
 * By default, these metrics will be created:
 *   Initialization.Latency - Latency for application initialization
 *   Initialization.Failure - Failure for this application initialization (1 for failure, 0 for success)
 */
var KatalMetricInitialization = /*#__PURE__*/function (_KatalMetricTimedAtte) {
  (0, _inherits2.default)(KatalMetricInitialization, _KatalMetricTimedAtte);

  var _super = _createSuper(KatalMetricInitialization);

  /** The name for this metric. */

  /**
   * Create a new timed attempt metric named "Initialization", for recording latency and failure information about
   * your application's initialization.
   */
  function KatalMetricInitialization() {
    (0, _classCallCheck2.default)(this, KatalMetricInitialization);
    return _super.call(this, KatalMetricInitialization.INITIALIZE_METRIC_NAME);
  }

  return KatalMetricInitialization;
}(_KatalMetricTimedAttempt.default);

exports.default = KatalMetricInitialization;
(0, _defineProperty2.default)(KatalMetricInitialization, "INITIALIZE_METRIC_NAME", 'Initialization');

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricNamedObjectList.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricNamedObjectList.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _KatalMetricObjectList = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricObjectList */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObjectList.js"));

var _ObjectValuesPonyfill = _interopRequireDefault(__webpack_require__(/*! ../helper/ObjectValuesPonyfill */ "./node_modules/@amzn/katal-metrics/lib/helper/ObjectValuesPonyfill.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Metric object list that tracks metrics by name, and generates metrics prefixed with the name of this object.
 */
var KatalMetricNamedObjectList = /*#__PURE__*/function (_KatalMetricObjectLis) {
  (0, _inherits2.default)(KatalMetricNamedObjectList, _KatalMetricObjectLis);

  var _super = _createSuper(KatalMetricNamedObjectList);

  /**
   * Create a new named object list.
   *
   * The name given here will be used to prefix all metrics.
   *
   * @param name Name of this metric
   */
  function KatalMetricNamedObjectList(name) {
    var _this;

    (0, _classCallCheck2.default)(this, KatalMetricNamedObjectList);
    _this = _super.call(this, name);
    _this.namedMetrics = {};
    return _this;
  }

  (0, _createClass2.default)(KatalMetricNamedObjectList, [{
    key: "metricList",
    get: function get() {
      return (0, _ObjectValuesPonyfill.default)(this.namedMetrics);
    }
    /**
     * Replace the metric with the given name with a new metric generated by the given function.
     *
     * If the newly created metric supports monitoring, its isMonitor flag will be set to the value of the
     * isMonitor flag for this containing object.
     *
     * @param subName Name of this sub-metric
     * @param metricCreator Function which takes the full name for this metric
     *        and returns a newly constructed KatalMetricObject with this name and an appropriate value
     */

  }, {
    key: "setNamedMetric",
    value: function setNamedMetric(subName, metricCreator) {
      var fullName = this.getNameForSubMetric(subName);
      var metric = metricCreator(fullName);

      if (metric.canMonitor) {
        metric.isMonitor = this.isMonitor;
      }

      this.namedMetrics[subName] = metric;
    }
    /**
     * If the given value is undefined or null, delete the metric with the give name; otherwise if the given named
     * metric already exists update its value; otherwise create a new metric of the given type and set its value.
     *
     * This specialized helper method is designed to deal with the common case of a value setter in a more complex
     * metric.  Outside of subclasses, other methods will probably prove more useful.
     *
     * If the value is null the metric will also be deleted.
     *
     * @param subName Name of metric to create or delete
     * @param newValueClass Class of new metric to create
     * @param newValue New value for this metric (or undefined to delete the metric)
     */

  }, {
    key: "setOrDeleteNamedMetricValue",
    value: function setOrDeleteNamedMetricValue(subName, newValueClass, newValue) {
      if (newValue == undefined) {
        this.deleteNamedMetric(subName);
      } else {
        var metric = this.getOrCreateNamedMetric(subName, function (name) {
          return new newValueClass(name, newValue);
        });
        metric.value = newValue;
      }
    }
    /**
     * Get the sub-metric with the given name if it exists, otherwise use the given function to create a new metric and
     * store and return that.
     *
     * @param subName Name of this sub-metric
     * @param metricCreator Function which takes the full name for this metric
     *        and returns a newly constructed KatalMetricObject with this name and an appropriate value
     * @return Metric object which was retrieved or created
     */

  }, {
    key: "getOrCreateNamedMetric",
    value: function getOrCreateNamedMetric(subName, metricCreator) {
      if (!this.namedMetrics[subName]) {
        this.setNamedMetric(subName, metricCreator);
      }

      return this.namedMetrics[subName];
    }
    /**
     * Return the given named sub-metric, if it exists.
     *
     * @param {string} subName Name of this sub-metric
     * @return {KatalMetricObject | undefined} Metric object with this name if it exists, otherwise undefined
     */

  }, {
    key: "getNamedMetric",
    value: function getNamedMetric(subName) {
      return this.namedMetrics[subName];
    }
    /**
     * Delete the given named sub-metric.
     *
     * @param subName Name of this sub-metric
     */

  }, {
    key: "deleteNamedMetric",
    value: function deleteNamedMetric(subName) {
      delete this.namedMetrics[subName];
    }
    /**
     * Get the value for the given metric, or undefined if the metric does not exist.
     *
     * @param subName Name of this sub-metric
     * @return Value for the given metric, or undefined if the metric does not exist
     */

  }, {
    key: "getNamedMetricValue",
    value: function getNamedMetricValue(subName) {
      var metric = this.getNamedMetric(subName);
      if (!metric) return undefined;
      return metric.value;
    }
    /**
     * Generate a name for the given sub-metric.
     *
     * @param subName Name of this sub-metric
     * @return Full name for this sub-metric
     */

  }, {
    key: "getNameForSubMetric",
    value: function getNameForSubMetric(subName) {
      return "".concat(this.name, ".").concat(subName);
    }
  }]);
  return KatalMetricNamedObjectList;
}(_KatalMetricObjectList.default);

exports.default = KatalMetricNamedObjectList;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));

var _ValidateSimpleString = _interopRequireDefault(__webpack_require__(/*! ../helper/ValidateSimpleString */ "./node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleString.js"));

var _KatalMetricType = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricType */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricType.js"));

/**
 * Abstract base class for a single metric in Katal.
 *
 * A single metric contains the name (metricKey), value, type, and the isMonitor flag; everything else is in the
 * KatalMetricsContext it is published to.
 */
var KatalMetricObject = /*#__PURE__*/function () {
  /**
   * Metric types.
   */

  /**
   * Create a new KatalMetricObject with the given name.
   *
   * @param name Name for this metric; published as metricKey field
   */
  function KatalMetricObject(name) {
    (0, _classCallCheck2.default)(this, KatalMetricObject);
    this._name = name;
    this._isMonitor = false;
  }
  /**
   * Get the name for this metric.
   *
   * Note that the name is immutable, and this cannot be set.
   *
   * @returns Name for this metric
   */


  (0, _createClass2.default)(KatalMetricObject, [{
    key: "name",
    get: function get() {
      return this._name;
    }
    /**
     * Alias for name.
     *
     * @returns Name for this metric
     */

  }, {
    key: "metricKey",
    get: function get() {
      return this._name;
    }
    /**
     * Set the isMonitor flag for this metric, and returns this object for continued use.
     *
     * This flag determines if the metric can be used for dashboards and alarms (i.e. if it will be published to PMET)
     * @param isMonitor New value for the isMonitor flag; defaults to true
     * @returns This object
     */

  }, {
    key: "withMonitor",
    value: function withMonitor() {
      var isMonitor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      this.isMonitor = isMonitor;
      return this;
    }
    /**
     * Set the isMonitor flag for this metric.
     *
     * The value is forced to a boolean based on its truthiness.
     *
     * @param isMonitor New value for the isMonitor flag
     */

  }, {
    key: "isMonitor",
    get:
    /**
     * Get the isMonitor flag for this metric.
     *
     * @returns isMonitor flag for this metric.
     */
    function get() {
      return this._isMonitor;
    }
    /**
     * Check if this metric can be meaningfully monitored.
     *
     * Subclasses must override this.
     *
     * @return Whether this metric can be meaningfully monitored
     */
    ,
    set: function set(isMonitor) {
      this._isMonitor = !!isMonitor;
    }
  }, {
    key: "canMonitor",
    get: function get() {
      throw new Error('Subclass of KatalMetricObject must implement canMonitor');
    }
    /**
     * Get the type of this metric.
     *
     * @return Type of this metric (one of: String, Counter, Timer, List)
     */

  }, {
    key: "type",
    get: function get() {
      throw new Error('Subclass of KatalMetricObject must implement type getter');
    }
    /**
     * Check for a validation error on this object.
     *
     * Returns the first validation error encountered if one is found, otherwise undefined.
     *
     * @returns {Error | undefined} Error found with this object, or undefined if no error is found
     */

  }, {
    key: "validationError",
    value: function validationError() {
      if (this.isMonitor !== undefined && typeof this.isMonitor !== 'boolean') {
        return new Error("Field isMonitor should be a boolean, but it was a ".concat((0, _typeof2.default)(this.isMonitor)));
      }

      return (0, _ValidateSimpleString.default)(this.name, 'field name');
    }
  }]);
  return KatalMetricObject;
}();

exports.default = KatalMetricObject;
(0, _defineProperty2.default)(KatalMetricObject, "Types", _KatalMetricType.default);

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObjectList.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObjectList.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js"));

var _set2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/set */ "./node_modules/@babel/runtime/helpers/set.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _KatalMetricObject2 = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricObject */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js"));

var _FirstMap = _interopRequireDefault(__webpack_require__(/*! ../helper/FirstMap */ "./node_modules/@amzn/katal-metrics/lib/helper/FirstMap.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Abstract metric that contains a list of other metrics; when it is published, the list of metrics is retrieved, and all
 * are published.
 */
var KatalMetricObjectList = /*#__PURE__*/function (_KatalMetricObject) {
  (0, _inherits2.default)(KatalMetricObjectList, _KatalMetricObject);

  var _super = _createSuper(KatalMetricObjectList);

  /**
   * Create a new KatalMetricObjectList.
   *
   * @param name Name for this metric.  Not really used, but present for consistency with other metrics.
   */
  function KatalMetricObjectList(name) {
    (0, _classCallCheck2.default)(this, KatalMetricObjectList);
    return _super.call(this, name);
  }
  /**
   * Get the list of for this object
   *
   * @returns Array of metrics for this object
   */


  (0, _createClass2.default)(KatalMetricObjectList, [{
    key: "metricList",
    get: function get() {
      throw new Error('Subclass of KatalMetricObjectList must implement metricList getter');
    }
  }, {
    key: "isMonitor",
    get: // This just delegates to the superclass, but if we override the setter without overriding the getter
    // getting the property will always return undefined.
    function get() {
      return (0, _get2.default)((0, _getPrototypeOf2.default)(KatalMetricObjectList.prototype), "isMonitor", this);
    },
    set: function set(isMonitor) {
      (0, _set2.default)((0, _getPrototypeOf2.default)(KatalMetricObjectList.prototype), "isMonitor", isMonitor, this, true);
      this.metricList.forEach(function (metric) {
        if (metric.canMonitor) {
          metric.isMonitor = isMonitor;
        }
      });
    }
  }, {
    key: "canMonitor",
    get: function get() {
      return true;
    }
  }, {
    key: "type",
    get: function get() {
      return _KatalMetricObject2.default.Types.List;
    }
    /**
     * If any of the contained metrics are invalid, return the first validation error encountered; otherwise return
     * undefined.
     *
     * Note that this isn't called by the publisher; it validates each sub-metric on its own.
     *
     * @returns Error found with submetric, if any; else undefined
     */

  }, {
    key: "validationError",
    value: function validationError() {
      // Doesn't make sense to check superclass error here, since it is the contained metrics that matter.
      return (0, _FirstMap.default)(this.metricList, function (metric) {
        return metric.validationError();
      });
    }
  }]);
  return KatalMetricObjectList;
}(_KatalMetricObject2.default);

exports.default = KatalMetricObjectList;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricString.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricString.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js"));

var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));

var _KatalMetricObject2 = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricObject */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * String type.
 *
 * Can be used to store arbitrary strings of data.
 */
var KatalMetricString = /*#__PURE__*/function (_KatalMetricObject) {
  (0, _inherits2.default)(KatalMetricString, _KatalMetricObject);

  var _super = _createSuper(KatalMetricString);

  /**
   * Create a string with the given name and value.
   *
   * @param name String name
   * @param value String value
   */
  function KatalMetricString(name, value) {
    var _this;

    (0, _classCallCheck2.default)(this, KatalMetricString);
    _this = _super.call(this, name);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "truncate", false);
    _this.value = value;
    return _this;
  }
  /**
   * Get the value for this string metric.
   *
   * @return Value for this metric
   */


  (0, _createClass2.default)(KatalMetricString, [{
    key: "value",
    get: function get() {
      return this._value;
    }
    /**
     * Set the value for this string metric.
     *
     * The new value should be a string, but number and boolean types will be automatically converted to strings.
     * For other types, including undefined and null, the value will be accepted, but will fail validation when publishing.
     *
     * @param value New value for this metric
     */
    ,
    set: function set(value) {
      if (typeof value === "number" || typeof value === "boolean") {
        value = value.toString();
      }

      this._value = value;
    }
    /**
     * Truncation flag for this string metric.
     *
     * If set, the value here will be automatically truncated to the maximum size allowed by the current schema.
     * Otherwise, sending a value larger than allowed will result in a failure.
     *
     * @param value True to automatically truncate metrics, otherwise false
     */

  }, {
    key: "type",
    get:
    /**
     * Gets the type for this metric.
     *
     * @return Always returns "String".
     */
    function get() {
      return _KatalMetricObject2.default.Types.String;
    }
  }, {
    key: "canMonitor",
    get: function get() {
      return false;
    }
  }, {
    key: "validationError",
    value: function validationError() {
      var superError = (0, _get2.default)((0, _getPrototypeOf2.default)(KatalMetricString.prototype), "validationError", this).call(this);
      if (superError) return superError;

      if (typeof this.value !== 'string') {
        return new Error("Expected field value in String metrics object '".concat(this.name, "' to be type string, but it was ").concat((0, _typeof2.default)(this.value)));
      }

      if (this.value.length > KatalMetricString.MAX_SIZE) {
        if (this.truncate) {
          this.value = this.value.substring(0, KatalMetricString.MAX_SIZE);
        } else {
          return new Error("Expected field value in String metrics object '".concat(this.name, "' to be ").concat(KatalMetricString.MAX_SIZE, " characters or less, but it was ").concat(this.value.length, " characters."));
        }
      } // Didn't find anything wrong, implicitly return undefined

    }
  }]);
  return KatalMetricString;
}(_KatalMetricObject2.default);

exports.default = KatalMetricString;
(0, _defineProperty2.default)(KatalMetricString, "MAX_SIZE", 256);

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimedAttempt.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimedAttempt.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));

var _KatalMetricNamedObjectList = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricNamedObjectList */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricNamedObjectList.js"));

var _KatalMetricTimerStopwatch = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimerStopwatch */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimerStopwatch.js"));

var _KatalMetricCounter = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricCounter */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricCounter.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Metric that pairs a timer and a failure counter to record the time and status of an attempt to do something.
 */
var KatalMetricTimedAttempt = /*#__PURE__*/function (_KatalMetricNamedObje) {
  (0, _inherits2.default)(KatalMetricTimedAttempt, _KatalMetricNamedObje);

  var _super = _createSuper(KatalMetricTimedAttempt);

  /** The sub-metric name for latency. */

  /** The sub-metric name for failure count. */

  /**
   * Create a new timed attempt with the given name
   *
   * This will create two inner metrics, a KatalMetricCounter that has the given name with ".Failure" appended,
   * and a KatalMetricTimerStopwatch that has the given name with ".Latency" appended.
   *
   * @param name Name of this attempt
   */
  function KatalMetricTimedAttempt(name) {
    var _this;

    (0, _classCallCheck2.default)(this, KatalMetricTimedAttempt);
    _this = _super.call(this, name);

    _this.setNamedMetric(KatalMetricTimedAttempt.LATENCY_SUFFIX, function (name) {
      return new _KatalMetricTimerStopwatch.default(name);
    });

    _this.setNamedMetric(KatalMetricTimedAttempt.FAILURE_SUFFIX, function (name) {
      return new _KatalMetricCounter.default(name, 1);
    });

    return _this;
  }
  /**
   * Set the failure counter metric based on the given failure status.
   *
   * If failure is true the counter will have a value of 1; if it is false the counter will have a value of 0.
   *
   * @param failure Whether this is a failure or not; default true
   */


  (0, _createClass2.default)(KatalMetricTimedAttempt, [{
    key: "setFailure",
    value: function setFailure() {
      var failure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var failureCount = failure ? 1 : 0;
      var metric = this.failureMetric;
      metric.value = failureCount;
    }
    /**
     * Set the failure status to false.
     */

  }, {
    key: "setSuccess",
    value: function setSuccess() {
      this.setFailure(false);
    }
    /**
     * Set the latency metric to the given value, in milliseconds.
     *
     * Note you don't normally have to set this, the underlying metric is a KatalMetricTimerStopwatch that will start
     * and stop automatically.
     *
     * @param latencyMs Latency in milliseconds
     */

  }, {
    key: "setLatency",
    value: function setLatency(latencyMs) {
      var metric = this.latencyMetric;
      metric.value = latencyMs;
    }
    /**
     * Get the timer stopwatch metric for this attempt.
     *
     * @return Timer stopwatch metric for this attempt
     */

  }, {
    key: "latencyMetric",
    get: function get() {
      return this.getNamedMetric(KatalMetricTimedAttempt.LATENCY_SUFFIX);
    }
    /**
     * Get the failure counter metric for this attempt.
     *
     * @return Failure counter metric for this event
     */

  }, {
    key: "failureMetric",
    get: function get() {
      return this.getNamedMetric(KatalMetricTimedAttempt.FAILURE_SUFFIX);
    }
  }]);
  return KatalMetricTimedAttempt;
}(_KatalMetricNamedObjectList.default);

exports.default = KatalMetricTimedAttempt;
(0, _defineProperty2.default)(KatalMetricTimedAttempt, "LATENCY_SUFFIX", 'Latency');
(0, _defineProperty2.default)(KatalMetricTimedAttempt, "FAILURE_SUFFIX", 'Failure');

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimer.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimer.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _KatalMetricObject2 = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricObject */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js"));

var _ValidateSimpleInt = _interopRequireDefault(__webpack_require__(/*! ../helper/ValidateSimpleInt */ "./node_modules/@amzn/katal-metrics/lib/helper/ValidateSimpleInt.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Timer type.
 *
 * Can be used to record a time.  This class requires explicit value; see KatalMetricTimerStopwatch for automatic
 * timing.
 */
var KatalMetricTimer = /*#__PURE__*/function (_KatalMetricObject) {
  (0, _inherits2.default)(KatalMetricTimer, _KatalMetricObject);

  var _super = _createSuper(KatalMetricTimer);

  /**
   * Create a new timer metric.
   *
   * @param name Name for the metric
   * @param value Timer value in milliseconds
   */
  function KatalMetricTimer(name, value) {
    var _this;

    (0, _classCallCheck2.default)(this, KatalMetricTimer);
    _this = _super.call(this, name);
    _this.value = value;
    return _this;
  }
  /**
   * Get the value for this timer
   *
   * @return Timer value in milliseconds
   */


  (0, _createClass2.default)(KatalMetricTimer, [{
    key: "value",
    get: function get() {
      return this._value;
    }
    /**
     * Set the value for this timer
     *
     * @param value New timer value in milliseconds
     */
    ,
    set: function set(value) {
      if (value == undefined) {
        this._value = value;
        return;
      } // Math.round will also coerce from a string if necessary, and return NaN if invalid


      this._value = Math.round(value);
    }
    /**
     * Get the type for this timer.
     *
     * @return Always returns "Timer".
     */

  }, {
    key: "type",
    get: function get() {
      return _KatalMetricObject2.default.Types.Timer;
    }
  }, {
    key: "canMonitor",
    get: function get() {
      return true;
    }
  }, {
    key: "validationError",
    value: function validationError() {
      var superError = (0, _get2.default)((0, _getPrototypeOf2.default)(KatalMetricTimer.prototype), "validationError", this).call(this);
      if (superError) return superError;
      return (0, _ValidateSimpleInt.default)(this.value, "field value in Timer metrics object '".concat(this.name, "'"));
    }
  }]);
  return KatalMetricTimer;
}(_KatalMetricObject2.default);

exports.default = KatalMetricTimer;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimerStopwatch.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimerStopwatch.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

var _set2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/set */ "./node_modules/@babel/runtime/helpers/set.js"));

var _get2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/get */ "./node_modules/@babel/runtime/helpers/get.js"));

var _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js"));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));

var _KatalMetricTimer2 = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimer */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimer.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Subclass of KatalMetricTimer that can be started and stopped, and will record the elapsed time between starting and
 * stopping.  By default it will start when the object is created, and stopped when the value is retrieved with
 * the getter "value".
 */
var KatalMetricTimerStopwatch = /*#__PURE__*/function (_KatalMetricTimer) {
  (0, _inherits2.default)(KatalMetricTimerStopwatch, _KatalMetricTimer);

  var _super = _createSuper(KatalMetricTimerStopwatch);

  /**
   * Create a new timer with the given name and starting time.  If no starting time is given, the current time is used.
   *
   * @param name Name for this timer
   * @param startTime Millisecond epoch time for the start time; defaults to now
   */
  function KatalMetricTimerStopwatch(name, startTime) {
    var _this;

    (0, _classCallCheck2.default)(this, KatalMetricTimerStopwatch);
    _this = _super.call(this, name, undefined);

    _this.start(startTime);

    _this._value = undefined;
    return _this;
  }
  /**
   * Re-start timer with the given start time, or the current time if none is given.
   *
   * @param startTime When the timer was started, in epoch milliseconds; defaults to now
   */


  (0, _createClass2.default)(KatalMetricTimerStopwatch, [{
    key: "start",
    value: function start(startTime) {
      this._startTime = startTime || this.now();
    }
    /**
     * Stop the timer and record the elapsed time.
     *
     * @param stopTime When the timer was stopped, in epoch milliseconds; defaults to now
     */

  }, {
    key: "stop",
    value: function stop(stopTime) {
      return this._stopTime = stopTime || this.now();
    }
    /**
     * Check if the timer has been stopped.
     *
     * @returns Whether the timer has been stopped yet
     */

  }, {
    key: "isStopped",
    get: function get() {
      return this._stopTime !== undefined;
    }
    /**
     * Get the elapsed time between when the timer was started and stopped; if the timer has not yet been stopped,
     * stop it first.
     *
     * @returns Elapsed time between when timer was started and stopped
     */

  }, {
    key: "value",
    get: function get() {
      if ((0, _get2.default)((0, _getPrototypeOf2.default)(KatalMetricTimerStopwatch.prototype), "value", this) === undefined) {
        if (!this.isStopped) {
          this.stop();
        } // Rely on super.value setter to round


        (0, _set2.default)((0, _getPrototypeOf2.default)(KatalMetricTimerStopwatch.prototype), "value", this.stopTime - this.startTime, this, true);
      }

      return (0, _get2.default)((0, _getPrototypeOf2.default)(KatalMetricTimerStopwatch.prototype), "value", this);
    }
    /**
     * Get when this timer was started.
     *
     * @return Start time, in epoch milliseconds
     */
    ,
    set:
    /**
     * Set the value for this metric.  Note this will override the stopwatch behavior and just use the given value.
     *
     * @param value Value for this metric
     */
    function set(value) {
      (0, _set2.default)((0, _getPrototypeOf2.default)(KatalMetricTimerStopwatch.prototype), "value", value, this, true);
    }
  }, {
    key: "startTime",
    get: function get() {
      return this._startTime;
    }
    /**
     * Get when this timer was stopped (or undefined if it is still running)
     *
     * @return Stop time, in epoch millseconds, or undefined if the stopwatch is still running
     */

  }, {
    key: "stopTime",
    get: function get() {
      return this._stopTime;
    }
  }, {
    key: "now",
    value: function now() {
      return performance.now();
    }
  }]);
  return KatalMetricTimerStopwatch;
}(_KatalMetricTimer2.default);

exports.default = KatalMetricTimerStopwatch;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricType.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricType.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * Metric types.
 */
var KatalMetricType;

(function (KatalMetricType) {
  KatalMetricType["String"] = "String";
  KatalMetricType["Counter"] = "Counter";
  KatalMetricType["Timer"] = "Timer";
  KatalMetricType["List"] = "List";
})(KatalMetricType || (KatalMetricType = {}));

;
var _default = KatalMetricType;
exports.default = _default;

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/metricObject/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/metricObject/index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Counter", {
  enumerable: true,
  get: function get() {
    return _KatalMetricCounter.default;
  }
});
Object.defineProperty(exports, "HttpRequest", {
  enumerable: true,
  get: function get() {
    return _KatalMetricHttpRequest.default;
  }
});
Object.defineProperty(exports, "Initialization", {
  enumerable: true,
  get: function get() {
    return _KatalMetricInitialization.default;
  }
});
Object.defineProperty(exports, "Object", {
  enumerable: true,
  get: function get() {
    return _KatalMetricObject.default;
  }
});
Object.defineProperty(exports, "String", {
  enumerable: true,
  get: function get() {
    return _KatalMetricString.default;
  }
});
Object.defineProperty(exports, "TimedAttempt", {
  enumerable: true,
  get: function get() {
    return _KatalMetricTimedAttempt.default;
  }
});
Object.defineProperty(exports, "Timer", {
  enumerable: true,
  get: function get() {
    return _KatalMetricTimer.default;
  }
});
Object.defineProperty(exports, "TimerStopwatch", {
  enumerable: true,
  get: function get() {
    return _KatalMetricTimerStopwatch.default;
  }
});

var _KatalMetricObject = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricObject */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricObject.js"));

var _KatalMetricString = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricString */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricString.js"));

var _KatalMetricCounter = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricCounter */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricCounter.js"));

var _KatalMetricTimer = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimer */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimer.js"));

var _KatalMetricTimerStopwatch = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimerStopwatch */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimerStopwatch.js"));

var _KatalMetricTimedAttempt = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricTimedAttempt */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricTimedAttempt.js"));

var _KatalMetricInitialization = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricInitialization */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricInitialization.js"));

var _KatalMetricHttpRequest = _interopRequireDefault(__webpack_require__(/*! ./KatalMetricHttpRequest */ "./node_modules/@amzn/katal-metrics/lib/metricObject/KatalMetricHttpRequest.js"));

/***/ }),

/***/ "./node_modules/@amzn/katal-metrics/lib/types/CloudWatchDimensions.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@amzn/katal-metrics/lib/types/CloudWatchDimensions.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

/***/ }),

/***/ "./node_modules/@amzn/katal-sushi-client/dist/SushiClient.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@amzn/katal-sushi-client/dist/SushiClient.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js"));

var _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * This class encapsulates two IIFEs that the Sushi library contains. A fake CSM and Window object are created and provided
 * to the functions so that they actually execute in a controlled environment away from any CSM code that might be executing
 * at the platform level within the page.
 *
 * The basic run order is the following:
 * 1. Build the mock CSM object, then build a mock Window object that references the CSM object as ue_csm
 * 2. Run the transportation-clients.js Script from SushiJavascriptClient providing the mocks. It will modify globals on the mock objects.
 * 3. Run the sushi-client.js script from SushiJavaScriptClient providing the mocks. It will create an instance of the sushi client and inject it into the CSM globals in the mocks.
 * 4. whenever event() is called, refer to the encapsulated csm object to add the event to the queue.
 */
var SushiClient =
/*#__PURE__*/
function () {
  (0, _createClass2.default)(SushiClient, null, [{
    key: "createSushiUrl",
    value: function createSushiUrl(region, sourceGroup) {
      if (!sourceGroup) {
        throw new Error("Sushi Driver was not provided with a source group.");
      }

      var domain;

      switch (region) {
        case SushiClient.REGIONS.NA:
          domain = "unagi-na";
          break;

        case SushiClient.REGIONS.EU:
          domain = "unagi-eu";
          break;

        case SushiClient.REGIONS.FE:
          domain = "unagi-fe";
          break;

        case SushiClient.REGIONS.CN:
          domain = "unagi-cn";
          break;

        default:
          throw new Error("Unrecognized region '".concat(region, "' provided to SushiClient."));
      }

      return "https://".concat(domain, ".amazon.com/1/events/").concat(sourceGroup);
    }
  }, {
    key: "createCsmUserContext",
    value: function createCsmUserContext(sushiUrl) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return _objectSpread({
        hiPriFlushInterval: 1000,
        lowPriFlushInterval: 10000,
        requestId: "1",
        errorChannel: "jserr",
        sessionStorageWrapper: undefined,
        errorHandlerFunction: console.log,
        sushiUrl: sushiUrl
      }, options);
    }
    /**
     * Create a Sushi Client for a region and source group
     *
     * @param region Region in SushiClient.REGIONS
     * @param sourceGroup Sushi Eel source group
     * @param errorHandler Error handler function
     * @param options Additional CSM context overrides
     * @param clientOverride An optional transportation client for overriding the default clients (navigator.sendBeacon and XDomainRequest or XMLHttpRequest)
     */

  }, {
    key: "REGIONS",
    get: function get() {
      return {
        NA: "NA",
        EU: "EU",
        FE: "FE",
        CN: "CN"
      };
    }
  }]);

  function SushiClient() {
    var region = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SushiClient.REGIONS.NA;
    var sourceGroup = arguments.length > 1 ? arguments[1] : undefined;
    var errorHandler = arguments.length > 2 ? arguments[2] : undefined;
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var clientOverride = arguments.length > 4 ? arguments[4] : undefined;
    (0, _classCallCheck2.default)(this, SushiClient);
    var sushiUrl = SushiClient.createSushiUrl(region, sourceGroup);
    var csmUserContext = SushiClient.createCsmUserContext(sushiUrl, options);
    this.ue_csm = this.setupMockCSMObject(csmUserContext);
    this.encapsulatedWindow = this.setupMockWindow(this.ue_csm);
    this.transportationClientCode(this.ue_csm, window);

    if (clientOverride) {
      this.ue_csm.ue._sBcn = {
        isSupported: true,
        send: function send(endpoint, payload) {
          clientOverride(endpoint, payload);
          return true;
        }
      };
    }

    this.clientCode(this.ue_csm, this.encapsulatedWindow);
    this.errorHandler = errorHandler;
  }

  (0, _createClass2.default)(SushiClient, [{
    key: "event",
    value: function event(data, producerId, schemaId, options) {
      var debug = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

      if (debug) {
        console.log("SushiClient wrapper publishing the following:", {
          data: data,
          producerId: producerId,
          schemaId: schemaId,
          options: options
        });
      }

      return this.ue_csm.ue.event(data, producerId, schemaId, options);
    }
    /**
     * If you plan to emit 1000 or more events per instantiated client,
     * call reset after calling event to allow the CSM client to continue sending events.
     */

  }, {
    key: "reset",
    value: function reset() {
      this.ue_csm.ue.event.reset();
    }
    /**
     * Register a callback that will be called just before each time metrics are
     * flushed to the network.
     * @param callback A function that sushi will call before flushes.
     */

  }, {
    key: "onSushiFlush",
    value: function onSushiFlush(callback) {
      this.ue_csm.ue.onSushiFlush(callback);
    }
    /**
     * Register a callback that will be called just before the page unloads.
     * This can be used to send any final metrics to sushi, such as page visit
     * duration or batched counters.
     * @param callback A function that sushi will call before unload.
     */

  }, {
    key: "onSushiUnload",
    value: function onSushiUnload(callback) {
      this.ue_csm.ue.onSushiUnload(callback);
    }
  }, {
    key: "setupMockCSMObject",
    value: function setupMockCSMObject(csmUserContext) {
      var _this = this;

      var execStub = function execStub(callback, attribution) {
        return callback;
      };

      var eventStub = function eventStub(log, producer, eventType) {
        console.warn("SushiClient CSM stub called in unsupported manner: event()");
      };

      var errorHandler = function errorHandler(logEvent, channel) {
        if (_this.errorHandler) {
          _this.errorHandler(logEvent);
        } else {
          console.log("An error has occurred in SushiClient channel " + channel, logEvent);
        }
      };

      var attachHandler = function attachHandler(evt, handler, container) {
        //TODO might be able to just use window.ue.attach?
        container = container || window; //ok to use real window global here.

        if (window.EventTarget && window.EventTarget.prototype && window.EventTarget.prototype.addEventListener) {
          window.EventTarget.prototype.addEventListener.call(container, evt, handler, !!window.ue_clf);
        } else if (container.addEventListener) {
          container.addEventListener(evt, handler, !!window.ue_clf);
        } else if (container.attachEvent) {
          container.attachEvent("on" + evt, handler);
        }
      };

      return {
        ue_hpsi: csmUserContext.hiPriFlushInterval,
        ue_lpsi: csmUserContext.lowPriFlushInterval,
        ue: {
          ssw: csmUserContext.sessionStorageWrapper,
          log: errorHandler,
          exec: execStub,
          event: eventStub,
          attach: attachHandler
        },
        ueLogError: csmUserContext.errorHandlerFunction,
        ue_surl: csmUserContext.sushiUrl,
        ue_id: csmUserContext.requestId,
        ue_err_chan: csmUserContext.errorChannel
      };
    }
  }, {
    key: "setupMockWindow",
    value: function setupMockWindow(ue_csm) {
      //apparently cannot ref the setTimeout function directly in some browsers so we have to wrap it.
      var timeoutWrapper = function timeoutWrapper(fn, timeout) {
        return window.setTimeout(fn, timeout);
      };

      return {
        ue_csm: ue_csm,
        ueLogError: ue_csm.ueLogError,
        ue: ue_csm.ue,
        setTimeout: timeoutWrapper
      };
    }
    /**
     * Code within function pulled directly from
     * https://code.amazon.com/packages/SushiJavaScriptClient/blobs/mainline/--/javascript/sushi-client.js
     */

  }, {
    key: "clientCode",
    value: function clientCode(ue_csm, window) {
      ue_csm.ue.exec(function (b, k) {
        function A() {
          for (var a = 0; a < arguments.length; a++) {
            var c = arguments[a];

            try {
              var h;

              if (c.isSupported) {
                var b = t.buildPayload(l, e);
                h = c.send(J, b);
              } else throw dummyException;

              return h;
            } catch (d) {}
          }

          B({
            m: "All supported clients failed",
            attribution: "CSMSushiClient_TRANSPORTATION_FAIL",
            f: "sushi-client.js",
            logLevel: "ERROR"
          }, k.ue_err_chan || "jserr");
        }

        function m() {
          if (e.length) {
            for (var a = 0; a < n.length; a++) {
              n[a]();
            }

            A(d._sBcn || {}, d._ajx || {});
            e = [];
            f = {};
            l = {};
            u = v = q = w = 0;
          }
        }

        function K() {
          var a = new Date(),
              c = function c(a) {
            return 10 > a ? "0" + a : a;
          };

          return Date.prototype.toISOString ? a.toISOString() : a.getUTCFullYear() + "-" + c(a.getUTCMonth() + 1) + "-" + c(a.getUTCDate()) + "T" + c(a.getUTCHours()) + ":" + c(a.getUTCMinutes()) + ":" + c(a.getUTCSeconds()) + "." + String((a.getUTCMilliseconds() / 1E3).toFixed(3)).slice(2, 5) + "Z";
        }

        function x(a) {
          try {
            return JSON.stringify(a);
          } catch (c) {}

          return null;
        }

        function C(a, c, h, g) {
          var p = !1;
          g = g || {};
          r++;
          r == D && B({
            m: "Max number of Sushi Logs exceeded",
            f: "sushi-client.js",
            logLevel: "ERROR",
            attribution: "CSMSushiClient_MAX_CALLS"
          }, k.ue_err_chan || "jserr");
          var f;
          if (f = !(r >= D)) (f = a && -1 < a.constructor.toString().indexOf("Object") && c && -1 < c.constructor.toString().indexOf("String") && h && -1 < h.constructor.toString().indexOf("String")) || L++;
          f && (d.count && d.count("Event:" + h, 1), a.producerId = a.producerId || c, a.schemaId = a.schemaId || h, a.timestamp = K(), c = Date.now ? Date.now() : +new Date(), h = Math.random().toString().substring(2, 12), a.messageId = b.ue_id + "-" + c + "-" + h, g && !g.ssd && (a.sessionId = a.sessionId || b.ue_sid, a.requestId = a.requestId || b.ue_id, a.obfuscatedMarketplaceId = a.obfuscatedMarketplaceId || b.ue_mid), (c = x(a)) ? (c = c.length, (e.length == M || q + c > N) && m(), q += c, a = {
            data: t.compressEvent(a)
          }, e.push(a), (g || {}).n ? 0 === E ? m() : u || (u = k.setTimeout(m, E)) : v || (v = k.setTimeout(m, O)), p = !0) : p = !1);
          !p && b.ue_int && console.error("Invalid JS Nexus API call");
          return p;
        }

        function F() {
          if (!G) {
            for (var a = 0; a < y.length; a++) {
              y[a]();
            }

            for (a = 0; a < n.length; a++) {
              n[a]();
            }

            e.length && (b.ue_sbuimp && b.ue && b.ue.ssw && (a = x({
              dct: l,
              evt: e
            }), b.ue.ssw("eeldata", a), b.ue.ssw("eelsts", "unk")), A(d._sBcn || {}));
            G = !0;
          }
        }

        function H(a) {
          y.push(a);
        }

        function I(a) {
          n.push(a);
        }

        var D = 1E3,
            M = 499,
            N = 524288,
            s = function s() {},
            d = b.ue || {},
            B = d.log || s,
            P = b.uex || s;

        (b.uet || s)("bb", "ue_sushi_v1", {
          wb: 1
        });

        var J = b.ue_surl || "https://unagi-na.amazon.com/1/events/com.amazon.csm.nexusclient.gamma",
            Q = ["messageId", "timestamp"],
            z = "#",
            e = [],
            f = {},
            l = {},
            q = 0,
            w = 0,
            L = 0,
            r = 0,
            y = [],
            n = [],
            G = !1,
            u,
            v,
            E = void 0 === b.ue_hpsi ? 1E3 : b.ue_hpsi,
            O = void 0 === b.ue_lpsi ? 1E4 : b.ue_lpsi,
            t = function () {
          function a(a) {
            f[a] = z + w++;
            l[f[a]] = a;
            return f[a];
          }

          function c(b) {
            if (!(b instanceof Function)) {
              if (b instanceof Array) {
                for (var g = [], d = b.length, e = 0; e < d; e++) {
                  g[e] = c(b[e]);
                }

                return g;
              }

              if (b instanceof Object) {
                g = {};

                for (d in b) {
                  b.hasOwnProperty(d) && (g[f[d] ? f[d] : a(d)] = -1 === Q.indexOf(d) ? c(b[d]) : b[d]);
                }

                return g;
              }

              return "string" === typeof b && (b.length > (z + w).length || b.charAt(0) === z) ? f[b] ? f[b] : a(b) : b;
            }
          }

          return {
            compressEvent: c,
            buildPayload: function buildPayload() {
              return x({
                cs: {
                  dct: l
                },
                events: e
              });
            }
          };
        }();

        (function () {
          if (d.event && d.event.isStub) {
            if (b.ue_sbuimp && b.ue && b.ue.ssw) {
              var a = b.ue.ssw("eelsts").val;

              if (a && "unk" === a && (a = b.ue.ssw("eeldata").val)) {
                var c;

                a: {
                  try {
                    c = JSON.parse(a);
                    break a;
                  } catch (f) {}

                  c = null;
                }

                c && c.evt instanceof Array && c.dct instanceof Object && (e = c.evt, l = c.dct, e && l && (m(), b.ue.ssw("eeldata", "{}"), b.ue.ssw("eelsts", "scs")));
              }
            }

            d.event.replay(function (a) {
              a[3] = a[3] || {};
              a[3].n = 1;
              C.apply(this, a);
            });
            d.onSushiUnload.replay(function (a) {
              H(a[0]);
            });
            d.onSushiFlush.replay(function (a) {
              I(a[0]);
            });
          }
        })();

        d.attach("beforeunload", F);
        d.attach("pagehide", F);
        d._cmps = t;
        d.event = C;

        d.event.reset = function () {
          r = 0;
        };

        d.onSushiUnload = H;
        d.onSushiFlush = I;

        try {
          k.P && k.P.register && k.P.register("sushi-client", s);
        } catch (R) {
          b.ueLogError(R, {
            logLevel: "WARN"
          });
        }

        P("ld", "ue_sushi_v1", {
          wb: 1
        });
      }, "Nxs-JS-Client")(ue_csm, window);
    }
    /**
     * The code in this function is pulled directly from:
     * https://code.amazon.com/packages/SushiJavaScriptClient/blobs/mainline/--/javascript/transportation-clients.js
     */

  }, {
    key: "transportationClientCode",
    value: function transportationClientCode(ue_csm, window) {
      ue_csm.ue.exec(function (b, c) {
        var e = function e() {},
            f = function () {
          return {
            send: function send(b, d) {
              if (d && b) {
                var a;
                if (c.XDomainRequest) a = new XDomainRequest(), a.onerror = e, a.ontimeout = e, a.onprogress = e, a.onload = e, a.timeout = 0;else if (c.XMLHttpRequest) {
                  if (a = new XMLHttpRequest(), !("withCredentials" in a)) throw "";
                } else a = void 0;
                if (!a) throw "";
                a.open("POST", b, !0);
                a.setRequestHeader && a.setRequestHeader("Content-type", "text/plain");
                a.send(d);
              }
            },
            isSupported: !0
          };
        }(),
            g = function () {
          return {
            send: function send(c, d) {
              if (c && d) if (navigator.sendBeacon(c, d)) b.ue_sbuimp && b.ue && b.ue.ssw && b.ue.ssw("eelsts", "scs");else throw "";
            },
            isSupported: !!navigator.sendBeacon && !(c.cordova && c.cordova.platformId && "ios" == c.cordova.platformId)
          };
        }();

        b.ue._ajx = f;
        b.ue._sBcn = g;
      }, "Transportation-clients")(ue_csm, window);
    }
  }]);
  return SushiClient;
}();

exports.default = SushiClient;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray.js */ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js");
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}
module.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/assertThisInitialized.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/createClass.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toPropertyKey = __webpack_require__(/*! ./toPropertyKey.js */ "./node_modules/@babel/runtime/helpers/toPropertyKey.js");
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/defineProperty.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toPropertyKey = __webpack_require__(/*! ./toPropertyKey.js */ "./node_modules/@babel/runtime/helpers/toPropertyKey.js");
function _defineProperty(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/get.js":
/*!****************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/get.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var superPropBase = __webpack_require__(/*! ./superPropBase.js */ "./node_modules/@babel/runtime/helpers/superPropBase.js");
function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    module.exports = _get = Reflect.get.bind(), module.exports.__esModule = true, module.exports["default"] = module.exports;
  } else {
    module.exports = _get = function _get(target, property, receiver) {
      var base = superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
  return _get.apply(this, arguments);
}
module.exports = _get, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/getPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  return _getPrototypeOf(o);
}
module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/inherits.js":
/*!*********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/inherits.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf.js */ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js");
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}
module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArray.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArray.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
module.exports = _iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableSpread.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableSpread.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
module.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! ./typeof.js */ "./node_modules/@babel/runtime/helpers/typeof.js")["default"];
var assertThisInitialized = __webpack_require__(/*! ./assertThisInitialized.js */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js");
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return assertThisInitialized(self);
}
module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/set.js":
/*!****************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/set.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var superPropBase = __webpack_require__(/*! ./superPropBase.js */ "./node_modules/@babel/runtime/helpers/superPropBase.js");
var defineProperty = __webpack_require__(/*! ./defineProperty.js */ "./node_modules/@babel/runtime/helpers/defineProperty.js");
function set(target, property, value, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.set) {
    set = Reflect.set;
  } else {
    set = function set(target, property, value, receiver) {
      var base = superPropBase(target, property);
      var desc;
      if (base) {
        desc = Object.getOwnPropertyDescriptor(base, property);
        if (desc.set) {
          desc.set.call(receiver, value);
          return true;
        } else if (!desc.writable) {
          return false;
        }
      }
      desc = Object.getOwnPropertyDescriptor(receiver, property);
      if (desc) {
        if (!desc.writable) {
          return false;
        }
        desc.value = value;
        Object.defineProperty(receiver, property, desc);
      } else {
        defineProperty(receiver, property, value);
      }
      return true;
    };
  }
  return set(target, property, value, receiver);
}
function _set(target, property, value, receiver, isStrict) {
  var s = set(target, property, value, receiver || target);
  if (!s && isStrict) {
    throw new TypeError('failed to set property');
  }
  return value;
}
module.exports = _set, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  return _setPrototypeOf(o, p);
}
module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/superPropBase.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/superPropBase.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getPrototypeOf = __webpack_require__(/*! ./getPrototypeOf.js */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = getPrototypeOf(object);
    if (object === null) break;
  }
  return object;
}
module.exports = _superPropBase, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toConsumableArray.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toConsumableArray.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(/*! ./arrayWithoutHoles.js */ "./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js");
var iterableToArray = __webpack_require__(/*! ./iterableToArray.js */ "./node_modules/@babel/runtime/helpers/iterableToArray.js");
var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray.js */ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");
var nonIterableSpread = __webpack_require__(/*! ./nonIterableSpread.js */ "./node_modules/@babel/runtime/helpers/nonIterableSpread.js");
function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}
module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toPrimitive.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toPrimitive.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! ./typeof.js */ "./node_modules/@babel/runtime/helpers/typeof.js")["default"];
function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
module.exports = toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toPropertyKey.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toPropertyKey.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! ./typeof.js */ "./node_modules/@babel/runtime/helpers/typeof.js")["default"];
var toPrimitive = __webpack_require__(/*! ./toPrimitive.js */ "./node_modules/@babel/runtime/helpers/toPrimitive.js");
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : String(i);
}
module.exports = toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(o) {
  "@babel/helpers - typeof";

  return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(o);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray.js */ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js");
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}
module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/build-url-ts/dist/build-url.js":
/*!*****************************************************!*\
  !*** ./node_modules/build-url-ts/dist/build-url.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
function buildQueryString(r,n,a){var o=[];for(var t in r)!function(t){var e;Object.prototype.hasOwnProperty.call(r,t)&&void 0!==r[t]&&(a&&Array.isArray(r[t])&&r[t].length?r[t].forEach(function(r){e=0!==r?r||"":0,o.push("".concat(t,"=").concat(encodeURIComponent(String(e).trim())))}):(e=n?String(r[t]).toLowerCase()||"":0!==r[t]?r[t]||"":0,o.push("".concat(t,"=").concat(encodeURIComponent(String(e).trim())))))}(t);return"?".concat(o.join("&"))}function appendPath(r,t,e){void 0===t&&(t=""),"/"===t[t.length-1]&&(t=t.slice(0,-1));var n=String(r).trim();return e&&(n=n.toLowerCase()),0===n.indexOf("/")?t+=n:t+="/".concat(n),t}function buildHash(r,t){var e="#".concat(String(r).trim());return t?e.toLowerCase():e}function buildUrl(r,t){var e;return null===r?e="":"object"==typeof r?(e="",t=r):e=r,null!=t&&t.path&&(e=appendPath(t.path,e,t.lowerCase)),null!=t&&t.queryParams&&(e+=buildQueryString(t.queryParams,t.lowerCase,t.disableCSV)),null!=t&&t.hash&&(e+=buildHash(t.hash,t.lowerCase)),e}Object.defineProperty(exports,"__esModule",{value:!0}),exports.appendPath=appendPath,exports.buildHash=buildHash,exports.buildQueryString=buildQueryString,exports.buildUrl=buildUrl,exports.default=buildUrl;
//# sourceMappingURL=build-url.js.map


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/iframe.css":
/*!******************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/iframe.css ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, "#aa-challenge-whole-page-iframe {\n    overflow:hidden;\n    opacity:1.0;\n    position:fixed;\n    top:0px;\n    bottom:0px;\n    right:0px;\n    border:none;\n    margin:0;\n    padding:0;\n    height:100%;\n    width:100%;\n    z-index:999999;\n}", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js":
/*!*************************************************************************!*\
  !*** ./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/**
 * A collection of shims that provide minimal functionality of the ES6 collections.
 *
 * These implementations are not meant to be used outside of the ResizeObserver
 * modules as they cover only a limited range of use cases.
 */
/* eslint-disable require-jsdoc, valid-jsdoc */
var MapShim = (function () {
    if (typeof Map !== 'undefined') {
        return Map;
    }
    /**
     * Returns index in provided array that matches the specified key.
     *
     * @param {Array<Array>} arr
     * @param {*} key
     * @returns {number}
     */
    function getIndex(arr, key) {
        var result = -1;
        arr.some(function (entry, index) {
            if (entry[0] === key) {
                result = index;
                return true;
            }
            return false;
        });
        return result;
    }
    return /** @class */ (function () {
        function class_1() {
            this.__entries__ = [];
        }
        Object.defineProperty(class_1.prototype, "size", {
            /**
             * @returns {boolean}
             */
            get: function () {
                return this.__entries__.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {*} key
         * @returns {*}
         */
        class_1.prototype.get = function (key) {
            var index = getIndex(this.__entries__, key);
            var entry = this.__entries__[index];
            return entry && entry[1];
        };
        /**
         * @param {*} key
         * @param {*} value
         * @returns {void}
         */
        class_1.prototype.set = function (key, value) {
            var index = getIndex(this.__entries__, key);
            if (~index) {
                this.__entries__[index][1] = value;
            }
            else {
                this.__entries__.push([key, value]);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.delete = function (key) {
            var entries = this.__entries__;
            var index = getIndex(entries, key);
            if (~index) {
                entries.splice(index, 1);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.has = function (key) {
            return !!~getIndex(this.__entries__, key);
        };
        /**
         * @returns {void}
         */
        class_1.prototype.clear = function () {
            this.__entries__.splice(0);
        };
        /**
         * @param {Function} callback
         * @param {*} [ctx=null]
         * @returns {void}
         */
        class_1.prototype.forEach = function (callback, ctx) {
            if (ctx === void 0) { ctx = null; }
            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                var entry = _a[_i];
                callback.call(ctx, entry[1], entry[0]);
            }
        };
        return class_1;
    }());
})();

/**
 * Detects whether window and document objects are available in current environment.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

// Returns global object of a current environment.
var global$1 = (function () {
    if (typeof global !== 'undefined' && global.Math === Math) {
        return global;
    }
    if (typeof self !== 'undefined' && self.Math === Math) {
        return self;
    }
    if (typeof window !== 'undefined' && window.Math === Math) {
        return window;
    }
    // eslint-disable-next-line no-new-func
    return Function('return this')();
})();

/**
 * A shim for the requestAnimationFrame which falls back to the setTimeout if
 * first one is not supported.
 *
 * @returns {number} Requests' identifier.
 */
var requestAnimationFrame$1 = (function () {
    if (typeof requestAnimationFrame === 'function') {
        // It's required to use a bounded function because IE sometimes throws
        // an "Invalid calling object" error if rAF is invoked without the global
        // object on the left hand side.
        return requestAnimationFrame.bind(global$1);
    }
    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
})();

// Defines minimum timeout before adding a trailing call.
var trailingTimeout = 2;
/**
 * Creates a wrapper function which ensures that provided callback will be
 * invoked only once during the specified delay period.
 *
 * @param {Function} callback - Function to be invoked after the delay period.
 * @param {number} delay - Delay after which to invoke callback.
 * @returns {Function}
 */
function throttle (callback, delay) {
    var leadingCall = false, trailingCall = false, lastCallTime = 0;
    /**
     * Invokes the original callback function and schedules new invocation if
     * the "proxy" was called during current request.
     *
     * @returns {void}
     */
    function resolvePending() {
        if (leadingCall) {
            leadingCall = false;
            callback();
        }
        if (trailingCall) {
            proxy();
        }
    }
    /**
     * Callback invoked after the specified delay. It will further postpone
     * invocation of the original function delegating it to the
     * requestAnimationFrame.
     *
     * @returns {void}
     */
    function timeoutCallback() {
        requestAnimationFrame$1(resolvePending);
    }
    /**
     * Schedules invocation of the original function.
     *
     * @returns {void}
     */
    function proxy() {
        var timeStamp = Date.now();
        if (leadingCall) {
            // Reject immediately following calls.
            if (timeStamp - lastCallTime < trailingTimeout) {
                return;
            }
            // Schedule new call to be in invoked when the pending one is resolved.
            // This is important for "transitions" which never actually start
            // immediately so there is a chance that we might miss one if change
            // happens amids the pending invocation.
            trailingCall = true;
        }
        else {
            leadingCall = true;
            trailingCall = false;
            setTimeout(timeoutCallback, delay);
        }
        lastCallTime = timeStamp;
    }
    return proxy;
}

// Minimum delay before invoking the update of observers.
var REFRESH_DELAY = 20;
// A list of substrings of CSS properties used to find transition events that
// might affect dimensions of observed elements.
var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
// Check if MutationObserver is available.
var mutationObserverSupported = typeof MutationObserver !== 'undefined';
/**
 * Singleton controller class which handles updates of ResizeObserver instances.
 */
var ResizeObserverController = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserverController.
     *
     * @private
     */
    function ResizeObserverController() {
        /**
         * Indicates whether DOM listeners have been added.
         *
         * @private {boolean}
         */
        this.connected_ = false;
        /**
         * Tells that controller has subscribed for Mutation Events.
         *
         * @private {boolean}
         */
        this.mutationEventsAdded_ = false;
        /**
         * Keeps reference to the instance of MutationObserver.
         *
         * @private {MutationObserver}
         */
        this.mutationsObserver_ = null;
        /**
         * A list of connected observers.
         *
         * @private {Array<ResizeObserverSPI>}
         */
        this.observers_ = [];
        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    /**
     * Adds observer to observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be added.
     * @returns {void}
     */
    ResizeObserverController.prototype.addObserver = function (observer) {
        if (!~this.observers_.indexOf(observer)) {
            this.observers_.push(observer);
        }
        // Add listeners if they haven't been added yet.
        if (!this.connected_) {
            this.connect_();
        }
    };
    /**
     * Removes observer from observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be removed.
     * @returns {void}
     */
    ResizeObserverController.prototype.removeObserver = function (observer) {
        var observers = this.observers_;
        var index = observers.indexOf(observer);
        // Remove observer if it's present in registry.
        if (~index) {
            observers.splice(index, 1);
        }
        // Remove listeners if controller has no connected observers.
        if (!observers.length && this.connected_) {
            this.disconnect_();
        }
    };
    /**
     * Invokes the update of observers. It will continue running updates insofar
     * it detects changes.
     *
     * @returns {void}
     */
    ResizeObserverController.prototype.refresh = function () {
        var changesDetected = this.updateObservers_();
        // Continue running updates if changes have been detected as there might
        // be future ones caused by CSS transitions.
        if (changesDetected) {
            this.refresh();
        }
    };
    /**
     * Updates every observer from observers list and notifies them of queued
     * entries.
     *
     * @private
     * @returns {boolean} Returns "true" if any observer has detected changes in
     *      dimensions of it's elements.
     */
    ResizeObserverController.prototype.updateObservers_ = function () {
        // Collect observers that have active observations.
        var activeObservers = this.observers_.filter(function (observer) {
            return observer.gatherActive(), observer.hasActive();
        });
        // Deliver notifications in a separate cycle in order to avoid any
        // collisions between observers, e.g. when multiple instances of
        // ResizeObserver are tracking the same element and the callback of one
        // of them changes content dimensions of the observed target. Sometimes
        // this may result in notifications being blocked for the rest of observers.
        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });
        return activeObservers.length > 0;
    };
    /**
     * Initializes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.connect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already added.
        if (!isBrowser || this.connected_) {
            return;
        }
        // Subscription to the "Transitionend" event is used as a workaround for
        // delayed transitions. This way it's possible to capture at least the
        // final state of an element.
        document.addEventListener('transitionend', this.onTransitionEnd_);
        window.addEventListener('resize', this.refresh);
        if (mutationObserverSupported) {
            this.mutationsObserver_ = new MutationObserver(this.refresh);
            this.mutationsObserver_.observe(document, {
                attributes: true,
                childList: true,
                characterData: true,
                subtree: true
            });
        }
        else {
            document.addEventListener('DOMSubtreeModified', this.refresh);
            this.mutationEventsAdded_ = true;
        }
        this.connected_ = true;
    };
    /**
     * Removes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.disconnect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already removed.
        if (!isBrowser || !this.connected_) {
            return;
        }
        document.removeEventListener('transitionend', this.onTransitionEnd_);
        window.removeEventListener('resize', this.refresh);
        if (this.mutationsObserver_) {
            this.mutationsObserver_.disconnect();
        }
        if (this.mutationEventsAdded_) {
            document.removeEventListener('DOMSubtreeModified', this.refresh);
        }
        this.mutationsObserver_ = null;
        this.mutationEventsAdded_ = false;
        this.connected_ = false;
    };
    /**
     * "Transitionend" event handler.
     *
     * @private
     * @param {TransitionEvent} event
     * @returns {void}
     */
    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;
        // Detect whether transition may affect dimensions of an element.
        var isReflowProperty = transitionKeys.some(function (key) {
            return !!~propertyName.indexOf(key);
        });
        if (isReflowProperty) {
            this.refresh();
        }
    };
    /**
     * Returns instance of the ResizeObserverController.
     *
     * @returns {ResizeObserverController}
     */
    ResizeObserverController.getInstance = function () {
        if (!this.instance_) {
            this.instance_ = new ResizeObserverController();
        }
        return this.instance_;
    };
    /**
     * Holds reference to the controller's instance.
     *
     * @private {ResizeObserverController}
     */
    ResizeObserverController.instance_ = null;
    return ResizeObserverController;
}());

/**
 * Defines non-writable/enumerable properties of the provided target object.
 *
 * @param {Object} target - Object for which to define properties.
 * @param {Object} props - Properties to be defined.
 * @returns {Object} Target object.
 */
var defineConfigurable = (function (target, props) {
    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
        var key = _a[_i];
        Object.defineProperty(target, key, {
            value: props[key],
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    return target;
});

/**
 * Returns the global object associated with provided element.
 *
 * @param {Object} target
 * @returns {Object}
 */
var getWindowOf = (function (target) {
    // Assume that the element is an instance of Node, which means that it
    // has the "ownerDocument" property from which we can retrieve a
    // corresponding global object.
    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
    // Return the local global object if it's not possible extract one from
    // provided element.
    return ownerGlobal || global$1;
});

// Placeholder of an empty content rectangle.
var emptyRect = createRectInit(0, 0, 0, 0);
/**
 * Converts provided string to a number.
 *
 * @param {number|string} value
 * @returns {number}
 */
function toFloat(value) {
    return parseFloat(value) || 0;
}
/**
 * Extracts borders size from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @param {...string} positions - Borders positions (top, right, ...)
 * @returns {number}
 */
function getBordersSize(styles) {
    var positions = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        positions[_i - 1] = arguments[_i];
    }
    return positions.reduce(function (size, position) {
        var value = styles['border-' + position + '-width'];
        return size + toFloat(value);
    }, 0);
}
/**
 * Extracts paddings sizes from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @returns {Object} Paddings box.
 */
function getPaddings(styles) {
    var positions = ['top', 'right', 'bottom', 'left'];
    var paddings = {};
    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
        var position = positions_1[_i];
        var value = styles['padding-' + position];
        paddings[position] = toFloat(value);
    }
    return paddings;
}
/**
 * Calculates content rectangle of provided SVG element.
 *
 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
 *      to be calculated.
 * @returns {DOMRectInit}
 */
function getSVGContentRect(target) {
    var bbox = target.getBBox();
    return createRectInit(0, 0, bbox.width, bbox.height);
}
/**
 * Calculates content rectangle of provided HTMLElement.
 *
 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
 * @returns {DOMRectInit}
 */
function getHTMLElementContentRect(target) {
    // Client width & height properties can't be
    // used exclusively as they provide rounded values.
    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
    // By this condition we can catch all non-replaced inline, hidden and
    // detached elements. Though elements with width & height properties less
    // than 0.5 will be discarded as well.
    //
    // Without it we would need to implement separate methods for each of
    // those cases and it's not possible to perform a precise and performance
    // effective test for hidden elements. E.g. even jQuery's ':visible' filter
    // gives wrong results for elements with width & height less than 0.5.
    if (!clientWidth && !clientHeight) {
        return emptyRect;
    }
    var styles = getWindowOf(target).getComputedStyle(target);
    var paddings = getPaddings(styles);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom;
    // Computed styles of width & height are being used because they are the
    // only dimensions available to JS that contain non-rounded values. It could
    // be possible to utilize the getBoundingClientRect if only it's data wasn't
    // affected by CSS transformations let alone paddings, borders and scroll bars.
    var width = toFloat(styles.width), height = toFloat(styles.height);
    // Width & height include paddings and borders when the 'border-box' box
    // model is applied (except for IE).
    if (styles.boxSizing === 'border-box') {
        // Following conditions are required to handle Internet Explorer which
        // doesn't include paddings and borders to computed CSS dimensions.
        //
        // We can say that if CSS dimensions + paddings are equal to the "client"
        // properties then it's either IE, and thus we don't need to subtract
        // anything, or an element merely doesn't have paddings/borders styles.
        if (Math.round(width + horizPad) !== clientWidth) {
            width -= getBordersSize(styles, 'left', 'right') + horizPad;
        }
        if (Math.round(height + vertPad) !== clientHeight) {
            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
        }
    }
    // Following steps can't be applied to the document's root element as its
    // client[Width/Height] properties represent viewport area of the window.
    // Besides, it's as well not necessary as the <html> itself neither has
    // rendered scroll bars nor it can be clipped.
    if (!isDocumentElement(target)) {
        // In some browsers (only in Firefox, actually) CSS width & height
        // include scroll bars size which can be removed at this step as scroll
        // bars are the only difference between rounded dimensions + paddings
        // and "client" properties, though that is not always true in Chrome.
        var vertScrollbar = Math.round(width + horizPad) - clientWidth;
        var horizScrollbar = Math.round(height + vertPad) - clientHeight;
        // Chrome has a rather weird rounding of "client" properties.
        // E.g. for an element with content width of 314.2px it sometimes gives
        // the client width of 315px and for the width of 314.7px it may give
        // 314px. And it doesn't happen all the time. So just ignore this delta
        // as a non-relevant.
        if (Math.abs(vertScrollbar) !== 1) {
            width -= vertScrollbar;
        }
        if (Math.abs(horizScrollbar) !== 1) {
            height -= horizScrollbar;
        }
    }
    return createRectInit(paddings.left, paddings.top, width, height);
}
/**
 * Checks whether provided element is an instance of the SVGGraphicsElement.
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
var isSVGGraphicsElement = (function () {
    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
    // interface.
    if (typeof SVGGraphicsElement !== 'undefined') {
        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
    }
    // If it's so, then check that element is at least an instance of the
    // SVGElement and that it has the "getBBox" method.
    // eslint-disable-next-line no-extra-parens
    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&
        typeof target.getBBox === 'function'); };
})();
/**
 * Checks whether provided element is a document element (<html>).
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
function isDocumentElement(target) {
    return target === getWindowOf(target).document.documentElement;
}
/**
 * Calculates an appropriate content rectangle for provided html or svg element.
 *
 * @param {Element} target - Element content rectangle of which needs to be calculated.
 * @returns {DOMRectInit}
 */
function getContentRect(target) {
    if (!isBrowser) {
        return emptyRect;
    }
    if (isSVGGraphicsElement(target)) {
        return getSVGContentRect(target);
    }
    return getHTMLElementContentRect(target);
}
/**
 * Creates rectangle with an interface of the DOMRectReadOnly.
 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
 *
 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
 * @returns {DOMRectReadOnly}
 */
function createReadOnlyRect(_a) {
    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
    // If DOMRectReadOnly is available use it as a prototype for the rectangle.
    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype);
    // Rectangle's properties are not writable and non-enumerable.
    defineConfigurable(rect, {
        x: x, y: y, width: width, height: height,
        top: y,
        right: x + width,
        bottom: height + y,
        left: x
    });
    return rect;
}
/**
 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
 *
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 * @param {number} width - Rectangle's width.
 * @param {number} height - Rectangle's height.
 * @returns {DOMRectInit}
 */
function createRectInit(x, y, width, height) {
    return { x: x, y: y, width: width, height: height };
}

/**
 * Class that is responsible for computations of the content rectangle of
 * provided DOM element and for keeping track of it's changes.
 */
var ResizeObservation = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObservation.
     *
     * @param {Element} target - Element to be observed.
     */
    function ResizeObservation(target) {
        /**
         * Broadcasted width of content rectangle.
         *
         * @type {number}
         */
        this.broadcastWidth = 0;
        /**
         * Broadcasted height of content rectangle.
         *
         * @type {number}
         */
        this.broadcastHeight = 0;
        /**
         * Reference to the last observed content rectangle.
         *
         * @private {DOMRectInit}
         */
        this.contentRect_ = createRectInit(0, 0, 0, 0);
        this.target = target;
    }
    /**
     * Updates content rectangle and tells whether it's width or height properties
     * have changed since the last broadcast.
     *
     * @returns {boolean}
     */
    ResizeObservation.prototype.isActive = function () {
        var rect = getContentRect(this.target);
        this.contentRect_ = rect;
        return (rect.width !== this.broadcastWidth ||
            rect.height !== this.broadcastHeight);
    };
    /**
     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
     * from the corresponding properties of the last observed content rectangle.
     *
     * @returns {DOMRectInit} Last observed content rectangle.
     */
    ResizeObservation.prototype.broadcastRect = function () {
        var rect = this.contentRect_;
        this.broadcastWidth = rect.width;
        this.broadcastHeight = rect.height;
        return rect;
    };
    return ResizeObservation;
}());

var ResizeObserverEntry = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObserverEntry.
     *
     * @param {Element} target - Element that is being observed.
     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
     */
    function ResizeObserverEntry(target, rectInit) {
        var contentRect = createReadOnlyRect(rectInit);
        // According to the specification following properties are not writable
        // and are also not enumerable in the native implementation.
        //
        // Property accessors are not being used as they'd require to define a
        // private WeakMap storage which may cause memory leaks in browsers that
        // don't support this type of collections.
        defineConfigurable(this, { target: target, contentRect: contentRect });
    }
    return ResizeObserverEntry;
}());

var ResizeObserverSPI = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback function that is invoked
     *      when one of the observed elements changes it's content dimensions.
     * @param {ResizeObserverController} controller - Controller instance which
     *      is responsible for the updates of observer.
     * @param {ResizeObserver} callbackCtx - Reference to the public
     *      ResizeObserver instance which will be passed to callback function.
     */
    function ResizeObserverSPI(callback, controller, callbackCtx) {
        /**
         * Collection of resize observations that have detected changes in dimensions
         * of elements.
         *
         * @private {Array<ResizeObservation>}
         */
        this.activeObservations_ = [];
        /**
         * Registry of the ResizeObservation instances.
         *
         * @private {Map<Element, ResizeObservation>}
         */
        this.observations_ = new MapShim();
        if (typeof callback !== 'function') {
            throw new TypeError('The callback provided as parameter 1 is not a function.');
        }
        this.callback_ = callback;
        this.controller_ = controller;
        this.callbackCtx_ = callbackCtx;
    }
    /**
     * Starts observing provided element.
     *
     * @param {Element} target - Element to be observed.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.observe = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is already being observed.
        if (observations.has(target)) {
            return;
        }
        observations.set(target, new ResizeObservation(target));
        this.controller_.addObserver(this);
        // Force the update of observations.
        this.controller_.refresh();
    };
    /**
     * Stops observing provided element.
     *
     * @param {Element} target - Element to stop observing.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.unobserve = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is not being observed.
        if (!observations.has(target)) {
            return;
        }
        observations.delete(target);
        if (!observations.size) {
            this.controller_.removeObserver(this);
        }
    };
    /**
     * Stops observing all elements.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.disconnect = function () {
        this.clearActive();
        this.observations_.clear();
        this.controller_.removeObserver(this);
    };
    /**
     * Collects observation instances the associated element of which has changed
     * it's content rectangle.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.gatherActive = function () {
        var _this = this;
        this.clearActive();
        this.observations_.forEach(function (observation) {
            if (observation.isActive()) {
                _this.activeObservations_.push(observation);
            }
        });
    };
    /**
     * Invokes initial callback function with a list of ResizeObserverEntry
     * instances collected from active resize observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.broadcastActive = function () {
        // Do nothing if observer doesn't have active observations.
        if (!this.hasActive()) {
            return;
        }
        var ctx = this.callbackCtx_;
        // Create ResizeObserverEntry instance for every active observation.
        var entries = this.activeObservations_.map(function (observation) {
            return new ResizeObserverEntry(observation.target, observation.broadcastRect());
        });
        this.callback_.call(ctx, entries, ctx);
        this.clearActive();
    };
    /**
     * Clears the collection of active observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.clearActive = function () {
        this.activeObservations_.splice(0);
    };
    /**
     * Tells whether observer has active observations.
     *
     * @returns {boolean}
     */
    ResizeObserverSPI.prototype.hasActive = function () {
        return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI;
}());

// Registry of internal observers. If WeakMap is not available use current shim
// for the Map collection as it has all required methods and because WeakMap
// can't be fully polyfilled anyway.
var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
/**
 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
 * exposing only those methods and properties that are defined in the spec.
 */
var ResizeObserver = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback that is invoked when
     *      dimensions of the observed elements change.
     */
    function ResizeObserver(callback) {
        if (!(this instanceof ResizeObserver)) {
            throw new TypeError('Cannot call a class as a function.');
        }
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        var controller = ResizeObserverController.getInstance();
        var observer = new ResizeObserverSPI(callback, controller, this);
        observers.set(this, observer);
    }
    return ResizeObserver;
}());
// Expose public methods of ResizeObserver.
[
    'observe',
    'unobserve',
    'disconnect'
].forEach(function (method) {
    ResizeObserver.prototype[method] = function () {
        var _a;
        return (_a = observers.get(this))[method].apply(_a, arguments);
    };
});

var index = (function () {
    // Export existing implementation if available.
    if (typeof global$1.ResizeObserver !== 'undefined') {
        return global$1.ResizeObserver;
    }
    return ResizeObserver;
})();

/* harmony default export */ __webpack_exports__["default"] = (index);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function insertStyleElement(options) {
  var style = document.createElement('style');
  var attributes = options.attributes || {};

  if (typeof attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : undefined;

    if (nonce) {
      attributes.nonce = nonce;
    }
  }

  Object.keys(attributes).forEach(function (key) {
    style.setAttribute(key, attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  } else {
    style.removeAttribute('media');
  }

  if (sourceMap && typeof btoa !== 'undefined') {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    if (Object.prototype.toString.call(newList) !== '[object Array]') {
      return;
    }

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/uuid/lib/bytesToUuid.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/bytesToUuid.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]]
  ]).join('');
}

module.exports = bytesToUuid;


/***/ }),

/***/ "./node_modules/uuid/lib/rng-browser.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/rng-browser.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}


/***/ }),

/***/ "./node_modules/uuid/v4.js":
/*!*********************************!*\
  !*** ./node_modules/uuid/v4.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(/*! ./lib/rng */ "./node_modules/uuid/lib/rng-browser.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "./node_modules/uuid/lib/bytesToUuid.js");

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/HostnameResolver.ts":
/*!*********************************!*\
  !*** ./src/HostnameResolver.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,'\x5f\x5f\x65\x73\x4d\x6f\x64\x75\x6c\x65',{value:true});var HostnameResolver=function(){var _ooQ0=['\x61\x74','\x65\x73\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x63\x61\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x66\x72\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x73\x61\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x65\x67\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x64\x75\x62\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x73\x67','\x69\x74','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x61\x74','\x65\x73\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d\x2e\x6d\x78','\x6a\x70\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d\x2e\x74\x72','\x73\x67','\x70\x6c\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x64\x75\x62\x2e\x78\x63\x6f\x72\x70\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x62\x72\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x65\x67','\x73\x61','\x65\x67','\x73\x67\x2d\x70\x72\x65\x70\x72\x6f\x64\x2e\x70\x64\x78\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x6d\x78\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x64\x65','\x6a\x70','\x73\x65','\x70\x6c','\x73\x65\x2e\x69\x6e\x74\x65\x67\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x70\x6c','\x65\x75','\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x64\x65','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x69\x74','\x61\x65\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x69\x6e\x74\x65\x67\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x69\x6e\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x69\x74\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x75\x6b\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x64\x65\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x73\x61','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x6e\x6c','\x66\x72','\x61\x65\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x64\x75\x62\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x65\x73','\x74\x72\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x64\x75\x62\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x73\x65','\x61\x65','\x6d\x78','\x73\x67\x2e\x69\x6e\x74\x65\x67\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x63\x61\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x66\x72','\x61\x75','\x6e\x6c\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x62\x72','\x69\x6e','\x74\x72','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x69\x6e','\x75\x6b\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x66\x72\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x6a\x70\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x69\x74\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x63\x61','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d\x2e\x62\x72','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x61','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x2e\x6a\x70','\x73\x65\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x64\x75\x62\x2e\x78\x63\x6f\x72\x70\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x62\x72\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x69\x6e\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x6e\x6c','\x64\x65\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x6d\x78\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x73\x61\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x61\x75\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x61\x65','\x65\x73','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d\x2e\x61\x75','\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x2e\x75\x6b','\x65\x67\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x69\x6e\x74\x65\x67\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x61\x75\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x74\x72\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x69\x6e\x74\x65\x67\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x6e\x6c\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x70\x6c\x2e\x69\x6e\x74\x65\x67\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x61\x74\x2d\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x75\x6b','\x75\x73','\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x61\x74\x2d\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d'];function HostnameResolver(){}HostnameResolver.getServiceHostnameByConfiguration=function(configuration){var _00Q=['\x77\x77\x77\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d',73,29357];if(configuration in HostnameResolver.DOMAIN_REALM_HOSTNAME){var _QOoQ00Q0=_00Q[1],_$zsZ2$zZ=_00Q[2];return HostnameResolver.DOMAIN_REALM_HOSTNAME[configuration];}else{return _00Q[0];}};HostnameResolver.getServiceHostnameByHostname=function(hostname){var _ss=['\x70\x72\x6f\x64','\x6d\x61\x73\x74\x65\x72',.044523906506509725,'\x74\x65\x73\x74','\x6e\x6f\x64\x65\x42'];var _SzSZSZZ$=_ss[2];if(HostnameResolver.isDevelopment(hostname)){var _0O0Qo0Qo=_ss[4];return this.getServiceHostByCountryCode(_ss[3],this.getCountryCodePrefix(hostname));}else if(HostnameResolver.isPreProd(hostname)){var _L1ll1iLI=function(_QOoQ0QOO,_z2S$zZ2s){var _llI=[.6902260528232169,4792,.3898077519635801,'\x65\x6e\x63\x72\x79\x70\x74\x42\x6c\x6f\x62','\x61\x6d\x61\x7a\x6f\x6e','\x65\x6e\x63\x72\x79\x70\x74\x42',16210];var _z$$SSZ2Z=_llI[3],_IL1LlIl1=_llI[0],_oQQo0Ooo=_llI[6];var _iili11Li=_llI[2],_QoQoQooO=_llI[5],_$2s$2S2s=_llI[1];return _llI[4];};return this.getServiceHostByCountryCode(_ss[1],this.getCountryCodePrefix(hostname));}else{var countryCode=HostnameResolver.getCountryCodeSuffix(hostname);return this.getServiceHostByCountryCode(_ss[0],countryCode);}};HostnameResolver.getServiceHostByCountryCode=function(domain,countryCode){var _szz=['\x2e','\x41\x6d\x61\x7a\x6f\x6e'];return this.getServiceHostnameByConfiguration(domain+_szz[0]+countryCode.toUpperCase()+_szz[1]);};HostnameResolver.isDevelopment=function(hostname){var _OO0=['\x69\x6e\x74\x65\x67\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x64\x65\x76\x65\x6c\x6f\x70\x6d\x65\x6e\x74\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x6c\x6f\x63\x61\x6c\x68\x6f\x73\x74','\x64\x65\x76\x2d\x64\x73\x6b'];return hostname.startsWith(_OO0[4])&&hostname.endsWith(_OO0[2])||hostname.startsWith(_OO0[3])||hostname.endsWith(_OO0[0])||hostname.endsWith(_OO0[1]);};HostnameResolver.isPreProd=function(hostname){var _l1l=['\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x70\x64\x78\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x64\x75\x62\x2e\x78\x63\x6f\x72\x70\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x70\x72\x65\x70\x72\x6f\x64\x2e\x70\x64\x78\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d','\x70\x72\x65\x2d\x70\x72\x6f\x64\x2e\x64\x75\x62\x2e\x61\x6d\x61\x7a\x6f\x6e\x2e\x63\x6f\x6d'];return hostname.endsWith(_l1l[3])||hostname.endsWith(_l1l[0])||hostname.endsWith(_l1l[4])||hostname.endsWith(_l1l[2])||hostname.endsWith(_l1l[1]);};HostnameResolver.getCountryCodePrefix=function(hostname){var _iiI=[0,'\x2e',46666,1,'\x65\x78\x65\x63\x75\x74\x65','\x75\x73','\x2d'];var splits=hostname.split(_iiI[6]);if(splits.length>_iiI[3]){var prefix_1=splits[_iiI[0]];if(this.COUNTRY_CODES.some(function(e){var _z$z=[];var _$2$zSssS=function(_ii1ILILl){var _Zs2=[.8842751898413561,'\x75\x73\x65\x72\x61\x67\x65\x6e\x74\x55\x73\x65\x72\x61\x67\x65\x6e\x74\x4a\x73\x6f\x6e','\x62\x6c\x6f\x62\x43\x6f\x6c\x6c\x65\x63\x74\x6f\x72\x48\x61\x73\x68'];var _0o00o0QO=_Zs2[1],_sSZzZZ$2=_Zs2[2];return _Zs2[0];};return e===prefix_1;})){return prefix_1;}}var _0O0QQ0QO=_iiI[4],_00oQ0QOQ=_iiI[2];splits=hostname.split(_iiI[1]);if(splits.length>_iiI[3]){var _LILI1liL=function(_0oQ0OQO0,_Q00oQO0Q){var _Sz=[24099,19047,2699,.31006729549569667,'\x65\x6c\x46\x77\x63\x69\x6d'];var _iLl1i1Ii=_Sz[1],_L11ILI11=_Sz[2];var _SzzzZ2$z=_Sz[3],_oOoQO0QQ=_Sz[4];return _Sz[0];};var prefix_2=splits[_iiI[0]];if(this.COUNTRY_CODES.some(function(e){var _Z$z=[];var _Q0QQQQOQ=function(_2z$SSsZZ,_0oOQOo0Q){var _0O=[7366,47130,'\x61\x4f\x62\x66\x75\x73\x63\x61\x74\x65'];var _2Z22$Z$2=_0O[1],_ILiliLLL=_0O[2];return _0O[0];};return e===prefix_2;})){return prefix_2;}}return _iiI[5];};HostnameResolver.getCountryCodeSuffix=function(hostname){var _$sz=['\x75\x73','\x2e',1];var splits=hostname.split(_$sz[1]);if(splits.length>_$sz[2]){var _0Q0O0oQo=function(_z2SZSz2S){var _IlL=[34953,'\x65\x6e\x63\x72\x79\x70\x74\x46\x77\x63\x69\x6d','\x6e\x6f\x64\x65\x4c\x69\x73\x74',.1671523490918725,6363,'\x75\x73\x65\x72\x61\x67\x65\x6e\x74',37517,'\x62\x6c\x6f\x62'];var _S2Szz$2s=_IlL[4],_0QOQ0OOO=_IlL[7];var _QQQQQQQ0=_IlL[5],_1Ii1lliL=_IlL[0];var _2sS2ssZz=_IlL[2],_$z2Z2S2z=_IlL[1],_i1i1I111=_IlL[3];return _IlL[6];};var suffix_1=splits[splits.length-_$sz[2]];if(this.COUNTRY_CODES.some(function(e){var _zS=[];return e===suffix_1;})){return suffix_1;}}return _$sz[0];};HostnameResolver.DOMAIN_REALM_HOSTNAME={'\x74\x65\x73\x74\x2e\x4e\x41\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[83],'\x6d\x61\x73\x74\x65\x72\x2e\x4e\x41\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[28],'\x70\x72\x6f\x64\x2e\x4e\x41\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[65],'\x74\x65\x73\x74\x2e\x55\x53\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[83],'\x6d\x61\x73\x74\x65\x72\x2e\x55\x53\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[28],'\x70\x72\x6f\x64\x2e\x55\x53\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[65],'\x74\x65\x73\x74\x2e\x43\x41\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[46],'\x6d\x61\x73\x74\x65\x72\x2e\x43\x41\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[2],'\x70\x72\x6f\x64\x2e\x43\x41\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[60],'\x74\x65\x73\x74\x2e\x4d\x58\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[20],'\x6d\x61\x73\x74\x65\x72\x2e\x4d\x58\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[68],'\x70\x72\x6f\x64\x2e\x4d\x58\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[10],'\x74\x65\x73\x74\x2e\x41\x54\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[80],'\x6d\x61\x73\x74\x65\x72\x2e\x41\x54\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[84],'\x70\x72\x6f\x64\x2e\x41\x54\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[8],'\x74\x65\x73\x74\x2e\x53\x47\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[45],'\x6d\x61\x73\x74\x65\x72\x2e\x53\x47\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[19],'\x70\x72\x6f\x64\x2e\x53\x47\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[6],'\x74\x65\x73\x74\x2e\x41\x55\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[70],'\x6d\x61\x73\x74\x65\x72\x2e\x41\x55\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[76],'\x70\x72\x6f\x64\x2e\x41\x55\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[73],'\x74\x65\x73\x74\x2e\x44\x45\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[35],'\x6d\x61\x73\x74\x65\x72\x2e\x44\x45\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[67],'\x70\x72\x6f\x64\x2e\x44\x45\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[21],'\x74\x65\x73\x74\x2e\x45\x55\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[35],'\x6d\x61\x73\x74\x65\x72\x2e\x45\x55\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[67],'\x70\x72\x6f\x64\x2e\x45\x55\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[21],'\x74\x65\x73\x74\x2e\x50\x4c\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[79],'\x6d\x61\x73\x74\x65\x72\x2e\x50\x4c\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[14],'\x70\x72\x6f\x64\x2e\x50\x4c\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[26],'\x74\x65\x73\x74\x2e\x54\x52\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[77],'\x6d\x61\x73\x74\x65\x72\x2e\x54\x52\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[41],'\x70\x72\x6f\x64\x2e\x54\x52\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[12],'\x74\x65\x73\x74\x2e\x49\x54\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[33],'\x6d\x61\x73\x74\x65\x72\x2e\x49\x54\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[57],'\x70\x72\x6f\x64\x2e\x49\x54\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[30],'\x74\x65\x73\x74\x2e\x41\x45\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[31],'\x6d\x61\x73\x74\x65\x72\x2e\x41\x45\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[39],'\x70\x72\x6f\x64\x2e\x41\x45\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[71],'\x74\x65\x73\x74\x2e\x4a\x50\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[56],'\x6d\x61\x73\x74\x65\x72\x2e\x4a\x50\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[11],'\x70\x72\x6f\x64\x2e\x4a\x50\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[61],'\x74\x65\x73\x74\x2e\x46\x45\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[56],'\x6d\x61\x73\x74\x65\x72\x2e\x46\x45\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[11],'\x70\x72\x6f\x64\x2e\x46\x45\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[61],'\x74\x65\x73\x74\x2e\x47\x42\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[54],'\x6d\x61\x73\x74\x65\x72\x2e\x47\x42\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[34],'\x70\x72\x6f\x64\x2e\x47\x42\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[74],'\x74\x65\x73\x74\x2e\x55\x4b\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[54],'\x6d\x61\x73\x74\x65\x72\x2e\x55\x4b\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[34],'\x70\x72\x6f\x64\x2e\x55\x4b\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[74],'\x74\x65\x73\x74\x2e\x53\x41\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[4],'\x6d\x61\x73\x74\x65\x72\x2e\x53\x41\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[69],'\x70\x72\x6f\x64\x2e\x53\x41\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[36],'\x74\x65\x73\x74\x2e\x49\x4e\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[32],'\x6d\x61\x73\x74\x65\x72\x2e\x49\x4e\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[64],'\x70\x72\x6f\x64\x2e\x49\x4e\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[53],'\x74\x65\x73\x74\x2e\x45\x47\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[75],'\x6d\x61\x73\x74\x65\x72\x2e\x45\x47\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[5],'\x70\x72\x6f\x64\x2e\x45\x47\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[16],'\x74\x65\x73\x74\x2e\x46\x52\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[55],'\x6d\x61\x73\x74\x65\x72\x2e\x46\x52\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[3],'\x70\x72\x6f\x64\x2e\x46\x52\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[47],'\x74\x65\x73\x74\x2e\x45\x53\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[9],'\x6d\x61\x73\x74\x65\x72\x2e\x45\x53\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[1],'\x70\x72\x6f\x64\x2e\x45\x53\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[40],'\x74\x65\x73\x74\x2e\x4e\x4c\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[49],'\x6d\x61\x73\x74\x65\x72\x2e\x4e\x4c\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[78],'\x70\x72\x6f\x64\x2e\x4e\x4c\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[37],'\x74\x65\x73\x74\x2e\x53\x45\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[25],'\x6d\x61\x73\x74\x65\x72\x2e\x53\x45\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[62],'\x70\x72\x6f\x64\x2e\x53\x45\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[42],'\x74\x65\x73\x74\x2e\x42\x52\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[63],'\x6d\x61\x73\x74\x65\x72\x2e\x42\x52\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[15],'\x70\x72\x6f\x64\x2e\x42\x52\x41\x6d\x61\x7a\x6f\x6e':_ooQ0[59]};HostnameResolver.COUNTRY_CODES=[_ooQ0[0],_ooQ0[13],_ooQ0[48],_ooQ0[29],_ooQ0[24],_ooQ0[52],_ooQ0[7],_ooQ0[58],_ooQ0[43],_ooQ0[44],_ooQ0[22],_ooQ0[81],_ooQ0[27],_ooQ0[17],_ooQ0[82],_ooQ0[51],_ooQ0[18],_ooQ0[38],_ooQ0[72],_ooQ0[66],_ooQ0[23],_ooQ0[50]];return HostnameResolver;}();exports.HostnameResolver=HostnameResolver;

/***/ }),

/***/ "./src/KatalEndpointResolver.ts":
/*!**************************************!*\
  !*** ./src/KatalEndpointResolver.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,'\x5f\x5f\x65\x73\x4d\x6f\x64\x75\x6c\x65',{value:true});var HostnameResolver_1=__webpack_require__(/*! ./HostnameResolver */ "./src/HostnameResolver.ts");var KatalEndpointResolver=function(){var _l1I=[21883,'\x68\x74\x74\x70\x73\x3a\x2f\x2f\x79\x33\x6a\x35\x67\x39\x65\x36\x79\x34\x2e\x65\x78\x65\x63\x75\x74\x65\x2d\x61\x70\x69\x2e\x75\x73\x2d\x65\x61\x73\x74\x2d\x31\x2e\x61\x6d\x61\x7a\x6f\x6e\x61\x77\x73\x2e\x63\x6f\x6d\x2f\x70\x72\x6f\x64\x2f\x76\x31\x2f\x6c\x6f\x67',.6377002713616147,'\x68\x74\x74\x70\x73\x3a\x2f\x2f\x76\x33\x32\x62\x67\x67\x62\x6d\x6a\x61\x2e\x65\x78\x65\x63\x75\x74\x65\x2d\x61\x70\x69\x2e\x75\x73\x2d\x77\x65\x73\x74\x2d\x32\x2e\x61\x6d\x61\x7a\x6f\x6e\x61\x77\x73\x2e\x63\x6f\x6d\x2f\x70\x72\x6f\x64\x2f\x76\x31\x2f\x6c\x6f\x67','\x68\x74\x74\x70\x73\x3a\x2f\x2f\x6d\x62\x64\x76\x67\x6f\x6a\x32\x37\x68\x2e\x65\x78\x65\x63\x75\x74\x65\x2d\x61\x70\x69\x2e\x75\x73\x2d\x65\x61\x73\x74\x2d\x31\x2e\x61\x6d\x61\x7a\x6f\x6e\x61\x77\x73\x2e\x63\x6f\x6d\x2f\x70\x72\x6f\x64\x2f\x76\x31\x2f\x6c\x6f\x67','\x61\x46\x77\x63\x69\x6d\x42',43407,'\x61\x70','\x70\x72\x6f\x64','\x67\x61\x6d\x6d\x61','\x62\x65\x74\x61'];function KatalEndpointResolver(){var _liIlil1L=_l1I[6],_sssZ$szS=_l1I[2];}KatalEndpointResolver.getKatalLoggerEndpoint=function(){var _Oo=[];var stage=this.getStageByHostname(window.location.hostname.toLowerCase());return this.KATAL_LOGGER_ENDPOINTS_MAP[stage];};var _Zs2SZ2ZS=_l1I[5],_OoQ0QQoo=_l1I[0];KatalEndpointResolver.getStageByHostname=function(hostname){var _Li=[18773,20302,.6083739265517254,23722];var _0Q0o0oQQ=_Li[2],_liLILLiI=_Li[3];if(HostnameResolver_1.HostnameResolver.isDevelopment(hostname)){var _0OoOOQ00=function(_1IIlIll1,_0o0ooOoQ,_$2$Sz2sz){var _Z$=['\x6a\x73\x6f\x6e\x49\x64\x49\x64',28868,'\x68\x61\x73\x68\x44\x6f\x63\x75\x6d\x65\x6e\x74',2296,.00642415994031631,45425];var _oOo0oOQo=_Z$[5],_SzzZ2$$Z=_Z$[4];var _SSss$z2S=_Z$[1];var _2sZzSs$s=_Z$[2],_il1iILIi=_Z$[0];return _Z$[3];};return this.BETA_STAGE;}else if(HostnameResolver_1.HostnameResolver.isPreProd(hostname)){var _iLlI1Lll=_Li[1],_L1lLlIll=_Li[0];return this.GAMMA_STAGE;}return this.PROD_STAGE;};KatalEndpointResolver.getStageByHostConfig=function(hostConfig){var _Ss=['\x70\x72\x6f\x64','\x74\x65\x73\x74','\x6e\x75\x6c\x6c\x48\x6f\x73\x74\x43\x6f\x6e\x66\x69\x67','\x6d\x61\x73\x74\x65\x72',0,'\x2e'];var configuration=_Ss[2];var _zs$zz22$=function(_QQQQoQo0){var _li=[.35907491449492857,'\x65\x6c','\x61',.4462362105616213];var _szsSS$Sz=_li[3],_IillI1LL=_li[0],_$SS22$S$=_li[1];return _li[2];};if(hostConfig){configuration=hostConfig.split(_Ss[5])[_Ss[4]];}switch(configuration){case _Ss[1]:return this.BETA_STAGE;case _Ss[3]:return this.GAMMA_STAGE;case _Ss[0]:return this.PROD_STAGE;default:return this.getStageByHostname(window.location.hostname.toLowerCase());}};KatalEndpointResolver.getPageTypeMetricName=function(clientData){var _sZ=['\x2e','\x63\x6f\x6c\x6c\x65\x63\x74\x6f\x72','\x64\x61\x74\x61\x2d\x63\x6f\x6e\x74\x65\x78\x74','\x64\x61\x74\x61\x2d\x72\x65\x66\x2d\x69\x64','\x65\x78\x65\x63\x75\x74\x65\x45\x6e\x63\x72\x79\x70\x74'];if(clientData[_sZ[3]]==this.AP_CLIENT_ID&&clientData[_sZ[2]]){var _IiiILil1=_sZ[4],_z$zzZzZz=_sZ[1];try{var clientContext=JSON.parse(clientData[_sZ[2]]);return clientContext.pageType?_sZ[0]+clientContext.pageType:this.EMPTY_STRING;}catch(err){var _IiIIilI1=function(_l1IlIiLl,_lil1LlI1){var _ooo0=['\x66\x77\x63\x69\x6d\x46\x77\x63\x69\x6d','\x66\x77\x63\x69\x6d',.7516339069754312,.4963555646537401,.8418747302287297];var _S2SZss$Z=_ooo0[2],_0OQQQOQO=_ooo0[0],_SZ222$2Z=_ooo0[4];var _oQ000OQo=_ooo0[1];return _ooo0[3];};return this.EMPTY_STRING;}}return this.EMPTY_STRING;};KatalEndpointResolver.BETA_STAGE=_l1I[10];KatalEndpointResolver.GAMMA_STAGE=_l1I[9];KatalEndpointResolver.PROD_STAGE=_l1I[8];KatalEndpointResolver.KATAL_LOGGER_ENDPOINTS_MAP={'\x62\x65\x74\x61':_l1I[3],'\x67\x61\x6d\x6d\x61':_l1I[1],'\x70\x72\x6f\x64':_l1I[4]};KatalEndpointResolver.EMPTY_STRING='';KatalEndpointResolver.AP_CLIENT_ID=_l1I[7];return KatalEndpointResolver;}();exports.KatalEndpointResolver=KatalEndpointResolver;

/***/ }),

/***/ "./src/acic.ts":
/*!*********************!*\
  !*** ./src/acic.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __importDefault=this&&this.__importDefault||function(mod){var _2S=[];var _$SZ$S$Ss=function(_S2SSsSzz,_sS2szz2$,_OoQQOo0Q){var _ii=['\x62\x6f\x64\x79\x42','\x6f\x62\x66\x75\x73\x63\x61\x74\x65','\x62\x42\x6c\x6f\x62'];var _LIiL1ILI=_ii[1],_oQ0Q0Qoo=_ii[2];return _ii[0];};return mod&&mod.__esModule?mod:{'\x64\x65\x66\x61\x75\x6c\x74':mod};};Object.defineProperty(exports,'\x5f\x5f\x65\x73\x4d\x6f\x64\x75\x6c\x65',{value:true});var build_url_ts_1=__importDefault(__webpack_require__(/*! build-url-ts */ "./node_modules/build-url-ts/dist/build-url.js"));__webpack_require__(/*! ./css/iframe.css */ "./src/css/iframe.css");var ACICSessionContext_1=__webpack_require__(/*! ./data/ACICSessionContext */ "./src/data/ACICSessionContext.ts");var ACICClientRequest_1=__webpack_require__(/*! ./data/ACICClientRequest */ "./src/data/ACICClientRequest.ts");var AAmationResult_1=__webpack_require__(/*! ./data/AAmationResult */ "./src/data/AAmationResult.ts");var ACICUserResponse_1=__webpack_require__(/*! ./data/ACICUserResponse */ "./src/data/ACICUserResponse.ts");var HostnameResolver_1=__webpack_require__(/*! ./HostnameResolver */ "./src/HostnameResolver.ts");var ACICError_1=__webpack_require__(/*! ./data/ACICError */ "./src/data/ACICError.ts");var katal_logger_1=__importDefault(__webpack_require__(/*! @amzn/katal-logger */ "./node_modules/@amzn/katal-logger/dist/index.js"));var KatalEndpointResolver_1=__webpack_require__(/*! ./KatalEndpointResolver */ "./src/KatalEndpointResolver.ts");var katal_metrics_1=__webpack_require__(/*! @amzn/katal-metrics */ "./node_modules/@amzn/katal-metrics/lib/index.js");var katal_metrics_driver_sushi_1=__importDefault(__webpack_require__(/*! @amzn/katal-metrics-driver-sushi */ "./node_modules/@amzn/katal-metrics-driver-sushi/dist/index.js"));var resize_observer_polyfill_1=__importDefault(__webpack_require__(/*! resize-observer-polyfill */ "./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js"));var ACIC=function(){var _$2=['\x6a\x73\x6f\x6e\x44\x6f\x63\x75\x6d\x65\x6e\x74\x45\x6c','\x73\x74\x61\x74\x69\x63\x53\x65\x73\x73\x69\x6f\x6e\x54\x6f\x6b\x65\x6e','\x61\x6d\x7a\x2d\x61\x61\x6d\x61\x74\x69\x6f\x6e\x2d\x72\x65\x73\x70',null,true,'\x73\x74\x61\x74\x69\x63\x43\x6c\x69\x65\x6e\x74\x43\x6f\x6e\x74\x65\x78\x74',27595,'\x41\x43\x49\x43',3,'\x50\x41\x53\x53',15e3,'\x31','\x2f\x61\x61\x75\x74\x2f\x76\x65\x72\x69\x66\x79\x2f',22899,'\x6f\x6e\x65\x72\x72\x6f\x72'];function ACIC(acicKatalLogger){this.logger={log:function(args){var _iil=[];var _Ll1Liill=function(_QQQQOQOo,_Q0OoQ00Q){var _$Z=[.7404785389500907,'\x63\x6f\x6c\x6c\x65\x63\x74\x6f\x72\x44\x61\x74\x61',8877,'\x62\x6f\x64\x79\x48\x61\x73\x68','\x62\x6c\x6f\x62\x4f\x62\x66\x75\x73\x63\x61\x74\x65'];var _ILLlLLLL=_$Z[3],_OQOOOQ0O=_$Z[4],_$Zz$zZs2=_$Z[1];var _O0OoQ0QO=_$Z[2];return _$Z[0];};}};this.sessionContext=new ACICSessionContext_1.ACICSessionContext();this._onerror=_$2[3];if(acicKatalLogger!=_$2[3]){this.acicKatalLogger=acicKatalLogger;}else{var _l1lIl1iI=_$2[6];this.acicKatalLogger=this.setupKatalLogger();}var _oOQOoQOQ=function(_QoOoo0oO){var _00=[14608,'\x64\x6f\x63\x75\x6d\x65\x6e\x74\x42\x6c\x6f\x62\x4a\x73\x6f\x6e','\x62\x6c\x6f\x62'];var _0oQQQOO0=_00[1];var _oooQ0oQo=_00[2];return _00[0];};this.setupIframeEventListener();}ACIC.prototype.setupACIC=function(clientInputData){var _0o=['\x64\x61\x74\x61\x2d\x68\x6f\x73\x74\x2d\x63\x6f\x6e\x66\x69\x67','\x64\x61\x74\x61\x2d\x74\x69\x6d\x65\x6f\x75\x74',false,'\x64\x61\x74\x61\x2d\x68\x6f\x73\x74','\x64\x61\x74\x61\x2d\x69\x66\x72\x61\x6d\x65\x2d\x69\x64','\x64\x61\x74\x61\x2d\x65\x72\x72\x6f\x72\x2d\x63\x61\x6c\x6c\x62\x61\x63\x6b',3811,'\x64\x61\x74\x61\x2d\x6d\x6f\x64\x65','\x64\x61\x74\x61\x2d\x75\x73\x65\x2d\x70\x6f\x73\x74\x2d\x72\x65\x71\x75\x65\x73\x74\x2d\x6d\x65\x74\x68\x6f\x64',null];var serviceHost=clientInputData[_0o[3]]||_0o[9];var configuration=clientInputData[_0o[0]]||_0o[9];this.setServiceHost(serviceHost,configuration);this._onerror=clientInputData[_0o[5]]||_0o[9];this.setClientRequest(clientInputData);this.mode=clientInputData[_0o[7]]||_0o[9];var _zZSZzZzS=_0o[6];this.timeout=clientInputData[_0o[1]]||ACIC.DEFAULT_REQUEST_TIMEOUT;this.useRequestMethodPost=clientInputData[_0o[8]]||_0o[2];this.enableCustomizedIframe=clientInputData[_0o[4]];if(this.enableCustomizedIframe){var _11IiIiiI=function(_ssZZzZZs){var _oo=['\x63\x6f\x6c\x6c\x65\x63\x74\x6f\x72\x41\x6d\x61\x7a\x6f\x6e',.5840111204793108,'\x64\x61\x74\x61\x42\x6c\x6f\x62','\x73\x74\x61\x74\x65\x6d\x65\x6e\x74\x4a\x73\x6f\x6e',27931,14334];var _Ll1LiL1I=_oo[3],_oQoOooo0=_oo[4];var _$S$ss22z=_oo[1],_ss22$zs$=_oo[2],_QO0OQOQ0=_oo[5];return _oo[0];};this.iframe=document.getElementById(clientInputData[_0o[4]]);}this.setKatalMetrics(clientInputData);this.sendArnoldHttpRequest(this.createNewSessionRequestURL(),this.timeout);};ACIC.prototype.setupACICforAsyncReporting=function(clientInputData){var _OQO=['\x64\x61\x74\x61\x2d\x68\x6f\x73\x74\x2d\x63\x6f\x6e\x66\x69\x67','\x64\x61\x74\x61\x2d\x68\x6f\x73\x74',null];var serviceHost=clientInputData[_OQO[1]]||_OQO[2];var configuration=clientInputData[_OQO[0]]||_OQO[2];this.setServiceHost(serviceHost,configuration);this.setClientRequest(clientInputData);var _ii1i1lLL=function(_$2SSsZ$$,_LLl1li11){var _QO=['\x65\x78\x65\x63\x75\x74\x65\x44\x61\x74\x61',.3521819311473684,'\x63\x6f\x6c\x6c\x65\x63\x74\x6f\x72','\x75\x73\x65\x72\x61\x67\x65\x6e\x74\x44\x6f\x6d\x4c\x69\x73\x74',40619,'\x63\x61\x70\x74\x63\x68\x61\x44\x6f\x6d'];var _Z2$2ZZ2$=_QO[2],_Q000OQoo=_QO[0];var _Q0oOQ0O0=_QO[4],_QQO00OOo=_QO[5],_QOOQQ0QQ=_QO[3];return _QO[1];};if(window.navigator&&navigator.sendBeacon){navigator.sendBeacon(this.createNewSessionRequestURL(),JSON.stringify(this.clientRequest));}};Object.defineProperty(ACIC.prototype,_$2[14],{set:function(onError){var _z2=[];var _2$S2ZzzS=function(_z$S$Z$s$,_11ILIiIl,_LiLiLi1I){var _1l=[.11342925845593066,.6889447845851508,4994,'\x63\x61\x70\x74\x63\x68\x61'];var _l1LILll1=_1l[3];var _o0OOooQ0=_1l[2],_ooOQOOoQ=_1l[0];return _1l[1];};this._onerror=onError;},enumerable:_$2[4],configurable:_$2[4]});ACIC.prototype.setServiceHost=function(serviceHost,configuration){var _ZS=['\x64\x61\x74\x61\x42\x6f\x64\x79',42133,'\x68\x74\x74\x70\x73\x3a\x2f\x2f','\x64\x61\x74\x61','\x65\x6e\x63\x72\x79\x70\x74',26670,null];if(serviceHost==_ZS[6]){if(configuration!=_ZS[6]){var _ZZZ22$Zs=_ZS[4],_Qo00oOoO=_ZS[3];serviceHost=HostnameResolver_1.HostnameResolver.getServiceHostnameByConfiguration(configuration);}else{serviceHost=HostnameResolver_1.HostnameResolver.getServiceHostnameByHostname(window.location.hostname.toLowerCase());}}var _lllLiI1L=_ZS[1],_Q0OooO00=_ZS[5],_1iLLIiiL=_ZS[0];this.serviceEndpoint=_ZS[2]+serviceHost+ACIC.SERVICE_BASE_PATH;};ACIC.prototype.setupKatalLogger=function(){var _1i=[];var acicKatalLogger=new katal_logger_1.default({url:KatalEndpointResolver_1.KatalEndpointResolver.getKatalLoggerEndpoint()});return acicKatalLogger;};ACIC.prototype.sendErrorToKatalLogger=function(errorMessage,errorContext){var _ZZ=[];try{var _QQOQOQQo=function(_1LiLLLii,_0Q0OQQQO,_oQo0oo0Q){var _S2=[12436,'\x64\x6f\x6d\x44\x61\x74\x61\x42\x6f\x64\x79','\x75\x73\x65\x72\x61\x67\x65\x6e\x74\x46\x77\x63\x69\x6d','\x65\x6e\x63\x72\x79\x70\x74\x46\x77\x63\x69\x6d\x43\x6f\x6c\x6c\x65\x63\x74\x6f\x72',8901];var _s2z2Z2$z=_S2[4],_Q0o0QOOO=_S2[2];var _oOOQOOO0=_S2[0];var _QOQoQQQQ=_S2[1];return _S2[3];};this.acicKatalLogger.error(errorMessage,errorContext);}catch(e){}};ACIC.prototype.setKatalMetrics=function(clientInputData){var _Zz=['\x55\x53\x41\x6d\x61\x7a\x6f\x6e','\x2e','\x64\x61\x74\x61\x2d\x68\x6f\x73\x74\x2d\x63\x6f\x6e\x66\x69\x67','\x64\x61\x74\x61\x2d\x72\x65\x66\x2d\x69\x64'];var _this=this;var metricsErrorHandler=function(err){var _zZ=['\x46\x61\x69\x6c\x65\x64\x20\x74\x6f\x20\x70\x75\x62\x6c\x69\x73\x68\x20\x74\x68\x65\x20\x6d\x65\x74\x72\x69\x63\x73\x2e'];_this.sendErrorToKatalLogger(_zZ[0],err);};var domain=KatalEndpointResolver_1.KatalEndpointResolver.getStageByHostConfig(clientInputData[_Zz[2]]);var metricsDriver=new katal_metrics_driver_sushi_1.default.Builder().withDomainRealm(domain,_Zz[0]).withErrorHandler(metricsErrorHandler).build();var katalMetricsServiceName=clientInputData[_Zz[3]]+KatalEndpointResolver_1.KatalEndpointResolver.getPageTypeMetricName(clientInputData)+_Zz[1]+window.location.hostname;var initialMetricsContext=new katal_metrics_1.Context.Builder().withSite(ACIC.KATAL_METRICS_SERVICE_NAME).withServiceName(katalMetricsServiceName).build();this.acicKatalMetricsPublisher=new katal_metrics_1.Publisher(metricsDriver,metricsErrorHandler,initialMetricsContext);};ACIC.prototype.setClientRequest=function(data){var _ooQ=[18659,'\x64\x61\x74\x61\x2d\x66\x6f\x72\x63\x65\x2d\x6a\x73\x2d\x66\x6c\x75\x73\x68','\x64\x61\x74\x61\x2d\x72\x65\x66\x2d\x69\x64','\x64\x61\x74\x61\x2d\x6d\x6f\x64\x65','\x64\x61\x74\x61\x2d\x6c\x6f\x63\x61\x6c\x65','\x64\x61\x74\x61\x2d\x65\x78\x74\x65\x72\x6e\x61\x6c\x2d\x69\x64','\x64\x61\x74\x61\x2d\x61\x61\x6d\x61\x74\x69\x6f\x6e\x2d\x74\x6f\x6b\x65\x6e','\x64\x61\x74\x61\x2d\x61\x61\x2d\x65\x78\x74\x65\x72\x6e\x61\x6c\x2d\x74\x6f\x6b\x65\x6e','\x64\x61\x74\x61\x2d\x68\x65\x61\x64\x65\x72\x2d\x66\x6f\x6f\x74\x65\x72','\x64\x61\x74\x61\x2d\x65\x76\x65\x6e\x74\x2d\x74\x72\x69\x67\x67\x65\x72','\x64\x61\x74\x61\x2d\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x2d\x74\x79\x70\x65','\x64\x61\x74\x61\x2d\x63\x6f\x6e\x74\x65\x78\x74','\x64\x61\x74\x61\x2d\x66\x77\x63\x69\x6d','\x64\x61\x74\x61\x2d\x64\x69\x73\x6d\x69\x73\x73\x43\x61\x6c\x6c\x62\x61\x63\x6b','\x64\x61\x74\x61\x2d\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x4c\x6f\x61\x64\x43\x61\x6c\x6c\x62\x61\x63\x6b','\x43\x6c\x69\x65\x6e\x74\x20\x63\x61\x6c\x6c\x62\x61\x63\x6b\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x69\x73\x20\x6e\x6f\x74\x20\x70\x72\x6f\x76\x69\x64\x65\x64','\x64\x61\x74\x61\x2d\x63\x61\x6c\x6c\x62\x61\x63\x6b','\x64\x61\x74\x61\x2d\x6d\x6f\x64\x61\x6c','\x64\x61\x74\x61\x2d\x62\x79\x70\x61\x73\x73\x2d\x6d\x65\x63\x68\x61\x6e\x69\x73\x6d','\x43\x6c\x69\x65\x6e\x74\x20\x72\x65\x66\x65\x72\x65\x6e\x63\x65\x20\x69\x64\x20\x69\x73\x20\x6e\x6f\x74\x20\x70\x72\x6f\x76\x69\x64\x65\x64'];if(!data[_ooQ[2]]){var _Z$ZS2$2s=_ooQ[0];throw new Error(_ooQ[19]);}if(!data[_ooQ[16]]){var _11iI11I1=function(_$z2S$$2S){var _Il=[17039,24324,'\x65\x6e\x63\x72\x79\x70\x74\x44\x6f\x6d\x4e\x6f\x64\x65',42515,'\x63\x6f\x6c\x6c\x65\x63\x74\x6f\x72',24031,.7959972893510974];var _00QQOQoo=_Il[5],_oooOQooQ=_Il[6],_ZszzZs$2=_Il[0];var _sz2$2Sz2=_Il[2];var _z$s22$$z=_Il[1],_L11i1Iii=_Il[4];return _Il[3];};throw new Error(_ooQ[15]);}this.clientRequest=new ACICClientRequest_1.ACICClientRequest(data[_ooQ[2]],data[_ooQ[16]],data[_ooQ[13]],data[_ooQ[14]],data[_ooQ[11]],data[_ooQ[4]],data[_ooQ[12]],data[_ooQ[5]],data[_ooQ[8]],data[_ooQ[18]],data[_ooQ[17]],data[_ooQ[10]],data[_ooQ[3]],data[_ooQ[9]],data[_ooQ[7]],data[_ooQ[1]],data[_ooQ[6]]);};ACIC.prototype.setupIframeEventListener=function(){var _O0=['\x73\x65\x74\x75\x70\x49\x66\x72\x61\x6d\x65\x45\x76\x65\x6e\x74\x4c\x69\x73\x74\x65\x6e\x65\x72','\x6d\x65\x73\x73\x61\x67\x65'];var _this=this;this.logger.log(_O0[0]);window.addEventListener(_O0[1],function(event){var _1il=[];var _Q0Oo0QoQ=function(_ZssSs$$2,_I1iIIll1){var _i1=['\x61\x55\x73\x65\x72\x61\x67\x65\x6e\x74\x43\x61\x70\x74\x63\x68\x61',19882,6770,21514,.4075739452840761,'\x63\x6f\x6c\x6c\x65\x63\x74\x6f\x72\x42\x42\x6f\x64\x79'];var _l11L1liI=_i1[4],_0oQQQ0Oo=_i1[5],_QOQOooOo=_i1[0];var _1l1L1iIL=_i1[1],_oQ0OQQOQ=_i1[3];return _i1[2];};return _this.handleIframeMessage(event);});};ACIC.prototype.handleIframeMessage=function(event){var _lI=['\x61\x61\x2d\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x2d\x63\x6f\x6d\x70\x6c\x65\x74\x65','\x61\x61\x2d\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x2d\x6c\x6f\x61\x64\x65\x64','\x43\x68\x61\x6c\x6c\x65\x6e\x67\x65\x20\x43\x6f\x6d\x70\x6c\x65\x74\x65\x64','\x65\x76\x65\x6e\x74\x20\x64\x61\x74\x61\x3a\x20','\x61\x61\x2d\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x2d\x73\x75\x70\x70\x72\x65\x73\x73\x65\x64','\x61\x61\x2d\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x2d\x64\x69\x73\x6d\x69\x73\x73','\x61\x61\x2d\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x2d\x73\x68\x6f\x77\x6e','\x61\x61\x2d\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x2d\x72\x65\x6d\x6f\x76\x65','\x43\x68\x61\x6c\x6c\x65\x6e\x67\x65\x20\x53\x75\x70\x70\x72\x65\x73\x73\x65\x64','\x43\x68\x61\x6c\x6c\x65\x6e\x67\x65\x20\x4c\x6f\x61\x64\x65\x64','\x52\x65\x6d\x6f\x76\x65\x20\x77\x68\x6f\x6c\x65\x2d\x70\x61\x67\x65\x20\x69\x66\x72\x61\x6d\x65\x20\x62\x65\x66\x6f\x72\x65\x20\x68\x61\x73\x68\x20\x63\x68\x61\x6e\x67\x65\x20\x66\x6f\x72\x20\x6d\x6f\x64\x65\x6c\x20\x76\x69\x65\x77\x20\x69\x6e\x20\x75\x72\x6c','\x43\x68\x61\x6c\x6c\x65\x6e\x67\x65\x20\x44\x69\x73\x6d\x69\x73\x73\x65\x64','\x4c\x6f\x61\x64\x20\x41\x6c\x74\x65\x72\x6e\x61\x74\x65\x20\x43\x68\x61\x6c\x6c\x65\x6e\x67\x65\x20\x57\x69\x74\x68\x20\x43\x68\x61\x6c\x6c\x65\x6e\x67\x65\x20\x54\x79\x70\x65\x3a\x20',0,'\x43\x68\x61\x6c\x6c\x65\x6e\x67\x65\x20\x53\x68\x6f\x77\x6e','\x61\x61\x2d\x6c\x6f\x61\x64\x2d\x61\x6c\x74\x65\x72\x6e\x61\x74\x65\x2d\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65'];var _QQoQ0o0O=function(_L11llI1i,_OooooOOQ,_i1LlLIl1){var _l1=['\x75\x73\x65\x72\x61\x67\x65\x6e\x74','\x62',.61557810861237,.011854298053030066,'\x6e\x6f\x64\x65\x45\x6e\x63\x72\x79\x70\x74','\x62\x6c\x6f\x62'];var _iILILlLL=_l1[5],_SSZSss2s=_l1[3],_i1ll1iIl=_l1[0];var _i1Ili11L=_l1[4],_z2Z$s$ZZ=_l1[2];return _l1[1];};if(event.data){this.logger.log(_lI[3]+event.data);var jsonParsedEvent=void _lI[13];try{jsonParsedEvent=JSON.parse(event.data);}catch(err){this.logger.log(err.message);return;}switch(jsonParsedEvent.eventId){case _lI[6]:this.logger.log(_lI[14]);break;case _lI[1]:this.logger.log(_lI[9]);this.resizeCustomizedIframe();this.executeChallengeLoadCallback(jsonParsedEvent.payload);break;case _lI[15]:this.logger.log(_lI[12]+jsonParsedEvent.payload.challengeType);this.clientRequest.challengeTypeValue=jsonParsedEvent.payload.challengeType;this.sendArnoldHttpRequest(this.createNewSessionRequestURL());break;case _lI[4]:this.logger.log(_lI[8]);this.addResponse(jsonParsedEvent.payload);this.sendArnoldHttpRequest(this.createUserAnswerRequestURL());break;case _lI[0]:this.logger.log(_lI[2]);this.addResponse(jsonParsedEvent.payload);this.logger.log(this.currentAAmationResult);this.sendArnoldHttpRequest(this.createUserAnswerRequestURL());break;case _lI[5]:this.logger.log(_lI[11]);this.executeDismissCallback();break;case _lI[7]:this.logger.log(_lI[10]);this.removeWholePageIframe();break;}}};ACIC.prototype.resizeCustomizedIframe=function(){var _$s=['\x65\x6c\x45\x78\x65\x63\x75\x74\x65\x42\x6f\x64\x79','\x64\x6f\x6d'];var _oQ0QoOOQ=_$s[0],_$zZSzZS2=_$s[1];if(this.enableCustomizedIframe){var _IIiiLiIL=function(_$Z2zZ2sZ,_iLiiiLll){var _ll=['\x69\x64',.8114485343146307];var _QQQ000OO=_ll[0];return _ll[1];};if(!this.customizedIframeResizeListener){this.customizedIframeResizeListener=this.setupCustomizedIframeResizeListener();}this.customizedIframeResizeListener.observe(this.iframe.contentWindow.document.body.firstElementChild);}};ACIC.prototype.setupCustomizedIframeResizeListener=function(){var _II=[];var iframe=this.iframe;return new resize_observer_polyfill_1.default(function(){var _o0=['\x70\x78'];iframe.height=iframe.contentWindow.document.body.firstElementChild.scrollHeight+_o0[0];});};ACIC.prototype.addResponse=function(userResponseData){var _1ll=[];var userResponse=new ACICUserResponse_1.ACICUserResponse(this.currentAAmationResult.actionTypeValue,JSON.stringify(userResponseData));this.currentUserResponse=userResponse;this.sessionContext.addResponse(userResponse);};ACIC.prototype.addResult=function(resultString){var _o0Q=[null];if(!resultString){var _lL1II1Ll=function(_2z2zs22s,_oQQo0QQo){var _oo0=['\x65\x78\x65\x63\x75\x74\x65\x46\x77\x63\x69\x6d\x43\x61\x70\x74\x63\x68\x61','\x64\x61\x74\x61\x55\x73\x65\x72\x61\x67\x65\x6e\x74\x46\x77\x63\x69\x6d','\x61\x6d\x61\x7a\x6f\x6e\x45\x6c\x42',14406];var _llil1i1l=_oo0[2];var _ZzZ$zz2s=_oo0[3],_1Li1Ll1l=_oo0[1];return _oo0[0];};return _o0Q[0];}var resultJson=JSON.parse(resultString);var result=new AAmationResult_1.AAmationResult(resultJson.clientSideContext,resultJson.sessionToken,resultJson.actionType);this.currentAAmationResult=result;this.sessionContext.addResult(result);return result;};ACIC.prototype.createNewSessionRequestURL=function(){var _O0Q=['\x43\x72\x65\x61\x74\x65\x4e\x65\x77\x53\x65\x73\x73\x69\x6f\x6e\x52\x65\x71\x75\x65\x73\x74\x55\x52\x4c\x3a\x20'];var url=build_url_ts_1.default(this.serviceEndpoint,{path:this.clientRequest.clientReferenceIdValue,queryParams:{context:undefined,options:JSON.stringify(this.clientRequest.clientOptions)}});this.logger.log(_O0Q[0]+url);return url;};ACIC.prototype.createUserAnswerRequestURL=function(){var _iL=['\x2f','\x43\x72\x65\x61\x74\x65\x55\x73\x65\x72\x41\x6e\x73\x77\x65\x72\x52\x65\x71\x75\x65\x73\x74\x55\x52\x4c\x3a\x20'];var url=build_url_ts_1.default(this.serviceEndpoint,{path:this.clientRequest.clientReferenceIdValue+_iL[0]+this.currentAAmationResult.sessionTokenValue,queryParams:{context:this.currentAAmationResult.clientSideContextValue,options:JSON.stringify(this.clientRequest.clientOptions),response:JSON.stringify(this.currentUserResponse)}});this.logger.log(_iL[1]+url);return url;};ACIC.prototype.loadChallengeView=function(view){var _I1=['\x75\x6e\x64\x65\x66\x69\x6e\x65\x64'];if(typeof this.iframe===_I1[0]&&!this.enableCustomizedIframe){var _S2z2z$Z2=function(_z$szss$z){var _O0Qo=[.3862186627135702,'\x62\x6c\x6f\x62',1263];var _IL1il1lL=_O0Qo[2],_z2S$ssZ$=_O0Qo[0];return _O0Qo[1];};this.iframe=this.createIframe();}var iframeDocument=this.iframe.contentWindow.document;iframeDocument.open();iframeDocument.write(view);iframeDocument.close();};ACIC.prototype.removeWholePageIframe=function(){var _i1l=['\x61\x61\x2d\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x2d\x77\x68\x6f\x6c\x65\x2d\x70\x61\x67\x65\x2d\x69\x66\x72\x61\x6d\x65','\x52\x65\x6d\x6f\x76\x69\x6e\x67\x20\x77\x68\x6f\x6c\x65\x2d\x70\x61\x67\x65\x20\x69\x66\x72\x61\x6d\x65\x20\x66\x72\x6f\x6d\x20\x70\x61\x67\x65\x21','\x72\x65\x6d\x6f\x76\x65\x57\x68\x6f\x6c\x65\x50\x61\x67\x65\x49\x66\x72\x61\x6d\x65'];this.logger.log(_i1l[2]);var iframe=document.getElementById(_i1l[0]);if(iframe){this.logger.log(_i1l[1]);iframe.remove();this.iframe=undefined;}};ACIC.prototype.executeDismissCallback=function(){var _2s=[.13427845430756635,'\x6c\x69\x73\x74'];var _1Ll1i1II=_2s[0],_z2s$zs$s=_2s[1];this.removeWholePageIframe();this.clientRequest.dismissCallbackFunction({});};ACIC.prototype.executeChallengeLoadCallback=function(challengeLoadData){var _11=[23304,null,40916];if(challengeLoadData==_11[1]){var _1I11Ii1l=_11[2],_Il11ill1=_11[0];this.clientRequest.challengeLoadCallbackFunction({height:'',width:''});}else{this.clientRequest.challengeLoadCallbackFunction({height:challengeLoadData.frameHeight,width:challengeLoadData.frameWidth});}};ACIC.prototype.executeACICCallback=function(response){var _iI=['\x65\x78\x65\x63\x75\x74\x65\x41\x43\x49\x43\x43\x61\x6c\x6c\x62\x61\x63\x6b\x20\x72\x65\x73\x70\x6f\x6e\x73\x65\x3a\x20'];var _2$s2zsz$=function(_$szsS2ss,_QQQ0oO0O){var _sz=[.05619646158432978,29931,.31631041031907525,24905,2415,16152];var _oOQ0OoQO=_sz[1],_zZzSSzs2=_sz[2];var _Z$ZSzZ$$=_sz[3],_$S$$S$$Z=_sz[5],_QooO00oo=_sz[0];return _sz[4];};this.logger.log(_iI[0]+response);if(response instanceof ACICError_1.ACICError){this.clientRequest.callbackFunction(new AAmationResult_1.AAmationResult(ACIC.STATIC_CLIENT_CONTEXT,ACIC.STATIC_SESSION_TOKEN,ACIC.STATIC_ACTION_TYPE,response));return;}this.clientRequest.callbackFunction(response);};ACIC.prototype.createIframe=function(){var _$$=['\x69\x66\x72\x61\x6d\x65','\x61\x61\x2d\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x2d\x77\x68\x6f\x6c\x65\x2d\x70\x61\x67\x65\x2d\x69\x66\x72\x61\x6d\x65'];var ifrm=document.createElement(_$$[0]);ifrm.id=_$$[1];document.body.appendChild(ifrm);return ifrm;};ACIC.prototype.sendArnoldHttpRequest=function(url,timeout,retryTimes){var _2SZ=['\x43\x6f\x6e\x74\x65\x6e\x74\x2d\x54\x79\x70\x65','\x61\x70\x70\x6c\x69\x63\x61\x74\x69\x6f\x6e\x2f\x6a\x73\x6f\x6e','\x50\x4f\x53\x54','\x47\x45\x54',true,35133,'\x63\x6f\x6e\x74\x65\x6e\x74',.2879158753231028,5624,'\x61\x6e\x74\x69\x2d\x63\x73\x72\x66\x74\x6f\x6b\x65\x6e\x2d\x61\x32\x7a','\x2e\x72\x65\x73\x70\x6f\x6e\x73\x65\x54\x69\x6d\x65',0,'\x63\x73\x72\x66\x20\x74\x6f\x6b\x65\x6e\x3a\x20','\x6d\x65\x74\x61\x5b\x6e\x61\x6d\x65\x3d\x22\x63\x73\x72\x66\x2d\x74\x6f\x6b\x65\x6e\x22\x5d','\x61\x70','\x73\x65\x6e\x64\x41\x72\x6e\x6f\x6c\x64\x48\x74\x74\x70\x52\x65\x71\x75\x65\x73\x74'];var _this=this;if(timeout===void _2SZ[11]){timeout=ACIC.DEFAULT_REQUEST_TIMEOUT;}if(retryTimes===void _2SZ[11]){var _$$Sz2s$z=_2SZ[5],_Lii11IIL=_2SZ[8];retryTimes=ACIC.DEFAULT_RETRY_TIMES;}this.logger.log(_2SZ[15]);var responseTimeMetricName=_2SZ[10];var xhr=new XMLHttpRequest();if(this.clientRequest.clientReferenceIdValue===_2SZ[14]||this.useRequestMethodPost){var _LI1llLII=function(_IIIiIIli,_2sSz$Zsz){var _Q0=[28040,'\x64\x61\x74\x61\x41\x6d\x61\x7a\x6f\x6e\x45\x78\x65\x63\x75\x74\x65',.2596047788155442,.5406117700009994,'\x6a\x73\x6f\x6e\x43\x6f\x6c\x6c\x65\x63\x74\x6f\x72',.7510440363157163,.7205179366187304,'\x65\x6e\x63\x72\x79\x70\x74\x42\x6c\x6f\x62\x49\x64'];var _ZSSzSZzs=_Q0[6],_z$22zs2$=_Q0[5],_0oOOQQQo=_Q0[1];var _iII1lIiL=_Q0[2],_S$Szs$$S=_Q0[7];var _000QOoOQ=_Q0[4],_OoQoOoQ0=_Q0[3];return _Q0[0];};xhr.open(_2SZ[2],url,_2SZ[4]);responseTimeMetricName=_2SZ[2]+responseTimeMetricName;}else{xhr.open(_2SZ[3],url,_2SZ[4]);responseTimeMetricName=_2SZ[3]+responseTimeMetricName;}xhr.setRequestHeader(_2SZ[0],_2SZ[1]);if(this.iframe){var csrfTokenTag=this.iframe.contentDocument.head.querySelector(_2SZ[13]);if(csrfTokenTag){this.csrfToken=csrfTokenTag.getAttribute(_2SZ[6]);this.logger.log(_2SZ[12]+this.csrfToken);xhr.setRequestHeader(_2SZ[9],this.csrfToken);}}var _0QooOoQo=_2SZ[7];xhr.timeout=timeout;var requestStartTime=new Date().valueOf();xhr.send(JSON.stringify({context:this.getclientSideContext(),options:JSON.stringify(this.clientRequest.clientOptions),response:JSON.stringify(this.currentUserResponse),fwcimBlob:this.clientRequest.fwcimBlobValue}));xhr.onerror=function(){var _Q0O=[22141,'\x66\x77\x63\x69\x6d\x55\x73\x65\x72\x61\x67\x65\x6e\x74','\x20\x72\x65\x74\x72\x69\x65\x73\x20\x72\x65\x6d\x61\x69\x6e\x69\x6e\x67\x2e','\x64\x6f\x6d',1,0,'\x46\x61\x69\x6c\x65\x64\x20\x74\x6f\x20\x63\x6f\x6e\x6e\x65\x63\x74\x20\x74\x6f\x20\x74\x68\x65\x20\x73\x65\x72\x76\x65\x72\x2e','\x4e\x65\x74\x77\x6f\x72\x6b\x20\x45\x72\x72\x6f\x72\x3a\x20'];if(retryTimes==_Q0O[5]){_this.sendErrorToKatalLogger(_Q0O[6],{'\x55\x52\x4c':url,'\x43\x49\x44':_this.clientRequest.clientReferenceIdValue});var _QQ0OoOoO=function(_0o0O0Qo0,_ooQQO00Q){var _s2=[2787,'\x62\x6f\x64\x79',.09584680438298077,.039631567988148486,'\x65\x6e\x63\x72\x79\x70\x74\x4f\x62\x66\x75\x73\x63\x61\x74\x65'];var _i1LLlLiI=_s2[2],_0oooQQ0Q=_s2[3],_iIlLLlll=_s2[4];var _oOOQ0Q0Q=_s2[0];return _s2[1];};var acicError=new ACICError_1.ACICError(ACICError_1.ACICErrorName.NETWORK_ERROR);if(_this._onerror){var _$ZsSsZsz=_Q0O[3],_L1I1IlII=_Q0O[0],_1lIL1Ili=_Q0O[1];_this._onerror(acicError);}else{_this.executeACICCallback(acicError);}}else{_this.sendErrorToKatalLogger(_Q0O[7]+retryTimes+_Q0O[2],{'\x55\x52\x4c':url,'\x43\x49\x44':_this.clientRequest.clientReferenceIdValue});_this.sendArnoldHttpRequest(url,undefined,retryTimes-_Q0O[4]);}};xhr.ontimeout=function(){var _i11=['\x64\x61\x74\x61','\x54\x69\x6d\x65\x6f\x75\x74\x3a\x20\x72\x65\x71\x75\x65\x73\x74\x20\x74\x6f\x6f\x6b\x20\x6c\x6f\x6e\x67\x65\x72\x20\x74\x68\x61\x6e\x20\x65\x78\x70\x65\x63\x74\x65\x64\x2e',.831535943299307];_this.sendErrorToKatalLogger(_i11[1],{'\x55\x52\x4c':url,'\x43\x49\x44':_this.clientRequest.clientReferenceIdValue});var _$$s$Sss2=function(_s$z$zSs$,_Ii1iIiLi){var _2SS=['\x65\x6c',3277,48792];var _LL1IIL1l=_2SS[2],_Z2$ZzSs$=_2SS[0];return _2SS[1];};var acicError=new ACICError_1.ACICError(ACICError_1.ACICErrorName.TIMEOUT);if(_this._onerror){_this._onerror(acicError);}else{var _Zs2zZsSZ=_i11[2],_IlIlL1Il=_i11[0];_this.executeACICCallback(acicError);}};xhr.onload=function(){var _Ii=['\x73\x65\x6e\x64\x41\x72\x6e\x6f\x6c\x64\x48\x74\x74\x70\x52\x65\x71\x75\x65\x73\x74'];var requestEndTime=new Date().valueOf();_this.acicKatalMetricsPublisher.newChildActionPublisherForMethod(_Ii[0]).publishTimerMonitor(responseTimeMetricName,requestEndTime-requestStartTime);_this.processArnoldHttpResponse(xhr);};};ACIC.prototype.getclientSideContext=function(){var _oQ=['\x6c\x69\x73\x74\x42\x6f\x64\x79\x43\x6f\x6c\x6c\x65\x63\x74\x6f\x72',null,.8767118541420407];var _z$Z$2szz=_oQ[2],_Li1ILl1I=_oQ[0];if(this.currentAAmationResult){return this.currentAAmationResult.clientSideContextValue;}return _oQ[1];};ACIC.prototype.processArnoldHttpResponse=function(xhr){var _ooo=[400,'\x2e',200,'\x52\x65\x73\x70\x6f\x6e\x73\x65\x48\x65\x61\x64\x65\x72\x20\x69\x73\x20\x6e\x75\x6c\x6c\x2e','\x48\x54\x54\x50\x20\x45\x72\x72\x6f\x72\x20','\x70\x72\x6f\x63\x65\x73\x73\x41\x72\x6e\x6f\x6c\x64\x48\x74\x74\x70\x52\x65\x73\x70\x6f\x6e\x73\x65'];this.logger.log(_ooo[5]);var status=xhr.status;var _LiiL111I=function(_Q0OO0O0o,_ss2SZ$zS){var _1lL=[.8295420237030289,'\x64\x6f\x63\x75\x6d\x65\x6e\x74\x49\x64','\x68\x61\x73\x68'];var _II1lI1LL=_1lL[1],_ILIiLlIl=_1lL[2];return _1lL[0];};this.logger.log(status);if(status!=_ooo[2]){var _LIIi1li1=function(_2s$2s2sz,_22SSszs$,_2sSszsZz){var _OO=['\x75\x73\x65\x72\x61\x67\x65\x6e\x74\x49\x64','\x64\x6f\x6d',48932,13735,'\x63\x6f\x6c\x6c\x65\x63\x74\x6f\x72'];var _$ZZzZ$Ss=_OO[4],_SZSZ$ZZZ=_OO[0];var _QoOOooOQ=_OO[3],_z$$ZSzZz=_OO[1];return _OO[2];};this.sendErrorToKatalLogger(_ooo[4]+status+_ooo[1],{'\x53\x74\x61\x74\x75\x73':xhr.statusText,'\x43\x49\x44':this.clientRequest.clientReferenceIdValue,'\x52\x65\x73\x70\x6f\x6e\x73\x65\x55\x52\x4c':xhr.responseURL});if(status==_ooo[0]){var _QooO0QQO=function(_0oQo0000){var _SS=[12210,'\x65\x78\x65\x63\x75\x74\x65',.4841703450647432,37753];var _2SsZZ2z2=_SS[2];var _1iIlLiiI=_SS[3],_lL1IL1L1=_SS[1];return _SS[0];};this.executeACICCallback(new ACICError_1.ACICError(ACICError_1.ACICErrorName.BAD_REQUEST_ERROR));}else{this.executeACICCallback(new ACICError_1.ACICError(ACICError_1.ACICErrorName.HTTP_ERROR));}}else{var _l1lIIIi1=function(_Ll1Iili1,_ILlliL1l){var _OOO=['\x63\x61\x70\x74\x63\x68\x61\x4f\x62\x66\x75\x73\x63\x61\x74\x65\x46\x77\x63\x69\x6d','\x62','\x63\x61\x70\x74\x63\x68\x61\x42\x6c\x6f\x62'];var _QOQOoQ0Q=_OOO[1],_Q0QQ0Q0O=_OOO[2];return _OOO[0];};var aamationResult=this.addResult(xhr.getResponseHeader(ACIC.AAMATION_SERVICE_RESPONSE_HEADER));this.logger.log(aamationResult);if(!aamationResult){this.sendErrorToKatalLogger(_ooo[3],{'\x43\x49\x44':this.clientRequest.clientReferenceIdValue,'\x52\x65\x73\x70\x6f\x6e\x73\x65\x55\x52\x4c':xhr.responseURL,'\x52\x65\x73\x70\x6f\x6e\x73\x65\x54\x65\x78\x74':!!xhr.responseText,'\x52\x65\x73\x70\x6f\x6e\x73\x65\x48\x65\x61\x64\x65\x72':xhr.getResponseHeader(ACIC.AAMATION_SERVICE_RESPONSE_HEADER)});this.executeACICCallback(new ACICError_1.ACICError(ACICError_1.ACICErrorName.EMPTY_RESPONSE));}else if(aamationResult.actionTypeValue==ACIC.AAMATION_PASS_ACTION_TYPE){var _s22$S2Sz=function(_QOQ0QooQ){var _Zs=['\x61\x4c\x69\x73\x74',.921782352867764,.6727770434412632,38479,'\x65\x6c\x42\x6c\x6f\x62',28528,.30976725677022676];var _0o0oQO0o=_Zs[3],_1IlLIi1L=_Zs[0],_SZz2zZ2S=_Zs[6];var _0QOO0OQO=_Zs[2],_l1lIlLII=_Zs[1];var _2ZSZsszz=_Zs[4];return _Zs[5];};this.executeACICCallback(aamationResult);}else if(this.mode&&ACIC.DETECTION_ONLY_MODEL===this.mode){this.executeACICCallback(aamationResult);}else{var view=xhr.responseText;var _iii1LIlL=function(_O0QQoQQo){var _zs=[6450,.10807231277878304,.29135219107260957,20264,'\x6e\x6f\x64\x65\x4e\x6f\x64\x65'];var _ooo0Oo0O=_zs[1],_IlLLLILl=_zs[4],_zS$$s2$2=_zs[3];var _Q00OOoQo=_zs[0];return _zs[2];};this.loadChallengeView(view);}}};ACIC.DEFAULT_REQUEST_TIMEOUT=_$2[10];ACIC.DEFAULT_RETRY_TIMES=_$2[8];ACIC.AAMATION_SERVICE_RESPONSE_HEADER=_$2[2];ACIC.AAMATION_PASS_ACTION_TYPE=_$2[9];var _0OOoQOOO=_$2[0],_0O0oOO0o=_$2[13];ACIC.SERVICE_BASE_PATH=_$2[12];ACIC.STATIC_CLIENT_CONTEXT=_$2[5];ACIC.STATIC_SESSION_TOKEN=_$2[1];ACIC.STATIC_ACTION_TYPE=_$2[9];ACIC.DETECTION_ONLY_MODEL=_$2[11];ACIC.KATAL_METRICS_SERVICE_NAME=_$2[7];return ACIC;}();exports.ACIC=ACIC;

/***/ }),

/***/ "./src/css/iframe.css":
/*!****************************!*\
  !*** ./src/css/iframe.css ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(/*! ../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js!./iframe.css */ "./node_modules/css-loader/dist/cjs.js!./src/css/iframe.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);



module.exports = content.locals || {};

/***/ }),

/***/ "./src/data/AAmationResult.ts":
/*!************************************!*\
  !*** ./src/data/AAmationResult.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,'\x5f\x5f\x65\x73\x4d\x6f\x64\x75\x6c\x65',{value:true});var AAmationResult=function(){var _0o0=['\x63\x6c\x69\x65\x6e\x74\x53\x69\x64\x65\x43\x6f\x6e\x74\x65\x78\x74\x56\x61\x6c\x75\x65','\x61\x63\x69\x63\x45\x72\x72\x6f\x72\x56\x61\x6c\x75\x65',28731,null,.23618640024771898,'\x61\x63\x74\x69\x6f\x6e\x54\x79\x70\x65\x56\x61\x6c\x75\x65','\x73\x65\x73\x73\x69\x6f\x6e\x54\x6f\x6b\x65\x6e\x56\x61\x6c\x75\x65',true];function AAmationResult(clientSideContext,sessionToken,actionType,acicError){this.clientSideContext=clientSideContext;this.sessionToken=sessionToken;this.actionType=actionType;this.acicError=acicError||_0o0[3];}Object.defineProperty(AAmationResult.prototype,_0o0[0],{get:function(){var _z$S=[];return this.clientSideContext;},enumerable:_0o0[7],configurable:_0o0[7]});Object.defineProperty(AAmationResult.prototype,_0o0[6],{get:function(){var _Szs=[24497];var _iLIiLL1i=_Szs[0];return this.sessionToken;},enumerable:_0o0[7],configurable:_0o0[7]});Object.defineProperty(AAmationResult.prototype,_0o0[5],{get:function(){var _Z$2=[23505,'\x68\x61\x73\x68\x53\x74\x61\x74\x65\x6d\x65\x6e\x74\x41\x6d\x61\x7a\x6f\x6e'];var _Q0ooQoQQ=_Z$2[0],_iiiLLIl1=_Z$2[1];return this.actionType;},enumerable:_0o0[7],configurable:_0o0[7]});var _2SSSZ222=_0o0[2],_00O0OoOo=_0o0[4];Object.defineProperty(AAmationResult.prototype,_0o0[1],{get:function(){var _oO=[.4626468626433853];var _IllLLlIi=_oO[0];return this.acicError;},enumerable:_0o0[7],configurable:_0o0[7]});return AAmationResult;}();exports.AAmationResult=AAmationResult;

/***/ }),

/***/ "./src/data/ACICClientRequest.ts":
/*!***************************************!*\
  !*** ./src/data/ACICClientRequest.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,'\x5f\x5f\x65\x73\x4d\x6f\x64\x75\x6c\x65',{value:true});var ACICClientRequest=function(){var _lL=['\x64\x69\x73\x6d\x69\x73\x73\x43\x61\x6c\x6c\x62\x61\x63\x6b\x46\x75\x6e\x63\x74\x69\x6f\x6e','\x66\x77\x63\x69\x6d\x42\x6c\x6f\x62\x56\x61\x6c\x75\x65',false,'\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x54\x79\x70\x65\x56\x61\x6c\x75\x65','\x63\x6c\x69\x65\x6e\x74\x52\x65\x66\x65\x72\x65\x6e\x63\x65\x49\x64\x56\x61\x6c\x75\x65',15677,null,'\x63\x61\x6c\x6c\x62\x61\x63\x6b\x46\x75\x6e\x63\x74\x69\x6f\x6e',true,.46578072271766,'\x75\x73\x65\x72\x4c\x61\x6e\x67\x75\x61\x67\x65','\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x4c\x6f\x61\x64\x43\x61\x6c\x6c\x62\x61\x63\x6b\x46\x75\x6e\x63\x74\x69\x6f\x6e','\x63\x6c\x69\x65\x6e\x74\x4f\x70\x74\x69\x6f\x6e\x73'];function ACICClientRequest(clientReferenceId,callback,dismissCallback,challengeLoadCallback,clientData,locale,fwcimBlob,externalId,enableHeaderFooter,enableBypassMechanism,enableModalView,challengeType,mode,eventTrigger,aaExternalToken,forceJsFlush,aamationToken){this.clientReferenceId=clientReferenceId;this.callback=callback;this.dismissCallback=dismissCallback||this.defaultDismissCallback;this.challengeLoadCallback=challengeLoadCallback||this.defaultChallengeLoadCallback;this.clientData=clientData||_lL[6];this.externalId=externalId||_lL[6];this.locale=locale||navigator.language||window.navigator[_lL[10]];var _iiI1l1lI=_lL[5],_oQQOQo00=_lL[9];this.fwcimBlob=fwcimBlob||_lL[6];this.enableHeaderFooter=enableHeaderFooter==_lL[2]?enableHeaderFooter:_lL[8];this.enableBypassMechanism=enableBypassMechanism==_lL[8]?enableBypassMechanism:_lL[2];this.enableModalView=enableModalView==_lL[8]?enableModalView:_lL[2];this.challengeType=challengeType||_lL[6];this.mode=mode||_lL[6];this.eventTrigger=eventTrigger||_lL[6];this.aaExternalToken=aaExternalToken||_lL[6];this.forceJsFlush=forceJsFlush==_lL[8]?forceJsFlush:_lL[2];this.aamationToken=aamationToken||_lL[6];}ACICClientRequest.prototype.defaultDismissCallback=function(){var _ZSZ=['\x44\x69\x73\x6d\x69\x73\x73\x20\x63\x61\x6c\x6c\x62\x61\x63\x6b\x20\x6e\x6f\x74\x20\x73\x70\x65\x63\x69\x66\x69\x65\x64',null];console.log(_ZSZ[0]);return _ZSZ[1];};ACICClientRequest.prototype.defaultChallengeLoadCallback=function(){var _SSS=['\x43\x6c\x69\x65\x6e\x74\x20\x63\x61\x6c\x6c\x62\x61\x63\x6b\x20\x6e\x6f\x74\x20\x73\x70\x65\x63\x69\x66\x69\x65\x64\x20\x66\x6f\x72\x20\x63\x68\x61\x6c\x6c\x65\x6e\x67\x65\x20\x70\x61\x67\x65',null];console.log(_SSS[0]);var _iILII1LI=function(_O0oQQ0OQ,_$$zSzsSs){var _i1i=[13454,30599,28005,.5785994069036828,48118,.25555035038222185];var _$2$$z$Ss=_i1i[3],_Q0OooOQO=_i1i[2],_ZSZ$SSz$=_i1i[4];var _0QQQO0OQ=_i1i[5],_LiIlLl1i=_i1i[0];return _i1i[1];};return _SSS[1];};Object.defineProperty(ACICClientRequest.prototype,_lL[4],{get:function(){var _0OQ=[];return this.clientReferenceId;},enumerable:_lL[8],configurable:_lL[8]});Object.defineProperty(ACICClientRequest.prototype,_lL[1],{get:function(){var _o00=[];return this.fwcimBlob;},enumerable:_lL[8],configurable:_lL[8]});Object.defineProperty(ACICClientRequest.prototype,_lL[7],{get:function(){var _L1=['\x65\x78\x65\x63\x75\x74\x65\x42\x6f\x64\x79'];var _SZ$$zs$Z=_L1[0];return this.callback;},enumerable:_lL[8],configurable:_lL[8]});Object.defineProperty(ACICClientRequest.prototype,_lL[0],{get:function(){var _lii=[];return this.dismissCallback;},enumerable:_lL[8],configurable:_lL[8]});Object.defineProperty(ACICClientRequest.prototype,_lL[11],{get:function(){var _I11=[];var _S2$22$zZ=function(_zzSSZz$$){var _QO0=[.530506330800282,24186,.9800069948465704];var _lILL1Ll1=_QO0[2],_IL1iIlii=_QO0[0];return _QO0[1];};return this.challengeLoadCallback;},enumerable:_lL[8],configurable:_lL[8]});Object.defineProperty(ACICClientRequest.prototype,_lL[12],{get:function(){var _L1l=[.980187645076696,.41647404259157295];var _QQQQoOQo=_L1l[0],_ZzZ2$2S2=_L1l[1];return{clientData:this.clientData,challengeType:this.challengeType,locale:this.locale,externalId:this.externalId,enableHeaderFooter:this.enableHeaderFooter,enableBypassMechanism:this.enableBypassMechanism,enableModalView:this.enableModalView,eventTrigger:this.eventTrigger,aaExternalToken:this.aaExternalToken,forceJsFlush:this.forceJsFlush,aamationToken:this.aamationToken};},enumerable:_lL[8],configurable:_lL[8]});Object.defineProperty(ACICClientRequest.prototype,_lL[3],{get:function(){var _LI=['\x75\x73\x65\x72\x61\x67\x65\x6e\x74\x4f\x62\x66\x75\x73\x63\x61\x74\x65'];var _oO00O0oQ=_LI[0];return this.challengeType;},set:function(challengeType){var _o000=[.1288551560253821,.6043763902766965];var _OOQOOOoO=_o000[0],_IiILIIiI=_o000[1];this.challengeType=challengeType;},enumerable:_lL[8],configurable:_lL[8]});return ACICClientRequest;}();exports.ACICClientRequest=ACICClientRequest;

/***/ }),

/***/ "./src/data/ACICError.ts":
/*!*******************************!*\
  !*** ./src/data/ACICError.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,'\x5f\x5f\x65\x73\x4d\x6f\x64\x75\x6c\x65',{value:true});var ACICErrorName;(function(ACICErrorName){var _iLI=['\x45\x6d\x70\x74\x79\x52\x65\x73\x70\x6f\x6e\x73\x65','\x42\x41\x44\x5f\x52\x45\x51\x55\x45\x53\x54\x5f\x45\x52\x52\x4f\x52','\x42\x61\x64\x52\x65\x71\x75\x65\x73\x74\x45\x72\x72\x6f\x72','\x4e\x45\x54\x57\x4f\x52\x4b\x5f\x45\x52\x52\x4f\x52','\x48\x54\x54\x50\x45\x72\x72\x6f\x72','\x54\x69\x6d\x65\x6f\x75\x74','\x54\x49\x4d\x45\x4f\x55\x54','\x4e\x65\x74\x77\x6f\x72\x6b\x45\x72\x72\x6f\x72','\x45\x4d\x50\x54\x59\x5f\x52\x45\x53\x50\x4f\x4e\x53\x45','\x48\x54\x54\x50\x5f\x45\x52\x52\x4f\x52'];ACICErrorName[_iLI[6]]=_iLI[5];ACICErrorName[_iLI[3]]=_iLI[7];ACICErrorName[_iLI[8]]=_iLI[0];var _L1IIilL1=function(_SZ$zSz2$,_sS2sZsZs){var _sss=[37845,4345,.08415353354689037,'\x64\x6f\x63\x75\x6d\x65\x6e\x74'];var _Z$$z$$ZS=_sss[2],_OOOQQOoQ=_sss[3],_$ZS2$$ZZ=_sss[1];return _sss[0];};ACICErrorName[_iLI[9]]=_iLI[4];ACICErrorName[_iLI[1]]=_iLI[2];}(ACICErrorName=exports.ACICErrorName||(exports.ACICErrorName={})));var ACICError=function(){var _iIl=['\x6a\x73\x6f\x6e\x43\x6f\x6c\x6c\x65\x63\x74\x6f\x72','\x65\x72\x72\x6f\x72\x4e\x61\x6d\x65\x56\x61\x6c\x75\x65',true,27372];function ACICError(name){var _2s$$22s2=_iIl[3],_0QoQOo0O=_iIl[0];this.errorName=name;}Object.defineProperty(ACICError.prototype,_iIl[1],{get:function(){var _11i=[.2458919781700779,'\x65\x78\x65\x63\x75\x74\x65\x42',42657];var _z2SZ2z$Z=_11i[2],_IilL1111=_11i[0],_o0oQoooO=_11i[1];return this.errorName;},enumerable:_iIl[2],configurable:_iIl[2]});return ACICError;}();exports.ACICError=ACICError;

/***/ }),

/***/ "./src/data/ACICSessionContext.ts":
/*!****************************************!*\
  !*** ./src/data/ACICSessionContext.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,'\x5f\x5f\x65\x73\x4d\x6f\x64\x75\x6c\x65',{value:true});var ACICSessionContext=function(){var _0Oo=[.6295393522182673];function ACICSessionContext(){this.aamationResults=[];var _zzzs$SZs=_0Oo[0];this.userResponses=[];}ACICSessionContext.prototype.addResponse=function(response){var _$ss=[];this.userResponses.push(response);};ACICSessionContext.prototype.addResult=function(result){var _S$=[];var _o0oOoo0o=function(_O0QoQ0oQ,_OO00QQoO){var _oo00=[17194,'\x62',46907,1864,'\x73\x74\x61\x74\x65\x6d\x65\x6e\x74\x42\x6f\x64\x79',.06388179721955733];var _O0oQ0QOo=_oo00[5],_O0QoQO0o=_oo00[3];var _0OQQOQoo=_oo00[4];var _Q00Qo0OO=_oo00[2],_2Zz$Z$Zs=_oo00[0];return _oo00[1];};this.aamationResults.push(result);};return ACICSessionContext;}();exports.ACICSessionContext=ACICSessionContext;

/***/ }),

/***/ "./src/data/ACICUserResponse.ts":
/*!**************************************!*\
  !*** ./src/data/ACICUserResponse.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,'\x5f\x5f\x65\x73\x4d\x6f\x64\x75\x6c\x65',{value:true});var ACICUserResponse=function(){var _1I=[];function ACICUserResponse(challengeType,data){this.challengeType=challengeType;this.data=data;}return ACICUserResponse;}();exports.ACICUserResponse=ACICUserResponse;

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __importDefault=this&&this.__importDefault||function(mod){var _OQ=[];return mod&&mod.__esModule?mod:{'\x64\x65\x66\x61\x75\x6c\x74':mod};};Object.defineProperty(exports,'\x5f\x5f\x65\x73\x4d\x6f\x64\x75\x6c\x65',{value:true});var acic_1=__webpack_require__(/*! ./acic */ "./src/acic.ts");var katal_logger_1=__importDefault(__webpack_require__(/*! @amzn/katal-logger */ "./node_modules/@amzn/katal-logger/dist/index.js"));var KatalEndpointResolver_1=__webpack_require__(/*! ./KatalEndpointResolver */ "./src/KatalEndpointResolver.ts");if(!String.prototype.startsWith){var _OQQ000Q0=.47494648455955635,_z$2szSS$=.7568743681199162;console.log('\x41\x64\x64\x69\x6e\x67\x20\x70\x6f\x6c\x79\x66\x69\x6c\x6c\x20\x66\x6f\x72\x20\x73\x74\x61\x72\x74\x73\x57\x69\x74\x68');Object.defineProperty(String.prototype,'\x73\x74\x61\x72\x74\x73\x57\x69\x74\x68',{value:function(search,rawPos){var _$z=[0];var pos=rawPos>_$z[0]?rawPos|_$z[0]:_$z[0];return this.substring(pos,pos+search.length)===search;}});}if(!String.prototype.endsWith){var _Q0QO0OQO=.08594482172218343;console.log('\x41\x64\x64\x69\x6e\x67\x20\x70\x6f\x6c\x79\x66\x69\x6c\x6c\x20\x66\x6f\x72\x20\x65\x6e\x64\x73\x57\x69\x74\x68');String.prototype.endsWith=function(search,this_len){var _z$=[];if(this_len===undefined||this_len>this.length){var _Ili1il1L=function(_zzZSzZs2,_lIIILiIi,_QQ00OOQo){var _IL=['\x61',13871,.8075930749074824,12827];var _0ooQo0OO=_IL[3],_liLIliLI=_IL[2],_111I1liI=_IL[0];return _IL[1];};this_len=this.length;}var _lIIllILl=function(_1l1I1lLi){var _Qo=['\x64\x6f\x6d\x45\x6c',42337,'\x62\x6f\x64\x79\x44\x6f\x6d\x55\x73\x65\x72\x61\x67\x65\x6e\x74',9235,.14955154573483442,.9943932376810751];var _O0ooO0Q0=_Qo[1],_IiI1ILll=_Qo[3];var _o0ooQO0Q=_Qo[5],_QO0QoQQ0=_Qo[2],_1iLliIlI=_Qo[0];return _Qo[4];};return this.substring(this_len-search.length,this_len)===search;};}var acicKatalLogger=new katal_logger_1.default({url:KatalEndpointResolver_1.KatalEndpointResolver.getKatalLoggerEndpoint()});var acic=new acic_1.ACIC(acicKatalLogger);window.acic=acic;

/***/ }),

/***/ 0:
/*!*******************************!*\
  !*** ./nodejsShims (ignored) ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 1:
/*!*******************************!*\
  !*** ./nodejsShims (ignored) ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9kaXN0L2hlbHBlci9tZXRyaWNzLWFnZ3JlZ2F0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9kaXN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvZGlzdC9tZXRyaWNzL2thdGFsLW1ldHJpY3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9kaXN0L21ldHJpY3MvbWV0cmljcy1wdWJsaXNoZXItc2luZ2xldG9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MtZHJpdmVyLXN1c2hpL2Rpc3QvS2F0YWxNZXRyaWNzRHJpdmVyU3VzaGkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy1kcml2ZXItc3VzaGkvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9LYXRhbE1ldHJpY3NDb250ZXh0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL0thdGFsTWV0cmljc1B1Ymxpc2hlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9kcml2ZXIvRXJyb3JIYW5kbGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL2RyaXZlci9LYXRhbE1ldHJpY3NEcml2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvaGVscGVyL0ZpcnN0TWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL2hlbHBlci9PYmplY3RWYWx1ZXNQb255ZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9oZWxwZXIvVmFsaWRhdGVTaW1wbGVJbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvaGVscGVyL1ZhbGlkYXRlU2ltcGxlU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL2hlbHBlci9lbWJlZFJlcXVlc3RJZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9oZWxwZXIvbWVyZ2VMaXN0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9oZWxwZXIvbWV0cmljc0V4dGVuc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9tZXRyaWNPYmplY3QvS2F0YWxNZXRyaWNDb3VudGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL21ldHJpY09iamVjdC9LYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL21ldHJpY09iamVjdC9LYXRhbE1ldHJpY0luaXRpYWxpemF0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL21ldHJpY09iamVjdC9LYXRhbE1ldHJpY05hbWVkT2JqZWN0TGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9tZXRyaWNPYmplY3QvS2F0YWxNZXRyaWNPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvbWV0cmljT2JqZWN0L0thdGFsTWV0cmljT2JqZWN0TGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9tZXRyaWNPYmplY3QvS2F0YWxNZXRyaWNTdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvbWV0cmljT2JqZWN0L0thdGFsTWV0cmljVGltZWRBdHRlbXB0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL21ldHJpY09iamVjdC9LYXRhbE1ldHJpY1RpbWVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL21ldHJpY09iamVjdC9LYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL21ldHJpY09iamVjdC9LYXRhbE1ldHJpY1R5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvbWV0cmljT2JqZWN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLXN1c2hpLWNsaWVudC9kaXN0L1N1c2hpQ2xpZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlMaWtlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5V2l0aG91dEhvbGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlV2lsZGNhcmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9ub25JdGVyYWJsZVNwcmVhZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFNwcmVhZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXRQcm90b3R5cGVPZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3N1cGVyUHJvcEJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL2Vycm9yLXN0YWNrLXBhcnNlci9lcnJvci1zdGFjay1wYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvcHJvbWlzZS1wb2x5ZmlsbC9zcmMvZmluYWxseS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9wcm9taXNlLXBvbHlmaWxsL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9hcnJheS1zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvYmFzZTY0LXZscS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9iYXNlNjQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvYmluYXJ5LXNlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9tYXBwaW5nLWxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvcXVpY2stc29ydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwLWNvbnN1bWVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAtZ2VuZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1ub2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9zb3VyY2UtbWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL3N0YWNrLWdlbmVyYXRvci9zdGFjay1nZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLWxvZ2dlci9ub2RlX21vZHVsZXMvc3RhY2tmcmFtZS9zdGFja2ZyYW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL3N0YWNrdHJhY2UtZ3BzL3N0YWNrdHJhY2UtZ3BzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1sb2dnZXIvbm9kZV9tb2R1bGVzL3N0YWNrdHJhY2UtanMvc3RhY2t0cmFjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy91dWlkL2xpYi9ieXRlc1RvVXVpZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy91dWlkL2xpYi9ybmctYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbG9nZ2VyL25vZGVfbW9kdWxlcy91dWlkL3Y0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzLWRyaXZlci1zdXNoaS9kaXN0L0thdGFsTWV0cmljc0RyaXZlclN1c2hpLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzLWRyaXZlci1zdXNoaS9kaXN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9LYXRhbE1ldHJpY3NDb250ZXh0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9LYXRhbE1ldHJpY3NQdWJsaXNoZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL2RyaXZlci9FcnJvckhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL2RyaXZlci9LYXRhbE1ldHJpY3NEcml2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL2hlbHBlci9GaXJzdE1hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvaGVscGVyL09iamVjdFZhbHVlc1BvbnlmaWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9oZWxwZXIvVmFsaWRhdGVTaW1wbGVJbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL2hlbHBlci9WYWxpZGF0ZVNpbXBsZVN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvaGVscGVyL2VtYmVkUmVxdWVzdElkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9oZWxwZXIvbWVyZ2VMaXN0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvaGVscGVyL21ldHJpY3NFeHRlbnNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL2hlbHBlci92YWxpZGF0ZUNsb3VkV2F0Y2hEaW1lbnNpb25zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvbWV0cmljT2JqZWN0L0thdGFsTWV0cmljQ291bnRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvbWV0cmljT2JqZWN0L0thdGFsTWV0cmljSHR0cFJlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL21ldHJpY09iamVjdC9LYXRhbE1ldHJpY0luaXRpYWxpemF0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9tZXRyaWNPYmplY3QvS2F0YWxNZXRyaWNOYW1lZE9iamVjdExpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL21ldHJpY09iamVjdC9LYXRhbE1ldHJpY09iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvbWV0cmljT2JqZWN0L0thdGFsTWV0cmljT2JqZWN0TGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvbWV0cmljT2JqZWN0L0thdGFsTWV0cmljU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9tZXRyaWNPYmplY3QvS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbXpuL2thdGFsLW1ldHJpY3MvbGliL21ldHJpY09iamVjdC9LYXRhbE1ldHJpY1RpbWVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi9tZXRyaWNPYmplY3QvS2F0YWxNZXRyaWNUaW1lclN0b3B3YXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvbWV0cmljT2JqZWN0L0thdGFsTWV0cmljVHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtbWV0cmljcy9saWIvbWV0cmljT2JqZWN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYW16bi9rYXRhbC1tZXRyaWNzL2xpYi90eXBlcy9DbG91ZFdhdGNoRGltZW5zaW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFtem4va2F0YWwtc3VzaGktY2xpZW50L2Rpc3QvU3VzaGlDbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlMaWtlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhvdXRIb2xlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVTcHJlYWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2V0UHJvdG90eXBlT2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc3VwZXJQcm9wQmFzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b1ByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b1Byb3BlcnR5S2V5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnVpbGQtdXJsLXRzL2Rpc3QvYnVpbGQtdXJsLmpzIiwid2VicGFjazovLy8uL3NyYy9jc3MvaWZyYW1lLmNzcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Jlc2l6ZS1vYnNlcnZlci1wb2x5ZmlsbC9kaXN0L1Jlc2l6ZU9ic2VydmVyLmVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXVpZC9saWIvYnl0ZXNUb1V1aWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3V1aWQvbGliL3JuZy1icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dWlkL3Y0LmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0hvc3RuYW1lUmVzb2x2ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0thdGFsRW5kcG9pbnRSZXNvbHZlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYWNpYy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY3NzL2lmcmFtZS5jc3M/ZWJjYyIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS9BQW1hdGlvblJlc3VsdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS9BQ0lDQ2xpZW50UmVxdWVzdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS9BQ0lDRXJyb3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhdGEvQUNJQ1Nlc3Npb25Db250ZXh0LnRzIiwid2VicGFjazovLy8uL3NyYy9kYXRhL0FDSUNVc2VyUmVzcG9uc2UudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LnRzIiwid2VicGFjazovLy8uL25vZGVqc1NoaW1zIChpZ25vcmVkKT81ZWUwIiwid2VicGFjazovLy8uL25vZGVqc1NoaW1zIChpZ25vcmVkKSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLEtBQUs7UUFDTDtRQUNBOztRQUVBO1FBQ0E7UUFDQSxpREFBaUQsY0FBYztRQUMvRDs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwyQkFBMkIsMEJBQTBCLEVBQUU7UUFDdkQsaUNBQWlDLGVBQWU7UUFDaEQ7UUFDQTtRQUNBOztRQUVBO1FBQ0Esc0RBQXNELCtEQUErRDs7UUFFckg7UUFDQTs7O1FBR0E7UUFDQTs7Ozs7Ozs7Ozs7OztBQ25FYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw4Qzs7Ozs7Ozs7Ozs7O0FDN0JhO0FBQ2I7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxRQUFRO0FBQ3pELHdDQUF3QyxRQUFRO0FBQ2hELHdEQUF3RCxRQUFRO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSx5Q0FBeUMsbUJBQU8sQ0FBQyxzR0FBa0I7QUFDbkUsc0NBQXNDLG1CQUFPLENBQUMsaUdBQWU7QUFDN0Qsc0JBQXNCLG1CQUFPLENBQUMsZ0dBQXlCO0FBQ3ZELDJCQUEyQixtQkFBTyxDQUFDLHdHQUE2QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOENBQThDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2IsK0xBQStMO0FBQy9MO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFB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O0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUZBQW1GLGFBQWE7QUFDaEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQSxzRkFBc0YsZUFBZTtBQUNyRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQSwrRUFBK0UsZUFBZTtBQUM5RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLCtFQUErRSxlQUFlO0FBQzlGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDLFk7Ozs7Ozs7Ozs7OztBQ3ZUWTs7QUFFYiw4QkFBOEIsbUJBQU8sQ0FBQyxzSkFBK0M7O0FBRXJGLDZCQUE2QixtQkFBTyxDQUFDLG9KQUE4Qzs7QUFFbkY7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSw4Q0FBOEMsbUJBQU8sQ0FBQyxzSUFBdUM7O0FBRTdGLDJDQUEyQyxtQkFBTyxDQUFDLGdJQUFvQzs7QUFFdkYsOENBQThDLG1CQUFPLENBQUMsc0lBQXVDOztBQUU3RixnQ0FBZ0MsbUJBQU8sQ0FBQywwRUFBUzs7QUFFakQsa0RBQWtELG1CQUFPLENBQUMsNEhBQXVCOztBQUVqRixnREFBZ0QsbUJBQU8sQ0FBQyxrSkFBa0M7O0FBRTFGLDJDQUEyQyxtQkFBTyxDQUFDLDBGQUFHOztBQUV0RCxnREFBZ0QsbUJBQU8sQ0FBQyxrSkFBa0M7O0FBRTFGLGtCQUFrQixtQkFBTyxDQUFDLHdIQUFxQjs7QUFFL0Msd0JBQXdCLG1CQUFPLENBQUMsb0lBQTJCOztBQUUzRCxzQkFBc0IsbUJBQU8sQ0FBQyxnSUFBeUI7O0FBRXZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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LFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUN2R0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMseUZBQVU7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixNQUFNO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzREFBc0QsWUFBWTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGNBQWM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3Q0FBd0M7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxtQkFBbUIsRUFBRTtBQUNwRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsTUFBTTtBQUNuQztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDLHFCQUFxQiwrQ0FBK0M7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7QUFDQSxxQkFBcUIsNEJBQTRCO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDempDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsaUdBQWM7QUFDdEMsV0FBVyxtQkFBTyxDQUFDLHFGQUFRO0FBQzNCLGVBQWUsbUJBQU8sQ0FBQywrRkFBYTtBQUNwQyxrQkFBa0IsbUJBQU8sQ0FBQyxxR0FBZ0I7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQ25aQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLG1CQUFPLENBQUMscUhBQXdCO0FBQ3pELFdBQVcsbUJBQU8sQ0FBQyxxRkFBUTs7QUFFM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQSxtRUFBbUUsbUJBQW1CO0FBQ3RGO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1GQUFtRixhQUFhO0FBQ2hHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esc0ZBQXNGLGVBQWU7QUFDckc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsK0VBQStFLGVBQWU7QUFDOUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQSwrRUFBK0UsZUFBZTtBQUM5RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQyxJOzs7Ozs7Ozs7Ozs7QUNuVVk7O0FBRWIsNkJBQTZCLG1CQUFPLENBQUMsb0hBQThDOztBQUVuRjtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLDhDQUE4QyxtQkFBTyxDQUFDLHNHQUF1Qzs7QUFFN0YsMkNBQTJDLG1CQUFPLENBQUMsZ0dBQW9DOztBQUV2Riw4Q0FBOEMsbUJBQU8sQ0FBQyxzR0FBdUM7O0FBRTdGLGdDQUFnQyxtQkFBTyxDQUFDLDBDQUFTOztBQUVqRCxrREFBa0QsbUJBQU8sQ0FBQyw0RkFBdUI7O0FBRWpGLG9CQUFvQixtQkFBTyxDQUFDLG9GQUFnQjs7QUFFNUMsa0JBQWtCLG1CQUFPLENBQUMsd0ZBQXFCOztBQUUvQyx3QkFBd0IsbUJBQU8sQ0FBQyxvR0FBMkI7O0FBRTNELHNCQUFzQixtQkFBTyxDQUFDLGdHQUF5Qjs7QUFFdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRCx3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O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixzQkFBc0I7QUFDL0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0EsYUFBYTtB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QUFrQyxvSkFBb0osc0NBQXNDLHVEQUF1RCxnQkFBZ0IsbUVBQW1FLGdEQUFnRCwyRUFBMkUsRUFBRSwwQ0FBMEMsaUI7Ozs7Ozs7Ozs7O0FDQWxnRSxlOzs7Ozs7Ozs7OztBQ0FBLGUiLCJmaWxlIjoiYWNpYy5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9pbmRleC50c1wiKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NZXRyaWNzQWdncmVnYXRvciA9IHZvaWQgMDtcbnZhciBNZXRyaWNzQWdncmVnYXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZXRyaWNzQWdncmVnYXRvcihmaWx0ZXJGdW5jdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmZpbHRlckZ1bmN0aW9uID0gZmlsdGVyRnVuY3Rpb247XG4gICAgICAgIHRoaXMuYWdncmVnYXRlZE1ldHJpY3MgPSB7fTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2thdGFsLm1ldHJpY3MucHVibGlzaCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgX3RoaXMuYWdncmVnYXRlTWV0cmljKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIE1ldHJpY3NBZ2dyZWdhdG9yLnByb3RvdHlwZS5hZ2dyZWdhdGVNZXRyaWMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hID0gZXZlbnQuZGV0YWlsLCBtZXRyaWMgPSBfYS5tZXRyaWMsIGNvbnRleHQgPSBfYS5jb250ZXh0O1xuICAgICAgICB2YXIgc2VydmljZU5hbWUgPSBjb250ZXh0LnNlcnZpY2VOYW1lLCBtZXRob2ROYW1lID0gY29udGV4dC5tZXRob2ROYW1lO1xuICAgICAgICBpZiAodGhpcy5maWx0ZXJGdW5jdGlvbiAmJiAhdGhpcy5maWx0ZXJGdW5jdGlvbihtZXRyaWMsIGNvbnRleHQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZ2dyZWdhdGVkTWV0cmljc1tzZXJ2aWNlTmFtZV0gPVxuICAgICAgICAgICAgdGhpcy5hZ2dyZWdhdGVkTWV0cmljc1tzZXJ2aWNlTmFtZV0gfHwge307XG4gICAgICAgIHRoaXMuYWdncmVnYXRlZE1ldHJpY3Nbc2VydmljZU5hbWVdW21ldGhvZE5hbWVdID1cbiAgICAgICAgICAgIHRoaXMuYWdncmVnYXRlZE1ldHJpY3Nbc2VydmljZU5hbWVdW21ldGhvZE5hbWVdIHx8IHt9O1xuICAgICAgICB0aGlzLmFnZ3JlZ2F0ZWRNZXRyaWNzW3NlcnZpY2VOYW1lXVttZXRob2ROYW1lXVttZXRyaWMubmFtZV0gPVxuICAgICAgICAgICAgdGhpcy5hZ2dyZWdhdGVkTWV0cmljc1tzZXJ2aWNlTmFtZV1bbWV0aG9kTmFtZV1bbWV0cmljLm5hbWVdIHx8IFtdO1xuICAgICAgICB0aGlzLmFnZ3JlZ2F0ZWRNZXRyaWNzW3NlcnZpY2VOYW1lXVttZXRob2ROYW1lXVttZXRyaWMubmFtZV0ucHVzaChtZXRyaWMudmFsdWUpO1xuICAgIH07XG4gICAgcmV0dXJuIE1ldHJpY3NBZ2dyZWdhdG9yO1xufSgpKTtcbmV4cG9ydHMuTWV0cmljc0FnZ3JlZ2F0b3IgPSBNZXRyaWNzQWdncmVnYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ldHJpY3MtYWdncmVnYXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19zcHJlYWRBcnJheXMgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xuICAgIHJldHVybiByO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGV2ZWwgPSB2b2lkIDA7XG52YXIgcHJvbWlzZV9wb2x5ZmlsbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwcm9taXNlLXBvbHlmaWxsXCIpKTtcbnZhciBzdGFja3RyYWNlX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInN0YWNrdHJhY2UtanNcIikpO1xudmFyIGthdGFsX21ldHJpY3NfMSA9IHJlcXVpcmUoXCIuL21ldHJpY3Mva2F0YWwtbWV0cmljc1wiKTtcbnZhciBtZXRyaWNzX2FnZ3JlZ2F0b3JfMSA9IHJlcXVpcmUoXCIuL2hlbHBlci9tZXRyaWNzLWFnZ3JlZ2F0b3JcIik7XG52YXIgTGV2ZWw7XG4oZnVuY3Rpb24gKExldmVsKSB7XG4gICAgTGV2ZWxbXCJERUJVR1wiXSA9IFwiZGVidWdcIjtcbiAgICBMZXZlbFtcIklORk9cIl0gPSBcImluZm9cIjtcbiAgICBMZXZlbFtcIldBUk5cIl0gPSBcIndhcm5cIjtcbiAgICBMZXZlbFtcIkVSUk9SXCJdID0gXCJlcnJvclwiO1xuICAgIExldmVsW1wiRkFUQUxcIl0gPSBcImZhdGFsXCI7XG59KShMZXZlbCA9IGV4cG9ydHMuTGV2ZWwgfHwgKGV4cG9ydHMuTGV2ZWwgPSB7fSkpO1xudmFyIExPR19MRVZFTFMgPSBbXG4gICAgTGV2ZWwuREVCVUcsXG4gICAgTGV2ZWwuSU5GTyxcbiAgICBMZXZlbC5XQVJOLFxuICAgIExldmVsLkVSUk9SLFxuICAgIExldmVsLkZBVEFMLFxuXTtcbnZhciBERUZBVUxUX01BWF9MT0dfTElORV9TSVpFID0gMTAwMDA7IC8vIDEwIGtpbG9ieXRlcyBkZWZhdWx0XG52YXIgREVGQVVMVF9CQVRDSF9USU1FT1VUX0RVUkFUSU9OID0gNTAwMDtcbnZhciBERUZBVUxUX01BWF9MT0dTX1BFUl9CQVRDSCA9IDI1O1xudmFyIENPTkZJR19ERUZBVUxUUyA9IHtcbiAgICBsb2dUaHJlc2hvbGQ6IExldmVsLkRFQlVHLFxuICAgIG1heExvZ0xpbmVTaXplOiBERUZBVUxUX01BWF9MT0dfTElORV9TSVpFLFxuICAgIGJhdGNoVGltZW91dER1cmF0aW9uOiBERUZBVUxUX0JBVENIX1RJTUVPVVRfRFVSQVRJT04sXG4gICAgZGVjb2RlU3RhY2tUcmFjZTogZmFsc2UsXG4gICAgcmVjb3JkTWV0cmljczogdHJ1ZSxcbiAgICBjb250ZXh0OiB7fSxcbiAgICBoZWFkZXJzOiB7fSxcbiAgICBsb2dUb0NvbnNvbGU6IGZhbHNlLFxuICAgIG1heExvZ3NQZXJCYXRjaDogREVGQVVMVF9NQVhfTE9HU19QRVJfQkFUQ0gsXG4gICAgdXNlWE1MSHR0cFJlcXVlc3Q6IGZhbHNlLFxufTtcbi8vIG9idGFpbmVkIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50XG52YXIgRVZFTlRfUFJPUEVSVElFUyA9IFtcbiAgICAnYnViYmxlcycsXG4gICAgJ2NhbmNlbEJ1YmJsZScsXG4gICAgJ2NhbmNlbGFibGUnLFxuICAgICdjb21wb3NlZCcsXG4gICAgJ2N1cnJlbnRUYXJnZXQnLFxuICAgICdkZWVwUGF0aCcsXG4gICAgJ2RlZmF1bHRQcmV2ZW50ZWQnLFxuICAgICdldmVudFBoYXNlJyxcbiAgICAnZXhwbGljaXRPcmlnaW5hbFRhcmdldCcsXG4gICAgJ29yaWdpbmFsVGFyZ2V0JyxcbiAgICAncmV0dXJuVmFsdWUnLFxuICAgICdzcmNFbGVtZW50JyxcbiAgICAndGFyZ2V0JyxcbiAgICAndGltZVN0YW1wJyxcbiAgICAndHlwZScsXG4gICAgJ2lzVHJ1c3RlZCcsXG5dO1xudmFyIEVSUk9SX0VWRU5UX1BST1BFUlRJRVMgPSBfX3NwcmVhZEFycmF5cyhFVkVOVF9QUk9QRVJUSUVTLCBbJ21lc3NhZ2UnXSk7XG52YXIgS2F0YWxMb2dnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgS2F0YWxMb2dnZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBLYXRhbExvZ2dlcihjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5yZXNvdXJjZVRpbWluZ0xvZ2dlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNlbmRMb2dzVG9CYWNrZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxvZ3NUb1NlbmQgPSBfdGhpcy5sb2dMaW5lUXVldWU7XG4gICAgICAgICAgICBpZiAobG9nc1RvU2VuZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5sb2dMaW5lUXVldWUgPSBbXTtcbiAgICAgICAgICAgIF90aGlzLmN1cnJlbnRMb2dCYXRjaFNpemUgPSAwO1xuICAgICAgICAgICAgdmFyIGxvZ3MgPSB7XG4gICAgICAgICAgICAgICAgbG9nczogbG9nc1RvU2VuZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfdGhpcy5zZW5kTG9nVG9CYWNrZW5kKF90aGlzLnRvSlNPTihsb2dzKSk7XG4gICAgICAgICAgICBfdGhpcy5xdWV1ZVRpbWVySWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBjb25maWdXaXRoRGVmYXVsdHMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgQ09ORklHX0RFRkFVTFRTKSwgY29uZmlnKTtcbiAgICAgICAgdGhpcy51cmwgPSBjb25maWdXaXRoRGVmYXVsdHMudXJsO1xuICAgICAgICB0aGlzLmxvZ1RocmVzaG9sZCA9IGNvbmZpZ1dpdGhEZWZhdWx0cy5sb2dUaHJlc2hvbGQ7XG4gICAgICAgIHRoaXMubWF4TG9nTGluZVNpemUgPSBjb25maWdXaXRoRGVmYXVsdHMubWF4TG9nTGluZVNpemU7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbmZpZ1dpdGhEZWZhdWx0cy5jb250ZXh0O1xuICAgICAgICB0aGlzLmxvZ1RvQ29uc29sZSA9IGNvbmZpZ1dpdGhEZWZhdWx0cy5sb2dUb0NvbnNvbGU7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGNvbmZpZ1dpdGhEZWZhdWx0cy5oZWFkZXJzO1xuICAgICAgICB0aGlzLnJlY29yZE1ldHJpY3MgPSBjb25maWdXaXRoRGVmYXVsdHMucmVjb3JkTWV0cmljcztcbiAgICAgICAgdGhpcy5iYXRjaFRpbWVvdXREdXJhdGlvbiA9IGNvbmZpZ1dpdGhEZWZhdWx0cy5iYXRjaFRpbWVvdXREdXJhdGlvbjtcbiAgICAgICAgdGhpcy5kZWNvZGVTdGFja1RyYWNlID0gY29uZmlnV2l0aERlZmF1bHRzLmRlY29kZVN0YWNrVHJhY2U7XG4gICAgICAgIHRoaXMubWF4TG9nc1BlckJhdGNoID0gY29uZmlnV2l0aERlZmF1bHRzLm1heExvZ3NQZXJCYXRjaDtcbiAgICAgICAgLy8gU29tZSB0ZWFtcyBhcmUgc2V0dGluZyBtYXhMb2dzUGVyQmF0Y2ggYXMgMCBmb3IgdW5pdCB0ZXN0IGNhc2VzIHdoaWNoIGlzIG1ha2luZyBtYXhMb2dCYXRjaFNpemUgYXMgMFxuICAgICAgICAvLyBhbmQgZHVlIHRvIHdoaWNoIHRoaXMgY2hlY2sgYHRoaXMubWF4TG9nQmF0Y2hTaXplIDwgdGhpcy5tYXhMb2dMaW5lU2l6ZWAgaXMgZmFpbGluZ1xuICAgICAgICAvLyBhbmQgdGhyb3dpbmcgYW4gZXJyb3IgZHVyaW5nIGJ1aWxkIHRpbWUuXG4gICAgICAgIC8vIGh0dHBzOi8vY29kZS5hbWF6b24uY29tL3NlYXJjaD90ZXJtPSUyMm1heExvZ3NQZXJCYXRjaCUzQSswJTIyXG4gICAgICAgIHRoaXMubWF4TG9nQmF0Y2hTaXplID1cbiAgICAgICAgICAgIGNvbmZpZy5tYXhMb2dCYXRjaFNpemUgfHxcbiAgICAgICAgICAgICAgICB0aGlzLm1heExvZ0xpbmVTaXplICogKHRoaXMubWF4TG9nc1BlckJhdGNoIHx8IDEpO1xuICAgICAgICB0aGlzLmN1cnJlbnRMb2dCYXRjaFNpemUgPSAwO1xuICAgICAgICB0aGlzLnhocldpdGhDcmVkZW50aWFscyA9IGNvbmZpZ1dpdGhEZWZhdWx0cy54aHJXaXRoQ3JlZGVudGlhbHM7XG4gICAgICAgIHRoaXMudXNlWE1MSHR0cFJlcXVlc3QgPSBjb25maWdXaXRoRGVmYXVsdHMudXNlWE1MSHR0cFJlcXVlc3Q7XG4gICAgICAgIHRoaXMubG9nTGluZVF1ZXVlID0gW107XG4gICAgICAgIHRoaXMudW5yZWdpc3RlckZucyA9IFtdO1xuICAgICAgICB0aGlzLnVubG9hZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubG9nVGhyZXNob2xkSW5kZXggPSBNYXRoLm1heChMT0dfTEVWRUxTLmluZGV4T2YoTGV2ZWwuREVCVUcpLCBMT0dfTEVWRUxTLmluZGV4T2YodGhpcy5sb2dUaHJlc2hvbGQpKTtcbiAgICAgICAgaWYgKHRoaXMubWF4TG9nQmF0Y2hTaXplIDwgdGhpcy5tYXhMb2dMaW5lU2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWF4TG9nQmF0Y2hTaXplKFwiICsgdGhpcy5tYXhMb2dCYXRjaFNpemUgKyBcIikgbXVzdCBiZSBncmVhdGVyIHRoYW4gbWF4TG9nTGluZVNpemUoXCIgKyB0aGlzLm1heExvZ0xpbmVTaXplICsgXCIpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWdXaXRoRGVmYXVsdHMuc2VuZFRvQmFja2VuZE92ZXJyaWRlICYmXG4gICAgICAgICAgICB0eXBlb2YgY29uZmlnV2l0aERlZmF1bHRzLnNlbmRUb0JhY2tlbmRPdmVycmlkZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5zZW5kTG9nVG9CYWNrZW5kID0gY29uZmlnV2l0aERlZmF1bHRzLnNlbmRUb0JhY2tlbmRPdmVycmlkZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWNvcmRNZXRyaWNzKSB7XG4gICAgICAgICAgICB0aGlzLm1ldHJpY3NQdWJsaXNoZXIgPSBrYXRhbF9tZXRyaWNzXzEuY3JlYXRlTWV0cmljc1B1Ymxpc2hlcignS2F0YWxMb2dnZXI6TG9hZGVkJyk7XG4gICAgICAgICAgICB0aGlzLm1ldHJpY3NQdWJsaXNoZXIucHVibGlzaENvdW50ZXJNb25pdG9yKCdLYXRhbExvZ2dlcjpjb25zdHJ1Y3QnLCAxKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZ2lzdGVyVW5sb2FkQWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnVubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIF90aGlzLnNlbmRMb2dzVG9CYWNrZW5kKCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoaXMudW5sb2FkZWQgdG8gZmFsc2UgdG8gY29udGludWUgcXVldWVpbmcgdGhlIGxvZ3NcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVnaXN0ZXJCYWNrVG9QYWdlQWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnVubG9hZGVkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3ZlciBhbGwgb2YgdGhlIHVubG9hZCBjYXNlczpcbiAgICAgKiBodHRwczovL3d3dy5pZ3ZpdGEuY29tLzIwMTUvMTEvMjAvZG9udC1sb3NlLXVzZXItYW5kLWFwcC1zdGF0ZS11c2UtcGFnZS12aXNpYmlsaXR5L1xuICAgICAqL1xuICAgIEthdGFsTG9nZ2VyLnByb3RvdHlwZS5yZWdpc3RlclVubG9hZEFjdGlvbiA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyRXZlbnQoJ3BhZ2VoaWRlJywgY2FsbGJhY2spO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyRXZlbnQoJ2JlZm9yZXVubG9hZCcsIGNhbGxiYWNrKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckV2ZW50KCd2aXNpYmlsaXR5Y2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ2hpZGRlbicpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSB1c2VyIGNvbWVzIGJhY2sgdG8gdGhlIHBhZ2VcbiAgICAgKiBodHRwczovL3QuY29ycC5hbWF6b24uY29tL0Q2OTkyNzQ2MFxuICAgICAqL1xuICAgIEthdGFsTG9nZ2VyLnByb3RvdHlwZS5yZWdpc3RlckJhY2tUb1BhZ2VBY3Rpb24gPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlckV2ZW50KCdwYWdlc2hvdycsIGNhbGxiYWNrKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckV2ZW50KCd2aXNpYmlsaXR5Y2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ3Zpc2libGUnKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMb2cgYSBjb3B5IG9mIEthdGFsIE1ldHJpY3MgZW1pdHRlZCBvbiB0aGlzIHBhZ2VcbiAgICAgKiBAcGFyYW0gZmlsdGVyRnVuY3Rpb246IGFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGZpbHRlciBtZXRyaWNzIGJlZm9yZSBwdWJsaXNoaW5nXG4gICAgICovXG4gICAgS2F0YWxMb2dnZXIucHJvdG90eXBlLmFkZE1ldHJpY3NMaXN0ZW5lciA9IGZ1bmN0aW9uIChmaWx0ZXJGdW5jdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYWdncmVnYXRvciA9IG5ldyBtZXRyaWNzX2FnZ3JlZ2F0b3JfMS5NZXRyaWNzQWdncmVnYXRvcihmaWx0ZXJGdW5jdGlvbik7XG4gICAgICAgIHZhciB1bmxvYWRlZEFscmVhZHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZWdpc3RlclVubG9hZEFjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodW5sb2FkZWRBbHJlYWR5KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHVubG9hZGVkQWxyZWFkeSA9IHRydWU7XG4gICAgICAgICAgICBfdGhpcy5pbmZvKCdLYXRhbCBNZXRyaWNzJywgYWdncmVnYXRvci5hZ2dyZWdhdGVkTWV0cmljcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGZvcm1hdHRlZCB2ZXJzaW9uIG9mIFBlcmZvcm1hbmNlIEFQSSBsb2dzLlxuICAgICAqIFVzZXMgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1BlcmZvcm1hbmNlL2dldEVudHJpZXNcbiAgICAgKiB0byBkZXRlcm1pbmUgcmVzb3VyY2UgYW5kIHBhaW50IHRpbWluZ3MuXG4gICAgICovXG4gICAgS2F0YWxMb2dnZXIucHJvdG90eXBlLmFkZFBlcmZvcm1hbmNlTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJVbmxvYWRBY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMubG9nUmVzb3VyY2VUaW1pbmcoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBLYXRhbExvZ2dlci5wcm90b3R5cGUubG9nUmVzb3VyY2VUaW1pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0aGlzLnJlc291cmNlVGltaW5nTG9nZ2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNvdXJjZVRpbWluZ0xvZ2dlZCA9IHRydWU7XG4gICAgICAgIHZhciByZXNvdXJjZSA9IHdpbmRvdy5wZXJmb3JtYW5jZVxuICAgICAgICAgICAgLmdldEVudHJpZXNCeVR5cGUoJ3Jlc291cmNlJylcbiAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcmVzb3VyY2VUaW1pbmcpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBfYiA9IHJlc291cmNlVGltaW5nLCBuYW1lID0gX2IubmFtZSwgaW5pdGlhdG9yVHlwZSA9IF9iLmluaXRpYXRvclR5cGUsIGR1cmF0aW9uID0gX2IuZHVyYXRpb247XG4gICAgICAgICAgICB2YXIgcmVzb3VyY2UgPSBuYW1lLnNwbGl0KCcvJykucG9wKCk7XG4gICAgICAgICAgICBhY2NbaW5pdGlhdG9yVHlwZV0gPSAoX2EgPSBhY2NbaW5pdGlhdG9yVHlwZV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9O1xuICAgICAgICAgICAgYWNjW2luaXRpYXRvclR5cGVdW3Jlc291cmNlXSA9IE1hdGgucm91bmQoZHVyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgICAgICB2YXIgcGFpbnQgPSB3aW5kb3cucGVyZm9ybWFuY2VcbiAgICAgICAgICAgIC5nZXRFbnRyaWVzQnlUeXBlKCdwYWludCcpXG4gICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChhY2MsIF9hKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IF9hLm5hbWUsIHN0YXJ0VGltZSA9IF9hLnN0YXJ0VGltZTtcbiAgICAgICAgICAgIGFjY1tuYW1lXSA9IE1hdGgucm91bmQoc3RhcnRUaW1lKTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgdmFyIG5hdmlnYXRpb24gPSBPYmplY3QuZW50cmllcygoX2IgPSAoX2EgPSB3aW5kb3cucGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5VHlwZSgnbmF2aWdhdGlvbicpWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9KU09OKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9KS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgX2EpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBfYVswXSwgdmFsdWUgPSBfYVsxXTtcbiAgICAgICAgICAgIGFjY1trZXldID0gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyA/IE1hdGgucm91bmQodmFsdWUpIDogdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHRoaXMuaW5mbyhcIlBlcmZvcm1hbmNlIFRpbWluZ1wiLCB7IHJlc291cmNlOiByZXNvdXJjZSwgcGFpbnQ6IHBhaW50LCBuYXZpZ2F0aW9uOiBuYXZpZ2F0aW9uIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciBmb3IgZXJyb3JzLiBXaWxsIGxvZyB0aGUgZXJyb3IgaWYgdGhlIGZpbHRlciBjYWxsYmFjayByZXR1cm5zIHRydWVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWx0ZXJDYWxsYmFjayBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIGVycm9yIG9iamVjdCBhbmQgcmV0dXJucyB3aGV0aGVyIGl0IHNob3VsZCBiZSBsb2dnZWRcbiAgICAgKi9cbiAgICBLYXRhbExvZ2dlci5wcm90b3R5cGUuYWRkRXJyb3JMaXN0ZW5lciA9IGZ1bmN0aW9uIChmaWx0ZXJDYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBbJ2Vycm9yJywgJ3VuaGFuZGxlZHJlamVjdGlvbiddLm1hcChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIF90aGlzLnJlZ2lzdGVyRXZlbnQobGlzdGVuZXIsIFxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSB0aGlzLmV2ZW50TGlzdGVuZXIgdGVzdGVkIHNlcGVyYXRlbHkgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmV2ZW50TGlzdGVuZXIoZSwgZmlsdGVyQ2FsbGJhY2spO1xuICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgcmVnaXN0ZXJlZCBlcnJvciBldmVudCBsaXN0ZW5lcnNcbiAgICAgKiBOb3JtYWwgYXBwbGljYXRpb25zIG5lZWQgbm90IGNhbGwgdGhpcy5cbiAgICAgKiBUaGlzIGlzIHJlcXVpcmVkIGZvciBtdWx0aXRlbmFudCBTUEFzIHRvIGF2b2lkIG1lbW9yeSBsZWFrcy5cbiAgICAgKi9cbiAgICBLYXRhbExvZ2dlci5wcm90b3R5cGUucmVtb3ZlRXJyb3JMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51bnJlZ2lzdGVyRm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9KTtcbiAgICB9O1xuICAgIEthdGFsTG9nZ2VyLnByb3RvdHlwZS5yZWdpc3RlckV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50LCBjYiwgY2FwdHVyZSkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2IsIGNhcHR1cmUpO1xuICAgICAgICB0aGlzLnVucmVnaXN0ZXJGbnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgY2IsIGNhcHR1cmUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEthdGFsTG9nZ2VyLnByb3RvdHlwZS5ldmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGUsIGZpbHRlckNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBlcnJvck1lc3NhZ2U7XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgLy8gZSBpcyBhbiBFcnJvckV2ZW50XG4gICAgICAgIGlmIChlLmVycm9yKSB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBlLmVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICBlcnJvciA9IGUuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZSBpcyBQcm9taXNlUmVqZWN0aW9uRXZlbnRcbiAgICAgICAgZWxzZSBpZiAoZS5yZWFzb24pIHtcbiAgICAgICAgICAgIGlmIChpc0Vycm9yKGUucmVhc29uKSkge1xuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGUucmVhc29uLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBlLnJlYXNvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGUucmVhc29uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRXJyb3IoZSkpIHtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGUubWVzc2FnZTtcbiAgICAgICAgICAgIGVycm9yID0gZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IFwiQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZDogXCIgKyB0aGlzLnRvU3RyaW5nT2JqZWN0KGUpO1xuICAgICAgICAgICAgLy8gQ2FwdHVyZSBhIHN0YWNrIHRyYWNlXG4gICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignVW5rbm93biBlcnJvcicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvck1lc3NhZ2UgIT09ICdLYXRhbExvZ2dlciBlcnJvcicgJiZcbiAgICAgICAgICAgICghZmlsdGVyQ2FsbGJhY2sgfHwgZmlsdGVyQ2FsbGJhY2soZXJyb3IpKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihlcnJvck1lc3NhZ2UsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBpbmZpbml0ZSBsb29wcyBieSBzd2FsbG93aW5nIGVycm9ycyB0aGF0IG9jY3VyIHdoaWxlIGxvZ2dpbmcgZXJyb3JzXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEthdGFsTG9nZ2VyLnByb3RvdHlwZS5jcmVhdGVKc29uU3RyaW5naWZ5UmVwbGFjZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwicmVmZXJlbmNlLWxvb3AsIGFsc28gcmVmZXJlbmNlZCBmcm9tICdcIiArIGNhY2hlLmdldCh2YWx1ZSkgKyBcIidcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FjaGUuc2V0KHZhbHVlLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRXZlbnQgb2JqZWN0cyBhcmUgaGFyZCB0byBzZXJpYWxpemUgKHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMTU0NzY3Mi9ob3ctdG8tc3RyaW5naWZ5LWV2ZW50LW9iamVjdCkgc28gd2UgbmVlZCBhIGhlbHBlciBtZXRob2RcbiAgICAgKi9cbiAgICBLYXRhbExvZ2dlci5wcm90b3R5cGUudG9TdHJpbmdPYmplY3QgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgIHZhciBjb25zdHJ1Y3Rvck5hbWUgPSBvYmplY3QuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgb2JqZWN0UHJvcGVydGllcyA9IEVWRU5UX1BST1BFUlRJRVM7XG4gICAgICAgICAgICB2YXIgZXZlbnRPYmplY3QgPSB7fTtcbiAgICAgICAgICAgIC8qKiBpZiBlcnJvciBldmVudCwgd2UgbmVlZCB0byBjYXB0dXJlIHRoZSBlcnJvciBtZXNzYWdlICovXG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgRXJyb3JFdmVudCkge1xuICAgICAgICAgICAgICAgIG9iamVjdFByb3BlcnRpZXMgPSBFUlJPUl9FVkVOVF9QUk9QRVJUSUVTO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBvYmplY3RQcm9wZXJ0aWVzXzEgPSBvYmplY3RQcm9wZXJ0aWVzOyBfaSA8IG9iamVjdFByb3BlcnRpZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcCA9IG9iamVjdFByb3BlcnRpZXNfMVtfaV07XG4gICAgICAgICAgICAgICAgLyoqIGlnbm9yZSBzZXJpYWxpemluZyBhbmQgbG9nZ2luZyB0aGUgZW50aXJlIHdpbmRvdyBsb2dcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0W3Byb3BdICE9PSB3aW5kb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRPYmplY3RbcHJvcF0gPSBvYmplY3RbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqZWN0ID0gZXZlbnRPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yTmFtZSArICc6JyArIHRoaXMudG9KU09OKG9iamVjdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBKU09OLnN0cmluZ2lmeSBjYW4gdGhyb3cgYnV0IHdlIHJlYWxseSBkb24ndCB3YW50IHRvIGVycm9yIHdoZW4gbG9nZ2luZyBlcnJvclxuICAgICAqIHNvIHVzZSBvdXIgb3duIGVycm9yLXNhZmUgc2VyaWFsaXphdGlvblxuICAgICAqL1xuICAgIEthdGFsTG9nZ2VyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgc3RyaW5naWZpZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdHJpbmdpZmllZCA9IEpTT04uc3RyaW5naWZ5KGRhdGEsIHRoaXMuY3JlYXRlSnNvblN0cmluZ2lmeVJlcGxhY2VyKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgc3RyaW5naWZpZWQgPSBcInsgXFxcIkthdGFsTG9nZ2VyXFxcIjogXFxcIkZhaWxlZCB0byBzZXJpYWxpemUhXFxcIiwgXFxcImRhdGFcXFwiOiBcXFwiXCIgKyBkYXRhICsgXCJcXFwiLCBcXFwiZXJyb3JcXFwiOiBcXFwiXCIgKyBlcnJvciArIFwiXFxcIiB9XCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmaWVkO1xuICAgIH07XG4gICAgS2F0YWxMb2dnZXIucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGVycm9yLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dHJhY3RBcmdzKExldmVsLkRFQlVHLCBtZXNzYWdlLCBlcnJvciwgY29udGV4dCkudGhlbihmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNlbmRSZXF1ZXN0KGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEthdGFsTG9nZ2VyLnByb3RvdHlwZS5pbmZvID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGVycm9yLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dHJhY3RBcmdzKExldmVsLklORk8sIG1lc3NhZ2UsIGVycm9yLCBjb250ZXh0KS50aGVuKGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuc2VuZFJlcXVlc3QoYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgS2F0YWxMb2dnZXIucHJvdG90eXBlLndhcm4gPSBmdW5jdGlvbiAobWVzc2FnZSwgZXJyb3IsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0cmFjdEFyZ3MoTGV2ZWwuV0FSTiwgbWVzc2FnZSwgZXJyb3IsIGNvbnRleHQpLnRoZW4oZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZW5kUmVxdWVzdChhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBLYXRhbExvZ2dlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgZXJyb3IsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0cmFjdEFyZ3MoTGV2ZWwuRVJST1IsIG1lc3NhZ2UsIGVycm9yLCBjb250ZXh0KS50aGVuKGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuc2VuZFJlcXVlc3QoYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgS2F0YWxMb2dnZXIucHJvdG90eXBlLmZhdGFsID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGVycm9yLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dHJhY3RBcmdzKExldmVsLkZBVEFMLCBtZXNzYWdlLCBlcnJvciwgY29udGV4dCkudGhlbihmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNlbmRSZXF1ZXN0KGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEthdGFsTG9nZ2VyLnByb3RvdHlwZS5leHRyYWN0QXJncyA9IGZ1bmN0aW9uIChsZXZlbCwgbWVzc2FnZSwgZXJyb3IsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGVycm9ySW5mbyA9IGlzRXJyb3IoZXJyb3IpXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgZXJyb3JOYW1lOiBlcnJvci5uYW1lLFxuICAgICAgICAgICAgICAgIGVycm9yU3RhY2tUcmFjZTogJycsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGxvZ1BheWxvYWQgPSB7XG4gICAgICAgICAgICBsZXZlbDogbGV2ZWwsXG4gICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgZXJyb3I6IGVycm9ySW5mbyxcbiAgICAgICAgICAgIGNvbnRleHQ6IF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGlzLmNvbnRleHQpLCAoZXJyb3JJbmZvID8gY29udGV4dCA6IGVycm9yKSksIHsgbG9nVGltZTogRGF0ZS5ub3coKSB9KSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGxvZ1BheWxvYWQuZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFN0YWNrVHJhY2VGcm9tRXJyb3IoZXJyb3IpLnRoZW4oZnVuY3Rpb24gKHRyYWNlKSB7XG4gICAgICAgICAgICAgICAgbG9nUGF5bG9hZC5lcnJvci5lcnJvclN0YWNrVHJhY2UgPSB0cmFjZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9nUGF5bG9hZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9taXNlX3BvbHlmaWxsXzEuZGVmYXVsdC5yZXNvbHZlKGxvZ1BheWxvYWQpO1xuICAgIH07XG4gICAgS2F0YWxMb2dnZXIucHJvdG90eXBlLmdldFN0YWNrVHJhY2VGcm9tRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRlY29kZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlX3BvbHlmaWxsXzEuZGVmYXVsdC5yZXNvbHZlKFN0cmluZyhlcnJvci5zdGFjaykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9taXNlX3BvbHlmaWxsXzEuZGVmYXVsdC5yZXNvbHZlKHN0YWNrdHJhY2VfanNfMS5kZWZhdWx0LmZyb21FcnJvcihlcnJvcilcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChzdGFja2ZyYW1lcykge1xuICAgICAgICAgICAgcmV0dXJuIHN0YWNrZnJhbWVzLm1hcChmdW5jdGlvbiAoc2YpIHsgcmV0dXJuIHNmLnRvU3RyaW5nKCk7IH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIC8vIHdlIGZhaWxlZCB0byBkZWNvZGUgaXQsIGp1c3Qgb3V0cHV0IHJhd1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhlcnJvci5zdGFjaykgK1xuICAgICAgICAgICAgICAgICdcXG5cXG5GYWlsZWQgdG8gZGVjb2RlIHN0YWNrdHJhY2U6XFxuJyArXG4gICAgICAgICAgICAgICAgU3RyaW5nKGVycik7XG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIEthdGFsTG9nZ2VyLnByb3RvdHlwZS5zZW5kUmVxdWVzdCA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgIHRoaXMucXVldWVMb2dMaW5lKHBheWxvYWQpO1xuICAgICAgICBpZiAodGhpcy5sb2dUb0NvbnNvbGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZExvZ1RvQ29uc29sZShwYXlsb2FkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgS2F0YWxMb2dnZXIucHJvdG90eXBlLnNlbmRMb2dUb0NvbnNvbGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgbGV2ZWwgPSBkYXRhLmxldmVsO1xuICAgICAgICBpZiAoIUxPR19MRVZFTFMuaW5jbHVkZXMoZGF0YS5sZXZlbCkgfHwgZGF0YS5sZXZlbCA9PT0gTGV2ZWwuRkFUQUwpIHtcbiAgICAgICAgICAgIGxldmVsID0gTGV2ZWwuRVJST1I7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZVtsZXZlbF0oZGF0YSk7XG4gICAgfTtcbiAgICBLYXRhbExvZ2dlci5wcm90b3R5cGUucXVldWVMb2dMaW5lID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgaWYgKHRoaXMucGF5bG9hZElzVmFsaWQocGF5bG9hZCkpIHtcbiAgICAgICAgICAgIHZhciBwYXlsb2FkU2l6ZSA9IHRoaXMuZ2V0UGF5bG9hZFNpemUocGF5bG9hZCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50TG9nQmF0Y2hTaXplICsgcGF5bG9hZFNpemUgPiB0aGlzLm1heExvZ0JhdGNoU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZExvZ3NUb0JhY2tlbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVG9RdWV1ZShwYXlsb2FkKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudExvZ0JhdGNoU2l6ZSArPSBwYXlsb2FkU2l6ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnVubG9hZGVkIHx8IHRoaXMubG9nTGluZVF1ZXVlLmxlbmd0aCA+PSB0aGlzLm1heExvZ3NQZXJCYXRjaCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZExvZ3NUb0JhY2tlbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLnF1ZXVlVGltZXJJZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWVUaW1lcklkID0gd2luZG93LnNldFRpbWVvdXQodGhpcy5zZW5kTG9nc1RvQmFja2VuZCwgdGhpcy5iYXRjaFRpbWVvdXREdXJhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEthdGFsTG9nZ2VyLnByb3RvdHlwZS5hcHBlbmRUb1F1ZXVlID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgdGhpcy5sb2dMaW5lUXVldWUucHVzaChwYXlsb2FkKTtcbiAgICB9O1xuICAgIEthdGFsTG9nZ2VyLnByb3RvdHlwZS5kb0NhbGxCZWFjb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoKG5hdmlnYXRvciA9PT0gbnVsbCB8fCBuYXZpZ2F0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5hdmlnYXRvci5zZW5kQmVhY29uKSAmJlxuICAgICAgICAgICAgIShPYmplY3Qua2V5cyh0aGlzLmhlYWRlcnMpLmxlbmd0aCB8fCB0aGlzLnVzZVhNTEh0dHBSZXF1ZXN0KSk7XG4gICAgfTtcbiAgICBLYXRhbExvZ2dlci5wcm90b3R5cGUuc2VuZExvZ1RvQmFja2VuZCA9IGZ1bmN0aW9uIChkYXRhU3RyaW5nKSB7XG4gICAgICAgIGlmICh0aGlzLnVybCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9DYWxsQmVhY29uKCkpIHtcbiAgICAgICAgICAgICAgICBuYXZpZ2F0b3Iuc2VuZEJlYWNvbih0aGlzLnVybCwgZGF0YVN0cmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgeGhyXzEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICAvLyB4aHIgcmVxdWVzdCBpcyBzZXQgdG8gYXN5bmMuXG4gICAgICAgICAgICAgICAgLy8gSW4gY2FzZSB0aGlzIG5lZWRzIHRvIGJlIGNoYW5nZWQgdG8gc3luYywgaXQgc2hvdWxkIGJlIG5vdGVkIHRoYXQgeGhyLndpdGhDcmVkZW50aWFscyB3aXRoIHN5bmMgcmVxdWVzdCBpcyBub3Qgc3VwcG9ydGVkIHNpbmNlIEZpcmVmb3ggMTEuXG4gICAgICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9YTUxIdHRwUmVxdWVzdC9Vc2luZ19YTUxIdHRwUmVxdWVzdCNicm93c2VyX2NvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgICB4aHJfMS5vcGVuKCdQT1NUJywgdGhpcy51cmwsIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnhocldpdGhDcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgICAgICB4aHJfMS53aXRoQ3JlZGVudGlhbHMgPSB0aGlzLnhocldpdGhDcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModGhpcy5oZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGVhZGVyTmFtZSA9IF9hWzBdLCBoZWFkZXJWYWx1ZSA9IF9hWzFdO1xuICAgICAgICAgICAgICAgICAgICB4aHJfMS5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlck5hbWUsIGhlYWRlclZhbHVlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB4aHJfMS5zZW5kKGRhdGFTdHJpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBLYXRhbExvZ2dlci5wcm90b3R5cGUucGF5bG9hZElzVmFsaWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgYSA9IExPR19MRVZFTFMuaW5kZXhPZihkYXRhLmxldmVsKTtcbiAgICAgICAgdmFyIGIgPSB0aGlzLmxvZ1RocmVzaG9sZEluZGV4O1xuICAgICAgICB2YXIgcGFzc2VzTG9nTGV2ZWxDaGVjayA9IGEgPj0gYjtcbiAgICAgICAgaWYgKHBhc3Nlc0xvZ0xldmVsQ2hlY2spIHtcbiAgICAgICAgICAgIHZhciBwYXlsb2FkU2l6ZSA9IHRoaXMuZ2V0UGF5bG9hZFNpemUoZGF0YSk7XG4gICAgICAgICAgICBpZiAocGF5bG9hZFNpemUgPD0gdGhpcy5tYXhMb2dMaW5lU2l6ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIEthdGFsTG9nZ2VyLnByb3RvdHlwZS5nZXRQYXlsb2FkU2l6ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBkYXRhU3RyaW5nID0gdGhpcy50b0pTT04oZGF0YSk7XG4gICAgICAgIHJldHVybiBkYXRhU3RyaW5nLmxlbmd0aDtcbiAgICB9O1xuICAgIHJldHVybiBLYXRhbExvZ2dlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBLYXRhbExvZ2dlcjtcbmZ1bmN0aW9uIGlzRXJyb3Iob2JqZWN0KSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBpbiBub2RlICh1bml0IHRlc3RzKSB0aGVyZSBpcyBubyBlcnJvci5jb25zdHJ1Y3Rvci4gSW4gaWUsIHRoZXJlIGlzIG5vIGVycm9yLnN0YWNrICovXG4gICAgcmV0dXJuICgob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0Lm5hbWUpICYmIG9iamVjdC5tZXNzYWdlICYmIChvYmplY3Quc3RhY2sgfHwgISFvYmplY3QuY29uc3RydWN0b3IpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyogaXN0YW5idWwgaWdub3JlIGZpbGUgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlTWV0cmljc1B1Ymxpc2hlciA9IHZvaWQgMDtcbnZhciBtZXRyaWNzX3B1Ymxpc2hlcl9zaW5nbGV0b25fMSA9IHJlcXVpcmUoXCIuL21ldHJpY3MtcHVibGlzaGVyLXNpbmdsZXRvblwiKTtcbmV4cG9ydHMuY3JlYXRlTWV0cmljc1B1Ymxpc2hlciA9IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gICAgcmV0dXJuIG1ldHJpY3NfcHVibGlzaGVyX3NpbmdsZXRvbl8xLk1ldHJpY3NQdWJsaXNoZXJTaW5nbGV0b24uZ2V0SW5zdGFuY2UoKS5uZXdDaGlsZEFjdGlvblB1Ymxpc2hlckZvck1ldGhvZChtZXRob2ROYW1lKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rYXRhbC1tZXRyaWNzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWV0cmljc1B1Ymxpc2hlclNpbmdsZXRvbiA9IHZvaWQgMDtcbnZhciBLYXRhbE1ldHJpY3MgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIkBhbXpuL2thdGFsLW1ldHJpY3NcIikpO1xudmFyIGthdGFsX21ldHJpY3NfZHJpdmVyX3N1c2hpXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBhbXpuL2thdGFsLW1ldHJpY3MtZHJpdmVyLXN1c2hpXCIpKTtcbnZhciBNZXRyaWNzUHVibGlzaGVyU2luZ2xldG9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gUHJpdmF0ZSBjb25zdHJ1Y3RvciB0byBwcmV2ZW50IGluaXRpYWxpemluZyB0aGUgc2luZ2xldG9uICovXG4gICAgZnVuY3Rpb24gTWV0cmljc1B1Ymxpc2hlclNpbmdsZXRvbigpIHtcbiAgICB9XG4gICAgTWV0cmljc1B1Ymxpc2hlclNpbmdsZXRvbi5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFNZXRyaWNzUHVibGlzaGVyU2luZ2xldG9uLmluc3RhbmNlKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIFRoaXMgaXMgaW52b2tlZCBieSB0aGUgbWV0cmljcyBkcml2ZXIgKi9cbiAgICAgICAgICAgIHZhciBtZXRyaWNzRXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgbWV0cmljc0RyaXZlciA9IHRoaXMuZ2V0TWV0cmljc0RyaXZlcihtZXRyaWNzRXJyb3JIYW5kbGVyKTtcbiAgICAgICAgICAgIHZhciBtZXRyaWNzQ29udGV4dCA9IHRoaXMuZ2V0TWV0cmljc0NvbnRleHQoKTtcbiAgICAgICAgICAgIE1ldHJpY3NQdWJsaXNoZXJTaW5nbGV0b24uaW5zdGFuY2UgPSBuZXcgS2F0YWxNZXRyaWNzLlB1Ymxpc2hlcihtZXRyaWNzRHJpdmVyLCBtZXRyaWNzRXJyb3JIYW5kbGVyLCBtZXRyaWNzQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1ldHJpY3NQdWJsaXNoZXJTaW5nbGV0b24uaW5zdGFuY2U7XG4gICAgfTtcbiAgICBNZXRyaWNzUHVibGlzaGVyU2luZ2xldG9uLmdldE1ldHJpY3NDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdXJsTWF0Y2ggPSAvKFteP10rKS8uZXhlYyh3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgICAgIHZhciB1cmxNZXRyaWMgPSBuZXcgS2F0YWxNZXRyaWNzLk1ldHJpYy5TdHJpbmcoJ3VybCcsIFxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIFRoaXMgaXMgaW52b2tlZCBieSB0aGUgbWV0cmljcyBjb250ZXh0ICovXG4gICAgICAgIHVybE1hdGNoID8gdXJsTWF0Y2hbMV0gOiB3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgICAgIHVybE1ldHJpYy50cnVuY2F0ZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBuZXcgS2F0YWxNZXRyaWNzLkNvbnRleHQuQnVpbGRlcigpXG4gICAgICAgICAgICAud2l0aFNpdGUoJ0thdGFsTG9nZ2VySW50ZXJuYWxNZXRyaWNzJylcbiAgICAgICAgICAgIC53aXRoU2VydmljZU5hbWUoJ0thdGFsTG9nZ2VyJylcbiAgICAgICAgICAgIC5hZGRSZWxhdGVkTWV0cmljcyh1cmxNZXRyaWMpXG4gICAgICAgICAgICAuYnVpbGQoKTtcbiAgICB9O1xuICAgIE1ldHJpY3NQdWJsaXNoZXJTaW5nbGV0b24uZ2V0TWV0cmljc0RyaXZlciA9IGZ1bmN0aW9uIChtZXRyaWNzRXJyb3JIYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcga2F0YWxfbWV0cmljc19kcml2ZXJfc3VzaGlfMS5kZWZhdWx0LkJ1aWxkZXIoKVxuICAgICAgICAgICAgLndpdGhEb21haW5SZWFsbSgncHJvZCcsICdVU0FtYXpvbicpXG4gICAgICAgICAgICAud2l0aEVycm9ySGFuZGxlcihtZXRyaWNzRXJyb3JIYW5kbGVyKVxuICAgICAgICAgICAgLmJ1aWxkKCk7XG4gICAgfTtcbiAgICByZXR1cm4gTWV0cmljc1B1Ymxpc2hlclNpbmdsZXRvbjtcbn0oKSk7XG5leHBvcnRzLk1ldHJpY3NQdWJsaXNoZXJTaW5nbGV0b24gPSBNZXRyaWNzUHVibGlzaGVyU2luZ2xldG9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0cmljcy1wdWJsaXNoZXItc2luZ2xldG9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuS2F0YWxNZXRyaWNzRHJpdmVyU3VzaGkgPSB2b2lkIDA7XG5cbnZhciBfb2JqZWN0U3ByZWFkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0U3ByZWFkXCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXNzZXJ0VGhpc0luaXRpYWxpemVkXCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY3NEcml2ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGFtem4va2F0YWwtbWV0cmljcy9saWIvZHJpdmVyL0thdGFsTWV0cmljc0RyaXZlclwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNUeXBlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGFtem4va2F0YWwtbWV0cmljcy9saWIvbWV0cmljT2JqZWN0L0thdGFsTWV0cmljVHlwZVwiKSk7XG5cbnZhciBfa2F0YWxTdXNoaUNsaWVudCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBhbXpuL2thdGFsLXN1c2hpLWNsaWVudFwiKSk7XG5cbnZhciBfdGVtcDtcblxudmFyIEtBVF9TVEFOREFMT05FX05FWFVTX1BST0RVQ0VSX0lEID0gJ2thdGFsJztcbnZhciBLQVRfU1RBTkRBTE9ORV9ERUZBVUxUX1NPVVJDRV9HUk9VUFMgPSB7XG4gIHRlc3Q6ICdjb20uYW1hem9uLmVlbC5rYXRhbC5tZXRyaWNzLmNvcmUubmV4dXMuZ2FtbWEnLFxuICBwcm9kOiAnY29tLmFtYXpvbi5lZWwua2F0YWwubWV0cmljcy5jb3JlLm5leHVzJ1xufTtcblxudmFyIEthdGFsTWV0cmljc0RyaXZlclN1c2hpID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfS2F0YWxNZXRyaWNzRHJpdmVyKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEthdGFsTWV0cmljc0RyaXZlclN1c2hpLCBfS2F0YWxNZXRyaWNzRHJpdmVyKTtcblxuICBmdW5jdGlvbiBLYXRhbE1ldHJpY3NEcml2ZXJTdXNoaShvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgS2F0YWxNZXRyaWNzRHJpdmVyU3VzaGkpO1xuICAgIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShLYXRhbE1ldHJpY3NEcml2ZXJTdXNoaSkuY2FsbCh0aGlzKSk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzKSwgXCJzdXNoaVwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpcyksIFwicHJvZHVjZXJJZFwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpcyksIFwic291cmNlR3JvdXBJZFwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpcyksIFwiZXJyb3JIYW5kbGVyXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzKSwgXCJjb21iaW5lZEVycm9ySGFuZGxlclwiLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoX3RoaXMuZXJyb3JIYW5kbGVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgX3RoaXMuZXJyb3JIYW5kbGVyKGVycik7IC8vIFJldHVybiB0byBhdm9pZCBmYWxsaW5nIHRocm91Z2ggdG8gZGVmYXVsdCBlcnJvciBoYW5kbGVyXG5cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBjYXRjaCAobmV4dEVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBoYW5kbGluZyBlcnJvciBwdWJsaXNoaW5nIG1ldHJpY3M6XCIpO1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IobmV4dEVycik7IC8vIEZhbGwgdGhyb3VnaFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmRlZmF1bHRFcnJvckhhbmRsZXIoZXJyKTtcbiAgICB9KTtcbiAgICB2YXIgZG9tYWluID0gb3B0aW9ucy5kb21haW4sXG4gICAgICAgIHJlYWxtID0gb3B0aW9ucy5yZWFsbSxcbiAgICAgICAgZXJyb3JIYW5kbGVyID0gb3B0aW9ucy5lcnJvckhhbmRsZXIsXG4gICAgICAgIHN1c2hpQ2xpZW50ID0gb3B0aW9ucy5zdXNoaUNsaWVudCxcbiAgICAgICAgX29wdGlvbnMkc3VzaGlQcm9kdWNlID0gb3B0aW9ucy5zdXNoaVByb2R1Y2VyLFxuICAgICAgICBwcm9kdWNlcklkID0gX29wdGlvbnMkc3VzaGlQcm9kdWNlID09PSB2b2lkIDAgPyBLQVRfU1RBTkRBTE9ORV9ORVhVU19QUk9EVUNFUl9JRCA6IF9vcHRpb25zJHN1c2hpUHJvZHVjZSxcbiAgICAgICAgc3VzaGlDbGllbnRPcHRpb25zID0gb3B0aW9ucy5zdXNoaUNsaWVudE9wdGlvbnMsXG4gICAgICAgIHN1c2hpQ2xpZW50VHJhbnNwb3J0T3ZlcnJpZGUgPSBvcHRpb25zLnN1c2hpQ2xpZW50VHJhbnNwb3J0T3ZlcnJpZGU7IC8vIGN1c3RvbSBzb3VyY2UgZ3JvdXAgYWx3YXlzIG92ZXJyaWRlcyBkZWZhdWx0c1xuXG4gICAgdmFyIHNvdXJjZUdyb3VwSWQgPSBvcHRpb25zLnNvdXJjZUdyb3VwSWQgfHwgS0FUX1NUQU5EQUxPTkVfREVGQVVMVF9TT1VSQ0VfR1JPVVBTW2RvbWFpbl0gfHwgS0FUX1NUQU5EQUxPTkVfREVGQVVMVF9TT1VSQ0VfR1JPVVBTWyd0ZXN0J107XG4gICAgX3RoaXMuc3VzaGkgPSBzdXNoaUNsaWVudCB8fCBfdGhpcy5idWlsZFN1c2hpQ2xpZW50KGRvbWFpbiwgcmVhbG0sIHNvdXJjZUdyb3VwSWQsIHN1c2hpQ2xpZW50T3B0aW9ucywgc3VzaGlDbGllbnRUcmFuc3BvcnRPdmVycmlkZSk7XG4gICAgX3RoaXMuZXJyb3JIYW5kbGVyID0gZXJyb3JIYW5kbGVyO1xuICAgIF90aGlzLnByb2R1Y2VySWQgPSBwcm9kdWNlcklkO1xuICAgIF90aGlzLnNvdXJjZUdyb3VwSWQgPSBzb3VyY2VHcm91cElkO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEthdGFsTWV0cmljc0RyaXZlclN1c2hpLCBbe1xuICAgIGtleTogXCJiZWZvcmVVbmxvYWRcIixcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIHJpZ2h0IGJlZm9yZSB0aGUgcGFnZSB1bmxvYWRzLiBUaGlzXG4gICAgICogYWxsb3dzIGZvciBhbnkgZmluYWwgbWV0cmljcywgc3VjaCBhcyBwYWdlIHZpc2l0IGR1cmF0aW9uLCB0byBiZSBzZW50XG4gICAgICogYmVmb3JlIHRoZSB1c2VyIG5hdmlnYXRlcyBhd2F5IGZyb20gdGhlIHBhZ2Ugb3IgY2xvc2VzIHRoZSB0YWIuXG4gICAgICogTk9URTogVGhpcyBpcyBhbiBleHBlcmltZW50YWwgQVBJIGFuZCBtYXkgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsLlxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBiZWZvcmVVbmxvYWQoY2IpIHtcbiAgICAgIHRoaXMuc3VzaGkub25TdXNoaVVubG9hZChjYik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgZXJyb3IgaGFuZGxlciBpZiB0aGUgdXNlci1zdXBwbGllZCBlcnJvciBoYW5kbGVyIGZhaWxzIG9yIGlzIHVuc2V0LiAgU2hvdWxkIG5ldmVyIGJlIGNhbGxlZCB1bmxlc3NcbiAgICAgKiB1c2VyLXByb3ZpZGVkIGVycm9yIGhhbmRsZXIgbWlzYmVoYXZlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlcnIgVW5oYW5kbGVkIGVycm9yIG9iamVjdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVmYXVsdEVycm9ySGFuZGxlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWZhdWx0RXJyb3JIYW5kbGVyKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHB1Ymxpc2hpbmcgbWV0cmljczpcIik7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGwgdGhlIGVycm9yLWhhbmRsZXIgc3VwcGxpZWQgYnkgdGhlIHVzZXIgd2hlbiB0aGlzIG9iamVjdCB3YXMgY29uc3RydWN0ZWQ7IGlmIHRoYXQgaXMgdW5zZXQgb3IgaXRzZWxmIHRocm93c1xuICAgICAqIGFuIGV4Y2VwdGlvbiwgY2FsbHMgdGhlIGRlZmF1bHQgZXJyb3IgaGFuZGxlciBhcyBhIGZhbGxiYWNrLCB3aGljaCB3aWxsIGp1c3QgbG9nIHRoZSBlcnJvciB0byB0aGUgY29uc29sZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlcnIgRXJyb3Igb2JqZWN0IHRvIGhhbmRsZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aEVycm9ySGFuZGxpbmdcIixcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gd3JhcCBhIGZ1bmN0aW9uIGluIHRoZSBlcnJvciBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRvVGhlVGhpbmcgRnVuY3Rpb24gdG8gcnVuIHVuZGVyIHRoZSB3cmFwcGVyXG4gICAgICogQHJldHVybiBSZXR1cm4gdmFsdWUgZnJvbSBjYWxsZWQgZnVuY3Rpb25cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aEVycm9ySGFuZGxpbmcoZG9UaGVUaGluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRvVGhlVGhpbmcoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLmNvbWJpbmVkRXJyb3JIYW5kbGVyKGVycik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJ1aWxkU3VzaGlDbGllbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGRTdXNoaUNsaWVudChkb21haW4sIHJlYWxtLCBzb3VyY2VHcm91cElkLCBzdXNoaUNsaWVudE9wdGlvbnMsIHN1c2hpQ2xpZW50VHJhbnNwb3J0T3ZlcnJpZGUpIHtcbiAgICAgIGlmICghZG9tYWluIHx8ICFyZWFsbSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0thdGFsTWV0cmljc0RyaXZlclN1c2hpIHJlcXVpcmVzIGEgZG9tYWluIGFuZCByZWFsbSB0byBidWlsZCBhIHN1c2hpIGNsaWVudC4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBfa2F0YWxTdXNoaUNsaWVudC5kZWZhdWx0KEthdGFsTWV0cmljc0RyaXZlclN1c2hpLmdldFJlYWxtTmFtZShyZWFsbSksIHNvdXJjZUdyb3VwSWQsIHRoaXMuY29tYmluZWRFcnJvckhhbmRsZXIsIHN1c2hpQ2xpZW50T3B0aW9ucywgc3VzaGlDbGllbnRUcmFuc3BvcnRPdmVycmlkZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInB1Ymxpc2hcIixcbiAgICAvLyBUT0RPOiBlcnJvckhhbmRsZXIgaW4gdGhpcyBtZXRob2QgaXMgZGVwcmVjYXRlZCBhbmQgaXMgbm90IHJlZmVyZW5jZWQuXG4gICAgLy8gVGVjaCBkZWJ0OiBodHRwczovL2lzc3Vlcy5hbWF6b24uY29tL2lzc3Vlcy9LQVQtODc1XG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1Ymxpc2gobWV0cmljT2JqZWN0LCBlcnJvckhhbmRsZXIsIGNvbnRleHQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAvLyBTdXBwb3J0IGZvciBuZXcgMi1hcmd1bWVudCBmb3JtIG9mIHB1Ymxpc2gsIHdoaWNoIGRvZXMgbm90IHBhc3MgdGhlIHVudXNlZCBlcnJvckhhbmRsZXIgb2JqZWN0IChLQVQtODc1KVxuICAgICAgdmFyIG1ldHJpY3NDb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyBhcmd1bWVudHNbMV0gOiBhcmd1bWVudHNbMl07XG4gICAgICB0aGlzLndpdGhFcnJvckhhbmRsaW5nKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBsb2dpYyBpcyBub3cgbW92ZWQgaW50byBLYXRhbE1ldHJpY3NQdWJsaXNoZXIsIG9uY2UgZXZlcnlib2R5IGhhcyB0aGF0IHVwZGF0ZSB3ZSBjYW4gcmVtb3ZlIHRoaXMuXG4gICAgICAgIC8vIFRlY2ggZGVidDogaHR0cHM6Ly9pc3N1ZXMuYW1hem9uLmNvbS9pc3N1ZXMvS0FULTg3NlxuICAgICAgICBpZiAoX0thdGFsTWV0cmljVHlwZS5kZWZhdWx0Lkxpc3QgPT09IG1ldHJpY09iamVjdC50eXBlKSB7XG4gICAgICAgICAgbWV0cmljT2JqZWN0Lm1ldHJpY0xpc3QuZm9yRWFjaChmdW5jdGlvbiAobWV0cmljKSB7XG4gICAgICAgICAgICBfdGhpczIucHVibGlzaChtZXRyaWMsIG1ldHJpY3NDb250ZXh0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV4dXNTY2hlbWEgPSBfdGhpczIubWFwT2JqZWN0VHlwZVRvTmV4dXNTY2hlbWEobWV0cmljT2JqZWN0LnR5cGUpO1xuXG4gICAgICAgIHZhciBmaWVsZHMgPSAoMCwgX29iamVjdFNwcmVhZDIuZGVmYXVsdCkoe30sIG1ldHJpY3NDb250ZXh0LmNvbnRleHQsIHtcbiAgICAgICAgICBtZXRyaWNLZXk6IG1ldHJpY09iamVjdC5uYW1lLFxuICAgICAgICAgIHZhbHVlOiBtZXRyaWNPYmplY3QudmFsdWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG1ldHJpY09iamVjdC5pc01vbml0b3IpIHtcbiAgICAgICAgICBmaWVsZHMuaXNNb25pdG9yID0gdHJ1ZTtcbiAgICAgICAgfSAvLyBSZXNldCB0aGUgZXZlbnQgY291bnQgYmFjayB0byAwLCBvdGhlcndpc2UgU3VzaGkgd2lsbCBzdG9wIHB1Ymxpc2hpbmcgYWZ0ZXIgMUsgaXRlbXMgKGh0dHBzOi8vaXNzdWVzLmFtYXpvbi5jb20vaXNzdWVzL0tBVC0xNTM0KVxuXG5cbiAgICAgICAgX3RoaXMyLnN1c2hpLnJlc2V0KCk7XG5cbiAgICAgICAgX3RoaXMyLnN1c2hpLmV2ZW50KGZpZWxkcywgX3RoaXMyLnByb2R1Y2VySWQsIG5leHVzU2NoZW1hLCB7XG4gICAgICAgICAgXCJzc2RcIjogMVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXBPYmplY3RUeXBlVG9OZXh1c1NjaGVtYVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXBPYmplY3RUeXBlVG9OZXh1c1NjaGVtYShvYmplY3RUeXBlKSB7XG4gICAgICBzd2l0Y2ggKG9iamVjdFR5cGUpIHtcbiAgICAgICAgY2FzZSBfS2F0YWxNZXRyaWNUeXBlLmRlZmF1bHQuU3RyaW5nOlxuICAgICAgICAgIHJldHVybiAna2F0YWwuY2xpZW50Lm1ldHJpY3MuU3RyaW5nLjInO1xuXG4gICAgICAgIGNhc2UgX0thdGFsTWV0cmljVHlwZS5kZWZhdWx0LkNvdW50ZXI6XG4gICAgICAgICAgcmV0dXJuICdrYXRhbC5jbGllbnQubWV0cmljcy5Db3VudGVyLjMnO1xuXG4gICAgICAgIGNhc2UgX0thdGFsTWV0cmljVHlwZS5kZWZhdWx0LlRpbWVyOlxuICAgICAgICAgIHJldHVybiAna2F0YWwuY2xpZW50Lm1ldHJpY3MuVGltZXIuMic7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHR5cGUgXCIuY29uY2F0KG9iamVjdFR5cGUsIFwiIHdoZW4gcHVibGlzaGluZyBtZXRyaWMgb2JqZWN0LlwiKSk7XG4gICAgICB9XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZ2V0UmVhbG1OYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJlYWxtTmFtZShyZWFsbSkge1xuICAgICAgc3dpdGNoIChyZWFsbSkge1xuICAgICAgICBjYXNlICdOQUFtYXpvbic6XG4gICAgICAgIGNhc2UgJ1VTQW1hem9uJzpcbiAgICAgICAgICByZXR1cm4gX2thdGFsU3VzaGlDbGllbnQuZGVmYXVsdC5SRUdJT05TLk5BO1xuXG4gICAgICAgIGNhc2UgJ0VVQW1hem9uJzpcbiAgICAgICAgICByZXR1cm4gX2thdGFsU3VzaGlDbGllbnQuZGVmYXVsdC5SRUdJT05TLkVVO1xuXG4gICAgICAgIGNhc2UgJ0ZFQW1hem9uJzpcbiAgICAgICAgY2FzZSAnSlBBbWF6b24nOlxuICAgICAgICAgIHJldHVybiBfa2F0YWxTdXNoaUNsaWVudC5kZWZhdWx0LlJFR0lPTlMuRkU7XG5cbiAgICAgICAgY2FzZSAnQ05BbWF6b24nOlxuICAgICAgICAgIHJldHVybiBfa2F0YWxTdXNoaUNsaWVudC5kZWZhdWx0LlJFR0lPTlMuQ047XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBMZXQgdGhlIFN1c2hpQ2xpZW50IGRlY2lkZSBpZiB0aGlzIGlzIGJvZ3VzIG9yIG5vdC5cbiAgICAgICAgICByZXR1cm4gcmVhbG07XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBLYXRhbE1ldHJpY3NEcml2ZXJTdXNoaTtcbn0oX0thdGFsTWV0cmljc0RyaXZlcjIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuS2F0YWxNZXRyaWNzRHJpdmVyU3VzaGkgPSBLYXRhbE1ldHJpY3NEcml2ZXJTdXNoaTtcbigwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKEthdGFsTWV0cmljc0RyaXZlclN1c2hpLCBcIkJ1aWxkZXJcIiwgKF90ZW1wID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gX3RlbXAoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgX3RlbXApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiY29udGV4dFwiLCB7fSk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShfdGVtcCwgW3tcbiAgICBrZXk6IFwid2l0aFN1c2hpQ2xpZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhTdXNoaUNsaWVudChzdXNoaUNsaWVudCkge1xuICAgICAgdGhpcy5jb250ZXh0LnN1c2hpQ2xpZW50ID0gc3VzaGlDbGllbnQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aERvbWFpblJlYWxtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhEb21haW5SZWFsbShkb21haW4sIHJlYWxtKSB7XG4gICAgICB0aGlzLmNvbnRleHQuZG9tYWluID0gZG9tYWluO1xuICAgICAgdGhpcy5jb250ZXh0LnJlYWxtID0gcmVhbG07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aEN1c3RvbVByb2R1Y2VyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhDdXN0b21Qcm9kdWNlcihzdXNoaVByb2R1Y2VySWQpIHtcbiAgICAgIHRoaXMuY29udGV4dC5zdXNoaVByb2R1Y2VyID0gc3VzaGlQcm9kdWNlcklkO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhDdXN0b21Tb3VyY2VHcm91cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoQ3VzdG9tU291cmNlR3JvdXAoc291cmNlR3JvdXBJZCkge1xuICAgICAgdGhpcy5jb250ZXh0LnNvdXJjZUdyb3VwSWQgPSBzb3VyY2VHcm91cElkO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhFcnJvckhhbmRsZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aEVycm9ySGFuZGxlcihlcnJvckhhbmRsZXIpIHtcbiAgICAgIHRoaXMuY29udGV4dC5lcnJvckhhbmRsZXIgPSBlcnJvckhhbmRsZXI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aFN1c2hpQ2xpZW50T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoU3VzaGlDbGllbnRPcHRpb25zKHN1c2hpQ2xpZW50T3B0aW9ucykge1xuICAgICAgdGhpcy5jb250ZXh0LnN1c2hpQ2xpZW50T3B0aW9ucyA9IHN1c2hpQ2xpZW50T3B0aW9ucztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3aXRoU3VzaGlDbGllbnRUcmFuc3BvcnRPdmVycmlkZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoU3VzaGlDbGllbnRUcmFuc3BvcnRPdmVycmlkZShzdXNoaUNsaWVudFRyYW5zcG9ydE92ZXJyaWRlKSB7XG4gICAgICB0aGlzLmNvbnRleHQuc3VzaGlDbGllbnRUcmFuc3BvcnRPdmVycmlkZSA9IHN1c2hpQ2xpZW50VHJhbnNwb3J0T3ZlcnJpZGU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYnVpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGQoKSB7XG4gICAgICByZXR1cm4gbmV3IEthdGFsTWV0cmljc0RyaXZlclN1c2hpKHRoaXMuY29udGV4dCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBfdGVtcDtcbn0oKSwgX3RlbXApKTsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxucmVxdWlyZShcIi4vbm9kZWpzU2hpbXNcIik7XG5cbnZhciBfS2F0YWxNZXRyaWNzRHJpdmVyU3VzaGkgPSByZXF1aXJlKFwiLi9LYXRhbE1ldHJpY3NEcml2ZXJTdXNoaVwiKTtcblxuLyogaXN0YW5idWwgaWdub3JlIGZpbGUgKi9cbnZhciBfZGVmYXVsdCA9IF9LYXRhbE1ldHJpY3NEcml2ZXJTdXNoaS5LYXRhbE1ldHJpY3NEcml2ZXJTdXNoaTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9vYmplY3RTcHJlYWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RTcHJlYWRcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX1ZhbGlkYXRlU2ltcGxlU3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9oZWxwZXIvVmFsaWRhdGVTaW1wbGVTdHJpbmdcIikpO1xuXG52YXIgX0ZpcnN0TWFwID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9oZWxwZXIvRmlyc3RNYXBcIikpO1xuXG52YXIgX21lcmdlTGlzdHMgPSByZXF1aXJlKFwiLi9oZWxwZXIvbWVyZ2VMaXN0c1wiKTtcblxudmFyIF9lbWJlZFJlcXVlc3RJZCA9IHJlcXVpcmUoXCIuL2hlbHBlci9lbWJlZFJlcXVlc3RJZFwiKTtcblxudmFyIF90ZW1wO1xuXG52YXIgUkVRVUlSRURfRklFTERTID0gWydzaXRlJywgJ3NlcnZpY2VOYW1lJywgJ21ldGhvZE5hbWUnXTtcblxudmFyIEthdGFsTWV0cmljc0NvbnRleHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IG1ldHJpY3MgY29udGV4dCB3aXRoIHRoZSBnaXZlbiBmaWVsZHMuXG4gICAqXG4gICAqIEBwYXJhbSBjb250ZXh0RmllbGRzIENvbnRleHQgZmllbGRzIHZhbHVlIChkZWZhdWx0IGVtcHR5KVxuICAgKi9cbiAgZnVuY3Rpb24gS2F0YWxNZXRyaWNzQ29udGV4dCgpIHtcbiAgICB2YXIgY29udGV4dEZpZWxkcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgS2F0YWxNZXRyaWNzQ29udGV4dCk7XG4gICAgLy8gQ29weSBmaWVsZHMgc28gdGhpcyBpcyBpbW11dGFibGVcbiAgICB0aGlzLmNvbnRleHQgPSAoMCwgX29iamVjdFNwcmVhZDIuZGVmYXVsdCkoe30sIGNvbnRleHRGaWVsZHMpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYSBuZXcgS2F0YWxNZXRyaWNzQ29udGV4dCB3aGljaCBpcyBhIGNvcHkgb2YgdGhpcyBjb250ZXh0LCB3aXRoIHZhbHVlcyBhZGRlZCBvciBvdmVycmlkZGVuIGZyb21cbiAgICogdGhlIGdpdmVuIGNvbnRleHQuXG4gICAqXG4gICAqIElmIHRoZSBnaXZlbiBjb250ZXh0IGlzIG51bGwgb3IgZW1wdHksIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9yaWdpbmFsIG9iamVjdCBhcyBhbiBvcHRpbWl6YXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB0aGF0Q29udGV4dCBDb250ZXh0IHRvIG1lcmdlIHZhbHVlcyBmcm9tXG4gICAqIEByZXR1cm4gTmV3IGNvbnRleHQgd2l0aCBkZWZhdWx0IHZhbHVlcyBmcm9tIHRoaXMgY29udGV4dCwgYW5kIHZhbHVlcyBvdmVycmlkZGVuIG9yIGFkZGVkIGJ5IHRoZSBnaXZlbiBjb250ZXh0LlxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEthdGFsTWV0cmljc0NvbnRleHQsIFt7XG4gICAga2V5OiBcIm1lcmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1lcmdlKHRoYXRDb250ZXh0KSB7XG4gICAgICBpZiAoIXRoYXRDb250ZXh0KSByZXR1cm4gdGhpczsgLy8gQ2hlY2sgZm9yIGEgY29tbW9uIGVycm9yXG5cbiAgICAgIGlmICh0aGF0Q29udGV4dCBpbnN0YW5jZW9mIEthdGFsTWV0cmljc0NvbnRleHQuQnVpbGRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLYXRhbE1ldHJpY3NDb250ZXh0LkJ1aWxkZXIgb2JqZWN0IHBhc3NlZCBpbnN0ZWFkIG9mIEthdGFsTWV0cmljc0NvbnRleHQuICBUcnkgY2FsbGluZyAuYnVpbGQoKSBtZXRob2QuXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoYXRDb250ZXh0IGluc3RhbmNlb2YgS2F0YWxNZXRyaWNzQ29udGV4dCA/IHRoYXRDb250ZXh0LmNvbnRleHQgOiB0aGF0Q29udGV4dDtcbiAgICAgIHZhciBuZXdDb250ZXh0ID0gKDAsIF9vYmplY3RTcHJlYWQyLmRlZmF1bHQpKHt9LCB0aGlzLmNvbnRleHQsIGNvbnRleHQsIHtcbiAgICAgICAgcmVsYXRlZE1ldHJpY3M6ICgwLCBfbWVyZ2VMaXN0cy5tZXJnZUxpc3RzKSh0aGlzLmNvbnRleHQucmVsYXRlZE1ldHJpY3MsIGNvbnRleHQucmVsYXRlZE1ldHJpY3MpLFxuICAgICAgICByZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbjogKDAsIF9tZXJnZUxpc3RzLm1lcmdlTGlzdHMpKHRoaXMuY29udGV4dC5yZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbiwgY29udGV4dC5yZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbilcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBLYXRhbE1ldHJpY3NDb250ZXh0KG5ld0NvbnRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBuZXcgY29udGV4dCB3aGljaCBpcyBhIGNvcHkgb2YgdGhpcyBjb250ZXh0IHdpdGggcmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb24gcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmUgY2FsbGVkIHdoZW4gY3JlYXRpbmcgYSBuZXcgY2hpbGQgcHVibGlzaGVyLlxuICAgICAqXG4gICAgICogQHJldHVybiBDb3B5IG9mIHRoaXMgY29udGV4dCwgd2l0aCByZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbiByZW1vdmVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ3aXRob3V0UmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aG91dFJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBLYXRhbE1ldHJpY3NDb250ZXh0KCgwLCBfb2JqZWN0U3ByZWFkMi5kZWZhdWx0KSh7fSwgdGhpcy5jb250ZXh0LCB7XG4gICAgICAgIHJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uOiB1bmRlZmluZWRcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgY29udGV4dCBzdWl0YWJsZSBmb3IgcHVibGljYXRpb24gdG8gdGhlIGRyaXZlci5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHN0cmlwcyBvdXQgYW55IHByaXZhdGUgZmllbGRzLCBhbmQgbGVhdmVzIG9ubHkgZmllbGRzIGZyb20gdGhlIHNjaGVtYSB0aGF0IHRoZSBkcml2ZXIgc2hvdWxkIHB1Ymxpc2guXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIENvbnRleHQgc3VpdGFibGUgZm9yIGRyaXZlciBwdWJsaWNhdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJpdmVyQ29udGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcml2ZXJDb250ZXh0KCkge1xuICAgICAgLy8gRG9uJ3QgcHVibGlzaCByZWxhdGVkTWV0cmljcyB0byB0aGUgZHJpdmVyXG4gICAgICB2YXIgbmV3Q29udGV4dEZpZWxkcyA9ICgwLCBfb2JqZWN0U3ByZWFkMi5kZWZhdWx0KSh7fSwgdGhpcy5jb250ZXh0KTtcbiAgICAgIGRlbGV0ZSBuZXdDb250ZXh0RmllbGRzW1wicmVsYXRlZE1ldHJpY3NcIl07XG4gICAgICBkZWxldGUgbmV3Q29udGV4dEZpZWxkc1tcInJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uXCJdO1xuICAgICAgZGVsZXRlIG5ld0NvbnRleHRGaWVsZHNbXCJyZXF1ZXN0SWRcIl07XG5cbiAgICAgIGlmICh0aGlzLmNvbnRleHQucmVxdWVzdElkKSB7XG4gICAgICAgIG5ld0NvbnRleHRGaWVsZHMuYWN0aW9uSWQgPSAoMCwgX2VtYmVkUmVxdWVzdElkLmVtYmVkUmVxdWVzdElkKShuZXdDb250ZXh0RmllbGRzLmFjdGlvbklkLCB0aGlzLmNvbnRleHQucmVxdWVzdElkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBLYXRhbE1ldHJpY3NDb250ZXh0KG5ld0NvbnRleHRGaWVsZHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzaW1wbGUgSmF2YVNjcmlwdCBvYmplY3Qgd2l0aCBhIGNvcHkgb2YgdGhlIGZpZWxkcyBmb3IgdGhpcyBjb250ZXh0LlxuICAgICAqXG4gICAgICogQHJldHVybiBTaW1wbGUgSmF2YXNjcmlwdCBvYmplY3Qgd2l0aCBhIGNvcHkgb2YgdGhlIGZpZWxkcyBmb3IgdGhpcyBjb250ZXh0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRGaWVsZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RmllbGRzKCkge1xuICAgICAgLy8gQ29weSBmaWVsZHMgc28gdGhpcyByZW1haW5zIGltbXV0YWJsZVxuICAgICAgcmV0dXJuICgwLCBfb2JqZWN0U3ByZWFkMi5kZWZhdWx0KSh7fSwgdGhpcy5jb250ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgZm9yIGEgdmFsaWRhdGlvbiBlcnJvciBvbiB0aGlzIGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCB2YWxpZGF0aW9uIGVycm9yIGVuY291bnRlcmVkIGlmIG9uZSBpcyBmb3VuZCwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEVycm9ycyBmb3VuZCB3aXRoIHRoaXMgY29udGV4dFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidmFsaWRhdGlvbkVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRpb25FcnJvcigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBlcnI7IC8vIEZpZWxkcyDigJxzaXRl4oCdLCDigJxzZXJ2aWNlTmFtZeKAnSwg4oCcbWV0aG9kTmFtZeKAnSwgYW5kIOKAnG1ldHJpY0tleeKAnSBhcmUgcmVxdWlyZWQuXG5cbiAgICAgIGVyciA9ICgwLCBfRmlyc3RNYXAuZGVmYXVsdCkoUkVRVUlSRURfRklFTERTLCBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgaWYgKF90aGlzLmNvbnRleHRbZmllbGRdID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXCJGaWVsZCBcIi5jb25jYXQoZmllbGQsIFwiIGlzIHJlcXVpcmVkLCBidXQgaXQgaXMgXCIpLmNvbmNhdChfdGhpcy5jb250ZXh0W2ZpZWxkXSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChlcnIpIHJldHVybiBlcnI7XG4gICAgICByZXR1cm4gKDAsIF9GaXJzdE1hcC5kZWZhdWx0KShPYmplY3Qua2V5cyh0aGlzLmNvbnRleHQpLCBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnZhbGlkYXRlRmllbGQoZmllbGQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIGFuIGluZGl2aWR1YWwgY29udGV4dCBmaWVsZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWVsZCBOYW1lIG9mIGZpZWxkIHRvIHZhbGlkYXRlXG4gICAgICogQHJldHVybnMgRXJyb3IgZm91bmQgd2l0aCB0aGlzIGZpZWxkLCBvciB1bmRlZmluZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInZhbGlkYXRlRmllbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGVGaWVsZChmaWVsZCkge1xuICAgICAgdmFyIHZhbCA9IHRoaXMuY29udGV4dFtmaWVsZF07XG4gICAgICB2YXIgbmFtZUZvckVycm9yID0gXCJmaWVsZCBcIi5jb25jYXQoZmllbGQpO1xuXG4gICAgICBzd2l0Y2ggKGZpZWxkKSB7XG4gICAgICAgIC8vIFN0cmluZ3Mgd2hpY2ggY291bGQgYmUgdXNlZCBhcyBwYXJ0aXRpb24ga2V5cyAoXCJzaXRlXCIgYW5kIFwic2VydmljZU5hbWVcIikgY2Fubm90IGNvbnRhaW4gc2xhc2hlcywgaW5cbiAgICAgICAgLy8gYWRkaXRpb24gdG8gdGhlIG90aGVyIHJlc3RpY3Rpb25zIGJlbG93LlxuICAgICAgICBjYXNlICdzaXRlJzpcbiAgICAgICAgY2FzZSAnc2VydmljZU5hbWUnOlxuICAgICAgICAgIGlmICh2YWwuaW5kZXhPZignLycpID4gLTEpIHJldHVybiBuZXcgRXJyb3IoXCJFeHBlY3RlZCBcIi5jb25jYXQobmFtZUZvckVycm9yLCBcIiB0byBjb250YWluIG9ubHkgdmFsaWQgY2hhcmFjdGVycywgYnV0IGl0IHdhcyBcIikuY29uY2F0KHZhbCwgXCIuICBJdCBjYW5ub3QgY29udGFpbiBhIHNsYXNoLlwiKSk7XG4gICAgICAgIC8vIEVsc2UgZmFsbCB0aHJvdWdoXG4gICAgICAgIC8vIFN0cmluZ3MgZm9yIGZpZWxkcyDigJxzaXRl4oCdLCDigJxzZXJ2aWNlTmFtZeKAnSwg4oCcbWV0aG9kTmFtZeKAnSwg4oCcbWV0cmljS2V54oCdIG11c3QgbWF0Y2ggYmUgdmFsaWQgUE1FVCBmaWVsZCBuYW1lczpcbiAgICAgICAgLy8gbWF4aW11bSBsZW5ndGggb2YgMjU2LCBvbmx5IGxldHRlcnMsIG51bWJlcnMsIGFuZCB0aGUgZG90LCBjb2xvbiwgYXQtc2lnbiwgdW5kZXJzY29yZSwgZm9yd2FyZC1zbGFzaCxcbiAgICAgICAgLy8gYW5kIHNsYXNoIGNoYXJhY3RlcnMgKGluIHNob3J0IHRoZSByZWdleCBeW0EtWmEtejAtOS46QF8vLV0rJCkuXG5cbiAgICAgICAgY2FzZSAnbWV0aG9kTmFtZSc6XG4gICAgICAgIGNhc2UgJ2FjdGlvbklkJzpcbiAgICAgICAgICByZXR1cm4gKDAsIF9WYWxpZGF0ZVNpbXBsZVN0cmluZy5kZWZhdWx0KSh2YWwsIG5hbWVGb3JFcnJvcik7XG4gICAgICB9IC8vIE5vIGVycm9yIGZvdW5kLCBpbXBsaWNpdGx5IHJldHVybiB1bmRlZmluZWRcblxuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWlsZGVyIGNsYXNzIGZvciBLYXRhbE1ldHJpY3NDb250ZXh0XG4gICAgICovXG5cbiAgfV0pO1xuICByZXR1cm4gS2F0YWxNZXRyaWNzQ29udGV4dDtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gS2F0YWxNZXRyaWNzQ29udGV4dDtcbigwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKEthdGFsTWV0cmljc0NvbnRleHQsIFwiQnVpbGRlclwiLCAoX3RlbXAgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBfdGVtcCgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBfdGVtcCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJjb250ZXh0XCIsIHt9KTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKF90ZW1wLCBbe1xuICAgIGtleTogXCJ3aXRoU2l0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoU2l0ZShzaXRlKSB7XG4gICAgICB0aGlzLmNvbnRleHQuc2l0ZSA9IHNpdGU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aFNlcnZpY2VOYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhTZXJ2aWNlTmFtZShzZXJ2aWNlTmFtZSkge1xuICAgICAgdGhpcy5jb250ZXh0LnNlcnZpY2VOYW1lID0gc2VydmljZU5hbWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aE1ldGhvZE5hbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aE1ldGhvZE5hbWUobWV0aG9kTmFtZSkge1xuICAgICAgdGhpcy5jb250ZXh0Lm1ldGhvZE5hbWUgPSBtZXRob2ROYW1lO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhBY3Rpb25JZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoQWN0aW9uSWQoYWN0aW9uSWQpIHtcbiAgICAgIHRoaXMuY29udGV4dC5hY3Rpb25JZCA9IGFjdGlvbklkO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhSZXF1ZXN0SWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aFJlcXVlc3RJZChyZXF1ZXN0SWQpIHtcbiAgICAgIHRoaXMuY29udGV4dC5yZXF1ZXN0SWQgPSByZXF1ZXN0SWQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVwbGFjZSBhbnkgcmVsYXRlZCBtZXRyaWNzIHdpdGggdGhlIGdpdmVuIGxpc3QgKHNlZSBhZGRSZWxhdGVkTWV0cmljcyB0byBhZGQgaW5zdGVhZCBvZiByZXBsYWNlKS5cbiAgICAgKlxuICAgICAqIFJlbGF0ZWQgbWV0cmljcyBhcmUgbWV0cmljcyB0aGF0IGFyZSBwdWJsaXNoZWQgd2hlbmV2ZXIgYSBuZXcgYWN0aW9uIGlzIHN0YXJ0ZWQuICBUaGV5IGFyZSB1c2VkIHRvIHJlbGF0ZSB0aGVcbiAgICAgKiBhY3Rpb24gYmFjayB0byB0aGUgY29udGV4dCB3aGVyZSBpdCBpcyBoYXBwZW5pbmcsIGZvciBleGFtcGxlIGEgcmVxdWVzdCBJRCBvciBhIHVzZXIgaWRlbnRpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVsYXRlZE1ldHJpY3MgUmVsYXRlZCBtZXRyaWNzIHRvIHB1Ymxpc2ggd2hlbiBhIG5ldyBhY3Rpb24gaXMgc3RhcnRlZCBmb3IgdGhpcyBjb250ZXh0XG4gICAgICogQHJldHVybnMgVGhpcyBidWlsZGVyIG9iamVjdCB0byBjb250aW51ZSBidWlsZGluZ1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aFJlbGF0ZWRNZXRyaWNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhSZWxhdGVkTWV0cmljcygpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCByZWxhdGVkTWV0cmljcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgcmVsYXRlZE1ldHJpY3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29udGV4dC5yZWxhdGVkTWV0cmljcyA9IHJlbGF0ZWRNZXRyaWNzO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhZGRpdGlvbmFsIHJlbGF0ZWQgbWV0cmljcyB0byB0aGlzIGJ1aWxkZXIuICBTZWUgd2l0aFJlbGF0ZWRNZXRyaWNzIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlbGF0ZWRNZXRyaWNzIEFkZGl0aW9uYWwgcmVsYXRlZCBtZXRyaWNzIHRvIHB1Ymxpc2ggd2hlbiBhIG5ldyBhY3Rpb24gaXMgc3RhcnRlZCBmb3IgdGhpcyBjb250ZXh0XG4gICAgICogQHJldHVybnMgVGhpcyBidWlsZGVyIG9iamVjdCB0byBjb250aW51ZSBidWlsZGluZ1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkUmVsYXRlZE1ldHJpY3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUmVsYXRlZE1ldHJpY3MoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlbGF0ZWRNZXRyaWNzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIHJlbGF0ZWRNZXRyaWNzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29udGV4dC5yZWxhdGVkTWV0cmljcyA9ICgwLCBfbWVyZ2VMaXN0cy5tZXJnZUxpc3RzKSh0aGlzLmNvbnRleHQucmVsYXRlZE1ldHJpY3MsIHJlbGF0ZWRNZXRyaWNzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlIHNpbmdsZS1hY3Rpb24gcmVsYXRlZCBtZXRyaWNzIHdpdGggdGhlIGdpdmVuIGxpc3QgKHNlZSBhZGRSZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbiB0byBhZGQgaW5zdGVhZCBvZiByZXBsYWNlLFxuICAgICAqIGFuZCB3aXRoUmVsYXRlZE1ldHJpY3MgZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgcmVsYXRlZCBtZXRyaWNzKS5cbiAgICAgKlxuICAgICAqIFNpbmdsZS1hY3Rpb24gcmVsYXRlZCBtZXRyaWNzIGFyZSBwdWJsaXNoZWQgd2hlbiBhIG5ldyBjaGlsZCBtZXRyaWMgcHVibGlzaGVyIGlzIGNyZWF0ZWQsIGJ1dCBub3QgaW5jbHVkZWQgYXNcbiAgICAgKiByZWxhdGVkIG1ldHJpY3MgZm9yIHRoZSBuZXcgY2hpbGQgbWV0cmljIHB1Ymxpc2hlciwgc28gYXJlIG5vdCBwdWJsaXNoZWQgYWdhaW4gaWYgdGhlIGNoaWxkIG1ldHJpYyBwdWJsaXNoZXJcbiAgICAgKiBjcmVhdGVzIGdyYW5kY2hpbGQgcHVibGlzaGVkIG1ldHJpY3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWV0cmljcyBSZWxhdGVkIG1ldHJpY3NcbiAgICAgKiBAcmV0dXJucyBUaGlzIGJ1aWxkZXIgb2JqZWN0IHRvIGNvbnRpbnVlIGJ1aWxkaW5nXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ3aXRoUmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aFJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBtZXRyaWNzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgIG1ldHJpY3NbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb250ZXh0LnJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uID0gbWV0cmljcztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYWRkaXRpb25hbCBzaW5nbGUtYWN0aW9uIHJlbGF0ZWQgbWV0cmljcyB0byB0aGlzIGJ1aWxkZXIuICBTZWUgYWRkUmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWV0cmljcyBSZWxhdGVkIG1ldHJpY3NcbiAgICAgKiBAcmV0dXJucyBUaGlzIGJ1aWxkZXIgb2JqZWN0IHRvIGNvbnRpbnVlIGJ1aWxkaW5nXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGRSZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRSZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbigpIHtcbiAgICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgbWV0cmljcyA9IG5ldyBBcnJheShfbGVuNCksIF9rZXk0ID0gMDsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgICAgICBtZXRyaWNzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29udGV4dC5yZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbiA9ICgwLCBfbWVyZ2VMaXN0cy5tZXJnZUxpc3RzKSh0aGlzLmNvbnRleHQucmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb24sIG1ldHJpY3MpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRha2UgdGhlIGZpZWxkcyBzZXQgaW4gdGhpcyBidWlsZGVyIGFuZCB1c2UgdGhlbSB0byBjcmVhdGUgYSBuZXcgS2F0YWxNZXRyaWNzQ29udGV4dC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gS2F0YWxNZXRyaWNzQ29udGV4dCBvYmplY3QgYnVpbHQgd2l0aCB0aGUgcGFyYW1ldGVycyBnaXZlbiB0byB0aGlzIGJ1aWxkZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImJ1aWxkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkKCkge1xuICAgICAgcmV0dXJuIG5ldyBLYXRhbE1ldHJpY3NDb250ZXh0KHRoaXMuY29udGV4dCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBfdGVtcDtcbn0oKSwgX3RlbXApKTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVXaWxkY2FyZFwiKTtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfdiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInV1aWQvdjRcIikpO1xuXG52YXIgX0thdGFsTWV0cmljc0NvbnRleHQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljc0NvbnRleHRcIikpO1xuXG52YXIgX0thdGFsTWV0cmljT2JqZWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9tZXRyaWNPYmplY3QvS2F0YWxNZXRyaWNPYmplY3RcIikpO1xuXG52YXIgS2F0YWxNZXRyaWNzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi5cIikpO1xuXG52YXIgX0thdGFsTWV0cmljU3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9tZXRyaWNPYmplY3QvS2F0YWxNZXRyaWNTdHJpbmdcIikpO1xuXG52YXIgX21lcmdlTGlzdHMgPSByZXF1aXJlKFwiLi9oZWxwZXIvbWVyZ2VMaXN0c1wiKTtcblxudmFyIF9tZXRyaWNzRXh0ZW5zaW9uID0gcmVxdWlyZShcIi4vaGVscGVyL21ldHJpY3NFeHRlbnNpb25cIik7XG5cbnZhciBfZW1iZWRSZXF1ZXN0SWQgPSByZXF1aXJlKFwiLi9oZWxwZXIvZW1iZWRSZXF1ZXN0SWRcIik7XG5cbnZhciBJTklUSUFMSVpBVElPTl9NRVRIT0RfTkFNRSA9ICdJbml0aWFsaXphdGlvbic7XG5cbi8qKlxuICogRGVmYXVsdCBlcnJvciBoYW5kbGVyIGlmIHRoZSB1c2VyLXN1cHBsaWVkIGVycm9yIGhhbmRsZXIgZmFpbHMgb3IgaXMgdW5zZXQuXG4gKiBTaG91bGQgbmV2ZXIgYmUgY2FsbGVkIHVubGVzcyB1c2VyLXByb3ZpZGVkIGVycm9yIGhhbmRsZXIgbWlzYmVoYXZlcy5cbiAqL1xudmFyIERFRkFVTFRfRVJST1JfSEFORExFUiA9IGZ1bmN0aW9uIERFRkFVTFRfRVJST1JfSEFORExFUihlcnIpIHtcbiAgY29uc29sZS5lcnJvcihcIkVycm9yIHB1Ymxpc2hpbmcgbWV0cmljczpcIik7XG4gIGNvbnNvbGUuZXJyb3IoZXJyKTtcbn07XG5cbnZhciBQQVJFTlRfQUNUSU9OX0lEX05BTUUgPSAncGFyZW50QWN0aW9uSWQnO1xuXG52YXIgZ2V0Q29udGV4dEZpZWxkcyA9IGZ1bmN0aW9uIGdldENvbnRleHRGaWVsZHMoY29udGV4dCkge1xuICBpZiAoY29udGV4dC5jb250ZXh0KSB7XG4gICAgcmV0dXJuIGNvbnRleHQuY29udGV4dDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxufTtcbi8qKlxuICogQ2xhc3MgdXNlZCBmb3IgcHVibGlzaGluZyBtZXRyaWNzIHRvIEthdGFsLiAgQ29udGFpbnMgYSBkcml2ZXIgYW5kIGEgY29udGV4dC5cbiAqXG4gKiBUaGlzIGNsYXNzIGtub3dzIGhvdyB0byBwdWJsaXNoIG1ldHJpY3MsIGFuZCBob3cgdG8gY3JlYXRlIG5ldyBwdWJsaXNoZXJzIHdpdGggYSBtb2RpZmllZCBjb250ZXh0LlxuICovXG5cblxudmFyIEthdGFsTWV0cmljc1B1Ymxpc2hlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgbWV0cmljcyBwdWJsaXNoZXIgd2l0aCB0aGUgZ2l2ZW4gZHJpdmVyIGFuZCBjb250ZXh0XG4gICAqXG4gICAqIEBwYXJhbSBkcml2ZXIgU3ViY2xhc3Mgb2YgS2F0YWxNZXRyaWNzRHJpdmVyIHVzZWQgdG8gcHVibGlzaCB0aGUgbWV0cmljc1xuICAgKiBAcGFyYW0gZXJyb3JIYW5kbGVyIEhhbmRsZXIgZm9yIGVycm9ycyB0aGF0IG9jY3VyIHdoaWxlIHVzaW5nIHRoaXMgcHVibGlzaGVyXG4gICAqIEBwYXJhbSBjb250ZXh0IENvbnRleHQgZm9yIHRoaXMgbWV0cmljcyBwdWJsaXNoZXI7IGNvbnRhaW5zIGRhdGEgdG8gYmUgaW5jbHVkZWQgd2l0aCBldmVyeVxuICAgKiAgICAgbWV0cmljIHB1Ymxpc2hlZCB1c2luZyB0aGlzIHB1Ymxpc2hlciBvYmplY3QuICBEZWZhdWx0IGlzIGFuIGVtcHR5IGNvbnRleHQuXG4gICAqL1xuICBmdW5jdGlvbiBLYXRhbE1ldHJpY3NQdWJsaXNoZXIoZHJpdmVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBlcnJvckhhbmRsZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IERFRkFVTFRfRVJST1JfSEFORExFUjtcbiAgICB2YXIgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbmV3IF9LYXRhbE1ldHJpY3NDb250ZXh0LmRlZmF1bHQoKTtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBLYXRhbE1ldHJpY3NQdWJsaXNoZXIpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiY29tYmluZWRFcnJvckhhbmRsZXJcIiwgZnVuY3Rpb24gKGVycikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgX3RoaXMuZXJyb3JIYW5kbGVyKGVycik7XG4gICAgICB9IGNhdGNoIChuZXh0RXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBoYW5kbGluZyBlcnJvciBwdWJsaXNoaW5nIG1ldHJpY3M6XCIpO1xuICAgICAgICBjb25zb2xlLmVycm9yKG5leHRFcnIpO1xuICAgICAgICBERUZBVUxUX0VSUk9SX0hBTkRMRVIoZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIENoZWNrIGZvciBhIGNvbW1vbiBlcnJvclxuICAgIGlmIChjb250ZXh0IGluc3RhbmNlb2YgX0thdGFsTWV0cmljc0NvbnRleHQuZGVmYXVsdC5CdWlsZGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLYXRhbE1ldHJpY3NDb250ZXh0LkJ1aWxkZXIgb2JqZWN0IHBhc3NlZCBpbnN0ZWFkIG9mIEthdGFsTWV0cmljc0NvbnRleHQuICBUcnkgY2FsbGluZyAuYnVpbGQoKSBtZXRob2QuXCIpO1xuICAgIH1cblxuICAgIHRoaXMuZHJpdmVyID0gZHJpdmVyO1xuICAgIHRoaXMuZXJyb3JIYW5kbGVyID0gZXJyb3JIYW5kbGVyO1xuICAgIHRoaXMuY29udGV4dCA9ICEoY29udGV4dCBpbnN0YW5jZW9mIF9LYXRhbE1ldHJpY3NDb250ZXh0LmRlZmF1bHQpID8gbmV3IF9LYXRhbE1ldHJpY3NDb250ZXh0LmRlZmF1bHQoY29udGV4dCkgOiBjb250ZXh0O1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIHRoZSBlcnJvci1oYW5kbGVyIHN1cHBsaWVkIGJ5IHRoZSB1c2VyIHdoZW4gdGhpcyBvYmplY3Qgd2FzIGNvbnN0cnVjdGVkOyBpZiB0aGF0IGlzIHVuc2V0IG9yIGl0c2VsZiB0aHJvd3NcbiAgICogYW4gZXhjZXB0aW9uLCBjYWxscyB0aGUgZGVmYXVsdCBlcnJvciBoYW5kbGVyIGFzIGEgZmFsbGJhY2ssIHdoaWNoIHdpbGwganVzdCBsb2cgdGhlIGVycm9yIHRvIHRoZSBjb25zb2xlLlxuICAgKlxuICAgKiBAcGFyYW0gZXJyIEVycm9yIG9iamVjdCB0byBoYW5kbGVcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShLYXRhbE1ldHJpY3NQdWJsaXNoZXIsIFt7XG4gICAga2V5OiBcIndpdGhFcnJvckhhbmRsaW5nXCIsXG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIHdyYXAgYSBmdW5jdGlvbiBpbiB0aGUgZXJyb3IgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkb1RoZVRoaW5nIEZ1bmN0aW9uIHRvIHJ1biB1bmRlciB0aGUgd3JhcHBlclxuICAgICAqIEByZXR1cm4gUmV0dXJuIHZhbHVlIGZyb20gY2FsbGVkIGZ1bmN0aW9uXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhFcnJvckhhbmRsaW5nKGRvVGhlVGhpbmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkb1RoZVRoaW5nKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5jb21iaW5lZEVycm9ySGFuZGxlcihlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIHJldHVybiBhbGwgdGhlIHJlbGF0ZWQgbWV0cmljcyBvZiBiYXNlIHB1Ymxpc2hlciBhbmQgYWRkaXRpb25hbENvbnRleHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbENvbnRleHQgQWRkaXRpb25hbCBjb250ZXh0IHRvIGJlIGluY2x1ZGVkIGluIHRoZSBuZXcgcHVibGlzaGVyXG4gICAgICogQHJldHVybiBSZXR1cm4gYWxsIHJlbGF0ZWQgbWV0cmljcyBmcm9tIGJhc2UgcHVibGlzaGVyIGFuZCBhZGRpdGlvbmFsQ29udGV4dC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEFkZGl0aW9uYWxSZWxhdGVkTWV0cmljc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBZGRpdGlvbmFsUmVsYXRlZE1ldHJpY3MoYWRkaXRpb25hbENvbnRleHQpIHtcbiAgICAgIHZhciBuZXdDb250ZXh0ID0gYWRkaXRpb25hbENvbnRleHQgaW5zdGFuY2VvZiBfS2F0YWxNZXRyaWNzQ29udGV4dC5kZWZhdWx0ID8gYWRkaXRpb25hbENvbnRleHQuY29udGV4dCA6IGFkZGl0aW9uYWxDb250ZXh0O1xuICAgICAgdmFyIGJhc2VSZWxhdGVkTWV0cmljcyA9IHRoaXMuZ2V0QmFzZVJlbGF0ZWRNZXRyaWNzKCk7XG4gICAgICByZXR1cm4gKDAsIF9tZXJnZUxpc3RzLm1lcmdlTGlzdHMpKGJhc2VSZWxhdGVkTWV0cmljcywgbmV3Q29udGV4dC5yZWxhdGVkTWV0cmljcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gcmV0dXJuIGFsbCB0aGUgcmVsYXRlZCBtZXRyaWNzIG9mIGJhc2UgcHVibGlzaGVyLlxuICAgICAqXG4gICAgICogQHJldHVybiBSZXR1cm4gYWxsIHJlbGF0ZWQgbWV0cmljcyBmcm9tIHRoZSBiYXNlIHB1Ymxpc2hlci5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEJhc2VSZWxhdGVkTWV0cmljc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCYXNlUmVsYXRlZE1ldHJpY3MoKSB7XG4gICAgICByZXR1cm4gKDAsIF9tZXJnZUxpc3RzLm1lcmdlTGlzdHMpKHRoaXMuY29udGV4dC5jb250ZXh0LnJlbGF0ZWRNZXRyaWNzLCB0aGlzLmNvbnRleHQuY29udGV4dC5yZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1Ymxpc2ggdGhlIGdpdmVuIG1ldHJpYyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBndWFyYW50ZWVkIG5ldmVyIHRvIHRocm93IGFuIGV4Y2VwdGlvbi4gIElmIHRoZSBtZXRyaWMgb2JqZWN0IG9yIGNvbnRleHQgYXJlIGludmFsaWQsXG4gICAgICogb3IgYW55IG90aGVyIGV4Y2VwdGlvbiBpcyB0aHJvd24gd2hpbGUgcHVibGlzaGluZywgdGhlIHB1Ymxpc2hlcidzIGVycm9yIGhhbmRsZXIgaXMgY2FsbGVkLiAgSWYgdGhlXG4gICAgICogcHVibGlzaGVyJ3MgZXJyb3IgaGFuZGxlciBpcyB1bnNldCBvciBmYWlscywgdGhlIGRlZmF1bHQgZXJyb3IgaGFuZGxlciBpcyBjYWxsZWQgKHNlZSBkZWZhdWx0RXJyb3JIYW5kbGVyKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrYXRhbE1ldHJpY09iamVjdCBNZXRyaWMgb2JqZWN0IHRvIHB1Ymxpc2hcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInB1Ymxpc2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVibGlzaChrYXRhbE1ldHJpY09iamVjdCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMud2l0aEVycm9ySGFuZGxpbmcoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWthdGFsTWV0cmljT2JqZWN0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHB1Ymxpc2ggdW5kZWZpbmVkL251bGwgbWV0cmljIG9iamVjdFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfS2F0YWxNZXRyaWNPYmplY3QuZGVmYXVsdC5UeXBlcy5MaXN0ID09PSBrYXRhbE1ldHJpY09iamVjdC50eXBlKSB7XG4gICAgICAgICAga2F0YWxNZXRyaWNPYmplY3QubWV0cmljTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChtZXRyaWMpIHtcbiAgICAgICAgICAgIF90aGlzMi5wdWJsaXNoKG1ldHJpYyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGRyaXZlckNvbnRleHQgPSBfdGhpczIuY29udGV4dC5kcml2ZXJDb250ZXh0KCk7XG5cbiAgICAgICAgICB2YXIgY29udGV4dEVycm9yID0gZHJpdmVyQ29udGV4dC52YWxpZGF0aW9uRXJyb3IoKTtcbiAgICAgICAgICBpZiAoY29udGV4dEVycm9yKSB0aHJvdyBjb250ZXh0RXJyb3I7XG4gICAgICAgICAgdmFyIG9iamVjdEVycm9yID0ga2F0YWxNZXRyaWNPYmplY3QudmFsaWRhdGlvbkVycm9yKCk7XG4gICAgICAgICAgaWYgKG9iamVjdEVycm9yKSB0aHJvdyBvYmplY3RFcnJvcjtcbiAgICAgICAgICAoMCwgX21ldHJpY3NFeHRlbnNpb24uZGlzcGF0Y2hNZXRyaWNFdmVudCkoa2F0YWxNZXRyaWNPYmplY3QsIGRyaXZlckNvbnRleHQpO1xuXG4gICAgICAgICAgX3RoaXMyLmRyaXZlci5wdWJsaXNoKGthdGFsTWV0cmljT2JqZWN0LCBfdGhpczIuY29tYmluZWRFcnJvckhhbmRsZXIsIGRyaXZlckNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHB1Ymxpc2hlciB3aGljaCBpcyBpZGVudGljYWwgdG8gdGhpcyBwdWJsaXNoZXIsIGJ1dCB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGZpZWxkcyBtZXJnZWQgaW50b1xuICAgICAqIHRoZSBuZXcgcHVibGlzaGVyJ3MgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsQ29udGV4dCBBZGRpdGlvbmFsIGNvbnRleHQgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIG5ldyBwdWJsaXNoZXJcbiAgICAgKiBAcmV0dXJucyBOZXcgcHVibGlzaGVyIGlkZW50aWNhbCB0byB0aGlzIG9uZSwgYnV0IHdpdGggYW4gdXBkYXRlZCBjb250ZXh0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJuZXdDaGlsZFB1Ymxpc2hlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXdDaGlsZFB1Ymxpc2hlcihhZGRpdGlvbmFsQ29udGV4dCkge1xuICAgICAgcmV0dXJuIG5ldyBLYXRhbE1ldHJpY3NQdWJsaXNoZXIodGhpcy5kcml2ZXIsIHRoaXMuZXJyb3JIYW5kbGVyLCB0aGlzLmNvbnRleHQubWVyZ2UoYWRkaXRpb25hbENvbnRleHQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmVnaW4gYSBuZXcgYWN0aW9uLCBhbmQgcmV0dXJuIGEgbmV3IHB1Ymxpc2hlciBmb3IgbWV0cmljcyByZWxhdGVkIHRvIHRoYXQgYWN0aW9uLlxuICAgICAqXG4gICAgICogQmVnaW5uaW5nIGEgbmV3IGFjdGlvbiBpbnZvbHZlcyB0aGUgZm9sbG93aW5nIHN0ZXBzOlxuICAgICAqICAgMS4gR2VuZXJhdGUgYSBuZXcgYWN0aW9uSWQgZm9yIHRoZSBhY3Rpb24sIHJhbmRvbWx5IGluIHRoZSBicm93c2VyXG4gICAgICogICAyLiBJZiB0aGVyZSBhcmUgYW55IHJlbGF0ZWQgbWV0cmljcyBpbiB0aGUgY29udGV4dCwgcHVibGlzaCB0aGVtXG4gICAgICogICAzLiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBwdWJsaXNoZXIgd2l0aCB0aGlzIG9iamVjdCdzIGNvbnRleHQsIG1lcmdlZCB3aXRoIGFueSBhZGRpdGlvbmFsIGNvbnRleHQgZ2l2ZW4sXG4gICAgICogICAgICBtZXJnZWQgd2l0aCB0aGUgYWN0aW9uSWQgZ2VuZXJhdGVkIGFib3ZlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxDb250ZXh0IEFkZGl0aW9uYWwgY29udGV4dCB0byBiZSBpbmNsdWRlZCBpbiB0aGUgbmV3IHB1Ymxpc2hlclxuICAgICAqIEByZXR1cm5zIE5ldyBwdWJsaXNoZXIgaWRlbnRpY2FsIHRvIHRoaXMgb25lLCBidXQgd2l0aCBhbiB1cGRhdGVkIGNvbnRleHRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm5ld0NoaWxkQWN0aW9uUHVibGlzaGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5ld0NoaWxkQWN0aW9uUHVibGlzaGVyKGFkZGl0aW9uYWxDb250ZXh0KSB7XG4gICAgICB2YXIgYWN0aW9uSWQgPSB0aGlzLl9nZW5lcmF0ZUFjdGlvbmlkKGFkZGl0aW9uYWxDb250ZXh0KTtcblxuICAgICAgdmFyIG5ld0NvbnRleHQgPSB0aGlzLmNvbnRleHQud2l0aG91dFJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uKCkubWVyZ2Uoe1xuICAgICAgICBhY3Rpb25JZDogYWN0aW9uSWRcbiAgICAgIH0pLm1lcmdlKGFkZGl0aW9uYWxDb250ZXh0KTtcbiAgICAgIHZhciBuZXdQdWJsaXNoZXIgPSBuZXcgS2F0YWxNZXRyaWNzUHVibGlzaGVyKHRoaXMuZHJpdmVyLCB0aGlzLmVycm9ySGFuZGxlciwgbmV3Q29udGV4dCk7XG4gICAgICB2YXIgYWxsUmVsYXRlZE1ldHJpY3MgPSBhZGRpdGlvbmFsQ29udGV4dCAmJiAhKGFkZGl0aW9uYWxDb250ZXh0IGluc3RhbmNlb2YgX0thdGFsTWV0cmljc0NvbnRleHQuZGVmYXVsdC5CdWlsZGVyKSA/IHRoaXMuZ2V0QWRkaXRpb25hbFJlbGF0ZWRNZXRyaWNzKGFkZGl0aW9uYWxDb250ZXh0KSA6IHRoaXMuZ2V0QmFzZVJlbGF0ZWRNZXRyaWNzKCk7XG5cbiAgICAgIGlmIChhbGxSZWxhdGVkTWV0cmljcykge1xuICAgICAgICBhbGxSZWxhdGVkTWV0cmljcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRyaWMpIHtcbiAgICAgICAgICBuZXdQdWJsaXNoZXIucHVibGlzaChtZXRyaWMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld1B1Ymxpc2hlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmVnaW4gYSBuZXcgY2hhaW5lZCBjaGlsZCBhY3Rpb24sIGFuZCByZXR1cm4gYSBuZXcgcHVibGlzaGVyIGZvciBtZXRyaWNzIHJlbGF0ZWQgdG8gdGhhdCBhY3Rpb24uXG4gICAgICpcbiAgICAgKiBBIGNoYWluZWQgYWN0aW9uIGlzIGhhbmRsZWQgdGhlIHNhbWUgd2F5IGFzIGluIG5ld0NoaWxkQWN0aW9uUHVibGlzaGVyLCBidXQgYWRkaXRpb25hbGx5LFxuICAgICAqIHRoZSByZXR1cm5lZCBwdWJsaXNoZXIgaGFzIGEgcmVsYXRlZE1ldHJpY05vSW5oZXJpdCBuYW1lZCBcInBhcmVudEFjdGlvbklkXCIsIHdpdGggdGhlIG5ld2x5XG4gICAgICogZ2VuZXJhdGVkIGFjdGlvbklkIGFzIGl0cyB2YWx1ZS5cbiAgICAgKlxuICAgICAqIFRoZSBlZmZlY3Qgb2YgdGhpcyBpcyB0aGF0IGFueSBmdXJ0aGVyIGNoYWluZWQgY2hpbGQgYWN0aW9ucyBjYW4gYmUgY29ubmVjdGVkIGJhY2sgdG8gdGhpc1xuICAgICAqIGFjdGlvbiB0aHJvdWdoIHRoZSBwYXJlbnRBY3Rpb25JZCwgYW5kIHNvIG9uIHJlY3Vyc2l2ZWx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxDb250ZXh0IEFkZGl0aW9uYWwgY29udGV4dCB0byBiZSBpbmNsdWRlZCBpbiB0aGUgbmV3IHB1Ymxpc2hlclxuICAgICAqIEByZXR1cm5zIE5ldyBwdWJsaXNoZXIgaWRlbnRpY2FsIHRvIHRoaXMgb25lLCBidXQgd2l0aCBhbiB1cGRhdGVkIGNvbnRleHRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm5ld0NoaWxkQWN0aW9uUHVibGlzaGVyQ2hhaW5lZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXdDaGlsZEFjdGlvblB1Ymxpc2hlckNoYWluZWQoYWRkaXRpb25hbENvbnRleHQpIHtcbiAgICAgIHZhciBhY3Rpb25JZCA9IHRoaXMuX2dlbmVyYXRlQWN0aW9uaWQoYWRkaXRpb25hbENvbnRleHQpO1xuXG4gICAgICB2YXIgcGFyZW50QWN0aW9uSWQgPSAoMCwgX2VtYmVkUmVxdWVzdElkLmVtYmVkUmVxdWVzdElkKShhY3Rpb25JZCwgdGhpcy5jb250ZXh0LmNvbnRleHQucmVxdWVzdElkKTtcbiAgICAgIHZhciByZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbiA9IFtuZXcgX0thdGFsTWV0cmljU3RyaW5nLmRlZmF1bHQoUEFSRU5UX0FDVElPTl9JRF9OQU1FLCBwYXJlbnRBY3Rpb25JZCldO1xuICAgICAgdmFyIG5ld0NvbnRleHQgPSBuZXcgX0thdGFsTWV0cmljc0NvbnRleHQuZGVmYXVsdCh7XG4gICAgICAgIGFjdGlvbklkOiBhY3Rpb25JZCxcbiAgICAgICAgcmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb246IHJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uXG4gICAgICB9KS5tZXJnZShhZGRpdGlvbmFsQ29udGV4dCk7XG4gICAgICByZXR1cm4gdGhpcy5uZXdDaGlsZEFjdGlvblB1Ymxpc2hlcihuZXdDb250ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgY2hhaW5lZCBjaGlsZCBhY3Rpb24gcHVibGlzaGVyIHdpdGggdGhlIGdpdmVuIHZhbHVlIGZvciBtZXRob2ROYW1lLlxuICAgICAqXG4gICAgICogQXBhcnQgZnJvbSBzZXR0aW5nIHRoZSBtZXRob2ROYW1lIGluIHRoZSBjaGlsZCBjb250ZXh0LCB0aGlzIG1ldGhvZCBpcyBpZGVudGljYWwgdG8gbmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXJDaGFpbmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1ldGhvZE5hbWUgTWV0aG9kIG5hbWUgZm9yIG5ldyBwdWJsaXNoZXIgY29udGV4dFxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsQ29udGV4dCBBZGRpdGlvbmFsIGNvbnRleHQgdG8gc3VwcGx5IChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJucyBOZXcgcHVibGlzaGVyIGlkZW50aWNhbCB0byB0aGlzIG9uZSwgYnV0IHdpdGggYW4gdXBkYXRlZCBjb250ZXh0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJuZXdDaGlsZEFjdGlvblB1Ymxpc2hlckNoYWluZWRGb3JNZXRob2RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXJDaGFpbmVkRm9yTWV0aG9kKG1ldGhvZE5hbWUsIGFkZGl0aW9uYWxDb250ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXdDaGlsZEFjdGlvblB1Ymxpc2hlckNoYWluZWQobmV3IF9LYXRhbE1ldHJpY3NDb250ZXh0LmRlZmF1bHQoe1xuICAgICAgICBtZXRob2ROYW1lOiBtZXRob2ROYW1lXG4gICAgICB9KS5tZXJnZShhZGRpdGlvbmFsQ29udGV4dCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBhY3Rpb24gcHVibGlzaGVyIHdpdGggdGhlIGdpdmVuIHZhbHVlIGZvciBtZXRob2ROYW1lLlxuICAgICAqXG4gICAgICogQXBhcnQgZnJvbSBzZXR0aW5nIHRoZSBtZXRob2ROYW1lIGluIHRoZSBjaGlsZCBjb250ZXh0LCB0aGlzIG1ldGhvZCBpcyBpZGVudGljYWwgdG8gbmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXJGb3JNZXRob2QuXG4gICAgICogQHBhcmFtIG1ldGhvZE5hbWUgTWV0aG9kIG5hbWUgZm9yIG5ldyBwdWJsaXNoZXIgY29udGV4dFxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsQ29udGV4dCBBZGRpdGlvbmFsIGNvbnRleHQgdG8gc3VwcGx5IChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJucyBOZXcgcHVibGlzaGVyIGlkZW50aWNhbCB0byB0aGlzIG9uZSwgYnV0IHdpdGggYW4gdXBkYXRlZCBjb250ZXh0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJuZXdDaGlsZEFjdGlvblB1Ymxpc2hlckZvck1ldGhvZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXdDaGlsZEFjdGlvblB1Ymxpc2hlckZvck1ldGhvZChtZXRob2ROYW1lLCBhZGRpdGlvbmFsQ29udGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMubmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXIobmV3IF9LYXRhbE1ldHJpY3NDb250ZXh0LmRlZmF1bHQoe1xuICAgICAgICBtZXRob2ROYW1lOiBtZXRob2ROYW1lXG4gICAgICB9KS5tZXJnZShhZGRpdGlvbmFsQ29udGV4dCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBhY3Rpb24gZm9yIGFwcGxpY2F0aW9uIGluaXRpYWxpemF0aW9uLiAgSXQgd2lsbCBhbHdheXMgaGF2ZSBhIG1ldGhvZE5hbWVcbiAgICAgKiBvZiBcIkluaXRpYWxpemF0aW9uXCI7IG90aGVyd2lzZSB0aGlzIG1ldGhvZCBpcyBpZGVudGljYWwgdG8gbmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXJGb3JNZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbENvbnRleHQgQWRkaXRpb25hbCBjb250ZXh0IHRvIGJlIGluY2x1ZGVkIGluIHRoZSBuZXcgcHVibGlzaGVyXG4gICAgICogQHJldHVybnMgTmV3IHB1Ymxpc2hlciBpZGVudGljYWwgdG8gdGhpcyBvbmUsIGJ1dCB3aXRoIGFuIHVwZGF0ZWQgY29udGV4dFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXJGb3JJbml0aWFsaXphdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXdDaGlsZEFjdGlvblB1Ymxpc2hlckZvckluaXRpYWxpemF0aW9uKGFkZGl0aW9uYWxDb250ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXdDaGlsZEFjdGlvblB1Ymxpc2hlckZvck1ldGhvZChJTklUSUFMSVpBVElPTl9NRVRIT0RfTkFNRSwgYWRkaXRpb25hbENvbnRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIHB1Ymxpc2ggYSBzdHJpbmcgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBhbmQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBNZXRyaWMgbmFtZVxuICAgICAqIEBwYXJhbSB2YWx1ZSBTdHJpbmcgdmFsdWVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInB1Ymxpc2hTdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVibGlzaFN0cmluZyhuYW1lLCB2YWx1ZSkge1xuICAgICAgdGhpcy5wdWJsaXNoKG5ldyBLYXRhbE1ldHJpY3MuTWV0cmljLlN0cmluZyhuYW1lLCB2YWx1ZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIHB1Ymxpc2ggYSBzdHJpbmcgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBhbmQgdmFsdWUsIHRydW5jYXRlZCB0byB0aGUgbWF4aW11bSBzaXplIGFsbG93ZWQgYnkgdGhlXG4gICAgICogc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgTWV0cmljIG5hbWVcbiAgICAgKiBAcGFyYW0gdmFsdWUgU3RyaW5nIHZhbHVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwdWJsaXNoU3RyaW5nVHJ1bmNhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVibGlzaFN0cmluZ1RydW5jYXRlKG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YXIgb2JqZWN0ID0gbmV3IEthdGFsTWV0cmljcy5NZXRyaWMuU3RyaW5nKG5hbWUsIHZhbHVlKTtcbiAgICAgIG9iamVjdC50cnVuY2F0ZSA9IHRydWU7XG4gICAgICB0aGlzLnB1Ymxpc2gob2JqZWN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBwdWJsaXNoIGEgY291bnRlciB3aXRoIHRoZSBnaXZlbiBuYW1lIGFuZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIE1ldHJpYyBuYW1lXG4gICAgICogQHBhcmFtIHZhbHVlIENvdW50ZXIgdmFsdWVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInB1Ymxpc2hDb3VudGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1Ymxpc2hDb3VudGVyKG5hbWUsIHZhbHVlKSB7XG4gICAgICB0aGlzLnB1Ymxpc2gobmV3IEthdGFsTWV0cmljcy5NZXRyaWMuQ291bnRlcihuYW1lLCB2YWx1ZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIHB1Ymxpc2ggYSB0aW1lciB3aXRoIHRoZSBnaXZlbiBuYW1lIGFuZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIE1ldHJpYyBuYW1lXG4gICAgICogQHBhcmFtIHZhbHVlIFRpbWVyIHZhbHVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwdWJsaXNoVGltZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVibGlzaFRpbWVyKG5hbWUsIHZhbHVlKSB7XG4gICAgICB0aGlzLnB1Ymxpc2gobmV3IEthdGFsTWV0cmljcy5NZXRyaWMuVGltZXIobmFtZSwgdmFsdWUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBwdWJsaXNoIGEgY291bnRlciB3aXRoIHRoZSBpc01vbml0b3IgZmxhZyBzZXQsIGFuZCB0aGUgZ2l2ZW4gbmFtZSBhbmQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBNZXRyaWMgbmFtZVxuICAgICAqIEBwYXJhbSB2YWx1ZSBDb3VudGVyIHZhbHVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwdWJsaXNoQ291bnRlck1vbml0b3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVibGlzaENvdW50ZXJNb25pdG9yKG5hbWUsIHZhbHVlKSB7XG4gICAgICB0aGlzLnB1Ymxpc2gobmV3IEthdGFsTWV0cmljcy5NZXRyaWMuQ291bnRlcihuYW1lLCB2YWx1ZSkud2l0aE1vbml0b3IoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gcHVibGlzaCBhIHRpbWVyIHdpdGggdGhlIGlzTW9uaXRvciBmbGFnIHNldCwgYW5kIHRoZSBnaXZlbiBuYW1lIGFuZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIE1ldHJpYyBuYW1lXG4gICAgICogQHBhcmFtIHZhbHVlIFRpbWVyIHZhbHVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwdWJsaXNoVGltZXJNb25pdG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1Ymxpc2hUaW1lck1vbml0b3IobmFtZSwgdmFsdWUpIHtcbiAgICAgIHRoaXMucHVibGlzaChuZXcgS2F0YWxNZXRyaWNzLk1ldHJpYy5UaW1lcihuYW1lLCB2YWx1ZSkud2l0aE1vbml0b3IoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByaXZhdGUgaGVscGVyIG1ldGhvZCB0byBleHRyYWN0IGFuIGFjdGlvbklkIGZyb20gYSBjb250ZXh0IGlmIG9uZSBpcyBwcm92aWRlZCwgYW5kIG90aGVyd2lzZSBnZW5lcmF0ZSBhIG5ldyBvbmUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBY3Rpb24gSUQgc3RyaW5nXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2VuZXJhdGVBY3Rpb25pZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2VuZXJhdGVBY3Rpb25pZChjb250ZXh0KSB7XG4gICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICB2YXIgZmllbGRzID0gZ2V0Q29udGV4dEZpZWxkcyhjb250ZXh0KTtcblxuICAgICAgICBpZiAoZmllbGRzLmFjdGlvbklkKSB7XG4gICAgICAgICAgcmV0dXJuIGZpZWxkcy5hY3Rpb25JZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gKDAsIF92LmRlZmF1bHQpKCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBLYXRhbE1ldHJpY3NQdWJsaXNoZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEthdGFsTWV0cmljc1B1Ymxpc2hlcjsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuREVGQVVMVF9FUlJPUl9IQU5ETEVSID0gdm9pZCAwO1xuXG52YXIgREVGQVVMVF9FUlJPUl9IQU5ETEVSID0gZnVuY3Rpb24gREVGQVVMVF9FUlJPUl9IQU5ETEVSKGVycikge1xuICB0aHJvdyBlcnI7XG59O1xuXG5leHBvcnRzLkRFRkFVTFRfRVJST1JfSEFORExFUiA9IERFRkFVTFRfRVJST1JfSEFORExFUjsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbi8qKlxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgYSBLYXRhbCBtZXRyaWNzIGRyaXZlci5cbiAqL1xudmFyIEthdGFsTWV0cmljc0RyaXZlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEthdGFsTWV0cmljc0RyaXZlcigpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBLYXRhbE1ldHJpY3NEcml2ZXIpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoS2F0YWxNZXRyaWNzRHJpdmVyLCBbe1xuICAgIGtleTogXCJwdWJsaXNoXCIsXG5cbiAgICAvKipcbiAgICAgKiBQdWJsaXNoIHRoZSBnaXZlbiBtZXRyaWMgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGVycm9yIGhhbmRsZXIgYW5kIGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWV0cmljT2JqZWN0IE1ldHJpYyBvYmplY3QgdG8gcHVibGlzaC4gIENvbnRhaW5zIG1ldHJpY0tleSwgaXNNb25pdG9yLCB0eXBlLCBhbmQgdmFsdWUuXG4gICAgICogQHBhcmFtIGVycm9ySGFuZGxlciBDYWxsYmFjayBmdW5jdGlvbiBmb3IgaGFuZGxpbmcgYW55IGFzeW5jaHJvbm91cyBlcnJvcnMgdGhhdCBvY2N1ciBpbiB0aGUgZHJpdmVyXG4gICAgICogICAgICh0aGUgZHJpdmVyIHNob3VsZCBqdXN0IHRocm93IGFuIGV4Y2VwdGlvbiBmb3IgYSBzeW5jaHJvbm91cyBlcnJvcikuXG4gICAgICogQHBhcmFtIGNvbnRleHQgQ29udGV4dCBmb3IgcHVibGlzaGluZyB0aGlzIG1ldHJpYy4gIENvbnRhaW5zIGFsbCBvdGhlciBmaWVsZHMgdG8gYmUgcHVibGlzaGVkLlxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBwdWJsaXNoKG1ldHJpY09iamVjdCwgZXJyb3JIYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0thdGFsTWV0cmljc0RyaXZlciBpcyBhbiBhYnN0cmFjdCBjbGFzcywgcGxlYXNlIGNob29zZSBhIGRyaXZlciBhbmQgdXNlIHRoYXQgaW5zdGVhZCcpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gS2F0YWxNZXRyaWNzRHJpdmVyO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBLYXRhbE1ldHJpY3NEcml2ZXI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBmaXJzdE1hcDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBub24tdW5kZWZpbmVkIHZhbHVlIHRoYXQgcmVzdWx0cyBmcm9tIHJ1bm5pbmcgZWFjaCB2YWx1ZVxuICogaW4gdGhlIGdpdmVuIGFycmF5IHRocm91Z2ggdGhlIG1hcHBlciBmdW5jdGlvbi5cbiAqIEBwYXJhbSBhcnJheSBBbiBhcnJheSBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0gbWFwcGVyIEEgbWFwcGVyIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIHJldHVybiBhIHZhbHVlIG9yIHVuZGVmaW5lZC5cbiAqIEByZXR1cm5zIFRoZSBmaXJzdCBub24tdW5kZWZpbmVkIHZhbHVlIGZyb20gdGhlIG1hcHBlciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gZmlyc3RNYXAoYXJyYXksIG1hcHBlcikge1xuICB2YXIgdG9SZXR1cm4gPSB1bmRlZmluZWQ7XG4gIGFycmF5LnNvbWUoZnVuY3Rpb24gKHZhbCkge1xuICAgIHRvUmV0dXJuID0gbWFwcGVyKHZhbCk7XG4gICAgcmV0dXJuIHRvUmV0dXJuICE9IG51bGw7XG4gIH0pO1xuICByZXR1cm4gdG9SZXR1cm47XG59XG5cbjsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBvYmplY3RWYWx1ZXMgPSBPYmplY3QudmFsdWVzID8gT2JqZWN0LnZhbHVlcyA6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gIH0pO1xufTtcbnZhciBfZGVmYXVsdCA9IG9iamVjdFZhbHVlcztcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZhbGlkYXRlU2ltcGxlSW50O1xuXG52YXIgX3R5cGVvZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKSk7XG5cbi8qKlxuICogTnVtYmVyLmlzSW50ZWdlciBpcyBub3QgaW4gSUUxMSwgYW5kIGxldHRpbmcgQmFiZWwgcG9seWZpbGwgaXQgYWRkZWQgdG9vIG11Y2ggd2VpZ2h0LlxuICogQWRhcHRlZCBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlci9pc0ludGVnZXJcbiAqL1xudmFyIGlzSW50ZWdlciA9IGZ1bmN0aW9uIGlzSW50ZWdlcih2YWwpIHtcbiAgcmV0dXJuIGlzRmluaXRlKHZhbCkgJiYgTWF0aC5mbG9vcih2YWwpID09PSB2YWw7XG59O1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgdmFsaWQgdG8gYmUgcHVibGlzaGVkIHRvIEthdGFsTWV0cmljcyBhcyBhbiBpbnRlZ2VyIChDb3VudGVyIG9yIFRpbWVyKSxcbiAqIGFuZCByZXR1cm4gZWl0aGVyIHVuZGVmaW5lZCAobm8gZXJyb3IpLCBvciBhbiBFcnJvciBvYmplY3QgZGVzY3JpYmluZyB0aGUgcHJvYmxlbS5cbiAqXG4gKiBAcGFyYW0gdmFsIFZhbHVlIHRvIGNoZWNrXG4gKiBAcGFyYW0gbmFtZUZvckVycm9yIE5hbWUgdG8gdXNlIHdoZW4gY29uc3RydWN0aW5nIHRoZSBlcnJvciBtZXNzYWdlLCBpZiBuZWNlc3NhcnlcbiAqIEByZXR1cm5zIEVycm9yLCBvciB1bmRlZmluZWQgaWYgbm8gZXJyb3JcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlU2ltcGxlSW50KHZhbCwgbmFtZUZvckVycm9yKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJFeHBlY3RlZCBcIi5jb25jYXQobmFtZUZvckVycm9yLCBcIiB0byBoYXZlIHR5cGUgJ251bWJlcicsIGJ1dCBpdCB3YXMgdHlwZSAnXCIpLmNvbmNhdCgoMCwgX3R5cGVvZjIuZGVmYXVsdCkodmFsKSwgXCInXCIpKTtcbiAgfVxuXG4gIGlmICh2YWwgPCAwKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcIkV4cGVjdGVkIFwiLmNvbmNhdChuYW1lRm9yRXJyb3IsIFwiIHRvIGJlIHBvc2l0aXZlLCBidXQgaXQgd2FzIFwiKS5jb25jYXQodmFsKSk7XG4gIH0gLy8gVGhpcyB3aWxsIGFsc28gY2F0Y2ggTmFOIGFuZCBJbmZpbml0eVxuXG5cbiAgaWYgKCFpc0ludGVnZXIodmFsKSkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJFeHBlY3RlZCBcIi5jb25jYXQobmFtZUZvckVycm9yLCBcIiB0byBiZSBhbiBpbnRlZ2VyLCBidXQgaXQgd2FzIFwiKS5jb25jYXQodmFsKSk7XG4gIH0gLy8gQ291bGRuJ3QgZmluZCBhbnl0aGluZyB3cm9uZywgaW1wbGljaXRseSByZXR1cm4gdW5kZWZpbmVkXG5cbn1cblxuOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZhbGlkYXRlU2ltcGxlU3RyaW5nO1xuXG52YXIgX3R5cGVvZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKSk7XG5cbnZhciBTSU1QTEVfU1RSSU5HX1BBVCA9IC9eW0EtWmEtejAtOS46QF8vLV0rJC87XG52YXIgU0lNUExFX1NUUklOR19NQVhfTEVOID0gMTI3O1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgdmFsaWQgdG8gYmUgcHVibGlzaGVkIHRvIEthdGFsTWV0cmljcyBhcyBhIGZpZWxkIHZhbHVlLFxuICogc3VjaCBhcyBzaXRlLCBzZXJ2aWNlTmFtZSwgbWV0aG9kTmFtZSwgb3IgYWN0aW9uSWQgKG5vdGUgdGhpcyBpcyBub3QgdXNlZCB0byBjaGVjayB2YWx1ZXMgZm9yIHN0cmluZyBtZXRyaWNzKS5cbiAqIEl0IHJldHVybnMgZWl0aGVyIHVuZGVmaW5lZCAobm8gZXJyb3IpLCBvciBhbiBFcnJvciBvYmplY3QgZGVzY3JpYmluZyB0aGUgcHJvYmxlbS5cbiAqXG4gKiBUbyBiZSBwdWJsaXNoZWQsIGl0IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nLCBsZXNzIHRoYW4gMjU2IGNoYXJhY3RlcnMsIGNvbnRhaW5pbmcgb25seSBBU0NJSVxuICogbGV0dGVycywgbnVtYmVycywgb3IgdGhlc2UgY2hhcmFjdGVyczogLjpAXy8tICh0aG9zZSBhcmUgdGhlIFBNRVQgZmllbGQgdmFsdWUgcmVxdWlyZW1lbnRzKS5cbiAqXG4gKiBAcGFyYW0gdmFsIFN0cmluZyB2YWx1ZSB0byBjaGVja1xuICogQHBhcmFtIG5hbWVGb3JFcnJvciBOYW1lIHRvIHVzZSBpbiB0aGUgZXJyb3IgbWVzc2FnZSwgaWYgb25lIGlzIGdlbmVyYXRlZFxuICogQHJldHVybnMgRXJyb3IsIG9yIHVuZGVmaW5lZCBpZiBubyBlcnJvclxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlU2ltcGxlU3RyaW5nKHZhbCwgbmFtZUZvckVycm9yKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcIkV4cGVjdGVkIFwiLmNvbmNhdChuYW1lRm9yRXJyb3IsIFwiIHRvIGJlIGEgc3RyaW5nLCBidXQgaXQgd2FzIGEgXCIpLmNvbmNhdCgoMCwgX3R5cGVvZjIuZGVmYXVsdCkodmFsKSkpO1xuICB9XG5cbiAgaWYgKHZhbC5sZW5ndGggPiBTSU1QTEVfU1RSSU5HX01BWF9MRU4pIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiRXhwZWN0ZWQgXCIuY29uY2F0KG5hbWVGb3JFcnJvciwgXCIgdG8gYmUgbGVzcyB0aGFuIFwiKS5jb25jYXQoU0lNUExFX1NUUklOR19NQVhfTEVOLCBcIiBjaGFyYWN0ZXJzLCBidXQgaXQgd2FzIFwiKS5jb25jYXQodmFsLmxlbmd0aCwgXCIgY2hhcmFjdGVyc1wiKSk7XG4gIH1cblxuICBpZiAodmFsLmxlbmd0aCA8IDEpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiRXhwZWN0ZWQgXCIuY29uY2F0KG5hbWVGb3JFcnJvciwgXCIgdG8gYmUgbm9uLWJsYW5rXCIpKTtcbiAgfVxuXG4gIGlmICghU0lNUExFX1NUUklOR19QQVQudGVzdCh2YWwpKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcIkV4cGVjdGVkIFwiLmNvbmNhdChuYW1lRm9yRXJyb3IsIFwiIHRvIGNvbnRhaW4gb25seSB2YWxpZCBjaGFyYWN0ZXJzLCBidXQgaXQgd2FzIFwiKS5jb25jYXQodmFsLCBcIi4gIEl0IGNhbiBvbmx5IGNvbnRhaW4gbGV0dGVycywgbnVtYmVycywgYW5kIHRoZXNlIHN5bWJvbHM6IC46QF8vLVwiKSk7XG4gIH0gLy8gQ291bGRuJ3QgZmluZCBhbnl0aGluZyB3cm9uZywgaW1wbGljaXRseSByZXR1cm4gdW5kZWZpbmVkXG5cbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZW1iZWRSZXF1ZXN0SWQgPSBlbWJlZFJlcXVlc3RJZDtcblxuLy8gdW50aWwgd2UgY2FuIGFkZCBhIHJlcXVlc3RJZCBmaWVsZCB0byB0aGUgYW5kZXMgc2NoZW1hIHdlIHdpbGwgZW1iZWQgaXQgaW4gdGhlIGFjdGlvbklkXG5mdW5jdGlvbiBlbWJlZFJlcXVlc3RJZChhY3Rpb25JZCwgcmVxdWVzdElkKSB7XG4gIGlmIChyZXF1ZXN0SWQpIHtcbiAgICByZXR1cm4gW3JlcXVlc3RJZCwgYWN0aW9uSWRdLmpvaW4oXCI6OlwiKTtcbiAgfVxuXG4gIHJldHVybiBhY3Rpb25JZDtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm1lcmdlTGlzdHMgPSBtZXJnZUxpc3RzO1xuXG52YXIgX3RvQ29uc3VtYWJsZUFycmF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXlcIikpO1xuXG4vLyBIZWxwZXIgbWV0aG9kIHRvIG1lcmdlIHR3byBsaXN0cyB3aGljaCBjb3VsZCBiZSB1bmRlZmluZWRcbi8vIFJldHVybnMgbWVyZ2VkIGxpc3RzIGlmIGVpdGhlciBpcyBkZWZpbmVkLCBvdGhlcndpc2UgcmV0dXJucyB1bmRlZmluZWRcbmZ1bmN0aW9uIG1lcmdlTGlzdHMobGlzdDEsIGxpc3QyKSB7XG4gIGlmIChsaXN0MSB8fCBsaXN0Mikge1xuICAgIHJldHVybiBbXS5jb25jYXQoKDAsIF90b0NvbnN1bWFibGVBcnJheTIuZGVmYXVsdCkobGlzdDEgfHwgW10pLCAoMCwgX3RvQ29uc3VtYWJsZUFycmF5Mi5kZWZhdWx0KShsaXN0MiB8fCBbXSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kaXNwYXRjaE1ldHJpY0V2ZW50ID0gZGlzcGF0Y2hNZXRyaWNFdmVudDtcblxuLyoqXG4gKiBQdWJsaXNoIHRvIGV4dGVybmFsIHBhcnRpZXMgdGhhdCBhcmUgXG4gKiBsaXN0ZW5pbmcgZm9yIGthdGFsLm1ldHJpY3MucHVibGlzaCBDdXN0b20gRXZlbnRzXG4gKi9cbmZ1bmN0aW9uIGRpc3BhdGNoTWV0cmljRXZlbnQobWV0cmljLCBjb250ZXh0KSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGRpc3BhdGNoQ3VzdG9tRXZlbnQobWV0cmljLCBjb250ZXh0KTsgLy8gZm9yIGxlZ2FjeSBwdXJwb3NlcywgYWxzbyBwdWJsaXNoIHRvIF9fS0FUQUxfTUVUUklDU19FWFRFTlNJT05fX1xuXG4gIHB1Ymxpc2hUb01ldHJpY3NFeHRlbnNpb24obWV0cmljLCBjb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hDdXN0b21FdmVudChtZXRyaWMsIGNvbnRleHQpIHtcbiAgaWYgKHR5cGVvZiBDdXN0b21FdmVudCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdrYXRhbC5tZXRyaWNzLnB1Ymxpc2gnLCB7XG4gICAgZGV0YWlsOiB7XG4gICAgICBtZXRyaWM6IG1ldHJpYyxcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQuZ2V0RmllbGRzKClcbiAgICB9XG4gIH0pO1xuICB3aW5kb3cuZGlzcGF0Y2hFdmVudChldmVudCk7XG59XG4vKipcbiAqIEBEZXByZWNhdGVkXG4gKiBQdWJsaXNoIHRvIGh0dHBzOi8vY29kZS5hbWF6b24uY29tL3BhY2thZ2VzL0thdGFsTWV0cmljc0V4dGVuc2lvblxuICogVGhlIGV4dGVuc2lvbiBpbmplY3RzIGEgZ2xvYmFsIF9fS0FUQUxfTUVUUklDU19FWFRFTlNJT05fXyBvYmplY3Qgd2l0aCBhXG4gKiBgcHVibGlzaGAgbWV0aG9kLlxuICovXG5cblxuZnVuY3Rpb24gcHVibGlzaFRvTWV0cmljc0V4dGVuc2lvbihtZXRyaWMsIGNvbnRleHQpIHtcbiAgdmFyIGV4dGVuc2lvbiA9IHdpbmRvdy5fX0tBVEFMX01FVFJJQ1NfRVhURU5TSU9OX187XG5cbiAgaWYgKGV4dGVuc2lvbikge1xuICAgIGV4dGVuc2lvbi5wdWJsaXNoKG1ldHJpYywgY29udGV4dC5nZXRGaWVsZHMoKSk7XG4gIH1cbn0iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlV2lsZGNhcmRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQdWJsaXNoZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0thdGFsTWV0cmljc1B1Ymxpc2hlci5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbnRleHRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0thdGFsTWV0cmljc0NvbnRleHQuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNZXRyaWNzRHJpdmVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9LYXRhbE1ldHJpY3NEcml2ZXIuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFcnJvckhhbmRsZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0Vycm9ySGFuZGxlci5FcnJvckhhbmRsZXI7XG4gIH1cbn0pO1xuZXhwb3J0cy5NZXRyaWMgPSB2b2lkIDA7XG5cbnZhciBNZXRyaWMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9tZXRyaWNPYmplY3RcIikpO1xuXG5leHBvcnRzLk1ldHJpYyA9IE1ldHJpYztcblxudmFyIF9LYXRhbE1ldHJpY3NQdWJsaXNoZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljc1B1Ymxpc2hlclwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNzQ29udGV4dCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNzQ29udGV4dFwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNzRHJpdmVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9kcml2ZXIvS2F0YWxNZXRyaWNzRHJpdmVyXCIpKTtcblxudmFyIF9FcnJvckhhbmRsZXIgPSByZXF1aXJlKFwiLi9kcml2ZXIvRXJyb3JIYW5kbGVyXCIpOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfZ2V0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0XCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY09iamVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljT2JqZWN0XCIpKTtcblxudmFyIF9WYWxpZGF0ZVNpbXBsZUludCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2hlbHBlci9WYWxpZGF0ZVNpbXBsZUludFwiKSk7XG5cbi8qKlxuICogQ291bnRlciB0eXBlLlxuICpcbiAqIENhbiBiZSB1c2VkIHRvIGNvdW50IHRoZSBudW1iZXIgb2YgdGltZXMgYW4gZXZlbnQgaGFwcGVuZWQgb24gYSBwYWdlLCBvciBhcyBhIHNpbXBsZSAxLzAgY291bnRlciB0byB0cmFja1xuICogc3VjY2VzcyBhbmQgZmFpbHVyZS5cbiAqL1xudmFyIEthdGFsTWV0cmljQ291bnRlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0thdGFsTWV0cmljT2JqZWN0KSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEthdGFsTWV0cmljQ291bnRlciwgX0thdGFsTWV0cmljT2JqZWN0KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGNvdW50ZXIgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBhbmQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIENvdW50ZXIgbmFtZVxuICAgKiBAcGFyYW0gdmFsdWUgQ291bnRlciB2YWx1ZVxuICAgKi9cbiAgZnVuY3Rpb24gS2F0YWxNZXRyaWNDb3VudGVyKG5hbWUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgS2F0YWxNZXRyaWNDb3VudGVyKTtcbiAgICBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIuZGVmYXVsdCkodGhpcywgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoS2F0YWxNZXRyaWNDb3VudGVyKS5jYWxsKHRoaXMsIG5hbWUpKTtcbiAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBmb3IgdGhpcyBjb3VudGVyXG4gICAqXG4gICAqIEByZXR1cm4gQ291bnRlciB2YWx1ZVxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEthdGFsTWV0cmljQ291bnRlciwgW3tcbiAgICBrZXk6IFwiYWRkXCIsXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBudW1iZXIgdG8gdGhpcyBjb3VudGVyLlxuICAgICAqXG4gICAgICogQ2FuIGFsc28gYmUgbmVnYXRpdmUgdG8gc3VidHJhY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkVmFsdWUgQW1vdW50IHRvIGFkZCB0byB0aGlzIGNvdW50ZXJcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKGFkZFZhbHVlKSB7XG4gICAgICB0aGlzLnZhbHVlICs9IGFkZFZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWxpZGF0aW9uRXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGlvbkVycm9yKCkge1xuICAgICAgdmFyIHN1cGVyRXJyb3IgPSAoMCwgX2dldDIuZGVmYXVsdCkoKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoS2F0YWxNZXRyaWNDb3VudGVyLnByb3RvdHlwZSksIFwidmFsaWRhdGlvbkVycm9yXCIsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICBpZiAoc3VwZXJFcnJvcikgcmV0dXJuIHN1cGVyRXJyb3I7XG4gICAgICByZXR1cm4gKDAsIF9WYWxpZGF0ZVNpbXBsZUludC5kZWZhdWx0KSh0aGlzLnZhbHVlLCBcImZpZWxkIHZhbHVlIGluIENvdW50ZXIgbWV0cmljcyBvYmplY3QgJ1wiLmNvbmNhdCh0aGlzLm5hbWUsIFwiJ1wiKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbHVlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBhIG5ldyB2YWx1ZSBmb3IgdGhpcyBjb3VudGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgTmV3IHZhbHVlIGZvciB0aGlzIGNvdW50ZXJcbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIC8vIE1hdGgucm91bmQgd2lsbCBhbHNvIGNvZXJjZSBmcm9tIGEgc3RyaW5nIGlmIG5lY2Vzc2FyeSwgYW5kIHJldHVybiBOYU4gaWYgaW52YWxpZFxuICAgICAgdGhpcy5fdmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdHlwZSBmb3IgdGhpcyBjb3VudGVyLlxuICAgICAqXG4gICAgICogQHJldHVybiBBbHdheXMgcmV0dXJucyBcIkNvdW50ZXJcIi5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInR5cGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfS2F0YWxNZXRyaWNPYmplY3QyLmRlZmF1bHQuVHlwZXMuQ291bnRlcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FuTW9uaXRvclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBLYXRhbE1ldHJpY0NvdW50ZXI7XG59KF9LYXRhbE1ldHJpY09iamVjdDIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEthdGFsTWV0cmljQ291bnRlcjsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX0thdGFsTWV0cmljVGltZWRBdHRlbXB0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdFwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljU3RyaW5nXCIpKTtcblxuLyoqXG4gKiBTdGFuZGFyZGl6ZWQgbWV0cmljIGZvciBpbnN0cnVtZW50aW5nIEhUVFAgcmVxdWVzdHMuXG4gKlxuICogVW5kZXIgdGhlIGhvb2QgaXQgaXMgYSBLYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdCB3aXRoIHRoZSBuYW1lIHlvdSBwcm92aWRlIHByZWZpeGVkIHdpdGggXCJIVFRQUmVxdWVzdC5cIi5cbiAqIFRoYXQgb2JqZWN0IHdpbGwgY29udGFpbiBhIG1ldHJpYyBzdWZmaXhlZCB3aXRoIFwiLkxhdGVuY3lcIiBmb3IgdGhlIGxhdGVuY3kgb2YgdGhpcyByZXF1ZXN0LCBhbmQgYSBtZXRyaWMgc3VmZml4ZWRcbiAqIHdpdGggXCIuRmFpbHVyZVwiIHRvIHJlY29yZCB0aGUgZmFpbHVyZSBvciBzdWNjZXNzIG9mIHRoaXMgcmVxdWVzdC5cbiAqXG4gKiBCeSBkZWZhdWx0IHRoZSByZXF1ZXN0IHdpbGwgYmUgdHJhY2tlZCBhcyBhIGZhaWx1cmU7IHRvIG1hcmsgaXQgYXMgYSBzdWNjZXNzIGNhbGwgdGhlIFwic2V0U3VjY2VzcygpXCIgbWV0aG9kLlxuICpcbiAqIEl0IGhhcyBhZGRpdGlvbmFsIHByb3BlcnRpZXMgd2hpY2ggd2lsbCBiZSBlbWl0dGVkIGlmIHNldDsgc2VlIHVybCwgc3RhdHVzQ29kZSwgYW5kIHN0YXR1c1RleHQuXG4gKlxuICogRm9yIGV4YW1wbGUsIGlmIHlvdSBnYXZlIHRoZSBuYW1lIFwiU2VhcmNoXCIsIHRoZXNlIG1ldHJpY3Mgd2lsbCBiZSBjcmVhdGVkOlxuICogICBIVFRQUmVxdWVzdC5TZWFyY2guTGF0ZW5jeSAtIExhdGVuY3kgZm9yIHRoaXMgcmVxdWVzdFxuICogICBIVFRQUmVxdWVzdC5TZWFyY2guRmFpbHVyZSAtIEZhaWx1cmUgZm9yIHRoaXMgcmVxdWVzdCAoMSBmb3IgZmFpbHVyZSwgMCBmb3Igc3VjY2VzcylcbiAqL1xudmFyIEthdGFsTWV0cmljSHR0cFJlcXVlc3QgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9LYXRhbE1ldHJpY1RpbWVkQXR0ZSkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LCBfS2F0YWxNZXRyaWNUaW1lZEF0dGUpO1xuXG4gIC8qKiBUaGUgcHJlZml4IGZvciB0aGlzIG1ldHJpYy4gKi9cblxuICAvKiogVGhlIHN1ZmZpeCBmb3IgVVJMIG1ldHJpY3Mgb2YgdGhpcyBjbGFzcy4gKi9cblxuICAvKiogVGhlIHN1ZmZpeCBmb3IgSFRUUCByZXNwb25zZSBjb2RlIG1ldHJpY3Mgb2YgdGhpcyBjbGFzcy4gKi9cblxuICAvKiogVGhlIHN1ZmZpeCBmb3IgSFRUUCByZXNwb25zZSB0ZXh0IG1ldHJpY3Mgb2YgdGhpcyBjbGFzcy4gKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IEhUVFAgUmVxdWVzdCB0aW1lZCBhdHRlbXB0IG1ldHJpYyBpbmNvcnBvcmF0aW5nIHRoZSBnaXZlbiBuYW1lLlxuICAgKlxuICAgKiBUaGUgbmFtZSB5b3UgZ2l2ZSB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlIGEgS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQgd2l0aCB0aGUgcHJvdmlkZWQgbmFtZSBwcmVmaXhlZCB3aXRoIFwiSFRUUFJlcXVlc3QuXCIuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhpcyBtZXRyaWM7IHJlc3VsdGluZyBtZXRyaWNzIHdpbGwgcHJlZml4IHRoaXMgbmFtZSB3aXRoIFwiSFRUUFJlcXVlc3QuXCJcbiAgICovXG4gIGZ1bmN0aW9uIEthdGFsTWV0cmljSHR0cFJlcXVlc3QobmFtZSkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEthdGFsTWV0cmljSHR0cFJlcXVlc3QpO1xuICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yLmRlZmF1bHQpKHRoaXMsICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKEthdGFsTWV0cmljSHR0cFJlcXVlc3QpLmNhbGwodGhpcywgXCJcIi5jb25jYXQoS2F0YWxNZXRyaWNIdHRwUmVxdWVzdC5IVFRQX1JFUVVFU1RfUFJFRklYLCBcIi5cIikuY29uY2F0KG5hbWUpKSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgdXJsIGZvciB0aGlzIG1ldHJpYy5cbiAgICpcbiAgICogQSBzdHJpbmcgbWV0cmljIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGxpc3Qgb2Ygb2JqZWN0cyB0aGF0IHdpbGwgYmUgcHVibGlzaGVkIGZvciB0aGlzIG1ldHJpYy4gIEl0cyBuYW1lIHdpbGxcbiAgICogYmUgdGhpcyBtZXRyaWNzIG5hbWUgc3VmZml4ZWQgd2l0aCAnLlVSTCcsIGFuZCBpdHMgdmFsdWUgd2lsbCBiZSB0aGUgVVJMIHZhbHVlIGdpdmVuIGhlcmUuXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZSBVUkwgZm9yIHRoaXMgbWV0cmljXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoS2F0YWxNZXRyaWNIdHRwUmVxdWVzdCwgW3tcbiAgICBrZXk6IFwidXJsXCIsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0T3JEZWxldGVOYW1lZE1ldHJpY1ZhbHVlKEthdGFsTWV0cmljSHR0cFJlcXVlc3QuVVJMX1NVRkZJWCwgX0thdGFsTWV0cmljU3RyaW5nLmRlZmF1bHQsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBVUkwgZm9yIHRoaXMgbWV0cmljLCBpZiBkZWZpbmVkLlxuICAgICAqXG4gICAgICogQHJldHVybiBUaGUgVVJMIGZvciB0aGlzIG1ldHJpYywgb3IgdW5kZWZpbmVkXG4gICAgICovXG4gICAgLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TmFtZWRNZXRyaWNWYWx1ZShLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LlVSTF9TVUZGSVgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIFVSTCBtZXRyaWMgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1ldHJpYywgaWYgZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gQXNzb2NpYXRlZCBVUkwgbWV0cmljIG9iamVjdCwgb3IgdW5kZWZpbmVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cmxNZXRyaWNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE5hbWVkTWV0cmljKEthdGFsTWV0cmljSHR0cFJlcXVlc3QuVVJMX1NVRkZJWCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgSFRUUCByZXNwb25zZSBzdGF0dXMgY29kZSBmb3IgdGhpcyBtZXRyaWMuXG4gICAgICpcbiAgICAgKiBBIHN0cmluZyBtZXRyaWMgd2lsbCBiZSBhZGRlZCB0byB0aGUgbGlzdCBvZiBvYmplY3RzIHRoYXQgd2lsbCBiZSBwdWJsaXNoZWQgZm9yIHRoaXMgbWV0cmljLiAgSXRzIG5hbWUgd2lsbFxuICAgICAqIGJlIHRoaXMgbWV0cmljcyBuYW1lIHN1ZmZpeGVkIHdpdGggJy5TdGF0dXNDb2RlJywgYW5kIGl0cyB2YWx1ZSB3aWxsIGJlIHRoZSBzdGF0dXMgY29kZSB2YWx1ZSBnaXZlbiBoZXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGUgZm9yIHRoaXMgbWV0cmljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzdGF0dXNDb2RlXCIsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0T3JEZWxldGVOYW1lZE1ldHJpY1ZhbHVlKEthdGFsTWV0cmljSHR0cFJlcXVlc3QuU1RBVFVTX0NPREVfU1VGRklYLCBfS2F0YWxNZXRyaWNTdHJpbmcuZGVmYXVsdCwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGUgZm9yIHRoaXMgbWV0cmljLCBpZiBkZWZpbmVkLlxuICAgICAqXG4gICAgICogQHJldHVybiBBc3NvY2lhdGVkIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGUgbWV0cmljIG9iamVjdCwgb3IgdW5kZWZpbmVkXG4gICAgICovXG4gICAgLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TmFtZWRNZXRyaWNWYWx1ZShLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LlNUQVRVU19DT0RFX1NVRkZJWCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgSFRUUCByZXNwb25zZSBzdGF0dXMgY29kZSBtZXRyaWMgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1ldHJpYywgaWYgZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gSFRUUCByZXNwb25zZSBzdGF0dXMgY29kZSBtZXRyaWMgb2JqZWN0LCBvciB1bmRlZmluZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN0YXR1c0NvZGVNZXRyaWNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE5hbWVkTWV0cmljKEthdGFsTWV0cmljSHR0cFJlcXVlc3QuU1RBVFVTX0NPREVfU1VGRklYKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBIVFRQIHJlc3BvbnNlIHN0YXR1cyB0ZXh0IGZvciB0aGlzIG1ldHJpYy5cbiAgICAgKlxuICAgICAqIEEgc3RyaW5nIG1ldHJpYyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBsaXN0IG9mIG9iamVjdHMgdGhhdCB3aWxsIGJlIHB1Ymxpc2hlZCBmb3IgdGhpcyBtZXRyaWMuICBJdHMgbmFtZSB3aWxsXG4gICAgICogYmUgdGhpcyBtZXRyaWNzIG5hbWUgc3VmZml4ZWQgd2l0aCAnLlN0YXR1c1RleHQnLCBhbmQgaXRzIHZhbHVlIHdpbGwgYmUgdGhlIHN0YXR1cyB0ZXh0IHZhbHVlIGdpdmVuIGhlcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhdHVzVGV4dCBIVFRQIHJlc3BvbnNlIHN0YXR1cyB0ZXh0IGZvciB0aGlzIG1ldHJpYywgb3IgdW5kZWZpbmVkIHRvIHJlbW92ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3RhdHVzVGV4dFwiLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLnNldE9yRGVsZXRlTmFtZWRNZXRyaWNWYWx1ZShLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LlNUQVRVU19URVhUX1NVRkZJWCwgX0thdGFsTWV0cmljU3RyaW5nLmRlZmF1bHQsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBIVFRQIHJlc3BvbnNlIHN0YXR1cyB0ZXh0IGZvciB0aGlzIG1ldHJpYywgaWYgZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gQXNzb2NpYXRlZCBIVFRQIHJlc3BvbnNlIHN0YXR1cyB0ZXh0IG1ldHJpYyBvYmplY3QsIG9yIHVuZGVmaW5lZFxuICAgICAqL1xuICAgICxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE5hbWVkTWV0cmljVmFsdWUoS2F0YWxNZXRyaWNIdHRwUmVxdWVzdC5TVEFUVVNfVEVYVF9TVUZGSVgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIHRleHQgZm9yIHRoaXMgbWV0cmljLCBpZiBkZWZpbmVkLlxuICAgICAqXG4gICAgICogQHJldHVybiBBc3NvY2lhdGVkIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIHRleHQgbWV0cmljIG9iamVjdCwgb3IgdW5kZWZpbmVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzdGF0dXNUZXh0TWV0cmljXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXROYW1lZE1ldHJpYyhLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LlNUQVRVU19URVhUX1NVRkZJWCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0O1xufShfS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEthdGFsTWV0cmljSHR0cFJlcXVlc3Q7XG4oMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KShLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LCBcIkhUVFBfUkVRVUVTVF9QUkVGSVhcIiwgJ0hUVFBSZXF1ZXN0Jyk7XG4oMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KShLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LCBcIlVSTF9TVUZGSVhcIiwgJ1VSTCcpO1xuKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoS2F0YWxNZXRyaWNIdHRwUmVxdWVzdCwgXCJTVEFUVVNfQ09ERV9TVUZGSVhcIiwgJ1N0YXR1c0NvZGUnKTtcbigwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKEthdGFsTWV0cmljSHR0cFJlcXVlc3QsIFwiU1RBVFVTX1RFWFRfU1VGRklYXCIsICdTdGF0dXNUZXh0Jyk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHRcIikpO1xuXG4vKipcbiAqIFN0YW5kYXJkaXplZCBtZXRyaWMgZm9yIGluc3RydW1lbnRpbmcgYXBwbGljYXRpb24gaW5pdGlhbGl6YXRpb24uXG4gKlxuICogVW5kZXIgdGhlIGhvb2QgaXQgaXMgYSBLYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdCB3aXRoIHRoZSBuYW1lIFwiSW5pdGlhbGl6YXRpb25cIi5cbiAqIFRoYXQgb2JqZWN0IHdpbGwgY29udGFpbiBhIG1ldHJpYyBzdWZmaXhlZCB3aXRoIFwiLkxhdGVuY3lcIiBmb3IgdGhlIGxhdGVuY3kgb2YgdGhpcyByZXF1ZXN0LCBhbmQgYSBtZXRyaWMgc3VmZml4ZWRcbiAqIHdpdGggXCIuRmFpbHVyZVwiIHRvIHJlY29yZCB0aGUgZmFpbHVyZSBvciBzdWNjZXNzIG9mIHRoaXMgcmVxdWVzdC5cbiAqXG4gKiBCeSBkZWZhdWx0IHRoZSByZXF1ZXN0IHdpbGwgYmUgdHJhY2tlZCBhcyBhIGZhaWx1cmU7IHRvIG1hcmsgaXQgYXMgYSBzdWNjZXNzIGNhbGwgdGhlIFwic2V0U3VjY2VzcygpXCIgbWV0aG9kLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHRoZXNlIG1ldHJpY3Mgd2lsbCBiZSBjcmVhdGVkOlxuICogICBJbml0aWFsaXphdGlvbi5MYXRlbmN5IC0gTGF0ZW5jeSBmb3IgYXBwbGljYXRpb24gaW5pdGlhbGl6YXRpb25cbiAqICAgSW5pdGlhbGl6YXRpb24uRmFpbHVyZSAtIEZhaWx1cmUgZm9yIHRoaXMgYXBwbGljYXRpb24gaW5pdGlhbGl6YXRpb24gKDEgZm9yIGZhaWx1cmUsIDAgZm9yIHN1Y2Nlc3MpXG4gKi9cbnZhciBLYXRhbE1ldHJpY0luaXRpYWxpemF0aW9uID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfS2F0YWxNZXRyaWNUaW1lZEF0dGUpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoS2F0YWxNZXRyaWNJbml0aWFsaXphdGlvbiwgX0thdGFsTWV0cmljVGltZWRBdHRlKTtcblxuICAvKiogVGhlIG5hbWUgZm9yIHRoaXMgbWV0cmljLiAqL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgdGltZWQgYXR0ZW1wdCBtZXRyaWMgbmFtZWQgXCJJbml0aWFsaXphdGlvblwiLCBmb3IgcmVjb3JkaW5nIGxhdGVuY3kgYW5kIGZhaWx1cmUgaW5mb3JtYXRpb24gYWJvdXRcbiAgICogeW91ciBhcHBsaWNhdGlvbidzIGluaXRpYWxpemF0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gS2F0YWxNZXRyaWNJbml0aWFsaXphdGlvbigpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBLYXRhbE1ldHJpY0luaXRpYWxpemF0aW9uKTtcbiAgICByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShLYXRhbE1ldHJpY0luaXRpYWxpemF0aW9uKS5jYWxsKHRoaXMsIEthdGFsTWV0cmljSW5pdGlhbGl6YXRpb24uSU5JVElBTElaRV9NRVRSSUNfTkFNRSkpO1xuICB9XG5cbiAgcmV0dXJuIEthdGFsTWV0cmljSW5pdGlhbGl6YXRpb247XG59KF9LYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdC5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gS2F0YWxNZXRyaWNJbml0aWFsaXphdGlvbjtcbigwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKEthdGFsTWV0cmljSW5pdGlhbGl6YXRpb24sIFwiSU5JVElBTElaRV9NRVRSSUNfTkFNRVwiLCAnSW5pdGlhbGl6YXRpb24nKTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIikpO1xuXG52YXIgX0thdGFsTWV0cmljT2JqZWN0TGlzdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNPYmplY3RMaXN0XCIpKTtcblxudmFyIF9PYmplY3RWYWx1ZXNQb255ZmlsbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2hlbHBlci9PYmplY3RWYWx1ZXNQb255ZmlsbFwiKSk7XG5cbi8qKlxuICogTWV0cmljIG9iamVjdCBsaXN0IHRoYXQgdHJhY2tzIG1ldHJpY3MgYnkgbmFtZSwgYW5kIGdlbmVyYXRlcyBtZXRyaWNzIHByZWZpeGVkIHdpdGggdGhlIG5hbWUgb2YgdGhpcyBvYmplY3QuXG4gKi9cbnZhciBLYXRhbE1ldHJpY05hbWVkT2JqZWN0TGlzdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0thdGFsTWV0cmljT2JqZWN0TGlzKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEthdGFsTWV0cmljTmFtZWRPYmplY3RMaXN0LCBfS2F0YWxNZXRyaWNPYmplY3RMaXMpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgbmFtZWQgb2JqZWN0IGxpc3QuXG4gICAqXG4gICAqIFRoZSBuYW1lIGdpdmVuIGhlcmUgd2lsbCBiZSB1c2VkIHRvIHByZWZpeCBhbGwgbWV0cmljcy5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGlzIG1ldHJpY1xuICAgKi9cbiAgZnVuY3Rpb24gS2F0YWxNZXRyaWNOYW1lZE9iamVjdExpc3QobmFtZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEthdGFsTWV0cmljTmFtZWRPYmplY3RMaXN0KTtcbiAgICBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIuZGVmYXVsdCkodGhpcywgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoS2F0YWxNZXRyaWNOYW1lZE9iamVjdExpc3QpLmNhbGwodGhpcywgbmFtZSkpO1xuICAgIF90aGlzLm5hbWVkTWV0cmljcyA9IHt9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEthdGFsTWV0cmljTmFtZWRPYmplY3RMaXN0LCBbe1xuICAgIGtleTogXCJzZXROYW1lZE1ldHJpY1wiLFxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZSB0aGUgbWV0cmljIHdpdGggdGhlIGdpdmVuIG5hbWUgd2l0aCBhIG5ldyBtZXRyaWMgZ2VuZXJhdGVkIGJ5IHRoZSBnaXZlbiBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIElmIHRoZSBuZXdseSBjcmVhdGVkIG1ldHJpYyBzdXBwb3J0cyBtb25pdG9yaW5nLCBpdHMgaXNNb25pdG9yIGZsYWcgd2lsbCBiZSBzZXQgdG8gdGhlIHZhbHVlIG9mIHRoZVxuICAgICAqIGlzTW9uaXRvciBmbGFnIGZvciB0aGlzIGNvbnRhaW5pbmcgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHN1Yk5hbWUgTmFtZSBvZiB0aGlzIHN1Yi1tZXRyaWNcbiAgICAgKiBAcGFyYW0gbWV0cmljQ3JlYXRvciBGdW5jdGlvbiB3aGljaCB0YWtlcyB0aGUgZnVsbCBuYW1lIGZvciB0aGlzIG1ldHJpY1xuICAgICAqICAgICAgICBhbmQgcmV0dXJucyBhIG5ld2x5IGNvbnN0cnVjdGVkIEthdGFsTWV0cmljT2JqZWN0IHdpdGggdGhpcyBuYW1lIGFuZCBhbiBhcHByb3ByaWF0ZSB2YWx1ZVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXROYW1lZE1ldHJpYyhzdWJOYW1lLCBtZXRyaWNDcmVhdG9yKSB7XG4gICAgICB2YXIgZnVsbE5hbWUgPSB0aGlzLmdldE5hbWVGb3JTdWJNZXRyaWMoc3ViTmFtZSk7XG4gICAgICB2YXIgbWV0cmljID0gbWV0cmljQ3JlYXRvcihmdWxsTmFtZSk7XG5cbiAgICAgIGlmIChtZXRyaWMuY2FuTW9uaXRvcikge1xuICAgICAgICBtZXRyaWMuaXNNb25pdG9yID0gdGhpcy5pc01vbml0b3I7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubmFtZWRNZXRyaWNzW3N1Yk5hbWVdID0gbWV0cmljO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgdW5kZWZpbmVkIG9yIG51bGwsIGRlbGV0ZSB0aGUgbWV0cmljIHdpdGggdGhlIGdpdmUgbmFtZTsgb3RoZXJ3aXNlIGlmIHRoZSBnaXZlbiBuYW1lZFxuICAgICAqIG1ldHJpYyBhbHJlYWR5IGV4aXN0cyB1cGRhdGUgaXRzIHZhbHVlOyBvdGhlcndpc2UgY3JlYXRlIGEgbmV3IG1ldHJpYyBvZiB0aGUgZ2l2ZW4gdHlwZSBhbmQgc2V0IGl0cyB2YWx1ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgc3BlY2lhbGl6ZWQgaGVscGVyIG1ldGhvZCBpcyBkZXNpZ25lZCB0byBkZWFsIHdpdGggdGhlIGNvbW1vbiBjYXNlIG9mIGEgdmFsdWUgc2V0dGVyIGluIGEgbW9yZSBjb21wbGV4XG4gICAgICogbWV0cmljLiAgT3V0c2lkZSBvZiBzdWJjbGFzc2VzLCBvdGhlciBtZXRob2RzIHdpbGwgcHJvYmFibHkgcHJvdmUgbW9yZSB1c2VmdWwuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgdmFsdWUgaXMgbnVsbCB0aGUgbWV0cmljIHdpbGwgYWxzbyBiZSBkZWxldGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN1Yk5hbWUgTmFtZSBvZiBtZXRyaWMgdG8gY3JlYXRlIG9yIGRlbGV0ZVxuICAgICAqIEBwYXJhbSBuZXdWYWx1ZUNsYXNzIENsYXNzIG9mIG5ldyBtZXRyaWMgdG8gY3JlYXRlXG4gICAgICogQHBhcmFtIG5ld1ZhbHVlIE5ldyB2YWx1ZSBmb3IgdGhpcyBtZXRyaWMgKG9yIHVuZGVmaW5lZCB0byBkZWxldGUgdGhlIG1ldHJpYylcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldE9yRGVsZXRlTmFtZWRNZXRyaWNWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPckRlbGV0ZU5hbWVkTWV0cmljVmFsdWUoc3ViTmFtZSwgbmV3VmFsdWVDbGFzcywgbmV3VmFsdWUpIHtcbiAgICAgIGlmIChuZXdWYWx1ZSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5kZWxldGVOYW1lZE1ldHJpYyhzdWJOYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBtZXRyaWMgPSB0aGlzLmdldE9yQ3JlYXRlTmFtZWRNZXRyaWMoc3ViTmFtZSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IG5ld1ZhbHVlQ2xhc3MobmFtZSwgbmV3VmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgbWV0cmljLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc3ViLW1ldHJpYyB3aXRoIHRoZSBnaXZlbiBuYW1lIGlmIGl0IGV4aXN0cywgb3RoZXJ3aXNlIHVzZSB0aGUgZ2l2ZW4gZnVuY3Rpb24gdG8gY3JlYXRlIGEgbmV3IG1ldHJpYyBhbmRcbiAgICAgKiBzdG9yZSBhbmQgcmV0dXJuIHRoYXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3ViTmFtZSBOYW1lIG9mIHRoaXMgc3ViLW1ldHJpY1xuICAgICAqIEBwYXJhbSBtZXRyaWNDcmVhdG9yIEZ1bmN0aW9uIHdoaWNoIHRha2VzIHRoZSBmdWxsIG5hbWUgZm9yIHRoaXMgbWV0cmljXG4gICAgICogICAgICAgIGFuZCByZXR1cm5zIGEgbmV3bHkgY29uc3RydWN0ZWQgS2F0YWxNZXRyaWNPYmplY3Qgd2l0aCB0aGlzIG5hbWUgYW5kIGFuIGFwcHJvcHJpYXRlIHZhbHVlXG4gICAgICogQHJldHVybiBNZXRyaWMgb2JqZWN0IHdoaWNoIHdhcyByZXRyaWV2ZWQgb3IgY3JlYXRlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0T3JDcmVhdGVOYW1lZE1ldHJpY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRPckNyZWF0ZU5hbWVkTWV0cmljKHN1Yk5hbWUsIG1ldHJpY0NyZWF0b3IpIHtcbiAgICAgIGlmICghdGhpcy5uYW1lZE1ldHJpY3Nbc3ViTmFtZV0pIHtcbiAgICAgICAgdGhpcy5zZXROYW1lZE1ldHJpYyhzdWJOYW1lLCBtZXRyaWNDcmVhdG9yKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMubmFtZWRNZXRyaWNzW3N1Yk5hbWVdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGdpdmVuIG5hbWVkIHN1Yi1tZXRyaWMsIGlmIGl0IGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdWJOYW1lIE5hbWUgb2YgdGhpcyBzdWItbWV0cmljXG4gICAgICogQHJldHVybiB7S2F0YWxNZXRyaWNPYmplY3QgfCB1bmRlZmluZWR9IE1ldHJpYyBvYmplY3Qgd2l0aCB0aGlzIG5hbWUgaWYgaXQgZXhpc3RzLCBvdGhlcndpc2UgdW5kZWZpbmVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXROYW1lZE1ldHJpY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROYW1lZE1ldHJpYyhzdWJOYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5uYW1lZE1ldHJpY3Nbc3ViTmFtZV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSB0aGUgZ2l2ZW4gbmFtZWQgc3ViLW1ldHJpYy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdWJOYW1lIE5hbWUgb2YgdGhpcyBzdWItbWV0cmljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVOYW1lZE1ldHJpY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVOYW1lZE1ldHJpYyhzdWJOYW1lKSB7XG4gICAgICBkZWxldGUgdGhpcy5uYW1lZE1ldHJpY3Nbc3ViTmFtZV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdmFsdWUgZm9yIHRoZSBnaXZlbiBtZXRyaWMsIG9yIHVuZGVmaW5lZCBpZiB0aGUgbWV0cmljIGRvZXMgbm90IGV4aXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHN1Yk5hbWUgTmFtZSBvZiB0aGlzIHN1Yi1tZXRyaWNcbiAgICAgKiBAcmV0dXJuIFZhbHVlIGZvciB0aGUgZ2l2ZW4gbWV0cmljLCBvciB1bmRlZmluZWQgaWYgdGhlIG1ldHJpYyBkb2VzIG5vdCBleGlzdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TmFtZWRNZXRyaWNWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROYW1lZE1ldHJpY1ZhbHVlKHN1Yk5hbWUpIHtcbiAgICAgIHZhciBtZXRyaWMgPSB0aGlzLmdldE5hbWVkTWV0cmljKHN1Yk5hbWUpO1xuICAgICAgaWYgKCFtZXRyaWMpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gbWV0cmljLnZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIG5hbWUgZm9yIHRoZSBnaXZlbiBzdWItbWV0cmljLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN1Yk5hbWUgTmFtZSBvZiB0aGlzIHN1Yi1tZXRyaWNcbiAgICAgKiBAcmV0dXJuIEZ1bGwgbmFtZSBmb3IgdGhpcyBzdWItbWV0cmljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXROYW1lRm9yU3ViTWV0cmljXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5hbWVGb3JTdWJNZXRyaWMoc3ViTmFtZSkge1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRoaXMubmFtZSwgXCIuXCIpLmNvbmNhdChzdWJOYW1lKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWV0cmljTGlzdFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICgwLCBfT2JqZWN0VmFsdWVzUG9ueWZpbGwuZGVmYXVsdCkodGhpcy5uYW1lZE1ldHJpY3MpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gS2F0YWxNZXRyaWNOYW1lZE9iamVjdExpc3Q7XG59KF9LYXRhbE1ldHJpY09iamVjdExpc3QuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEthdGFsTWV0cmljTmFtZWRPYmplY3RMaXN0OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX1ZhbGlkYXRlU2ltcGxlU3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vaGVscGVyL1ZhbGlkYXRlU2ltcGxlU3RyaW5nXCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY1R5cGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljVHlwZVwiKSk7XG5cbi8qKlxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgYSBzaW5nbGUgbWV0cmljIGluIEthdGFsLlxuICpcbiAqIEEgc2luZ2xlIG1ldHJpYyBjb250YWlucyB0aGUgbmFtZSAobWV0cmljS2V5KSwgdmFsdWUsIHR5cGUsIGFuZCB0aGUgaXNNb25pdG9yIGZsYWc7IGV2ZXJ5dGhpbmcgZWxzZSBpcyBpbiB0aGVcbiAqIEthdGFsTWV0cmljc0NvbnRleHQgaXQgaXMgcHVibGlzaGVkIHRvLlxuICovXG52YXIgS2F0YWxNZXRyaWNPYmplY3QgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogTWV0cmljIHR5cGVzLlxuICAgKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IEthdGFsTWV0cmljT2JqZWN0IHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIE5hbWUgZm9yIHRoaXMgbWV0cmljOyBwdWJsaXNoZWQgYXMgbWV0cmljS2V5IGZpZWxkXG4gICAqL1xuICBmdW5jdGlvbiBLYXRhbE1ldHJpY09iamVjdChuYW1lKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgS2F0YWxNZXRyaWNPYmplY3QpO1xuICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgIHRoaXMuX2lzTW9uaXRvciA9IGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWUgZm9yIHRoaXMgbWV0cmljLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIG5hbWUgaXMgaW1tdXRhYmxlLCBhbmQgdGhpcyBjYW5ub3QgYmUgc2V0LlxuICAgKlxuICAgKiBAcmV0dXJucyBOYW1lIGZvciB0aGlzIG1ldHJpY1xuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEthdGFsTWV0cmljT2JqZWN0LCBbe1xuICAgIGtleTogXCJ3aXRoTW9uaXRvclwiLFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBpc01vbml0b3IgZmxhZyBmb3IgdGhpcyBtZXRyaWMsIGFuZCByZXR1cm5zIHRoaXMgb2JqZWN0IGZvciBjb250aW51ZWQgdXNlLlxuICAgICAqXG4gICAgICogVGhpcyBmbGFnIGRldGVybWluZXMgaWYgdGhlIG1ldHJpYyBjYW4gYmUgdXNlZCBmb3IgZGFzaGJvYXJkcyBhbmQgYWxhcm1zIChpLmUuIGlmIGl0IHdpbGwgYmUgcHVibGlzaGVkIHRvIFBNRVQpXG4gICAgICogQHBhcmFtIGlzTW9uaXRvciBOZXcgdmFsdWUgZm9yIHRoZSBpc01vbml0b3IgZmxhZzsgZGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAqIEByZXR1cm5zIFRoaXMgb2JqZWN0XG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhNb25pdG9yKCkge1xuICAgICAgdmFyIGlzTW9uaXRvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcbiAgICAgIHRoaXMuaXNNb25pdG9yID0gaXNNb25pdG9yO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgaXNNb25pdG9yIGZsYWcgZm9yIHRoaXMgbWV0cmljLlxuICAgICAqXG4gICAgICogVGhlIHZhbHVlIGlzIGZvcmNlZCB0byBhIGJvb2xlYW4gYmFzZWQgb24gaXRzIHRydXRoaW5lc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaXNNb25pdG9yIE5ldyB2YWx1ZSBmb3IgdGhlIGlzTW9uaXRvciBmbGFnXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ2YWxpZGF0aW9uRXJyb3JcIixcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGZvciBhIHZhbGlkYXRpb24gZXJyb3Igb24gdGhpcyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCB2YWxpZGF0aW9uIGVycm9yIGVuY291bnRlcmVkIGlmIG9uZSBpcyBmb3VuZCwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtFcnJvciB8IHVuZGVmaW5lZH0gRXJyb3IgZm91bmQgd2l0aCB0aGlzIG9iamVjdCwgb3IgdW5kZWZpbmVkIGlmIG5vIGVycm9yIGlzIGZvdW5kXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRpb25FcnJvcigpIHtcbiAgICAgIGlmICh0aGlzLmlzTW9uaXRvciAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB0aGlzLmlzTW9uaXRvciAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoXCJGaWVsZCBpc01vbml0b3Igc2hvdWxkIGJlIGEgYm9vbGVhbiwgYnV0IGl0IHdhcyBhIFwiLmNvbmNhdCgoMCwgX3R5cGVvZjIuZGVmYXVsdCkodGhpcy5pc01vbml0b3IpKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoMCwgX1ZhbGlkYXRlU2ltcGxlU3RyaW5nLmRlZmF1bHQpKHRoaXMubmFtZSwgJ2ZpZWxkIG5hbWUnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibmFtZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciBuYW1lLlxuICAgICAqXG4gICAgICogQHJldHVybnMgTmFtZSBmb3IgdGhpcyBtZXRyaWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm1ldHJpY0tleVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzTW9uaXRvclwiLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGlzTW9uaXRvcikge1xuICAgICAgdGhpcy5faXNNb25pdG9yID0gISFpc01vbml0b3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaXNNb25pdG9yIGZsYWcgZm9yIHRoaXMgbWV0cmljLlxuICAgICAqXG4gICAgICogQHJldHVybnMgaXNNb25pdG9yIGZsYWcgZm9yIHRoaXMgbWV0cmljLlxuICAgICAqL1xuICAgICxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pc01vbml0b3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgbWV0cmljIGNhbiBiZSBtZWFuaW5nZnVsbHkgbW9uaXRvcmVkLlxuICAgICAqXG4gICAgICogU3ViY2xhc3NlcyBtdXN0IG92ZXJyaWRlIHRoaXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIFdoZXRoZXIgdGhpcyBtZXRyaWMgY2FuIGJlIG1lYW5pbmdmdWxseSBtb25pdG9yZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNhbk1vbml0b3JcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3ViY2xhc3Mgb2YgS2F0YWxNZXRyaWNPYmplY3QgbXVzdCBpbXBsZW1lbnQgY2FuTW9uaXRvcicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHR5cGUgb2YgdGhpcyBtZXRyaWMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIFR5cGUgb2YgdGhpcyBtZXRyaWMgKG9uZSBvZjogU3RyaW5nLCBDb3VudGVyLCBUaW1lciwgTGlzdClcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInR5cGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3ViY2xhc3Mgb2YgS2F0YWxNZXRyaWNPYmplY3QgbXVzdCBpbXBsZW1lbnQgdHlwZSBnZXR0ZXInKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEthdGFsTWV0cmljT2JqZWN0O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBLYXRhbE1ldHJpY09iamVjdDtcbigwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKEthdGFsTWV0cmljT2JqZWN0LCBcIlR5cGVzXCIsIF9LYXRhbE1ldHJpY1R5cGUuZGVmYXVsdCk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRcIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX3NldDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3NldFwiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNPYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY09iamVjdFwiKSk7XG5cbnZhciBfRmlyc3RNYXAgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9oZWxwZXIvRmlyc3RNYXBcIikpO1xuXG4vKipcbiAqIEFic3RyYWN0IG1ldHJpYyB0aGF0IGNvbnRhaW5zIGEgbGlzdCBvZiBvdGhlciBtZXRyaWNzOyB3aGVuIGl0IGlzIHB1Ymxpc2hlZCwgdGhlIGxpc3Qgb2YgbWV0cmljcyBpcyByZXRyaWV2ZWQsIGFuZCBhbGxcbiAqIGFyZSBwdWJsaXNoZWQuXG4gKi9cbnZhciBLYXRhbE1ldHJpY09iamVjdExpc3QgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9LYXRhbE1ldHJpY09iamVjdCkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShLYXRhbE1ldHJpY09iamVjdExpc3QsIF9LYXRhbE1ldHJpY09iamVjdCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBLYXRhbE1ldHJpY09iamVjdExpc3QuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIE5hbWUgZm9yIHRoaXMgbWV0cmljLiAgTm90IHJlYWxseSB1c2VkLCBidXQgcHJlc2VudCBmb3IgY29uc2lzdGVuY3kgd2l0aCBvdGhlciBtZXRyaWNzLlxuICAgKi9cbiAgZnVuY3Rpb24gS2F0YWxNZXRyaWNPYmplY3RMaXN0KG5hbWUpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBLYXRhbE1ldHJpY09iamVjdExpc3QpO1xuICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yLmRlZmF1bHQpKHRoaXMsICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKEthdGFsTWV0cmljT2JqZWN0TGlzdCkuY2FsbCh0aGlzLCBuYW1lKSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgbGlzdCBvZiBmb3IgdGhpcyBvYmplY3RcbiAgICpcbiAgICogQHJldHVybnMgQXJyYXkgb2YgbWV0cmljcyBmb3IgdGhpcyBvYmplY3RcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShLYXRhbE1ldHJpY09iamVjdExpc3QsIFt7XG4gICAga2V5OiBcInZhbGlkYXRpb25FcnJvclwiLFxuXG4gICAgLyoqXG4gICAgICogSWYgYW55IG9mIHRoZSBjb250YWluZWQgbWV0cmljcyBhcmUgaW52YWxpZCwgcmV0dXJuIHRoZSBmaXJzdCB2YWxpZGF0aW9uIGVycm9yIGVuY291bnRlcmVkOyBvdGhlcndpc2UgcmV0dXJuXG4gICAgICogdW5kZWZpbmVkLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoaXMgaXNuJ3QgY2FsbGVkIGJ5IHRoZSBwdWJsaXNoZXI7IGl0IHZhbGlkYXRlcyBlYWNoIHN1Yi1tZXRyaWMgb24gaXRzIG93bi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEVycm9yIGZvdW5kIHdpdGggc3VibWV0cmljLCBpZiBhbnk7IGVsc2UgdW5kZWZpbmVkXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRpb25FcnJvcigpIHtcbiAgICAgIC8vIERvZXNuJ3QgbWFrZSBzZW5zZSB0byBjaGVjayBzdXBlcmNsYXNzIGVycm9yIGhlcmUsIHNpbmNlIGl0IGlzIHRoZSBjb250YWluZWQgbWV0cmljcyB0aGF0IG1hdHRlci5cbiAgICAgIHJldHVybiAoMCwgX0ZpcnN0TWFwLmRlZmF1bHQpKHRoaXMubWV0cmljTGlzdCwgZnVuY3Rpb24gKG1ldHJpYykge1xuICAgICAgICByZXR1cm4gbWV0cmljLnZhbGlkYXRpb25FcnJvcigpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1ldHJpY0xpc3RcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3ViY2xhc3Mgb2YgS2F0YWxNZXRyaWNPYmplY3RMaXN0IG11c3QgaW1wbGVtZW50IG1ldHJpY0xpc3QgZ2V0dGVyJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzTW9uaXRvclwiLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGlzTW9uaXRvcikge1xuICAgICAgKDAsIF9zZXQyLmRlZmF1bHQpKCgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKEthdGFsTWV0cmljT2JqZWN0TGlzdC5wcm90b3R5cGUpLCBcImlzTW9uaXRvclwiLCBpc01vbml0b3IsIHRoaXMsIHRydWUpO1xuICAgICAgdGhpcy5tZXRyaWNMaXN0LmZvckVhY2goZnVuY3Rpb24gKG1ldHJpYykge1xuICAgICAgICBpZiAobWV0cmljLmNhbk1vbml0b3IpIHtcbiAgICAgICAgICBtZXRyaWMuaXNNb25pdG9yID0gaXNNb25pdG9yO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IC8vIFRoaXMganVzdCBkZWxlZ2F0ZXMgdG8gdGhlIHN1cGVyY2xhc3MsIGJ1dCBpZiB3ZSBvdmVycmlkZSB0aGUgc2V0dGVyIHdpdGhvdXQgb3ZlcnJpZGluZyB0aGUgZ2V0dGVyXG4gICAgLy8gZ2V0dGluZyB0aGUgcHJvcGVydHkgd2lsbCBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZC5cbiAgICAsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gKDAsIF9nZXQyLmRlZmF1bHQpKCgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKEthdGFsTWV0cmljT2JqZWN0TGlzdC5wcm90b3R5cGUpLCBcImlzTW9uaXRvclwiLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FuTW9uaXRvclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInR5cGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfS2F0YWxNZXRyaWNPYmplY3QyLmRlZmF1bHQuVHlwZXMuTGlzdDtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEthdGFsTWV0cmljT2JqZWN0TGlzdDtcbn0oX0thdGFsTWV0cmljT2JqZWN0Mi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gS2F0YWxNZXRyaWNPYmplY3RMaXN0OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX2dldDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFwiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNPYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY09iamVjdFwiKSk7XG5cbi8qKlxuICogU3RyaW5nIHR5cGUuXG4gKlxuICogQ2FuIGJlIHVzZWQgdG8gc3RvcmUgYXJiaXRyYXJ5IHN0cmluZ3Mgb2YgZGF0YS5cbiAqL1xudmFyIEthdGFsTWV0cmljU3RyaW5nID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfS2F0YWxNZXRyaWNPYmplY3QpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoS2F0YWxNZXRyaWNTdHJpbmcsIF9LYXRhbE1ldHJpY09iamVjdCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHN0cmluZyB3aXRoIHRoZSBnaXZlbiBuYW1lIGFuZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgU3RyaW5nIG5hbWVcbiAgICogQHBhcmFtIHZhbHVlIFN0cmluZyB2YWx1ZVxuICAgKi9cbiAgZnVuY3Rpb24gS2F0YWxNZXRyaWNTdHJpbmcobmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBLYXRhbE1ldHJpY1N0cmluZyk7XG4gICAgX3RoaXMgPSAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yLmRlZmF1bHQpKHRoaXMsICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKEthdGFsTWV0cmljU3RyaW5nKS5jYWxsKHRoaXMsIG5hbWUpKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIuZGVmYXVsdCkoX3RoaXMpLCBcInRydW5jYXRlXCIsIGZhbHNlKTtcbiAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBmb3IgdGhpcyBzdHJpbmcgbWV0cmljLlxuICAgKlxuICAgKiBAcmV0dXJuIFZhbHVlIGZvciB0aGlzIG1ldHJpY1xuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEthdGFsTWV0cmljU3RyaW5nLCBbe1xuICAgIGtleTogXCJ2YWxpZGF0aW9uRXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGlvbkVycm9yKCkge1xuICAgICAgdmFyIHN1cGVyRXJyb3IgPSAoMCwgX2dldDIuZGVmYXVsdCkoKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoS2F0YWxNZXRyaWNTdHJpbmcucHJvdG90eXBlKSwgXCJ2YWxpZGF0aW9uRXJyb3JcIiwgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgIGlmIChzdXBlckVycm9yKSByZXR1cm4gc3VwZXJFcnJvcjtcblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKFwiRXhwZWN0ZWQgZmllbGQgdmFsdWUgaW4gU3RyaW5nIG1ldHJpY3Mgb2JqZWN0ICdcIi5jb25jYXQodGhpcy5uYW1lLCBcIicgdG8gYmUgdHlwZSBzdHJpbmcsIGJ1dCBpdCB3YXMgXCIpLmNvbmNhdCgoMCwgX3R5cGVvZjIuZGVmYXVsdCkodGhpcy52YWx1ZSkpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudmFsdWUubGVuZ3RoID4gS2F0YWxNZXRyaWNTdHJpbmcuTUFYX1NJWkUpIHtcbiAgICAgICAgaWYgKHRoaXMudHJ1bmNhdGUpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZS5zdWJzdHJpbmcoMCwgS2F0YWxNZXRyaWNTdHJpbmcuTUFYX1NJWkUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXCJFeHBlY3RlZCBmaWVsZCB2YWx1ZSBpbiBTdHJpbmcgbWV0cmljcyBvYmplY3QgJ1wiLmNvbmNhdCh0aGlzLm5hbWUsIFwiJyB0byBiZSBcIikuY29uY2F0KEthdGFsTWV0cmljU3RyaW5nLk1BWF9TSVpFLCBcIiBjaGFyYWN0ZXJzIG9yIGxlc3MsIGJ1dCBpdCB3YXMgXCIpLmNvbmNhdCh0aGlzLnZhbHVlLmxlbmd0aCwgXCIgY2hhcmFjdGVycy5cIikpO1xuICAgICAgICB9XG4gICAgICB9IC8vIERpZG4ndCBmaW5kIGFueXRoaW5nIHdyb25nLCBpbXBsaWNpdGx5IHJldHVybiB1bmRlZmluZWRcblxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWx1ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHZhbHVlIGZvciB0aGlzIHN0cmluZyBtZXRyaWMuXG4gICAgICpcbiAgICAgKiBUaGUgbmV3IHZhbHVlIHNob3VsZCBiZSBhIHN0cmluZywgYnV0IG51bWJlciBhbmQgYm9vbGVhbiB0eXBlcyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIHN0cmluZ3MuXG4gICAgICogRm9yIG90aGVyIHR5cGVzLCBpbmNsdWRpbmcgdW5kZWZpbmVkIGFuZCBudWxsLCB0aGUgdmFsdWUgd2lsbCBiZSBhY2NlcHRlZCwgYnV0IHdpbGwgZmFpbCB2YWxpZGF0aW9uIHdoZW4gcHVibGlzaGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBOZXcgdmFsdWUgZm9yIHRoaXMgbWV0cmljXG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcnVuY2F0aW9uIGZsYWcgZm9yIHRoaXMgc3RyaW5nIG1ldHJpYy5cbiAgICAgKlxuICAgICAqIElmIHNldCwgdGhlIHZhbHVlIGhlcmUgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHRydW5jYXRlZCB0byB0aGUgbWF4aW11bSBzaXplIGFsbG93ZWQgYnkgdGhlIGN1cnJlbnQgc2NoZW1hLlxuICAgICAqIE90aGVyd2lzZSwgc2VuZGluZyBhIHZhbHVlIGxhcmdlciB0aGFuIGFsbG93ZWQgd2lsbCByZXN1bHQgaW4gYSBmYWlsdXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIFRydWUgdG8gYXV0b21hdGljYWxseSB0cnVuY2F0ZSBtZXRyaWNzLCBvdGhlcndpc2UgZmFsc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInR5cGVcIixcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHR5cGUgZm9yIHRoaXMgbWV0cmljLlxuICAgICAqXG4gICAgICogQHJldHVybiBBbHdheXMgcmV0dXJucyBcIlN0cmluZ1wiLlxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9LYXRhbE1ldHJpY09iamVjdDIuZGVmYXVsdC5UeXBlcy5TdHJpbmc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbk1vbml0b3JcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEthdGFsTWV0cmljU3RyaW5nO1xufShfS2F0YWxNZXRyaWNPYmplY3QyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBLYXRhbE1ldHJpY1N0cmluZztcbigwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKEthdGFsTWV0cmljU3RyaW5nLCBcIk1BWF9TSVpFXCIsIDI1Nik7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY05hbWVkT2JqZWN0TGlzdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNOYW1lZE9iamVjdExpc3RcIikpO1xuXG52YXIgX0thdGFsTWV0cmljVGltZXJTdG9wd2F0Y2ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljVGltZXJTdG9wd2F0Y2hcIikpO1xuXG52YXIgX0thdGFsTWV0cmljQ291bnRlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNDb3VudGVyXCIpKTtcblxuLyoqXG4gKiBNZXRyaWMgdGhhdCBwYWlycyBhIHRpbWVyIGFuZCBhIGZhaWx1cmUgY291bnRlciB0byByZWNvcmQgdGhlIHRpbWUgYW5kIHN0YXR1cyBvZiBhbiBhdHRlbXB0IHRvIGRvIHNvbWV0aGluZy5cbiAqL1xudmFyIEthdGFsTWV0cmljVGltZWRBdHRlbXB0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfS2F0YWxNZXRyaWNOYW1lZE9iamUpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQsIF9LYXRhbE1ldHJpY05hbWVkT2JqZSk7XG5cbiAgLyoqIFRoZSBzdWItbWV0cmljIG5hbWUgZm9yIGxhdGVuY3kuICovXG5cbiAgLyoqIFRoZSBzdWItbWV0cmljIG5hbWUgZm9yIGZhaWx1cmUgY291bnQuICovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyB0aW1lZCBhdHRlbXB0IHdpdGggdGhlIGdpdmVuIG5hbWVcbiAgICpcbiAgICogVGhpcyB3aWxsIGNyZWF0ZSB0d28gaW5uZXIgbWV0cmljcywgYSBLYXRhbE1ldHJpY0NvdW50ZXIgdGhhdCBoYXMgdGhlIGdpdmVuIG5hbWUgd2l0aCBcIi5GYWlsdXJlXCIgYXBwZW5kZWQsXG4gICAqIGFuZCBhIEthdGFsTWV0cmljVGltZXJTdG9wd2F0Y2ggdGhhdCBoYXMgdGhlIGdpdmVuIG5hbWUgd2l0aCBcIi5MYXRlbmN5XCIgYXBwZW5kZWQuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhpcyBhdHRlbXB0XG4gICAqL1xuICBmdW5jdGlvbiBLYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdChuYW1lKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQpO1xuICAgIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdCkuY2FsbCh0aGlzLCBuYW1lKSk7XG5cbiAgICBfdGhpcy5zZXROYW1lZE1ldHJpYyhLYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdC5MQVRFTkNZX1NVRkZJWCwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHJldHVybiBuZXcgX0thdGFsTWV0cmljVGltZXJTdG9wd2F0Y2guZGVmYXVsdChuYW1lKTtcbiAgICB9KTtcblxuICAgIF90aGlzLnNldE5hbWVkTWV0cmljKEthdGFsTWV0cmljVGltZWRBdHRlbXB0LkZBSUxVUkVfU1VGRklYLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIG5ldyBfS2F0YWxNZXRyaWNDb3VudGVyLmRlZmF1bHQobmFtZSwgMSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgZmFpbHVyZSBjb3VudGVyIG1ldHJpYyBiYXNlZCBvbiB0aGUgZ2l2ZW4gZmFpbHVyZSBzdGF0dXMuXG4gICAqXG4gICAqIElmIGZhaWx1cmUgaXMgdHJ1ZSB0aGUgY291bnRlciB3aWxsIGhhdmUgYSB2YWx1ZSBvZiAxOyBpZiBpdCBpcyBmYWxzZSB0aGUgY291bnRlciB3aWxsIGhhdmUgYSB2YWx1ZSBvZiAwLlxuICAgKlxuICAgKiBAcGFyYW0gZmFpbHVyZSBXaGV0aGVyIHRoaXMgaXMgYSBmYWlsdXJlIG9yIG5vdDsgZGVmYXVsdCB0cnVlXG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQsIFt7XG4gICAga2V5OiBcInNldEZhaWx1cmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RmFpbHVyZSgpIHtcbiAgICAgIHZhciBmYWlsdXJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuICAgICAgdmFyIGZhaWx1cmVDb3VudCA9IGZhaWx1cmUgPyAxIDogMDtcbiAgICAgIHZhciBtZXRyaWMgPSB0aGlzLmZhaWx1cmVNZXRyaWM7XG4gICAgICBtZXRyaWMudmFsdWUgPSBmYWlsdXJlQ291bnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZmFpbHVyZSBzdGF0dXMgdG8gZmFsc2UuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRTdWNjZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFN1Y2Nlc3MoKSB7XG4gICAgICB0aGlzLnNldEZhaWx1cmUoZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGxhdGVuY3kgbWV0cmljIHRvIHRoZSBnaXZlbiB2YWx1ZSwgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqXG4gICAgICogTm90ZSB5b3UgZG9uJ3Qgbm9ybWFsbHkgaGF2ZSB0byBzZXQgdGhpcywgdGhlIHVuZGVybHlpbmcgbWV0cmljIGlzIGEgS2F0YWxNZXRyaWNUaW1lclN0b3B3YXRjaCB0aGF0IHdpbGwgc3RhcnRcbiAgICAgKiBhbmQgc3RvcCBhdXRvbWF0aWNhbGx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGxhdGVuY3lNcyBMYXRlbmN5IGluIG1pbGxpc2Vjb25kc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TGF0ZW5jeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRMYXRlbmN5KGxhdGVuY3lNcykge1xuICAgICAgdmFyIG1ldHJpYyA9IHRoaXMubGF0ZW5jeU1ldHJpYztcbiAgICAgIG1ldHJpYy52YWx1ZSA9IGxhdGVuY3lNcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB0aW1lciBzdG9wd2F0Y2ggbWV0cmljIGZvciB0aGlzIGF0dGVtcHQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIFRpbWVyIHN0b3B3YXRjaCBtZXRyaWMgZm9yIHRoaXMgYXR0ZW1wdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibGF0ZW5jeU1ldHJpY1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TmFtZWRNZXRyaWMoS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQuTEFURU5DWV9TVUZGSVgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGZhaWx1cmUgY291bnRlciBtZXRyaWMgZm9yIHRoaXMgYXR0ZW1wdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gRmFpbHVyZSBjb3VudGVyIG1ldHJpYyBmb3IgdGhpcyBldmVudFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmFpbHVyZU1ldHJpY1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TmFtZWRNZXRyaWMoS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQuRkFJTFVSRV9TVUZGSVgpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQ7XG59KF9LYXRhbE1ldHJpY05hbWVkT2JqZWN0TGlzdC5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQ7XG4oMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdCwgXCJMQVRFTkNZX1NVRkZJWFwiLCAnTGF0ZW5jeScpO1xuKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQsIFwiRkFJTFVSRV9TVUZGSVhcIiwgJ0ZhaWx1cmUnKTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX2dldDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFwiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNPYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY09iamVjdFwiKSk7XG5cbnZhciBfVmFsaWRhdGVTaW1wbGVJbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9oZWxwZXIvVmFsaWRhdGVTaW1wbGVJbnRcIikpO1xuXG4vKipcbiAqIFRpbWVyIHR5cGUuXG4gKlxuICogQ2FuIGJlIHVzZWQgdG8gcmVjb3JkIGEgdGltZS4gIFRoaXMgY2xhc3MgcmVxdWlyZXMgZXhwbGljaXQgdmFsdWU7IHNlZSBLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoIGZvciBhdXRvbWF0aWNcbiAqIHRpbWluZy5cbiAqL1xudmFyIEthdGFsTWV0cmljVGltZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9LYXRhbE1ldHJpY09iamVjdCkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVyLCBfS2F0YWxNZXRyaWNPYmplY3QpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgdGltZXIgbWV0cmljLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBOYW1lIGZvciB0aGUgbWV0cmljXG4gICAqIEBwYXJhbSB2YWx1ZSBUaW1lciB2YWx1ZSBpbiBtaWxsaXNlY29uZHNcbiAgICovXG4gIGZ1bmN0aW9uIEthdGFsTWV0cmljVGltZXIobmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBLYXRhbE1ldHJpY1RpbWVyKTtcbiAgICBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIuZGVmYXVsdCkodGhpcywgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoS2F0YWxNZXRyaWNUaW1lcikuY2FsbCh0aGlzLCBuYW1lKSk7XG4gICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgZm9yIHRoaXMgdGltZXJcbiAgICpcbiAgICogQHJldHVybiBUaW1lciB2YWx1ZSBpbiBtaWxsaXNlY29uZHNcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVyLCBbe1xuICAgIGtleTogXCJ2YWxpZGF0aW9uRXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGlvbkVycm9yKCkge1xuICAgICAgdmFyIHN1cGVyRXJyb3IgPSAoMCwgX2dldDIuZGVmYXVsdCkoKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoS2F0YWxNZXRyaWNUaW1lci5wcm90b3R5cGUpLCBcInZhbGlkYXRpb25FcnJvclwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgaWYgKHN1cGVyRXJyb3IpIHJldHVybiBzdXBlckVycm9yO1xuICAgICAgcmV0dXJuICgwLCBfVmFsaWRhdGVTaW1wbGVJbnQuZGVmYXVsdCkodGhpcy52YWx1ZSwgXCJmaWVsZCB2YWx1ZSBpbiBUaW1lciBtZXRyaWNzIG9iamVjdCAnXCIuY29uY2F0KHRoaXMubmFtZSwgXCInXCIpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmFsdWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2YWx1ZSBmb3IgdGhpcyB0aW1lclxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIE5ldyB0aW1lciB2YWx1ZSBpbiBtaWxsaXNlY29uZHNcbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBNYXRoLnJvdW5kIHdpbGwgYWxzbyBjb2VyY2UgZnJvbSBhIHN0cmluZyBpZiBuZWNlc3NhcnksIGFuZCByZXR1cm4gTmFOIGlmIGludmFsaWRcblxuXG4gICAgICB0aGlzLl92YWx1ZSA9IE1hdGgucm91bmQodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHR5cGUgZm9yIHRoaXMgdGltZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIEFsd2F5cyByZXR1cm5zIFwiVGltZXJcIi5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInR5cGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfS2F0YWxNZXRyaWNPYmplY3QyLmRlZmF1bHQuVHlwZXMuVGltZXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbk1vbml0b3JcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gS2F0YWxNZXRyaWNUaW1lcjtcbn0oX0thdGFsTWV0cmljT2JqZWN0Mi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gS2F0YWxNZXRyaWNUaW1lcjsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX3NldDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3NldFwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfZ2V0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0XCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY1RpbWVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNUaW1lclwiKSk7XG5cbi8qKlxuICogU3ViY2xhc3Mgb2YgS2F0YWxNZXRyaWNUaW1lciB0aGF0IGNhbiBiZSBzdGFydGVkIGFuZCBzdG9wcGVkLCBhbmQgd2lsbCByZWNvcmQgdGhlIGVsYXBzZWQgdGltZSBiZXR3ZWVuIHN0YXJ0aW5nIGFuZFxuICogc3RvcHBpbmcuICBCeSBkZWZhdWx0IGl0IHdpbGwgc3RhcnQgd2hlbiB0aGUgb2JqZWN0IGlzIGNyZWF0ZWQsIGFuZCBzdG9wcGVkIHdoZW4gdGhlIHZhbHVlIGlzIHJldHJpZXZlZCB3aXRoXG4gKiB0aGUgZ2V0dGVyIFwidmFsdWVcIi5cbiAqL1xudmFyIEthdGFsTWV0cmljVGltZXJTdG9wd2F0Y2ggPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9LYXRhbE1ldHJpY1RpbWVyKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEthdGFsTWV0cmljVGltZXJTdG9wd2F0Y2gsIF9LYXRhbE1ldHJpY1RpbWVyKTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHRpbWVyIHdpdGggdGhlIGdpdmVuIG5hbWUgYW5kIHN0YXJ0aW5nIHRpbWUuICBJZiBubyBzdGFydGluZyB0aW1lIGlzIGdpdmVuLCB0aGUgY3VycmVudCB0aW1lIGlzIHVzZWQuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIE5hbWUgZm9yIHRoaXMgdGltZXJcbiAgICogQHBhcmFtIHN0YXJ0VGltZSBNaWxsaXNlY29uZCBlcG9jaCB0aW1lIGZvciB0aGUgc3RhcnQgdGltZTsgZGVmYXVsdHMgdG8gbm93XG4gICAqL1xuICBmdW5jdGlvbiBLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoKG5hbWUsIHN0YXJ0VGltZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEthdGFsTWV0cmljVGltZXJTdG9wd2F0Y2gpO1xuICAgIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoKS5jYWxsKHRoaXMsIG5hbWUsIHVuZGVmaW5lZCkpO1xuXG4gICAgX3RoaXMuc3RhcnQoc3RhcnRUaW1lKTtcblxuICAgIF90aGlzLl92YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFJlLXN0YXJ0IHRpbWVyIHdpdGggdGhlIGdpdmVuIHN0YXJ0IHRpbWUsIG9yIHRoZSBjdXJyZW50IHRpbWUgaWYgbm9uZSBpcyBnaXZlbi5cbiAgICpcbiAgICogQHBhcmFtIHN0YXJ0VGltZSBXaGVuIHRoZSB0aW1lciB3YXMgc3RhcnRlZCwgaW4gZXBvY2ggbWlsbGlzZWNvbmRzOyBkZWZhdWx0cyB0byBub3dcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoLCBbe1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydChzdGFydFRpbWUpIHtcbiAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IHN0YXJ0VGltZSB8fCB0aGlzLm5vdygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wIHRoZSB0aW1lciBhbmQgcmVjb3JkIHRoZSBlbGFwc2VkIHRpbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RvcFRpbWUgV2hlbiB0aGUgdGltZXIgd2FzIHN0b3BwZWQsIGluIGVwb2NoIG1pbGxpc2Vjb25kczsgZGVmYXVsdHMgdG8gbm93XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzdG9wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3Aoc3RvcFRpbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdG9wVGltZSA9IHN0b3BUaW1lIHx8IHRoaXMubm93KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSB0aW1lciBoYXMgYmVlbiBzdG9wcGVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgdGltZXIgaGFzIGJlZW4gc3RvcHBlZCB5ZXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm5vd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub3coKSB7XG4gICAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzU3RvcHBlZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0b3BUaW1lICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZWxhcHNlZCB0aW1lIGJldHdlZW4gd2hlbiB0aGUgdGltZXIgd2FzIHN0YXJ0ZWQgYW5kIHN0b3BwZWQ7IGlmIHRoZSB0aW1lciBoYXMgbm90IHlldCBiZWVuIHN0b3BwZWQsXG4gICAgICogc3RvcCBpdCBmaXJzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEVsYXBzZWQgdGltZSBiZXR3ZWVuIHdoZW4gdGltZXIgd2FzIHN0YXJ0ZWQgYW5kIHN0b3BwZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInZhbHVlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoKDAsIF9nZXQyLmRlZmF1bHQpKCgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKEthdGFsTWV0cmljVGltZXJTdG9wd2F0Y2gucHJvdG90eXBlKSwgXCJ2YWx1ZVwiLCB0aGlzKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgfSAvLyBSZWx5IG9uIHN1cGVyLnZhbHVlIHNldHRlciB0byByb3VuZFxuXG5cbiAgICAgICAgKDAsIF9zZXQyLmRlZmF1bHQpKCgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKEthdGFsTWV0cmljVGltZXJTdG9wd2F0Y2gucHJvdG90eXBlKSwgXCJ2YWx1ZVwiLCB0aGlzLnN0b3BUaW1lIC0gdGhpcy5zdGFydFRpbWUsIHRoaXMsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKDAsIF9nZXQyLmRlZmF1bHQpKCgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKEthdGFsTWV0cmljVGltZXJTdG9wd2F0Y2gucHJvdG90eXBlKSwgXCJ2YWx1ZVwiLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHdoZW4gdGhpcyB0aW1lciB3YXMgc3RhcnRlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gU3RhcnQgdGltZSwgaW4gZXBvY2ggbWlsbGlzZWNvbmRzXG4gICAgICovXG4gICAgLFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2YWx1ZSBmb3IgdGhpcyBtZXRyaWMuICBOb3RlIHRoaXMgd2lsbCBvdmVycmlkZSB0aGUgc3RvcHdhdGNoIGJlaGF2aW9yIGFuZCBqdXN0IHVzZSB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgVmFsdWUgZm9yIHRoaXMgbWV0cmljXG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICgwLCBfc2V0Mi5kZWZhdWx0KSgoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoLnByb3RvdHlwZSksIFwidmFsdWVcIiwgdmFsdWUsIHRoaXMsIHRydWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFRpbWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdGFydFRpbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB3aGVuIHRoaXMgdGltZXIgd2FzIHN0b3BwZWQgKG9yIHVuZGVmaW5lZCBpZiBpdCBpcyBzdGlsbCBydW5uaW5nKVxuICAgICAqXG4gICAgICogQHJldHVybiBTdG9wIHRpbWUsIGluIGVwb2NoIG1pbGxzZWNvbmRzLCBvciB1bmRlZmluZWQgaWYgdGhlIHN0b3B3YXRjaCBpcyBzdGlsbCBydW5uaW5nXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzdG9wVGltZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0b3BUaW1lO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gS2F0YWxNZXRyaWNUaW1lclN0b3B3YXRjaDtcbn0oX0thdGFsTWV0cmljVGltZXIyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG4vKipcbiAqIE1ldHJpYyB0eXBlcy5cbiAqL1xudmFyIEthdGFsTWV0cmljVHlwZTtcblxuKGZ1bmN0aW9uIChLYXRhbE1ldHJpY1R5cGUpIHtcbiAgS2F0YWxNZXRyaWNUeXBlW1wiU3RyaW5nXCJdID0gXCJTdHJpbmdcIjtcbiAgS2F0YWxNZXRyaWNUeXBlW1wiQ291bnRlclwiXSA9IFwiQ291bnRlclwiO1xuICBLYXRhbE1ldHJpY1R5cGVbXCJUaW1lclwiXSA9IFwiVGltZXJcIjtcbiAgS2F0YWxNZXRyaWNUeXBlW1wiTGlzdFwiXSA9IFwiTGlzdFwiO1xufSkoS2F0YWxNZXRyaWNUeXBlIHx8IChLYXRhbE1ldHJpY1R5cGUgPSB7fSkpO1xuXG47XG52YXIgX2RlZmF1bHQgPSBLYXRhbE1ldHJpY1R5cGU7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJPYmplY3RcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0thdGFsTWV0cmljT2JqZWN0LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU3RyaW5nXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9LYXRhbE1ldHJpY1N0cmluZy5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvdW50ZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0thdGFsTWV0cmljQ291bnRlci5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRpbWVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9LYXRhbE1ldHJpY1RpbWVyLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGltZXJTdG9wd2F0Y2hcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0thdGFsTWV0cmljVGltZXJTdG9wd2F0Y2guZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUaW1lZEF0dGVtcHRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0thdGFsTWV0cmljVGltZWRBdHRlbXB0LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5pdGlhbGl6YXRpb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0thdGFsTWV0cmljSW5pdGlhbGl6YXRpb24uZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJIdHRwUmVxdWVzdFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfS2F0YWxNZXRyaWNIdHRwUmVxdWVzdC5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9LYXRhbE1ldHJpY09iamVjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNPYmplY3RcIikpO1xuXG52YXIgX0thdGFsTWV0cmljU3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY1N0cmluZ1wiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNDb3VudGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY0NvdW50ZXJcIikpO1xuXG52YXIgX0thdGFsTWV0cmljVGltZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljVGltZXJcIikpO1xuXG52YXIgX0thdGFsTWV0cmljVGltZXJTdG9wd2F0Y2ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljVGltZXJTdG9wd2F0Y2hcIikpO1xuXG52YXIgX0thdGFsTWV0cmljVGltZWRBdHRlbXB0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdFwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNJbml0aWFsaXphdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNJbml0aWFsaXphdGlvblwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNIdHRwUmVxdWVzdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNIdHRwUmVxdWVzdFwiKSk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoc291cmNlLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbi8qKlxuICogVGhpcyBjbGFzcyBlbmNhcHN1bGF0ZXMgdHdvIElJRkVzIHRoYXQgdGhlIFN1c2hpIGxpYnJhcnkgY29udGFpbnMuIEEgZmFrZSBDU00gYW5kIFdpbmRvdyBvYmplY3QgYXJlIGNyZWF0ZWQgYW5kIHByb3ZpZGVkXG4gKiB0byB0aGUgZnVuY3Rpb25zIHNvIHRoYXQgdGhleSBhY3R1YWxseSBleGVjdXRlIGluIGEgY29udHJvbGxlZCBlbnZpcm9ubWVudCBhd2F5IGZyb20gYW55IENTTSBjb2RlIHRoYXQgbWlnaHQgYmUgZXhlY3V0aW5nXG4gKiBhdCB0aGUgcGxhdGZvcm0gbGV2ZWwgd2l0aGluIHRoZSBwYWdlLlxuICpcbiAqIFRoZSBiYXNpYyBydW4gb3JkZXIgaXMgdGhlIGZvbGxvd2luZzpcbiAqIDEuIEJ1aWxkIHRoZSBtb2NrIENTTSBvYmplY3QsIHRoZW4gYnVpbGQgYSBtb2NrIFdpbmRvdyBvYmplY3QgdGhhdCByZWZlcmVuY2VzIHRoZSBDU00gb2JqZWN0IGFzIHVlX2NzbVxuICogMi4gUnVuIHRoZSB0cmFuc3BvcnRhdGlvbi1jbGllbnRzLmpzIFNjcmlwdCBmcm9tIFN1c2hpSmF2YXNjcmlwdENsaWVudCBwcm92aWRpbmcgdGhlIG1vY2tzLiBJdCB3aWxsIG1vZGlmeSBnbG9iYWxzIG9uIHRoZSBtb2NrIG9iamVjdHMuXG4gKiAzLiBSdW4gdGhlIHN1c2hpLWNsaWVudC5qcyBzY3JpcHQgZnJvbSBTdXNoaUphdmFTY3JpcHRDbGllbnQgcHJvdmlkaW5nIHRoZSBtb2Nrcy4gSXQgd2lsbCBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhlIHN1c2hpIGNsaWVudCBhbmQgaW5qZWN0IGl0IGludG8gdGhlIENTTSBnbG9iYWxzIGluIHRoZSBtb2Nrcy5cbiAqIDQuIHdoZW5ldmVyIGV2ZW50KCkgaXMgY2FsbGVkLCByZWZlciB0byB0aGUgZW5jYXBzdWxhdGVkIGNzbSBvYmplY3QgdG8gYWRkIHRoZSBldmVudCB0byB0aGUgcXVldWUuXG4gKi9cbnZhciBTdXNoaUNsaWVudCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKFN1c2hpQ2xpZW50LCBudWxsLCBbe1xuICAgIGtleTogXCJjcmVhdGVTdXNoaVVybFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVTdXNoaVVybChyZWdpb24sIHNvdXJjZUdyb3VwKSB7XG4gICAgICBpZiAoIXNvdXJjZUdyb3VwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN1c2hpIERyaXZlciB3YXMgbm90IHByb3ZpZGVkIHdpdGggYSBzb3VyY2UgZ3JvdXAuXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZG9tYWluO1xuXG4gICAgICBzd2l0Y2ggKHJlZ2lvbikge1xuICAgICAgICBjYXNlIFN1c2hpQ2xpZW50LlJFR0lPTlMuTkE6XG4gICAgICAgICAgZG9tYWluID0gXCJ1bmFnaS1uYVwiO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3VzaGlDbGllbnQuUkVHSU9OUy5FVTpcbiAgICAgICAgICBkb21haW4gPSBcInVuYWdpLWV1XCI7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTdXNoaUNsaWVudC5SRUdJT05TLkZFOlxuICAgICAgICAgIGRvbWFpbiA9IFwidW5hZ2ktZmVcIjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN1c2hpQ2xpZW50LlJFR0lPTlMuQ046XG4gICAgICAgICAgZG9tYWluID0gXCJ1bmFnaS1jblwiO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIHJlZ2lvbiAnXCIuY29uY2F0KHJlZ2lvbiwgXCInIHByb3ZpZGVkIHRvIFN1c2hpQ2xpZW50LlwiKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBcImh0dHBzOi8vXCIuY29uY2F0KGRvbWFpbiwgXCIuYW1hem9uLmNvbS8xL2V2ZW50cy9cIikuY29uY2F0KHNvdXJjZUdyb3VwKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlQ3NtVXNlckNvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlQ3NtVXNlckNvbnRleHQoc3VzaGlVcmwpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgaGlQcmlGbHVzaEludGVydmFsOiAxMDAwLFxuICAgICAgICBsb3dQcmlGbHVzaEludGVydmFsOiAxMDAwMCxcbiAgICAgICAgcmVxdWVzdElkOiBcIjFcIixcbiAgICAgICAgZXJyb3JDaGFubmVsOiBcImpzZXJyXCIsXG4gICAgICAgIHNlc3Npb25TdG9yYWdlV3JhcHBlcjogdW5kZWZpbmVkLFxuICAgICAgICBlcnJvckhhbmRsZXJGdW5jdGlvbjogY29uc29sZS5sb2csXG4gICAgICAgIHN1c2hpVXJsOiBzdXNoaVVybFxuICAgICAgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIFN1c2hpIENsaWVudCBmb3IgYSByZWdpb24gYW5kIHNvdXJjZSBncm91cFxuICAgICAqXG4gICAgICogQHBhcmFtIHJlZ2lvbiBSZWdpb24gaW4gU3VzaGlDbGllbnQuUkVHSU9OU1xuICAgICAqIEBwYXJhbSBzb3VyY2VHcm91cCBTdXNoaSBFZWwgc291cmNlIGdyb3VwXG4gICAgICogQHBhcmFtIGVycm9ySGFuZGxlciBFcnJvciBoYW5kbGVyIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQWRkaXRpb25hbCBDU00gY29udGV4dCBvdmVycmlkZXNcbiAgICAgKiBAcGFyYW0gY2xpZW50T3ZlcnJpZGUgQW4gb3B0aW9uYWwgdHJhbnNwb3J0YXRpb24gY2xpZW50IGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0IGNsaWVudHMgKG5hdmlnYXRvci5zZW5kQmVhY29uIGFuZCBYRG9tYWluUmVxdWVzdCBvciBYTUxIdHRwUmVxdWVzdClcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIlJFR0lPTlNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIE5BOiBcIk5BXCIsXG4gICAgICAgIEVVOiBcIkVVXCIsXG4gICAgICAgIEZFOiBcIkZFXCIsXG4gICAgICAgIENOOiBcIkNOXCJcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG5cbiAgZnVuY3Rpb24gU3VzaGlDbGllbnQoKSB7XG4gICAgdmFyIHJlZ2lvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogU3VzaGlDbGllbnQuUkVHSU9OUy5OQTtcbiAgICB2YXIgc291cmNlR3JvdXAgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgZXJyb3JIYW5kbGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICAgIHZhciBjbGllbnRPdmVycmlkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ID8gYXJndW1lbnRzWzRdIDogdW5kZWZpbmVkO1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFN1c2hpQ2xpZW50KTtcbiAgICB2YXIgc3VzaGlVcmwgPSBTdXNoaUNsaWVudC5jcmVhdGVTdXNoaVVybChyZWdpb24sIHNvdXJjZUdyb3VwKTtcbiAgICB2YXIgY3NtVXNlckNvbnRleHQgPSBTdXNoaUNsaWVudC5jcmVhdGVDc21Vc2VyQ29udGV4dChzdXNoaVVybCwgb3B0aW9ucyk7XG4gICAgdGhpcy51ZV9jc20gPSB0aGlzLnNldHVwTW9ja0NTTU9iamVjdChjc21Vc2VyQ29udGV4dCk7XG4gICAgdGhpcy5lbmNhcHN1bGF0ZWRXaW5kb3cgPSB0aGlzLnNldHVwTW9ja1dpbmRvdyh0aGlzLnVlX2NzbSk7XG4gICAgdGhpcy50cmFuc3BvcnRhdGlvbkNsaWVudENvZGUodGhpcy51ZV9jc20sIHdpbmRvdyk7XG5cbiAgICBpZiAoY2xpZW50T3ZlcnJpZGUpIHtcbiAgICAgIHRoaXMudWVfY3NtLnVlLl9zQmNuID0ge1xuICAgICAgICBpc1N1cHBvcnRlZDogdHJ1ZSxcbiAgICAgICAgc2VuZDogZnVuY3Rpb24gc2VuZChlbmRwb2ludCwgcGF5bG9hZCkge1xuICAgICAgICAgIGNsaWVudE92ZXJyaWRlKGVuZHBvaW50LCBwYXlsb2FkKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLmNsaWVudENvZGUodGhpcy51ZV9jc20sIHRoaXMuZW5jYXBzdWxhdGVkV2luZG93KTtcbiAgICB0aGlzLmVycm9ySGFuZGxlciA9IGVycm9ySGFuZGxlcjtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKFN1c2hpQ2xpZW50LCBbe1xuICAgIGtleTogXCJldmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBldmVudChkYXRhLCBwcm9kdWNlcklkLCBzY2hlbWFJZCwgb3B0aW9ucykge1xuICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBmYWxzZTtcblxuICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiU3VzaGlDbGllbnQgd3JhcHBlciBwdWJsaXNoaW5nIHRoZSBmb2xsb3dpbmc6XCIsIHtcbiAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgIHByb2R1Y2VySWQ6IHByb2R1Y2VySWQsXG4gICAgICAgICAgc2NoZW1hSWQ6IHNjaGVtYUlkLFxuICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnVlX2NzbS51ZS5ldmVudChkYXRhLCBwcm9kdWNlcklkLCBzY2hlbWFJZCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHlvdSBwbGFuIHRvIGVtaXQgMTAwMCBvciBtb3JlIGV2ZW50cyBwZXIgaW5zdGFudGlhdGVkIGNsaWVudCxcbiAgICAgKiBjYWxsIHJlc2V0IGFmdGVyIGNhbGxpbmcgZXZlbnQgdG8gYWxsb3cgdGhlIENTTSBjbGllbnQgdG8gY29udGludWUgc2VuZGluZyBldmVudHMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZXNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHRoaXMudWVfY3NtLnVlLmV2ZW50LnJlc2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCBqdXN0IGJlZm9yZSBlYWNoIHRpbWUgbWV0cmljcyBhcmVcbiAgICAgKiBmbHVzaGVkIHRvIHRoZSBuZXR3b3JrLlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBBIGZ1bmN0aW9uIHRoYXQgc3VzaGkgd2lsbCBjYWxsIGJlZm9yZSBmbHVzaGVzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25TdXNoaUZsdXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uU3VzaGlGbHVzaChjYWxsYmFjaykge1xuICAgICAgdGhpcy51ZV9jc20udWUub25TdXNoaUZsdXNoKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIGp1c3QgYmVmb3JlIHRoZSBwYWdlIHVubG9hZHMuXG4gICAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBzZW5kIGFueSBmaW5hbCBtZXRyaWNzIHRvIHN1c2hpLCBzdWNoIGFzIHBhZ2UgdmlzaXRcbiAgICAgKiBkdXJhdGlvbiBvciBiYXRjaGVkIGNvdW50ZXJzLlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBBIGZ1bmN0aW9uIHRoYXQgc3VzaGkgd2lsbCBjYWxsIGJlZm9yZSB1bmxvYWQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvblN1c2hpVW5sb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uU3VzaGlVbmxvYWQoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMudWVfY3NtLnVlLm9uU3VzaGlVbmxvYWQoY2FsbGJhY2spO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXR1cE1vY2tDU01PYmplY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0dXBNb2NrQ1NNT2JqZWN0KGNzbVVzZXJDb250ZXh0KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgZXhlY1N0dWIgPSBmdW5jdGlvbiBleGVjU3R1YihjYWxsYmFjaywgYXR0cmlidXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrO1xuICAgICAgfTtcblxuICAgICAgdmFyIGV2ZW50U3R1YiA9IGZ1bmN0aW9uIGV2ZW50U3R1Yihsb2csIHByb2R1Y2VyLCBldmVudFR5cGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiU3VzaGlDbGllbnQgQ1NNIHN0dWIgY2FsbGVkIGluIHVuc3VwcG9ydGVkIG1hbm5lcjogZXZlbnQoKVwiKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBlcnJvckhhbmRsZXIgPSBmdW5jdGlvbiBlcnJvckhhbmRsZXIobG9nRXZlbnQsIGNoYW5uZWwpIHtcbiAgICAgICAgaWYgKF90aGlzLmVycm9ySGFuZGxlcikge1xuICAgICAgICAgIF90aGlzLmVycm9ySGFuZGxlcihsb2dFdmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJBbiBlcnJvciBoYXMgb2NjdXJyZWQgaW4gU3VzaGlDbGllbnQgY2hhbm5lbCBcIiArIGNoYW5uZWwsIGxvZ0V2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIGF0dGFjaEhhbmRsZXIgPSBmdW5jdGlvbiBhdHRhY2hIYW5kbGVyKGV2dCwgaGFuZGxlciwgY29udGFpbmVyKSB7XG4gICAgICAgIC8vVE9ETyBtaWdodCBiZSBhYmxlIHRvIGp1c3QgdXNlIHdpbmRvdy51ZS5hdHRhY2g/XG4gICAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lciB8fCB3aW5kb3c7IC8vb2sgdG8gdXNlIHJlYWwgd2luZG93IGdsb2JhbCBoZXJlLlxuXG4gICAgICAgIGlmICh3aW5kb3cuRXZlbnRUYXJnZXQgJiYgd2luZG93LkV2ZW50VGFyZ2V0LnByb3RvdHlwZSAmJiB3aW5kb3cuRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICB3aW5kb3cuRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIuY2FsbChjb250YWluZXIsIGV2dCwgaGFuZGxlciwgISF3aW5kb3cudWVfY2xmKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciwgISF3aW5kb3cudWVfY2xmKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb250YWluZXIuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICBjb250YWluZXIuYXR0YWNoRXZlbnQoXCJvblwiICsgZXZ0LCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdWVfaHBzaTogY3NtVXNlckNvbnRleHQuaGlQcmlGbHVzaEludGVydmFsLFxuICAgICAgICB1ZV9scHNpOiBjc21Vc2VyQ29udGV4dC5sb3dQcmlGbHVzaEludGVydmFsLFxuICAgICAgICB1ZToge1xuICAgICAgICAgIHNzdzogY3NtVXNlckNvbnRleHQuc2Vzc2lvblN0b3JhZ2VXcmFwcGVyLFxuICAgICAgICAgIGxvZzogZXJyb3JIYW5kbGVyLFxuICAgICAgICAgIGV4ZWM6IGV4ZWNTdHViLFxuICAgICAgICAgIGV2ZW50OiBldmVudFN0dWIsXG4gICAgICAgICAgYXR0YWNoOiBhdHRhY2hIYW5kbGVyXG4gICAgICAgIH0sXG4gICAgICAgIHVlTG9nRXJyb3I6IGNzbVVzZXJDb250ZXh0LmVycm9ySGFuZGxlckZ1bmN0aW9uLFxuICAgICAgICB1ZV9zdXJsOiBjc21Vc2VyQ29udGV4dC5zdXNoaVVybCxcbiAgICAgICAgdWVfaWQ6IGNzbVVzZXJDb250ZXh0LnJlcXVlc3RJZCxcbiAgICAgICAgdWVfZXJyX2NoYW46IGNzbVVzZXJDb250ZXh0LmVycm9yQ2hhbm5lbFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0dXBNb2NrV2luZG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldHVwTW9ja1dpbmRvdyh1ZV9jc20pIHtcbiAgICAgIC8vYXBwYXJlbnRseSBjYW5ub3QgcmVmIHRoZSBzZXRUaW1lb3V0IGZ1bmN0aW9uIGRpcmVjdGx5IGluIHNvbWUgYnJvd3NlcnMgc28gd2UgaGF2ZSB0byB3cmFwIGl0LlxuICAgICAgdmFyIHRpbWVvdXRXcmFwcGVyID0gZnVuY3Rpb24gdGltZW91dFdyYXBwZXIoZm4sIHRpbWVvdXQpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGZuLCB0aW1lb3V0KTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVlX2NzbTogdWVfY3NtLFxuICAgICAgICB1ZUxvZ0Vycm9yOiB1ZV9jc20udWVMb2dFcnJvcixcbiAgICAgICAgdWU6IHVlX2NzbS51ZSxcbiAgICAgICAgc2V0VGltZW91dDogdGltZW91dFdyYXBwZXJcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvZGUgd2l0aGluIGZ1bmN0aW9uIHB1bGxlZCBkaXJlY3RseSBmcm9tXG4gICAgICogaHR0cHM6Ly9jb2RlLmFtYXpvbi5jb20vcGFja2FnZXMvU3VzaGlKYXZhU2NyaXB0Q2xpZW50L2Jsb2JzL21haW5saW5lLy0tL2phdmFzY3JpcHQvc3VzaGktY2xpZW50LmpzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjbGllbnRDb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsaWVudENvZGUodWVfY3NtLCB3aW5kb3cpIHtcbiAgICAgIHVlX2NzbS51ZS5leGVjKGZ1bmN0aW9uIChiLCBrKSB7XG4gICAgICAgIGZ1bmN0aW9uIEEoKSB7XG4gICAgICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCBhcmd1bWVudHMubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgICAgIHZhciBjID0gYXJndW1lbnRzW2FdO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YXIgaDtcblxuICAgICAgICAgICAgICBpZiAoYy5pc1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgIHZhciBiID0gdC5idWlsZFBheWxvYWQobCwgZSk7XG4gICAgICAgICAgICAgICAgaCA9IGMuc2VuZChKLCBiKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHRocm93IGR1bW15RXhjZXB0aW9uO1xuXG4gICAgICAgICAgICAgIHJldHVybiBoO1xuICAgICAgICAgICAgfSBjYXRjaCAoZCkge31cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBCKHtcbiAgICAgICAgICAgIG06IFwiQWxsIHN1cHBvcnRlZCBjbGllbnRzIGZhaWxlZFwiLFxuICAgICAgICAgICAgYXR0cmlidXRpb246IFwiQ1NNU3VzaGlDbGllbnRfVFJBTlNQT1JUQVRJT05fRkFJTFwiLFxuICAgICAgICAgICAgZjogXCJzdXNoaS1jbGllbnQuanNcIixcbiAgICAgICAgICAgIGxvZ0xldmVsOiBcIkVSUk9SXCJcbiAgICAgICAgICB9LCBrLnVlX2Vycl9jaGFuIHx8IFwianNlcnJcIik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtKCkge1xuICAgICAgICAgIGlmIChlLmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCBuLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgICAgICAgIG5bYV0oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQShkLl9zQmNuIHx8IHt9LCBkLl9hanggfHwge30pO1xuICAgICAgICAgICAgZSA9IFtdO1xuICAgICAgICAgICAgZiA9IHt9O1xuICAgICAgICAgICAgbCA9IHt9O1xuICAgICAgICAgICAgdSA9IHYgPSBxID0gdyA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gSygpIHtcbiAgICAgICAgICB2YXIgYSA9IG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgIGMgPSBmdW5jdGlvbiBjKGEpIHtcbiAgICAgICAgICAgIHJldHVybiAxMCA+IGEgPyBcIjBcIiArIGEgOiBhO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICByZXR1cm4gRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcgPyBhLnRvSVNPU3RyaW5nKCkgOiBhLmdldFVUQ0Z1bGxZZWFyKCkgKyBcIi1cIiArIGMoYS5nZXRVVENNb250aCgpICsgMSkgKyBcIi1cIiArIGMoYS5nZXRVVENEYXRlKCkpICsgXCJUXCIgKyBjKGEuZ2V0VVRDSG91cnMoKSkgKyBcIjpcIiArIGMoYS5nZXRVVENNaW51dGVzKCkpICsgXCI6XCIgKyBjKGEuZ2V0VVRDU2Vjb25kcygpKSArIFwiLlwiICsgU3RyaW5nKChhLmdldFVUQ01pbGxpc2Vjb25kcygpIC8gMUUzKS50b0ZpeGVkKDMpKS5zbGljZSgyLCA1KSArIFwiWlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24geChhKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhKTtcbiAgICAgICAgICB9IGNhdGNoIChjKSB7fVxuXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBDKGEsIGMsIGgsIGcpIHtcbiAgICAgICAgICB2YXIgcCA9ICExO1xuICAgICAgICAgIGcgPSBnIHx8IHt9O1xuICAgICAgICAgIHIrKztcbiAgICAgICAgICByID09IEQgJiYgQih7XG4gICAgICAgICAgICBtOiBcIk1heCBudW1iZXIgb2YgU3VzaGkgTG9ncyBleGNlZWRlZFwiLFxuICAgICAgICAgICAgZjogXCJzdXNoaS1jbGllbnQuanNcIixcbiAgICAgICAgICAgIGxvZ0xldmVsOiBcIkVSUk9SXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGlvbjogXCJDU01TdXNoaUNsaWVudF9NQVhfQ0FMTFNcIlxuICAgICAgICAgIH0sIGsudWVfZXJyX2NoYW4gfHwgXCJqc2VyclwiKTtcbiAgICAgICAgICB2YXIgZjtcbiAgICAgICAgICBpZiAoZiA9ICEociA+PSBEKSkgKGYgPSBhICYmIC0xIDwgYS5jb25zdHJ1Y3Rvci50b1N0cmluZygpLmluZGV4T2YoXCJPYmplY3RcIikgJiYgYyAmJiAtMSA8IGMuY29uc3RydWN0b3IudG9TdHJpbmcoKS5pbmRleE9mKFwiU3RyaW5nXCIpICYmIGggJiYgLTEgPCBoLmNvbnN0cnVjdG9yLnRvU3RyaW5nKCkuaW5kZXhPZihcIlN0cmluZ1wiKSkgfHwgTCsrO1xuICAgICAgICAgIGYgJiYgKGQuY291bnQgJiYgZC5jb3VudChcIkV2ZW50OlwiICsgaCwgMSksIGEucHJvZHVjZXJJZCA9IGEucHJvZHVjZXJJZCB8fCBjLCBhLnNjaGVtYUlkID0gYS5zY2hlbWFJZCB8fCBoLCBhLnRpbWVzdGFtcCA9IEsoKSwgYyA9IERhdGUubm93ID8gRGF0ZS5ub3coKSA6ICtuZXcgRGF0ZSgpLCBoID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygpLnN1YnN0cmluZygyLCAxMiksIGEubWVzc2FnZUlkID0gYi51ZV9pZCArIFwiLVwiICsgYyArIFwiLVwiICsgaCwgZyAmJiAhZy5zc2QgJiYgKGEuc2Vzc2lvbklkID0gYS5zZXNzaW9uSWQgfHwgYi51ZV9zaWQsIGEucmVxdWVzdElkID0gYS5yZXF1ZXN0SWQgfHwgYi51ZV9pZCwgYS5vYmZ1c2NhdGVkTWFya2V0cGxhY2VJZCA9IGEub2JmdXNjYXRlZE1hcmtldHBsYWNlSWQgfHwgYi51ZV9taWQpLCAoYyA9IHgoYSkpID8gKGMgPSBjLmxlbmd0aCwgKGUubGVuZ3RoID09IE0gfHwgcSArIGMgPiBOKSAmJiBtKCksIHEgKz0gYywgYSA9IHtcbiAgICAgICAgICAgIGRhdGE6IHQuY29tcHJlc3NFdmVudChhKVxuICAgICAgICAgIH0sIGUucHVzaChhKSwgKGcgfHwge30pLm4gPyAwID09PSBFID8gbSgpIDogdSB8fCAodSA9IGsuc2V0VGltZW91dChtLCBFKSkgOiB2IHx8ICh2ID0gay5zZXRUaW1lb3V0KG0sIE8pKSwgcCA9ICEwKSA6IHAgPSAhMSk7XG4gICAgICAgICAgIXAgJiYgYi51ZV9pbnQgJiYgY29uc29sZS5lcnJvcihcIkludmFsaWQgSlMgTmV4dXMgQVBJIGNhbGxcIik7XG4gICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBGKCkge1xuICAgICAgICAgIGlmICghRykge1xuICAgICAgICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCB5Lmxlbmd0aDsgYSsrKSB7XG4gICAgICAgICAgICAgIHlbYV0oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChhID0gMDsgYSA8IG4ubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgICAgICAgblthXSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlLmxlbmd0aCAmJiAoYi51ZV9zYnVpbXAgJiYgYi51ZSAmJiBiLnVlLnNzdyAmJiAoYSA9IHgoe1xuICAgICAgICAgICAgICBkY3Q6IGwsXG4gICAgICAgICAgICAgIGV2dDogZVxuICAgICAgICAgICAgfSksIGIudWUuc3N3KFwiZWVsZGF0YVwiLCBhKSwgYi51ZS5zc3coXCJlZWxzdHNcIiwgXCJ1bmtcIikpLCBBKGQuX3NCY24gfHwge30pKTtcbiAgICAgICAgICAgIEcgPSAhMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBIKGEpIHtcbiAgICAgICAgICB5LnB1c2goYSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBJKGEpIHtcbiAgICAgICAgICBuLnB1c2goYSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgRCA9IDFFMyxcbiAgICAgICAgICAgIE0gPSA0OTksXG4gICAgICAgICAgICBOID0gNTI0Mjg4LFxuICAgICAgICAgICAgcyA9IGZ1bmN0aW9uIHMoKSB7fSxcbiAgICAgICAgICAgIGQgPSBiLnVlIHx8IHt9LFxuICAgICAgICAgICAgQiA9IGQubG9nIHx8IHMsXG4gICAgICAgICAgICBQID0gYi51ZXggfHwgcztcblxuICAgICAgICAoYi51ZXQgfHwgcykoXCJiYlwiLCBcInVlX3N1c2hpX3YxXCIsIHtcbiAgICAgICAgICB3YjogMVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgSiA9IGIudWVfc3VybCB8fCBcImh0dHBzOi8vdW5hZ2ktbmEuYW1hem9uLmNvbS8xL2V2ZW50cy9jb20uYW1hem9uLmNzbS5uZXh1c2NsaWVudC5nYW1tYVwiLFxuICAgICAgICAgICAgUSA9IFtcIm1lc3NhZ2VJZFwiLCBcInRpbWVzdGFtcFwiXSxcbiAgICAgICAgICAgIHogPSBcIiNcIixcbiAgICAgICAgICAgIGUgPSBbXSxcbiAgICAgICAgICAgIGYgPSB7fSxcbiAgICAgICAgICAgIGwgPSB7fSxcbiAgICAgICAgICAgIHEgPSAwLFxuICAgICAgICAgICAgdyA9IDAsXG4gICAgICAgICAgICBMID0gMCxcbiAgICAgICAgICAgIHIgPSAwLFxuICAgICAgICAgICAgeSA9IFtdLFxuICAgICAgICAgICAgbiA9IFtdLFxuICAgICAgICAgICAgRyA9ICExLFxuICAgICAgICAgICAgdSxcbiAgICAgICAgICAgIHYsXG4gICAgICAgICAgICBFID0gdm9pZCAwID09PSBiLnVlX2hwc2kgPyAxRTMgOiBiLnVlX2hwc2ksXG4gICAgICAgICAgICBPID0gdm9pZCAwID09PSBiLnVlX2xwc2kgPyAxRTQgOiBiLnVlX2xwc2ksXG4gICAgICAgICAgICB0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZ1bmN0aW9uIGEoYSkge1xuICAgICAgICAgICAgZlthXSA9IHogKyB3Kys7XG4gICAgICAgICAgICBsW2ZbYV1dID0gYTtcbiAgICAgICAgICAgIHJldHVybiBmW2FdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGMoYikge1xuICAgICAgICAgICAgaWYgKCEoYiBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgICAgICAgICBpZiAoYiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZyA9IFtdLCBkID0gYi5sZW5ndGgsIGUgPSAwOyBlIDwgZDsgZSsrKSB7XG4gICAgICAgICAgICAgICAgICBnW2VdID0gYyhiW2VdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChiIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgZyA9IHt9O1xuXG4gICAgICAgICAgICAgICAgZm9yIChkIGluIGIpIHtcbiAgICAgICAgICAgICAgICAgIGIuaGFzT3duUHJvcGVydHkoZCkgJiYgKGdbZltkXSA/IGZbZF0gOiBhKGQpXSA9IC0xID09PSBRLmluZGV4T2YoZCkgPyBjKGJbZF0pIDogYltkXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGc7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGIgJiYgKGIubGVuZ3RoID4gKHogKyB3KS5sZW5ndGggfHwgYi5jaGFyQXQoMCkgPT09IHopID8gZltiXSA/IGZbYl0gOiBhKGIpIDogYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29tcHJlc3NFdmVudDogYyxcbiAgICAgICAgICAgIGJ1aWxkUGF5bG9hZDogZnVuY3Rpb24gYnVpbGRQYXlsb2FkKCkge1xuICAgICAgICAgICAgICByZXR1cm4geCh7XG4gICAgICAgICAgICAgICAgY3M6IHtcbiAgICAgICAgICAgICAgICAgIGRjdDogbFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXZlbnRzOiBlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0oKTtcblxuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChkLmV2ZW50ICYmIGQuZXZlbnQuaXNTdHViKSB7XG4gICAgICAgICAgICBpZiAoYi51ZV9zYnVpbXAgJiYgYi51ZSAmJiBiLnVlLnNzdykge1xuICAgICAgICAgICAgICB2YXIgYSA9IGIudWUuc3N3KFwiZWVsc3RzXCIpLnZhbDtcblxuICAgICAgICAgICAgICBpZiAoYSAmJiBcInVua1wiID09PSBhICYmIChhID0gYi51ZS5zc3coXCJlZWxkYXRhXCIpLnZhbCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYztcblxuICAgICAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGMgPSBKU09OLnBhcnNlKGEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZikge31cblxuICAgICAgICAgICAgICAgICAgYyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYyAmJiBjLmV2dCBpbnN0YW5jZW9mIEFycmF5ICYmIGMuZGN0IGluc3RhbmNlb2YgT2JqZWN0ICYmIChlID0gYy5ldnQsIGwgPSBjLmRjdCwgZSAmJiBsICYmIChtKCksIGIudWUuc3N3KFwiZWVsZGF0YVwiLCBcInt9XCIpLCBiLnVlLnNzdyhcImVlbHN0c1wiLCBcInNjc1wiKSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGQuZXZlbnQucmVwbGF5KGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgIGFbM10gPSBhWzNdIHx8IHt9O1xuICAgICAgICAgICAgICBhWzNdLm4gPSAxO1xuICAgICAgICAgICAgICBDLmFwcGx5KHRoaXMsIGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkLm9uU3VzaGlVbmxvYWQucmVwbGF5KGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgIEgoYVswXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGQub25TdXNoaUZsdXNoLnJlcGxheShmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICBJKGFbMF0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuXG4gICAgICAgIGQuYXR0YWNoKFwiYmVmb3JldW5sb2FkXCIsIEYpO1xuICAgICAgICBkLmF0dGFjaChcInBhZ2VoaWRlXCIsIEYpO1xuICAgICAgICBkLl9jbXBzID0gdDtcbiAgICAgICAgZC5ldmVudCA9IEM7XG5cbiAgICAgICAgZC5ldmVudC5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByID0gMDtcbiAgICAgICAgfTtcblxuICAgICAgICBkLm9uU3VzaGlVbmxvYWQgPSBIO1xuICAgICAgICBkLm9uU3VzaGlGbHVzaCA9IEk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBrLlAgJiYgay5QLnJlZ2lzdGVyICYmIGsuUC5yZWdpc3RlcihcInN1c2hpLWNsaWVudFwiLCBzKTtcbiAgICAgICAgfSBjYXRjaCAoUikge1xuICAgICAgICAgIGIudWVMb2dFcnJvcihSLCB7XG4gICAgICAgICAgICBsb2dMZXZlbDogXCJXQVJOXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIFAoXCJsZFwiLCBcInVlX3N1c2hpX3YxXCIsIHtcbiAgICAgICAgICB3YjogMVxuICAgICAgICB9KTtcbiAgICAgIH0sIFwiTnhzLUpTLUNsaWVudFwiKSh1ZV9jc20sIHdpbmRvdyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjb2RlIGluIHRoaXMgZnVuY3Rpb24gaXMgcHVsbGVkIGRpcmVjdGx5IGZyb206XG4gICAgICogaHR0cHM6Ly9jb2RlLmFtYXpvbi5jb20vcGFja2FnZXMvU3VzaGlKYXZhU2NyaXB0Q2xpZW50L2Jsb2JzL21haW5saW5lLy0tL2phdmFzY3JpcHQvdHJhbnNwb3J0YXRpb24tY2xpZW50cy5qc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidHJhbnNwb3J0YXRpb25DbGllbnRDb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyYW5zcG9ydGF0aW9uQ2xpZW50Q29kZSh1ZV9jc20sIHdpbmRvdykge1xuICAgICAgdWVfY3NtLnVlLmV4ZWMoZnVuY3Rpb24gKGIsIGMpIHtcbiAgICAgICAgdmFyIGUgPSBmdW5jdGlvbiBlKCkge30sXG4gICAgICAgICAgICBmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZW5kOiBmdW5jdGlvbiBzZW5kKGIsIGQpIHtcbiAgICAgICAgICAgICAgaWYgKGQgJiYgYikge1xuICAgICAgICAgICAgICAgIHZhciBhO1xuICAgICAgICAgICAgICAgIGlmIChjLlhEb21haW5SZXF1ZXN0KSBhID0gbmV3IFhEb21haW5SZXF1ZXN0KCksIGEub25lcnJvciA9IGUsIGEub250aW1lb3V0ID0gZSwgYS5vbnByb2dyZXNzID0gZSwgYS5vbmxvYWQgPSBlLCBhLnRpbWVvdXQgPSAwO2Vsc2UgaWYgKGMuWE1MSHR0cFJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChhID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCksICEoXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiBhKSkgdGhyb3cgXCJcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgYSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAoIWEpIHRocm93IFwiXCI7XG4gICAgICAgICAgICAgICAgYS5vcGVuKFwiUE9TVFwiLCBiLCAhMCk7XG4gICAgICAgICAgICAgICAgYS5zZXRSZXF1ZXN0SGVhZGVyICYmIGEuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtdHlwZVwiLCBcInRleHQvcGxhaW5cIik7XG4gICAgICAgICAgICAgICAgYS5zZW5kKGQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNTdXBwb3J0ZWQ6ICEwXG4gICAgICAgICAgfTtcbiAgICAgICAgfSgpLFxuICAgICAgICAgICAgZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2VuZDogZnVuY3Rpb24gc2VuZChjLCBkKSB7XG4gICAgICAgICAgICAgIGlmIChjICYmIGQpIGlmIChuYXZpZ2F0b3Iuc2VuZEJlYWNvbihjLCBkKSkgYi51ZV9zYnVpbXAgJiYgYi51ZSAmJiBiLnVlLnNzdyAmJiBiLnVlLnNzdyhcImVlbHN0c1wiLCBcInNjc1wiKTtlbHNlIHRocm93IFwiXCI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNTdXBwb3J0ZWQ6ICEhbmF2aWdhdG9yLnNlbmRCZWFjb24gJiYgIShjLmNvcmRvdmEgJiYgYy5jb3Jkb3ZhLnBsYXRmb3JtSWQgJiYgXCJpb3NcIiA9PSBjLmNvcmRvdmEucGxhdGZvcm1JZClcbiAgICAgICAgICB9O1xuICAgICAgICB9KCk7XG5cbiAgICAgICAgYi51ZS5fYWp4ID0gZjtcbiAgICAgICAgYi51ZS5fc0JjbiA9IGc7XG4gICAgICB9LCBcIlRyYW5zcG9ydGF0aW9uLWNsaWVudHNcIikodWVfY3NtLCB3aW5kb3cpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU3VzaGlDbGllbnQ7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFN1c2hpQ2xpZW50OyIsImZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlMaWtlVG9BcnJheTtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJ2YXIgYXJyYXlMaWtlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2FycmF5TGlrZVRvQXJyYXkuanNcIik7XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRob3V0SG9sZXM7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzQ2FsbENoZWNrO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY3JlYXRlQ2xhc3M7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmluZVByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsInZhciBzdXBlclByb3BCYXNlID0gcmVxdWlyZShcIi4vc3VwZXJQcm9wQmFzZS5qc1wiKTtcblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9nZXQgPSBSZWZsZWN0LmdldDtcbiAgICBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgICAgdmFyIGJhc2UgPSBzdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuXG4gICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZ2V0O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mLmpzXCIpO1xuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBzZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2luaGVyaXRzO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgXCJkZWZhdWx0XCI6IG9ialxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIilbXCJkZWZhdWx0XCJdO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHtcbiAgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsO1xuICB2YXIgY2FjaGVCYWJlbEludGVyb3AgPSBuZXcgV2Vha01hcCgpO1xuICB2YXIgY2FjaGVOb2RlSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7XG4gIHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7XG4gICAgcmV0dXJuIG5vZGVJbnRlcm9wID8gY2FjaGVOb2RlSW50ZXJvcCA6IGNhY2hlQmFiZWxJbnRlcm9wO1xuICB9KShub2RlSW50ZXJvcCk7XG59XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaiwgbm9kZUludGVyb3ApIHtcbiAgaWYgKCFub2RlSW50ZXJvcCAmJiBvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFwiZGVmYXVsdFwiOiBvYmpcbiAgICB9O1xuICB9XG5cbiAgdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKTtcblxuICBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHtcbiAgICByZXR1cm4gY2FjaGUuZ2V0KG9iaik7XG4gIH1cblxuICB2YXIgbmV3T2JqID0ge307XG4gIHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGtleSAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7XG5cbiAgICAgIGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld09ialtrZXldID0gb2JqW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajtcblxuICBpZiAoY2FjaGUpIHtcbiAgICBjYWNoZS5zZXQob2JqLCBuZXdPYmopO1xuICB9XG5cbiAgcmV0dXJuIG5ld09iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZDtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheTtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVNwcmVhZDtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJ2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKFwiLi9kZWZpbmVQcm9wZXJ0eS5qc1wiKTtcblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBPYmplY3QoYXJndW1lbnRzW2ldKSA6IHt9O1xuICAgIHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblxuICAgIGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb3duS2V5cy5wdXNoLmFwcGx5KG93bktleXMsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX29iamVjdFNwcmVhZDtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKVtcImRlZmF1bHRcIl07XG5cbnZhciBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQgPSByZXF1aXJlKFwiLi9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanNcIik7XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7XG4gIH1cblxuICByZXR1cm4gYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsInZhciBzdXBlclByb3BCYXNlID0gcmVxdWlyZShcIi4vc3VwZXJQcm9wQmFzZS5qc1wiKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZShcIi4vZGVmaW5lUHJvcGVydHkuanNcIik7XG5cbmZ1bmN0aW9uIHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3Quc2V0KSB7XG4gICAgc2V0ID0gUmVmbGVjdC5zZXQ7XG4gIH0gZWxzZSB7XG4gICAgc2V0ID0gZnVuY3Rpb24gc2V0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlcikge1xuICAgICAgdmFyIGJhc2UgPSBzdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgdmFyIGRlc2M7XG5cbiAgICAgIGlmIChiYXNlKSB7XG4gICAgICAgIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTtcblxuICAgICAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgICAgICBkZXNjLnNldC5jYWxsKHJlY2VpdmVyLCB2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoIWRlc2Mud3JpdGFibGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocmVjZWl2ZXIsIHByb3BlcnR5KTtcblxuICAgICAgaWYgKGRlc2MpIHtcbiAgICAgICAgaWYgKCFkZXNjLndyaXRhYmxlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVzYy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIHByb3BlcnR5LCBkZXNjKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZVByb3BlcnR5KHJlY2VpdmVyLCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpO1xufVxuXG5mdW5jdGlvbiBfc2V0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlciwgaXNTdHJpY3QpIHtcbiAgdmFyIHMgPSBzZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyIHx8IHRhcmdldCk7XG5cbiAgaWYgKCFzICYmIGlzU3RyaWN0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gc2V0IHByb3BlcnR5Jyk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3NldDtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsInZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL2dldFByb3RvdHlwZU9mLmpzXCIpO1xuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gIHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgfVxuXG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3N1cGVyUHJvcEJhc2U7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwidmFyIGFycmF5V2l0aG91dEhvbGVzID0gcmVxdWlyZShcIi4vYXJyYXlXaXRob3V0SG9sZXMuanNcIik7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXkuanNcIik7XG5cbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzXCIpO1xuXG52YXIgbm9uSXRlcmFibGVTcHJlYWQgPSByZXF1aXJlKFwiLi9ub25JdGVyYWJsZVNwcmVhZC5qc1wiKTtcblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3RvQ29uc3VtYWJsZUFycmF5O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3R5cGVvZjtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJ2YXIgYXJyYXlMaWtlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2FycmF5TGlrZVRvQXJyYXkuanNcIik7XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsIihmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vIFVuaXZlcnNhbCBNb2R1bGUgRGVmaW5pdGlvbiAoVU1EKSB0byBzdXBwb3J0IEFNRCwgQ29tbW9uSlMvTm9kZS5qcywgUmhpbm8sIGFuZCBicm93c2Vycy5cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoJ2Vycm9yLXN0YWNrLXBhcnNlcicsIFsnc3RhY2tmcmFtZSddLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnc3RhY2tmcmFtZScpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LkVycm9yU3RhY2tQYXJzZXIgPSBmYWN0b3J5KHJvb3QuU3RhY2tGcmFtZSk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyKFN0YWNrRnJhbWUpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgRklSRUZPWF9TQUZBUklfU1RBQ0tfUkVHRVhQID0gLyhefEApXFxTKzpcXGQrLztcbiAgICB2YXIgQ0hST01FX0lFX1NUQUNLX1JFR0VYUCA9IC9eXFxzKmF0IC4qKFxcUys6XFxkK3xcXChuYXRpdmVcXCkpL207XG4gICAgdmFyIFNBRkFSSV9OQVRJVkVfQ09ERV9SRUdFWFAgPSAvXihldmFsQCk/KFxcW25hdGl2ZSBjb2RlXSk/JC87XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2l2ZW4gYW4gRXJyb3Igb2JqZWN0LCBleHRyYWN0IHRoZSBtb3N0IGluZm9ybWF0aW9uIGZyb20gaXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheX0gb2YgU3RhY2tGcmFtZXNcbiAgICAgICAgICovXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZShlcnJvcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnJvci5zdGFja3RyYWNlICE9PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZXJyb3JbJ29wZXJhI3NvdXJjZWxvYyddICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3BlcmEoZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvci5zdGFjayAmJiBlcnJvci5zdGFjay5tYXRjaChDSFJPTUVfSUVfU1RBQ0tfUkVHRVhQKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVjhPcklFKGVycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3Iuc3RhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZGT3JTYWZhcmkoZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSBnaXZlbiBFcnJvciBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBTZXBhcmF0ZSBsaW5lIGFuZCBjb2x1bW4gbnVtYmVycyBmcm9tIGEgc3RyaW5nIG9mIHRoZSBmb3JtOiAoVVJJOkxpbmU6Q29sdW1uKVxuICAgICAgICBleHRyYWN0TG9jYXRpb246IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJGV4dHJhY3RMb2NhdGlvbih1cmxMaWtlKSB7XG4gICAgICAgICAgICAvLyBGYWlsLWZhc3QgYnV0IHJldHVybiBsb2NhdGlvbnMgbGlrZSBcIihuYXRpdmUpXCJcbiAgICAgICAgICAgIGlmICh1cmxMaWtlLmluZGV4T2YoJzonKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3VybExpa2VdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVnRXhwID0gLyguKz8pKD86OihcXGQrKSk/KD86OihcXGQrKSk/JC87XG4gICAgICAgICAgICB2YXIgcGFydHMgPSByZWdFeHAuZXhlYyh1cmxMaWtlLnJlcGxhY2UoL1soKV0vZywgJycpKTtcbiAgICAgICAgICAgIHJldHVybiBbcGFydHNbMV0sIHBhcnRzWzJdIHx8IHVuZGVmaW5lZCwgcGFydHNbM10gfHwgdW5kZWZpbmVkXTtcbiAgICAgICAgfSxcblxuICAgICAgICBwYXJzZVY4T3JJRTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VWOE9ySUUoZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBmaWx0ZXJlZCA9IGVycm9yLnN0YWNrLnNwbGl0KCdcXG4nKS5maWx0ZXIoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIWxpbmUubWF0Y2goQ0hST01FX0lFX1NUQUNLX1JFR0VYUCk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcmVkLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUuaW5kZXhPZignKGV2YWwgJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaHJvdyBhd2F5IGV2YWwgaW5mb3JtYXRpb24gdW50aWwgd2UgaW1wbGVtZW50IHN0YWNrdHJhY2UuanMvc3RhY2tmcmFtZSM4XG4gICAgICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoL2V2YWwgY29kZS9nLCAnZXZhbCcpLnJlcGxhY2UoLyhcXChldmFsIGF0IFteKCldKil8KFxcKSwuKiQpL2csICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHNhbml0aXplZExpbmUgPSBsaW5lLnJlcGxhY2UoL15cXHMrLywgJycpLnJlcGxhY2UoL1xcKGV2YWwgY29kZS9nLCAnKCcpO1xuXG4gICAgICAgICAgICAgICAgLy8gY2FwdHVyZSBhbmQgcHJlc2V2ZSB0aGUgcGFyZW50aGVzaXplZCBsb2NhdGlvbiBcIigvZm9vL215IGJhci5qczoxMjo4NylcIiBpblxuICAgICAgICAgICAgICAgIC8vIGNhc2UgaXQgaGFzIHNwYWNlcyBpbiBpdCwgYXMgdGhlIHN0cmluZyBpcyBzcGxpdCBvbiBcXHMrIGxhdGVyIG9uXG4gICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gc2FuaXRpemVkTGluZS5tYXRjaCgvIChcXCgoLispOihcXGQrKTooXFxkKylcXCkkKS8pO1xuXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBwYXJlbnRoZXNpemVkIGxvY2F0aW9uIGZyb20gdGhlIGxpbmUsIGlmIGl0IHdhcyBtYXRjaGVkXG4gICAgICAgICAgICAgICAgc2FuaXRpemVkTGluZSA9IGxvY2F0aW9uID8gc2FuaXRpemVkTGluZS5yZXBsYWNlKGxvY2F0aW9uWzBdLCAnJykgOiBzYW5pdGl6ZWRMaW5lO1xuXG4gICAgICAgICAgICAgICAgdmFyIHRva2VucyA9IHNhbml0aXplZExpbmUuc3BsaXQoL1xccysvKS5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICAvLyBpZiBhIGxvY2F0aW9uIHdhcyBtYXRjaGVkLCBwYXNzIGl0IHRvIGV4dHJhY3RMb2NhdGlvbigpIG90aGVyd2lzZSBwb3AgdGhlIGxhc3QgdG9rZW5cbiAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb25QYXJ0cyA9IHRoaXMuZXh0cmFjdExvY2F0aW9uKGxvY2F0aW9uID8gbG9jYXRpb25bMV0gOiB0b2tlbnMucG9wKCkpO1xuICAgICAgICAgICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSB0b2tlbnMuam9pbignICcpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZU5hbWUgPSBbJ2V2YWwnLCAnPGFub255bW91cz4nXS5pbmRleE9mKGxvY2F0aW9uUGFydHNbMF0pID4gLTEgPyB1bmRlZmluZWQgOiBsb2NhdGlvblBhcnRzWzBdO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGFja0ZyYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBmaWxlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogbG9jYXRpb25QYXJ0c1sxXSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uTnVtYmVyOiBsb2NhdGlvblBhcnRzWzJdLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGxpbmVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlRkZPclNhZmFyaTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VGRk9yU2FmYXJpKGVycm9yKSB7XG4gICAgICAgICAgICB2YXIgZmlsdGVyZWQgPSBlcnJvci5zdGFjay5zcGxpdCgnXFxuJykuZmlsdGVyKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWxpbmUubWF0Y2goU0FGQVJJX05BVElWRV9DT0RFX1JFR0VYUCk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcmVkLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhyb3cgYXdheSBldmFsIGluZm9ybWF0aW9uIHVudGlsIHdlIGltcGxlbWVudCBzdGFja3RyYWNlLmpzL3N0YWNrZnJhbWUjOFxuICAgICAgICAgICAgICAgIGlmIChsaW5lLmluZGV4T2YoJyA+IGV2YWwnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoLyBsaW5lIChcXGQrKSg/OiA+IGV2YWwgbGluZSBcXGQrKSogPiBldmFsOlxcZCs6XFxkKy9nLCAnOiQxJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGxpbmUuaW5kZXhPZignQCcpID09PSAtMSAmJiBsaW5lLmluZGV4T2YoJzonKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIGV2YWwgZnJhbWVzIG9ubHkgaGF2ZSBmdW5jdGlvbiBuYW1lcyBhbmQgbm90aGluZyBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3RhY2tGcmFtZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZVJlZ2V4ID0gLygoLipcIi4rXCJbXkBdKik/W15AXSopKD86QCkvO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IGxpbmUubWF0Y2goZnVuY3Rpb25OYW1lUmVnZXgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gbWF0Y2hlcyAmJiBtYXRjaGVzWzFdID8gbWF0Y2hlc1sxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uUGFydHMgPSB0aGlzLmV4dHJhY3RMb2NhdGlvbihsaW5lLnJlcGxhY2UoZnVuY3Rpb25OYW1lUmVnZXgsICcnKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGFja0ZyYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWU6IGxvY2F0aW9uUGFydHNbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsb2NhdGlvblBhcnRzWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uTnVtYmVyOiBsb2NhdGlvblBhcnRzWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBsaW5lXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlT3BlcmE6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlT3BlcmEoZSkge1xuICAgICAgICAgICAgaWYgKCFlLnN0YWNrdHJhY2UgfHwgKGUubWVzc2FnZS5pbmRleE9mKCdcXG4nKSA+IC0xICYmXG4gICAgICAgICAgICAgICAgZS5tZXNzYWdlLnNwbGl0KCdcXG4nKS5sZW5ndGggPiBlLnN0YWNrdHJhY2Uuc3BsaXQoJ1xcbicpLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9wZXJhOShlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWUuc3RhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9wZXJhMTAoZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3BlcmExMShlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwYXJzZU9wZXJhOTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VPcGVyYTkoZSkge1xuICAgICAgICAgICAgdmFyIGxpbmVSRSA9IC9MaW5lIChcXGQrKS4qc2NyaXB0ICg/OmluICk/KFxcUyspL2k7XG4gICAgICAgICAgICB2YXIgbGluZXMgPSBlLm1lc3NhZ2Uuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMiwgbGVuID0gbGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBsaW5lUkUuZXhlYyhsaW5lc1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBTdGFja0ZyYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBtYXRjaFsyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IG1hdGNoWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBsaW5lc1tpXVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlT3BlcmExMDogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VPcGVyYTEwKGUpIHtcbiAgICAgICAgICAgIHZhciBsaW5lUkUgPSAvTGluZSAoXFxkKykuKnNjcmlwdCAoPzppbiApPyhcXFMrKSg/OjogSW4gZnVuY3Rpb24gKFxcUyspKT8kL2k7XG4gICAgICAgICAgICB2YXIgbGluZXMgPSBlLnN0YWNrdHJhY2Uuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBsaW5lUkUuZXhlYyhsaW5lc1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogbWF0Y2hbM10gfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBtYXRjaFsyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBtYXRjaFsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGxpbmVzW2ldXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBPcGVyYSAxMC42NSsgRXJyb3Iuc3RhY2sgdmVyeSBzaW1pbGFyIHRvIEZGL1NhZmFyaVxuICAgICAgICBwYXJzZU9wZXJhMTE6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlT3BlcmExMShlcnJvcikge1xuICAgICAgICAgICAgdmFyIGZpbHRlcmVkID0gZXJyb3Iuc3RhY2suc3BsaXQoJ1xcbicpLmZpbHRlcihmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhbGluZS5tYXRjaChGSVJFRk9YX1NBRkFSSV9TVEFDS19SRUdFWFApICYmICFsaW5lLm1hdGNoKC9eRXJyb3IgY3JlYXRlZCBhdC8pO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJlZC5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgIHZhciB0b2tlbnMgPSBsaW5lLnNwbGl0KCdAJyk7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uUGFydHMgPSB0aGlzLmV4dHJhY3RMb2NhdGlvbih0b2tlbnMucG9wKCkpO1xuICAgICAgICAgICAgICAgIHZhciBmdW5jdGlvbkNhbGwgPSAodG9rZW5zLnNoaWZ0KCkgfHwgJycpO1xuICAgICAgICAgICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSBmdW5jdGlvbkNhbGxcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLzxhbm9ueW1vdXMgZnVuY3Rpb24oOiAoXFx3KykpPz4vLCAnJDInKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwoW14pXSpcXCkvZywgJycpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB2YXIgYXJnc1JhdztcbiAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb25DYWxsLm1hdGNoKC9cXCgoW14pXSopXFwpLykpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1JhdyA9IGZ1bmN0aW9uQ2FsbC5yZXBsYWNlKC9eW14oXStcXCgoW14pXSopXFwpJC8sICckMScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IChhcmdzUmF3ID09PSB1bmRlZmluZWQgfHwgYXJnc1JhdyA9PT0gJ1thcmd1bWVudHMgbm90IGF2YWlsYWJsZV0nKSA/XG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6IGFyZ3NSYXcuc3BsaXQoJywnKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3RhY2tGcmFtZSh7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBhcmdzLFxuICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZTogbG9jYXRpb25QYXJ0c1swXSxcbiAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogbG9jYXRpb25QYXJ0c1sxXSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uTnVtYmVyOiBsb2NhdGlvblBhcnRzWzJdLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGxpbmVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbn0pKTtcbiIsIi8qKlxuICogQHRoaXMge1Byb21pc2V9XG4gKi9cbmZ1bmN0aW9uIGZpbmFsbHlDb25zdHJ1Y3RvcihjYWxsYmFjaykge1xuICB2YXIgY29uc3RydWN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdGhpcy50aGVuKFxuICAgIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICByZXR1cm4gY29uc3RydWN0b3IucmVzb2x2ZShjYWxsYmFjaygpKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLnJlc29sdmUoY2FsbGJhY2soKSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gY29uc3RydWN0b3IucmVqZWN0KHJlYXNvbik7XG4gICAgICB9KTtcbiAgICB9XG4gICk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZpbmFsbHlDb25zdHJ1Y3RvcjtcbiIsImltcG9ydCBwcm9taXNlRmluYWxseSBmcm9tICcuL2ZpbmFsbHknO1xuXG4vLyBTdG9yZSBzZXRUaW1lb3V0IHJlZmVyZW5jZSBzbyBwcm9taXNlLXBvbHlmaWxsIHdpbGwgYmUgdW5hZmZlY3RlZCBieVxuLy8gb3RoZXIgY29kZSBtb2RpZnlpbmcgc2V0VGltZW91dCAobGlrZSBzaW5vbi51c2VGYWtlVGltZXJzKCkpXG52YXIgc2V0VGltZW91dEZ1bmMgPSBzZXRUaW1lb3V0O1xuXG5mdW5jdGlvbiBpc0FycmF5KHgpIHtcbiAgcmV0dXJuIEJvb2xlYW4oeCAmJiB0eXBlb2YgeC5sZW5ndGggIT09ICd1bmRlZmluZWQnKTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbi8vIFBvbHlmaWxsIGZvciBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgZm4uYXBwbHkodGhpc0FyZywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cbmZ1bmN0aW9uIFByb21pc2UoZm4pIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFByb21pc2UpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2VzIG11c3QgYmUgY29uc3RydWN0ZWQgdmlhIG5ldycpO1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3QgYSBmdW5jdGlvbicpO1xuICAvKiogQHR5cGUgeyFudW1iZXJ9ICovXG4gIHRoaXMuX3N0YXRlID0gMDtcbiAgLyoqIEB0eXBlIHshYm9vbGVhbn0gKi9cbiAgdGhpcy5faGFuZGxlZCA9IGZhbHNlO1xuICAvKiogQHR5cGUge1Byb21pc2V8dW5kZWZpbmVkfSAqL1xuICB0aGlzLl92YWx1ZSA9IHVuZGVmaW5lZDtcbiAgLyoqIEB0eXBlIHshQXJyYXk8IUZ1bmN0aW9uPn0gKi9cbiAgdGhpcy5fZGVmZXJyZWRzID0gW107XG5cbiAgZG9SZXNvbHZlKGZuLCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlKHNlbGYsIGRlZmVycmVkKSB7XG4gIHdoaWxlIChzZWxmLl9zdGF0ZSA9PT0gMykge1xuICAgIHNlbGYgPSBzZWxmLl92YWx1ZTtcbiAgfVxuICBpZiAoc2VsZi5fc3RhdGUgPT09IDApIHtcbiAgICBzZWxmLl9kZWZlcnJlZHMucHVzaChkZWZlcnJlZCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHNlbGYuX2hhbmRsZWQgPSB0cnVlO1xuICBQcm9taXNlLl9pbW1lZGlhdGVGbihmdW5jdGlvbigpIHtcbiAgICB2YXIgY2IgPSBzZWxmLl9zdGF0ZSA9PT0gMSA/IGRlZmVycmVkLm9uRnVsZmlsbGVkIDogZGVmZXJyZWQub25SZWplY3RlZDtcbiAgICBpZiAoY2IgPT09IG51bGwpIHtcbiAgICAgIChzZWxmLl9zdGF0ZSA9PT0gMSA/IHJlc29sdmUgOiByZWplY3QpKGRlZmVycmVkLnByb21pc2UsIHNlbGYuX3ZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHJldDtcbiAgICB0cnkge1xuICAgICAgcmV0ID0gY2Ioc2VsZi5fdmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJlamVjdChkZWZlcnJlZC5wcm9taXNlLCBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVzb2x2ZShkZWZlcnJlZC5wcm9taXNlLCByZXQpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZShzZWxmLCBuZXdWYWx1ZSkge1xuICB0cnkge1xuICAgIC8vIFByb21pc2UgUmVzb2x1dGlvbiBQcm9jZWR1cmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9wcm9taXNlcy1hcGx1cy9wcm9taXNlcy1zcGVjI3RoZS1wcm9taXNlLXJlc29sdXRpb24tcHJvY2VkdXJlXG4gICAgaWYgKG5ld1ZhbHVlID09PSBzZWxmKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBwcm9taXNlIGNhbm5vdCBiZSByZXNvbHZlZCB3aXRoIGl0c2VsZi4nKTtcbiAgICBpZiAoXG4gICAgICBuZXdWYWx1ZSAmJlxuICAgICAgKHR5cGVvZiBuZXdWYWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG5ld1ZhbHVlID09PSAnZnVuY3Rpb24nKVxuICAgICkge1xuICAgICAgdmFyIHRoZW4gPSBuZXdWYWx1ZS50aGVuO1xuICAgICAgaWYgKG5ld1ZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICBzZWxmLl9zdGF0ZSA9IDM7XG4gICAgICAgIHNlbGYuX3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIGZpbmFsZShzZWxmKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkb1Jlc29sdmUoYmluZCh0aGVuLCBuZXdWYWx1ZSksIHNlbGYpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGYuX3N0YXRlID0gMTtcbiAgICBzZWxmLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIGZpbmFsZShzZWxmKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJlamVjdChzZWxmLCBlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWplY3Qoc2VsZiwgbmV3VmFsdWUpIHtcbiAgc2VsZi5fc3RhdGUgPSAyO1xuICBzZWxmLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICBmaW5hbGUoc2VsZik7XG59XG5cbmZ1bmN0aW9uIGZpbmFsZShzZWxmKSB7XG4gIGlmIChzZWxmLl9zdGF0ZSA9PT0gMiAmJiBzZWxmLl9kZWZlcnJlZHMubGVuZ3RoID09PSAwKSB7XG4gICAgUHJvbWlzZS5faW1tZWRpYXRlRm4oZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXNlbGYuX2hhbmRsZWQpIHtcbiAgICAgICAgUHJvbWlzZS5fdW5oYW5kbGVkUmVqZWN0aW9uRm4oc2VsZi5fdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlbGYuX2RlZmVycmVkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGhhbmRsZShzZWxmLCBzZWxmLl9kZWZlcnJlZHNbaV0pO1xuICB9XG4gIHNlbGYuX2RlZmVycmVkcyA9IG51bGw7XG59XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHByb21pc2UpIHtcbiAgdGhpcy5vbkZ1bGZpbGxlZCA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogbnVsbDtcbiAgdGhpcy5vblJlamVjdGVkID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT09ICdmdW5jdGlvbicgPyBvblJlamVjdGVkIDogbnVsbDtcbiAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbn1cblxuLyoqXG4gKiBUYWtlIGEgcG90ZW50aWFsbHkgbWlzYmVoYXZpbmcgcmVzb2x2ZXIgZnVuY3Rpb24gYW5kIG1ha2Ugc3VyZVxuICogb25GdWxmaWxsZWQgYW5kIG9uUmVqZWN0ZWQgYXJlIG9ubHkgY2FsbGVkIG9uY2UuXG4gKlxuICogTWFrZXMgbm8gZ3VhcmFudGVlcyBhYm91dCBhc3luY2hyb255LlxuICovXG5mdW5jdGlvbiBkb1Jlc29sdmUoZm4sIHNlbGYpIHtcbiAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBmbihcbiAgICAgIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICByZXNvbHZlKHNlbGYsIHZhbHVlKTtcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIHJlamVjdChzZWxmLCByZWFzb24pO1xuICAgICAgfVxuICAgICk7XG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICBkb25lID0gdHJ1ZTtcbiAgICByZWplY3Qoc2VsZiwgZXgpO1xuICB9XG59XG5cblByb21pc2UucHJvdG90eXBlWydjYXRjaCddID0gZnVuY3Rpb24ob25SZWplY3RlZCkge1xuICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0ZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgdmFyIHByb20gPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcihub29wKTtcblxuICBoYW5kbGUodGhpcywgbmV3IEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHByb20pKTtcbiAgcmV0dXJuIHByb207XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZVsnZmluYWxseSddID0gcHJvbWlzZUZpbmFsbHk7XG5cblByb21pc2UuYWxsID0gZnVuY3Rpb24oYXJyKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICBpZiAoIWlzQXJyYXkoYXJyKSkge1xuICAgICAgcmV0dXJuIHJlamVjdChuZXcgVHlwZUVycm9yKCdQcm9taXNlLmFsbCBhY2NlcHRzIGFuIGFycmF5JykpO1xuICAgIH1cblxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyKTtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHJldHVybiByZXNvbHZlKFtdKTtcbiAgICB2YXIgcmVtYWluaW5nID0gYXJncy5sZW5ndGg7XG5cbiAgICBmdW5jdGlvbiByZXMoaSwgdmFsKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodmFsICYmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgIHZhciB0aGVuID0gdmFsLnRoZW47XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGVuLmNhbGwoXG4gICAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgICAgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgcmVzKGksIHZhbCk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHJlamVjdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXJnc1tpXSA9IHZhbDtcbiAgICAgICAgaWYgKC0tcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgcmVzb2x2ZShhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgcmVqZWN0KGV4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlcyhpLCBhcmdzW2ldKTtcbiAgICB9XG4gIH0pO1xufTtcblxuUHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IFByb21pc2UpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgIHJlc29sdmUodmFsdWUpO1xuICB9KTtcbn07XG5cblByb21pc2UucmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHJlamVjdCh2YWx1ZSk7XG4gIH0pO1xufTtcblxuUHJvbWlzZS5yYWNlID0gZnVuY3Rpb24oYXJyKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICBpZiAoIWlzQXJyYXkoYXJyKSkge1xuICAgICAgcmV0dXJuIHJlamVjdChuZXcgVHlwZUVycm9yKCdQcm9taXNlLnJhY2UgYWNjZXB0cyBhbiBhcnJheScpKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBQcm9taXNlLnJlc29sdmUoYXJyW2ldKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8vIFVzZSBwb2x5ZmlsbCBmb3Igc2V0SW1tZWRpYXRlIGZvciBwZXJmb3JtYW5jZSBnYWluc1xuUHJvbWlzZS5faW1tZWRpYXRlRm4gPVxuICAvLyBAdHMtaWdub3JlXG4gICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nICYmXG4gICAgZnVuY3Rpb24oZm4pIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHNldEltbWVkaWF0ZShmbik7XG4gICAgfSkgfHxcbiAgZnVuY3Rpb24oZm4pIHtcbiAgICBzZXRUaW1lb3V0RnVuYyhmbiwgMCk7XG4gIH07XG5cblByb21pc2UuX3VuaGFuZGxlZFJlamVjdGlvbkZuID0gZnVuY3Rpb24gX3VuaGFuZGxlZFJlamVjdGlvbkZuKGVycikge1xuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUpIHtcbiAgICBjb25zb2xlLndhcm4oJ1Bvc3NpYmxlIFVuaGFuZGxlZCBQcm9taXNlIFJlamVjdGlvbjonLCBlcnIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgUHJvbWlzZTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggaXMgYSBjb21iaW5hdGlvbiBvZiBhbiBhcnJheSBhbmQgYSBzZXQuIEFkZGluZyBhIG5ld1xuICogbWVtYmVyIGlzIE8oMSksIHRlc3RpbmcgZm9yIG1lbWJlcnNoaXAgaXMgTygxKSwgYW5kIGZpbmRpbmcgdGhlIGluZGV4IG9mIGFuXG4gKiBlbGVtZW50IGlzIE8oMSkuIFJlbW92aW5nIGVsZW1lbnRzIGZyb20gdGhlIHNldCBpcyBub3Qgc3VwcG9ydGVkLiBPbmx5XG4gKiBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQgZm9yIG1lbWJlcnNoaXAuXG4gKi9cbmZ1bmN0aW9uIEFycmF5U2V0KCkge1xuICB0aGlzLl9hcnJheSA9IFtdO1xuICB0aGlzLl9zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuXG4vKipcbiAqIFN0YXRpYyBtZXRob2QgZm9yIGNyZWF0aW5nIEFycmF5U2V0IGluc3RhbmNlcyBmcm9tIGFuIGV4aXN0aW5nIGFycmF5LlxuICovXG5BcnJheVNldC5mcm9tQXJyYXkgPSBmdW5jdGlvbiBBcnJheVNldF9mcm9tQXJyYXkoYUFycmF5LCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gIHZhciBzZXQgPSBuZXcgQXJyYXlTZXQoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFBcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHNldC5hZGQoYUFycmF5W2ldLCBhQWxsb3dEdXBsaWNhdGVzKTtcbiAgfVxuICByZXR1cm4gc2V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm4gaG93IG1hbnkgdW5pcXVlIGl0ZW1zIGFyZSBpbiB0aGlzIEFycmF5U2V0LiBJZiBkdXBsaWNhdGVzIGhhdmUgYmVlblxuICogYWRkZWQsIHRoYW4gdGhvc2UgZG8gbm90IGNvdW50IHRvd2FyZHMgdGhlIHNpemUuXG4gKlxuICogQHJldHVybnMgTnVtYmVyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gQXJyYXlTZXRfc2l6ZSgpIHtcbiAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMuX3NldCkubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBBZGQgdGhlIGdpdmVuIHN0cmluZyB0byB0aGlzIHNldC5cbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIEFycmF5U2V0X2FkZChhU3RyLCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gIHZhciBzU3RyID0gdXRpbC50b1NldFN0cmluZyhhU3RyKTtcbiAgdmFyIGlzRHVwbGljYXRlID0gaGFzLmNhbGwodGhpcy5fc2V0LCBzU3RyKTtcbiAgdmFyIGlkeCA9IHRoaXMuX2FycmF5Lmxlbmd0aDtcbiAgaWYgKCFpc0R1cGxpY2F0ZSB8fCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gICAgdGhpcy5fYXJyYXkucHVzaChhU3RyKTtcbiAgfVxuICBpZiAoIWlzRHVwbGljYXRlKSB7XG4gICAgdGhpcy5fc2V0W3NTdHJdID0gaWR4O1xuICB9XG59O1xuXG4vKipcbiAqIElzIHRoZSBnaXZlbiBzdHJpbmcgYSBtZW1iZXIgb2YgdGhpcyBzZXQ/XG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBBcnJheVNldF9oYXMoYVN0cikge1xuICB2YXIgc1N0ciA9IHV0aWwudG9TZXRTdHJpbmcoYVN0cik7XG4gIHJldHVybiBoYXMuY2FsbCh0aGlzLl9zZXQsIHNTdHIpO1xufTtcblxuLyoqXG4gKiBXaGF0IGlzIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gc3RyaW5nIGluIHRoZSBhcnJheT9cbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBBcnJheVNldF9pbmRleE9mKGFTdHIpIHtcbiAgdmFyIHNTdHIgPSB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpO1xuICBpZiAoaGFzLmNhbGwodGhpcy5fc2V0LCBzU3RyKSkge1xuICAgIHJldHVybiB0aGlzLl9zZXRbc1N0cl07XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhU3RyICsgJ1wiIGlzIG5vdCBpbiB0aGUgc2V0LicpO1xufTtcblxuLyoqXG4gKiBXaGF0IGlzIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleD9cbiAqXG4gKiBAcGFyYW0gTnVtYmVyIGFJZHhcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gQXJyYXlTZXRfYXQoYUlkeCkge1xuICBpZiAoYUlkeCA+PSAwICYmIGFJZHggPCB0aGlzLl9hcnJheS5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXJyYXlbYUlkeF07XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdObyBlbGVtZW50IGluZGV4ZWQgYnkgJyArIGFJZHgpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBhcnJheSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNldCAod2hpY2ggaGFzIHRoZSBwcm9wZXIgaW5kaWNlc1xuICogaW5kaWNhdGVkIGJ5IGluZGV4T2YpLiBOb3RlIHRoYXQgdGhpcyBpcyBhIGNvcHkgb2YgdGhlIGludGVybmFsIGFycmF5IHVzZWRcbiAqIGZvciBzdG9yaW5nIHRoZSBtZW1iZXJzIHNvIHRoYXQgbm8gb25lIGNhbiBtZXNzIHdpdGggaW50ZXJuYWwgc3RhdGUuXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gQXJyYXlTZXRfdG9BcnJheSgpIHtcbiAgcmV0dXJuIHRoaXMuX2FycmF5LnNsaWNlKCk7XG59O1xuXG5leHBvcnRzLkFycmF5U2V0ID0gQXJyYXlTZXQ7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICpcbiAqIEJhc2VkIG9uIHRoZSBCYXNlIDY0IFZMUSBpbXBsZW1lbnRhdGlvbiBpbiBDbG9zdXJlIENvbXBpbGVyOlxuICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jbG9zdXJlLWNvbXBpbGVyL3NvdXJjZS9icm93c2UvdHJ1bmsvc3JjL2NvbS9nb29nbGUvZGVidWdnaW5nL3NvdXJjZW1hcC9CYXNlNjRWTFEuamF2YVxuICpcbiAqIENvcHlyaWdodCAyMDExIFRoZSBDbG9zdXJlIENvbXBpbGVyIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICogICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAqICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZFxuICogICAgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICogICogTmVpdGhlciB0aGUgbmFtZSBvZiBHb29nbGUgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkXG4gKiAgICBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbiAqIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICogVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICogKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCcuL2Jhc2U2NCcpO1xuXG4vLyBBIHNpbmdsZSBiYXNlIDY0IGRpZ2l0IGNhbiBjb250YWluIDYgYml0cyBvZiBkYXRhLiBGb3IgdGhlIGJhc2UgNjQgdmFyaWFibGVcbi8vIGxlbmd0aCBxdWFudGl0aWVzIHdlIHVzZSBpbiB0aGUgc291cmNlIG1hcCBzcGVjLCB0aGUgZmlyc3QgYml0IGlzIHRoZSBzaWduLFxuLy8gdGhlIG5leHQgZm91ciBiaXRzIGFyZSB0aGUgYWN0dWFsIHZhbHVlLCBhbmQgdGhlIDZ0aCBiaXQgaXMgdGhlXG4vLyBjb250aW51YXRpb24gYml0LiBUaGUgY29udGludWF0aW9uIGJpdCB0ZWxscyB1cyB3aGV0aGVyIHRoZXJlIGFyZSBtb3JlXG4vLyBkaWdpdHMgaW4gdGhpcyB2YWx1ZSBmb2xsb3dpbmcgdGhpcyBkaWdpdC5cbi8vXG4vLyAgIENvbnRpbnVhdGlvblxuLy8gICB8ICAgIFNpZ25cbi8vICAgfCAgICB8XG4vLyAgIFYgICAgVlxuLy8gICAxMDEwMTFcblxudmFyIFZMUV9CQVNFX1NISUZUID0gNTtcblxuLy8gYmluYXJ5OiAxMDAwMDBcbnZhciBWTFFfQkFTRSA9IDEgPDwgVkxRX0JBU0VfU0hJRlQ7XG5cbi8vIGJpbmFyeTogMDExMTExXG52YXIgVkxRX0JBU0VfTUFTSyA9IFZMUV9CQVNFIC0gMTtcblxuLy8gYmluYXJ5OiAxMDAwMDBcbnZhciBWTFFfQ09OVElOVUFUSU9OX0JJVCA9IFZMUV9CQVNFO1xuXG4vKipcbiAqIENvbnZlcnRzIGZyb20gYSB0d28tY29tcGxlbWVudCB2YWx1ZSB0byBhIHZhbHVlIHdoZXJlIHRoZSBzaWduIGJpdCBpc1xuICogcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XG4gKiAgIDEgYmVjb21lcyAyICgxMCBiaW5hcnkpLCAtMSBiZWNvbWVzIDMgKDExIGJpbmFyeSlcbiAqICAgMiBiZWNvbWVzIDQgKDEwMCBiaW5hcnkpLCAtMiBiZWNvbWVzIDUgKDEwMSBiaW5hcnkpXG4gKi9cbmZ1bmN0aW9uIHRvVkxRU2lnbmVkKGFWYWx1ZSkge1xuICByZXR1cm4gYVZhbHVlIDwgMFxuICAgID8gKCgtYVZhbHVlKSA8PCAxKSArIDFcbiAgICA6IChhVmFsdWUgPDwgMSkgKyAwO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRvIGEgdHdvLWNvbXBsZW1lbnQgdmFsdWUgZnJvbSBhIHZhbHVlIHdoZXJlIHRoZSBzaWduIGJpdCBpc1xuICogcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XG4gKiAgIDIgKDEwIGJpbmFyeSkgYmVjb21lcyAxLCAzICgxMSBiaW5hcnkpIGJlY29tZXMgLTFcbiAqICAgNCAoMTAwIGJpbmFyeSkgYmVjb21lcyAyLCA1ICgxMDEgYmluYXJ5KSBiZWNvbWVzIC0yXG4gKi9cbmZ1bmN0aW9uIGZyb21WTFFTaWduZWQoYVZhbHVlKSB7XG4gIHZhciBpc05lZ2F0aXZlID0gKGFWYWx1ZSAmIDEpID09PSAxO1xuICB2YXIgc2hpZnRlZCA9IGFWYWx1ZSA+PiAxO1xuICByZXR1cm4gaXNOZWdhdGl2ZVxuICAgID8gLXNoaWZ0ZWRcbiAgICA6IHNoaWZ0ZWQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYmFzZSA2NCBWTFEgZW5jb2RlZCB2YWx1ZS5cbiAqL1xuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiBiYXNlNjRWTFFfZW5jb2RlKGFWYWx1ZSkge1xuICB2YXIgZW5jb2RlZCA9IFwiXCI7XG4gIHZhciBkaWdpdDtcblxuICB2YXIgdmxxID0gdG9WTFFTaWduZWQoYVZhbHVlKTtcblxuICBkbyB7XG4gICAgZGlnaXQgPSB2bHEgJiBWTFFfQkFTRV9NQVNLO1xuICAgIHZscSA+Pj49IFZMUV9CQVNFX1NISUZUO1xuICAgIGlmICh2bHEgPiAwKSB7XG4gICAgICAvLyBUaGVyZSBhcmUgc3RpbGwgbW9yZSBkaWdpdHMgaW4gdGhpcyB2YWx1ZSwgc28gd2UgbXVzdCBtYWtlIHN1cmUgdGhlXG4gICAgICAvLyBjb250aW51YXRpb24gYml0IGlzIG1hcmtlZC5cbiAgICAgIGRpZ2l0IHw9IFZMUV9DT05USU5VQVRJT05fQklUO1xuICAgIH1cbiAgICBlbmNvZGVkICs9IGJhc2U2NC5lbmNvZGUoZGlnaXQpO1xuICB9IHdoaWxlICh2bHEgPiAwKTtcblxuICByZXR1cm4gZW5jb2RlZDtcbn07XG5cbi8qKlxuICogRGVjb2RlcyB0aGUgbmV4dCBiYXNlIDY0IFZMUSB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBzdHJpbmcgYW5kIHJldHVybnMgdGhlXG4gKiB2YWx1ZSBhbmQgdGhlIHJlc3Qgb2YgdGhlIHN0cmluZyB2aWEgdGhlIG91dCBwYXJhbWV0ZXIuXG4gKi9cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gYmFzZTY0VkxRX2RlY29kZShhU3RyLCBhSW5kZXgsIGFPdXRQYXJhbSkge1xuICB2YXIgc3RyTGVuID0gYVN0ci5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSAwO1xuICB2YXIgc2hpZnQgPSAwO1xuICB2YXIgY29udGludWF0aW9uLCBkaWdpdDtcblxuICBkbyB7XG4gICAgaWYgKGFJbmRleCA+PSBzdHJMZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG1vcmUgZGlnaXRzIGluIGJhc2UgNjQgVkxRIHZhbHVlLlwiKTtcbiAgICB9XG5cbiAgICBkaWdpdCA9IGJhc2U2NC5kZWNvZGUoYVN0ci5jaGFyQ29kZUF0KGFJbmRleCsrKSk7XG4gICAgaWYgKGRpZ2l0ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBiYXNlNjQgZGlnaXQ6IFwiICsgYVN0ci5jaGFyQXQoYUluZGV4IC0gMSkpO1xuICAgIH1cblxuICAgIGNvbnRpbnVhdGlvbiA9ICEhKGRpZ2l0ICYgVkxRX0NPTlRJTlVBVElPTl9CSVQpO1xuICAgIGRpZ2l0ICY9IFZMUV9CQVNFX01BU0s7XG4gICAgcmVzdWx0ID0gcmVzdWx0ICsgKGRpZ2l0IDw8IHNoaWZ0KTtcbiAgICBzaGlmdCArPSBWTFFfQkFTRV9TSElGVDtcbiAgfSB3aGlsZSAoY29udGludWF0aW9uKTtcblxuICBhT3V0UGFyYW0udmFsdWUgPSBmcm9tVkxRU2lnbmVkKHJlc3VsdCk7XG4gIGFPdXRQYXJhbS5yZXN0ID0gYUluZGV4O1xufTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIGludFRvQ2hhck1hcCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJy5zcGxpdCgnJyk7XG5cbi8qKlxuICogRW5jb2RlIGFuIGludGVnZXIgaW4gdGhlIHJhbmdlIG9mIDAgdG8gNjMgdG8gYSBzaW5nbGUgYmFzZSA2NCBkaWdpdC5cbiAqL1xuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gIGlmICgwIDw9IG51bWJlciAmJiBudW1iZXIgPCBpbnRUb0NoYXJNYXAubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGludFRvQ2hhck1hcFtudW1iZXJdO1xuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJNdXN0IGJlIGJldHdlZW4gMCBhbmQgNjM6IFwiICsgbnVtYmVyKTtcbn07XG5cbi8qKlxuICogRGVjb2RlIGEgc2luZ2xlIGJhc2UgNjQgY2hhcmFjdGVyIGNvZGUgZGlnaXQgdG8gYW4gaW50ZWdlci4gUmV0dXJucyAtMSBvblxuICogZmFpbHVyZS5cbiAqL1xuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiAoY2hhckNvZGUpIHtcbiAgdmFyIGJpZ0EgPSA2NTsgICAgIC8vICdBJ1xuICB2YXIgYmlnWiA9IDkwOyAgICAgLy8gJ1onXG5cbiAgdmFyIGxpdHRsZUEgPSA5NzsgIC8vICdhJ1xuICB2YXIgbGl0dGxlWiA9IDEyMjsgLy8gJ3onXG5cbiAgdmFyIHplcm8gPSA0ODsgICAgIC8vICcwJ1xuICB2YXIgbmluZSA9IDU3OyAgICAgLy8gJzknXG5cbiAgdmFyIHBsdXMgPSA0MzsgICAgIC8vICcrJ1xuICB2YXIgc2xhc2ggPSA0NzsgICAgLy8gJy8nXG5cbiAgdmFyIGxpdHRsZU9mZnNldCA9IDI2O1xuICB2YXIgbnVtYmVyT2Zmc2V0ID0gNTI7XG5cbiAgLy8gMCAtIDI1OiBBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlxuICBpZiAoYmlnQSA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBiaWdaKSB7XG4gICAgcmV0dXJuIChjaGFyQ29kZSAtIGJpZ0EpO1xuICB9XG5cbiAgLy8gMjYgLSA1MTogYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcbiAgaWYgKGxpdHRsZUEgPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gbGl0dGxlWikge1xuICAgIHJldHVybiAoY2hhckNvZGUgLSBsaXR0bGVBICsgbGl0dGxlT2Zmc2V0KTtcbiAgfVxuXG4gIC8vIDUyIC0gNjE6IDAxMjM0NTY3ODlcbiAgaWYgKHplcm8gPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gbmluZSkge1xuICAgIHJldHVybiAoY2hhckNvZGUgLSB6ZXJvICsgbnVtYmVyT2Zmc2V0KTtcbiAgfVxuXG4gIC8vIDYyOiArXG4gIGlmIChjaGFyQ29kZSA9PSBwbHVzKSB7XG4gICAgcmV0dXJuIDYyO1xuICB9XG5cbiAgLy8gNjM6IC9cbiAgaWYgKGNoYXJDb2RlID09IHNsYXNoKSB7XG4gICAgcmV0dXJuIDYzO1xuICB9XG5cbiAgLy8gSW52YWxpZCBiYXNlNjQgZGlnaXQuXG4gIHJldHVybiAtMTtcbn07XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbmV4cG9ydHMuR1JFQVRFU1RfTE9XRVJfQk9VTkQgPSAxO1xuZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCA9IDI7XG5cbi8qKlxuICogUmVjdXJzaXZlIGltcGxlbWVudGF0aW9uIG9mIGJpbmFyeSBzZWFyY2guXG4gKlxuICogQHBhcmFtIGFMb3cgSW5kaWNlcyBoZXJlIGFuZCBsb3dlciBkbyBub3QgY29udGFpbiB0aGUgbmVlZGxlLlxuICogQHBhcmFtIGFIaWdoIEluZGljZXMgaGVyZSBhbmQgaGlnaGVyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuXG4gKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCBiZWluZyBzZWFyY2hlZCBmb3IuXG4gKiBAcGFyYW0gYUhheXN0YWNrIFRoZSBub24tZW1wdHkgYXJyYXkgYmVpbmcgc2VhcmNoZWQuXG4gKiBAcGFyYW0gYUNvbXBhcmUgRnVuY3Rpb24gd2hpY2ggdGFrZXMgdHdvIGVsZW1lbnRzIGFuZCByZXR1cm5zIC0xLCAwLCBvciAxLlxuICogQHBhcmFtIGFCaWFzIEVpdGhlciAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICovXG5mdW5jdGlvbiByZWN1cnNpdmVTZWFyY2goYUxvdywgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gdGVybWluYXRlcyB3aGVuIG9uZSBvZiB0aGUgZm9sbG93aW5nIGlzIHRydWU6XG4gIC8vXG4gIC8vICAgMS4gV2UgZmluZCB0aGUgZXhhY3QgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gIC8vXG4gIC8vICAgMi4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBidXQgd2UgY2FuIHJldHVybiB0aGUgaW5kZXggb2ZcbiAgLy8gICAgICB0aGUgbmV4dC1jbG9zZXN0IGVsZW1lbnQuXG4gIC8vXG4gIC8vICAgMy4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBhbmQgdGhlcmUgaXMgbm8gbmV4dC1jbG9zZXN0XG4gIC8vICAgICAgZWxlbWVudCB0aGFuIHRoZSBvbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IsIHNvIHdlIHJldHVybiAtMS5cbiAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGFIaWdoIC0gYUxvdykgLyAyKSArIGFMb3c7XG4gIHZhciBjbXAgPSBhQ29tcGFyZShhTmVlZGxlLCBhSGF5c3RhY2tbbWlkXSwgdHJ1ZSk7XG4gIGlmIChjbXAgPT09IDApIHtcbiAgICAvLyBGb3VuZCB0aGUgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gICAgcmV0dXJuIG1pZDtcbiAgfVxuICBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgLy8gT3VyIG5lZWRsZSBpcyBncmVhdGVyIHRoYW4gYUhheXN0YWNrW21pZF0uXG4gICAgaWYgKGFIaWdoIC0gbWlkID4gMSkge1xuICAgICAgLy8gVGhlIGVsZW1lbnQgaXMgaW4gdGhlIHVwcGVyIGhhbGYuXG4gICAgICByZXR1cm4gcmVjdXJzaXZlU2VhcmNoKG1pZCwgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgZXhhY3QgbmVlZGxlIGVsZW1lbnQgd2FzIG5vdCBmb3VuZCBpbiB0aGlzIGhheXN0YWNrLiBEZXRlcm1pbmUgaWZcbiAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMykgb3IgKDIpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuICAgIGlmIChhQmlhcyA9PSBleHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EKSB7XG4gICAgICByZXR1cm4gYUhpZ2ggPCBhSGF5c3RhY2subGVuZ3RoID8gYUhpZ2ggOiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gT3VyIG5lZWRsZSBpcyBsZXNzIHRoYW4gYUhheXN0YWNrW21pZF0uXG4gICAgaWYgKG1pZCAtIGFMb3cgPiAxKSB7XG4gICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgbG93ZXIgaGFsZi5cbiAgICAgIHJldHVybiByZWN1cnNpdmVTZWFyY2goYUxvdywgbWlkLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcyk7XG4gICAgfVxuXG4gICAgLy8gd2UgYXJlIGluIHRlcm1pbmF0aW9uIGNhc2UgKDMpIG9yICgyKSBhbmQgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSB0aGluZy5cbiAgICBpZiAoYUJpYXMgPT0gZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCkge1xuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFMb3cgPCAwID8gLTEgOiBhTG93O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaCB3aGljaCB3aWxsIGFsd2F5cyB0cnkgYW5kIHJldHVyblxuICogdGhlIGluZGV4IG9mIHRoZSBjbG9zZXN0IGVsZW1lbnQgaWYgdGhlcmUgaXMgbm8gZXhhY3QgaGl0LiBUaGlzIGlzIGJlY2F1c2VcbiAqIG1hcHBpbmdzIGJldHdlZW4gb3JpZ2luYWwgYW5kIGdlbmVyYXRlZCBsaW5lL2NvbCBwYWlycyBhcmUgc2luZ2xlIHBvaW50cyxcbiAqIGFuZCB0aGVyZSBpcyBhbiBpbXBsaWNpdCByZWdpb24gYmV0d2VlbiBlYWNoIG9mIHRoZW0sIHNvIGEgbWlzcyBqdXN0IG1lYW5zXG4gKiB0aGF0IHlvdSBhcmVuJ3Qgb24gdGhlIHZlcnkgc3RhcnQgb2YgYSByZWdpb24uXG4gKlxuICogQHBhcmFtIGFOZWVkbGUgVGhlIGVsZW1lbnQgeW91IGFyZSBsb29raW5nIGZvci5cbiAqIEBwYXJhbSBhSGF5c3RhY2sgVGhlIGFycmF5IHRoYXQgaXMgYmVpbmcgc2VhcmNoZWQuXG4gKiBAcGFyYW0gYUNvbXBhcmUgQSBmdW5jdGlvbiB3aGljaCB0YWtlcyB0aGUgbmVlZGxlIGFuZCBhbiBlbGVtZW50IGluIHRoZVxuICogICAgIGFycmF5IGFuZCByZXR1cm5zIC0xLCAwLCBvciAxIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBuZWVkbGUgaXMgbGVzc1xuICogICAgIHRoYW4sIGVxdWFsIHRvLCBvciBncmVhdGVyIHRoYW4gdGhlIGVsZW1lbnQsIHJlc3BlY3RpdmVseS5cbiAqIEBwYXJhbSBhQmlhcyBFaXRoZXIgJ2JpbmFyeVNlYXJjaC5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqICAgICBEZWZhdWx0cyB0byAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAqL1xuZXhwb3J0cy5zZWFyY2ggPSBmdW5jdGlvbiBzZWFyY2goYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpIHtcbiAgaWYgKGFIYXlzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICB2YXIgaW5kZXggPSByZWN1cnNpdmVTZWFyY2goLTEsIGFIYXlzdGFjay5sZW5ndGgsIGFOZWVkbGUsIGFIYXlzdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFDb21wYXJlLCBhQmlhcyB8fCBleHBvcnRzLkdSRUFURVNUX0xPV0VSX0JPVU5EKTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8vIFdlIGhhdmUgZm91bmQgZWl0aGVyIHRoZSBleGFjdCBlbGVtZW50LCBvciB0aGUgbmV4dC1jbG9zZXN0IGVsZW1lbnQgdGhhblxuICAvLyB0aGUgb25lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLiBIb3dldmVyLCB0aGVyZSBtYXkgYmUgbW9yZSB0aGFuIG9uZSBzdWNoXG4gIC8vIGVsZW1lbnQuIE1ha2Ugc3VyZSB3ZSBhbHdheXMgcmV0dXJuIHRoZSBzbWFsbGVzdCBvZiB0aGVzZS5cbiAgd2hpbGUgKGluZGV4IC0gMSA+PSAwKSB7XG4gICAgaWYgKGFDb21wYXJlKGFIYXlzdGFja1tpbmRleF0sIGFIYXlzdGFja1tpbmRleCAtIDFdLCB0cnVlKSAhPT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC0taW5kZXg7XG4gIH1cblxuICByZXR1cm4gaW5kZXg7XG59O1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDE0IE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIG1hcHBpbmdCIGlzIGFmdGVyIG1hcHBpbmdBIHdpdGggcmVzcGVjdCB0byBnZW5lcmF0ZWRcbiAqIHBvc2l0aW9uLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZWRQb3NpdGlvbkFmdGVyKG1hcHBpbmdBLCBtYXBwaW5nQikge1xuICAvLyBPcHRpbWl6ZWQgZm9yIG1vc3QgY29tbW9uIGNhc2VcbiAgdmFyIGxpbmVBID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZTtcbiAgdmFyIGxpbmVCID0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgdmFyIGNvbHVtbkEgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW47XG4gIHZhciBjb2x1bW5CID0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICByZXR1cm4gbGluZUIgPiBsaW5lQSB8fCBsaW5lQiA9PSBsaW5lQSAmJiBjb2x1bW5CID49IGNvbHVtbkEgfHxcbiAgICAgICAgIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZ0EsIG1hcHBpbmdCKSA8PSAwO1xufVxuXG4vKipcbiAqIEEgZGF0YSBzdHJ1Y3R1cmUgdG8gcHJvdmlkZSBhIHNvcnRlZCB2aWV3IG9mIGFjY3VtdWxhdGVkIG1hcHBpbmdzIGluIGFcbiAqIHBlcmZvcm1hbmNlIGNvbnNjaW91cyBtYW5uZXIuIEl0IHRyYWRlcyBhIG5lZ2xpYmFibGUgb3ZlcmhlYWQgaW4gZ2VuZXJhbFxuICogY2FzZSBmb3IgYSBsYXJnZSBzcGVlZHVwIGluIGNhc2Ugb2YgbWFwcGluZ3MgYmVpbmcgYWRkZWQgaW4gb3JkZXIuXG4gKi9cbmZ1bmN0aW9uIE1hcHBpbmdMaXN0KCkge1xuICB0aGlzLl9hcnJheSA9IFtdO1xuICB0aGlzLl9zb3J0ZWQgPSB0cnVlO1xuICAvLyBTZXJ2ZXMgYXMgaW5maW11bVxuICB0aGlzLl9sYXN0ID0ge2dlbmVyYXRlZExpbmU6IC0xLCBnZW5lcmF0ZWRDb2x1bW46IDB9O1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgdGhyb3VnaCBpbnRlcm5hbCBpdGVtcy4gVGhpcyBtZXRob2QgdGFrZXMgdGhlIHNhbWUgYXJndW1lbnRzIHRoYXRcbiAqIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgdGFrZXMuXG4gKlxuICogTk9URTogVGhlIG9yZGVyIG9mIHRoZSBtYXBwaW5ncyBpcyBOT1QgZ3VhcmFudGVlZC5cbiAqL1xuTWFwcGluZ0xpc3QucHJvdG90eXBlLnVuc29ydGVkRm9yRWFjaCA9XG4gIGZ1bmN0aW9uIE1hcHBpbmdMaXN0X2ZvckVhY2goYUNhbGxiYWNrLCBhVGhpc0FyZykge1xuICAgIHRoaXMuX2FycmF5LmZvckVhY2goYUNhbGxiYWNrLCBhVGhpc0FyZyk7XG4gIH07XG5cbi8qKlxuICogQWRkIHRoZSBnaXZlbiBzb3VyY2UgbWFwcGluZy5cbiAqXG4gKiBAcGFyYW0gT2JqZWN0IGFNYXBwaW5nXG4gKi9cbk1hcHBpbmdMaXN0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBNYXBwaW5nTGlzdF9hZGQoYU1hcHBpbmcpIHtcbiAgaWYgKGdlbmVyYXRlZFBvc2l0aW9uQWZ0ZXIodGhpcy5fbGFzdCwgYU1hcHBpbmcpKSB7XG4gICAgdGhpcy5fbGFzdCA9IGFNYXBwaW5nO1xuICAgIHRoaXMuX2FycmF5LnB1c2goYU1hcHBpbmcpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX3NvcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2FycmF5LnB1c2goYU1hcHBpbmcpO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZsYXQsIHNvcnRlZCBhcnJheSBvZiBtYXBwaW5ncy4gVGhlIG1hcHBpbmdzIGFyZSBzb3J0ZWQgYnlcbiAqIGdlbmVyYXRlZCBwb3NpdGlvbi5cbiAqXG4gKiBXQVJOSU5HOiBUaGlzIG1ldGhvZCByZXR1cm5zIGludGVybmFsIGRhdGEgd2l0aG91dCBjb3B5aW5nLCBmb3JcbiAqIHBlcmZvcm1hbmNlLiBUaGUgcmV0dXJuIHZhbHVlIG11c3QgTk9UIGJlIG11dGF0ZWQsIGFuZCBzaG91bGQgYmUgdHJlYXRlZCBhc1xuICogYW4gaW1tdXRhYmxlIGJvcnJvdy4gSWYgeW91IHdhbnQgdG8gdGFrZSBvd25lcnNoaXAsIHlvdSBtdXN0IG1ha2UgeW91ciBvd25cbiAqIGNvcHkuXG4gKi9cbk1hcHBpbmdMaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gTWFwcGluZ0xpc3RfdG9BcnJheSgpIHtcbiAgaWYgKCF0aGlzLl9zb3J0ZWQpIHtcbiAgICB0aGlzLl9hcnJheS5zb3J0KHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQpO1xuICAgIHRoaXMuX3NvcnRlZCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2FycmF5O1xufTtcblxuZXhwb3J0cy5NYXBwaW5nTGlzdCA9IE1hcHBpbmdMaXN0O1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG4vLyBJdCB0dXJucyBvdXQgdGhhdCBzb21lIChtb3N0PykgSmF2YVNjcmlwdCBlbmdpbmVzIGRvbid0IHNlbGYtaG9zdFxuLy8gYEFycmF5LnByb3RvdHlwZS5zb3J0YC4gVGhpcyBtYWtlcyBzZW5zZSBiZWNhdXNlIEMrKyB3aWxsIGxpa2VseSByZW1haW5cbi8vIGZhc3RlciB0aGFuIEpTIHdoZW4gZG9pbmcgcmF3IENQVS1pbnRlbnNpdmUgc29ydGluZy4gSG93ZXZlciwgd2hlbiB1c2luZyBhXG4vLyBjdXN0b20gY29tcGFyYXRvciBmdW5jdGlvbiwgY2FsbGluZyBiYWNrIGFuZCBmb3J0aCBiZXR3ZWVuIHRoZSBWTSdzIEMrKyBhbmRcbi8vIEpJVCdkIEpTIGlzIHJhdGhlciBzbG93ICphbmQqIGxvc2VzIEpJVCB0eXBlIGluZm9ybWF0aW9uLCByZXN1bHRpbmcgaW5cbi8vIHdvcnNlIGdlbmVyYXRlZCBjb2RlIGZvciB0aGUgY29tcGFyYXRvciBmdW5jdGlvbiB0aGFuIHdvdWxkIGJlIG9wdGltYWwuIEluXG4vLyBmYWN0LCB3aGVuIHNvcnRpbmcgd2l0aCBhIGNvbXBhcmF0b3IsIHRoZXNlIGNvc3RzIG91dHdlaWdoIHRoZSBiZW5lZml0cyBvZlxuLy8gc29ydGluZyBpbiBDKysuIEJ5IHVzaW5nIG91ciBvd24gSlMtaW1wbGVtZW50ZWQgUXVpY2sgU29ydCAoYmVsb3cpLCB3ZSBnZXRcbi8vIGEgfjM1MDBtcyBtZWFuIHNwZWVkLXVwIGluIGBiZW5jaC9iZW5jaC5odG1sYC5cblxuLyoqXG4gKiBTd2FwIHRoZSBlbGVtZW50cyBpbmRleGVkIGJ5IGB4YCBhbmQgYHlgIGluIHRoZSBhcnJheSBgYXJ5YC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAqICAgICAgICBUaGUgYXJyYXkuXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogICAgICAgIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgaXRlbS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiAgICAgICAgVGhlIGluZGV4IG9mIHRoZSBzZWNvbmQgaXRlbS5cbiAqL1xuZnVuY3Rpb24gc3dhcChhcnksIHgsIHkpIHtcbiAgdmFyIHRlbXAgPSBhcnlbeF07XG4gIGFyeVt4XSA9IGFyeVt5XTtcbiAgYXJ5W3ldID0gdGVtcDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmFuZG9tIGludGVnZXIgd2l0aGluIHRoZSByYW5nZSBgbG93IC4uIGhpZ2hgIGluY2x1c2l2ZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbG93XG4gKiAgICAgICAgVGhlIGxvd2VyIGJvdW5kIG9uIHRoZSByYW5nZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBoaWdoXG4gKiAgICAgICAgVGhlIHVwcGVyIGJvdW5kIG9uIHRoZSByYW5nZS5cbiAqL1xuZnVuY3Rpb24gcmFuZG9tSW50SW5SYW5nZShsb3csIGhpZ2gpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQobG93ICsgKE1hdGgucmFuZG9tKCkgKiAoaGlnaCAtIGxvdykpKTtcbn1cblxuLyoqXG4gKiBUaGUgUXVpY2sgU29ydCBhbGdvcml0aG0uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gKiAgICAgICAgQW4gYXJyYXkgdG8gc29ydC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXBhcmF0b3JcbiAqICAgICAgICBGdW5jdGlvbiB0byB1c2UgdG8gY29tcGFyZSB0d28gaXRlbXMuXG4gKiBAcGFyYW0ge051bWJlcn0gcFxuICogICAgICAgIFN0YXJ0IGluZGV4IG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IHJcbiAqICAgICAgICBFbmQgaW5kZXggb2YgdGhlIGFycmF5XG4gKi9cbmZ1bmN0aW9uIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcCwgcikge1xuICAvLyBJZiBvdXIgbG93ZXIgYm91bmQgaXMgbGVzcyB0aGFuIG91ciB1cHBlciBib3VuZCwgd2UgKDEpIHBhcnRpdGlvbiB0aGVcbiAgLy8gYXJyYXkgaW50byB0d28gcGllY2VzIGFuZCAoMikgcmVjdXJzZSBvbiBlYWNoIGhhbGYuIElmIGl0IGlzIG5vdCwgdGhpcyBpc1xuICAvLyB0aGUgZW1wdHkgYXJyYXkgYW5kIG91ciBiYXNlIGNhc2UuXG5cbiAgaWYgKHAgPCByKSB7XG4gICAgLy8gKDEpIFBhcnRpdGlvbmluZy5cbiAgICAvL1xuICAgIC8vIFRoZSBwYXJ0aXRpb25pbmcgY2hvb3NlcyBhIHBpdm90IGJldHdlZW4gYHBgIGFuZCBgcmAgYW5kIG1vdmVzIGFsbFxuICAgIC8vIGVsZW1lbnRzIHRoYXQgYXJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcGl2b3QgdG8gdGhlIGJlZm9yZSBpdCwgYW5kXG4gICAgLy8gYWxsIHRoZSBlbGVtZW50cyB0aGF0IGFyZSBncmVhdGVyIHRoYW4gaXQgYWZ0ZXIgaXQuIFRoZSBlZmZlY3QgaXMgdGhhdFxuICAgIC8vIG9uY2UgcGFydGl0aW9uIGlzIGRvbmUsIHRoZSBwaXZvdCBpcyBpbiB0aGUgZXhhY3QgcGxhY2UgaXQgd2lsbCBiZSB3aGVuXG4gICAgLy8gdGhlIGFycmF5IGlzIHB1dCBpbiBzb3J0ZWQgb3JkZXIsIGFuZCBpdCB3aWxsIG5vdCBuZWVkIHRvIGJlIG1vdmVkXG4gICAgLy8gYWdhaW4uIFRoaXMgcnVucyBpbiBPKG4pIHRpbWUuXG5cbiAgICAvLyBBbHdheXMgY2hvb3NlIGEgcmFuZG9tIHBpdm90IHNvIHRoYXQgYW4gaW5wdXQgYXJyYXkgd2hpY2ggaXMgcmV2ZXJzZVxuICAgIC8vIHNvcnRlZCBkb2VzIG5vdCBjYXVzZSBPKG5eMikgcnVubmluZyB0aW1lLlxuICAgIHZhciBwaXZvdEluZGV4ID0gcmFuZG9tSW50SW5SYW5nZShwLCByKTtcbiAgICB2YXIgaSA9IHAgLSAxO1xuXG4gICAgc3dhcChhcnksIHBpdm90SW5kZXgsIHIpO1xuICAgIHZhciBwaXZvdCA9IGFyeVtyXTtcblxuICAgIC8vIEltbWVkaWF0ZWx5IGFmdGVyIGBqYCBpcyBpbmNyZW1lbnRlZCBpbiB0aGlzIGxvb3AsIHRoZSBmb2xsb3dpbmcgaG9sZFxuICAgIC8vIHRydWU6XG4gICAgLy9cbiAgICAvLyAgICogRXZlcnkgZWxlbWVudCBpbiBgYXJ5W3AgLi4gaV1gIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcGl2b3QuXG4gICAgLy9cbiAgICAvLyAgICogRXZlcnkgZWxlbWVudCBpbiBgYXJ5W2krMSAuLiBqLTFdYCBpcyBncmVhdGVyIHRoYW4gdGhlIHBpdm90LlxuICAgIGZvciAodmFyIGogPSBwOyBqIDwgcjsgaisrKSB7XG4gICAgICBpZiAoY29tcGFyYXRvcihhcnlbal0sIHBpdm90KSA8PSAwKSB7XG4gICAgICAgIGkgKz0gMTtcbiAgICAgICAgc3dhcChhcnksIGksIGopO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3YXAoYXJ5LCBpICsgMSwgaik7XG4gICAgdmFyIHEgPSBpICsgMTtcblxuICAgIC8vICgyKSBSZWN1cnNlIG9uIGVhY2ggaGFsZi5cblxuICAgIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcCwgcSAtIDEpO1xuICAgIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcSArIDEsIHIpO1xuICB9XG59XG5cbi8qKlxuICogU29ydCB0aGUgZ2l2ZW4gYXJyYXkgaW4tcGxhY2Ugd2l0aCB0aGUgZ2l2ZW4gY29tcGFyYXRvciBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAqICAgICAgICBBbiBhcnJheSB0byBzb3J0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyYXRvclxuICogICAgICAgIEZ1bmN0aW9uIHRvIHVzZSB0byBjb21wYXJlIHR3byBpdGVtcy5cbiAqL1xuZXhwb3J0cy5xdWlja1NvcnQgPSBmdW5jdGlvbiAoYXJ5LCBjb21wYXJhdG9yKSB7XG4gIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgMCwgYXJ5Lmxlbmd0aCAtIDEpO1xufTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBiaW5hcnlTZWFyY2ggPSByZXF1aXJlKCcuL2JpbmFyeS1zZWFyY2gnKTtcbnZhciBBcnJheVNldCA9IHJlcXVpcmUoJy4vYXJyYXktc2V0JykuQXJyYXlTZXQ7XG52YXIgYmFzZTY0VkxRID0gcmVxdWlyZSgnLi9iYXNlNjQtdmxxJyk7XG52YXIgcXVpY2tTb3J0ID0gcmVxdWlyZSgnLi9xdWljay1zb3J0JykucXVpY2tTb3J0O1xuXG5mdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwKSB7XG4gIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgc291cmNlTWFwID0gSlNPTi5wYXJzZShhU291cmNlTWFwLnJlcGxhY2UoL15cXClcXF1cXH0nLywgJycpKTtcbiAgfVxuXG4gIHJldHVybiBzb3VyY2VNYXAuc2VjdGlvbnMgIT0gbnVsbFxuICAgID8gbmV3IEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXApXG4gICAgOiBuZXcgQmFzaWNTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXApO1xufVxuXG5Tb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwID0gZnVuY3Rpb24oYVNvdXJjZU1hcCkge1xuICByZXR1cm4gQmFzaWNTb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwKGFTb3VyY2VNYXApO1xufVxuXG4vKipcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLy8gYF9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZCBgX19vcmlnaW5hbE1hcHBpbmdzYCBhcmUgYXJyYXlzIHRoYXQgaG9sZCB0aGVcbi8vIHBhcnNlZCBtYXBwaW5nIGNvb3JkaW5hdGVzIGZyb20gdGhlIHNvdXJjZSBtYXAncyBcIm1hcHBpbmdzXCIgYXR0cmlidXRlLiBUaGV5XG4vLyBhcmUgbGF6aWx5IGluc3RhbnRpYXRlZCwgYWNjZXNzZWQgdmlhIHRoZSBgX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbi8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgZ2V0dGVycyByZXNwZWN0aXZlbHksIGFuZCB3ZSBvbmx5IHBhcnNlIHRoZSBtYXBwaW5nc1xuLy8gYW5kIGNyZWF0ZSB0aGVzZSBhcnJheXMgb25jZSBxdWVyaWVkIGZvciBhIHNvdXJjZSBsb2NhdGlvbi4gV2UganVtcCB0aHJvdWdoXG4vLyB0aGVzZSBob29wcyBiZWNhdXNlIHRoZXJlIGNhbiBiZSBtYW55IHRob3VzYW5kcyBvZiBtYXBwaW5ncywgYW5kIHBhcnNpbmdcbi8vIHRoZW0gaXMgZXhwZW5zaXZlLCBzbyB3ZSBvbmx5IHdhbnQgdG8gZG8gaXQgaWYgd2UgbXVzdC5cbi8vXG4vLyBFYWNoIG9iamVjdCBpbiB0aGUgYXJyYXlzIGlzIG9mIHRoZSBmb3JtOlxuLy9cbi8vICAgICB7XG4vLyAgICAgICBnZW5lcmF0ZWRMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBzb3VyY2U6IFRoZSBwYXRoIHRvIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSB0aGF0IGdlbmVyYXRlZCB0aGlzXG4vLyAgICAgICAgICAgICAgIGNodW5rIG9mIGNvZGUsXG4vLyAgICAgICBvcmlnaW5hbExpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbi8vICAgICAgICAgICAgICAgICAgICAgY29ycmVzcG9uZHMgdG8gdGhpcyBjaHVuayBvZiBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIG9yaWdpbmFsQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbi8vICAgICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kcyB0byB0aGlzIGNodW5rIG9mIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgbmFtZTogVGhlIG5hbWUgb2YgdGhlIG9yaWdpbmFsIHN5bWJvbCB3aGljaCBnZW5lcmF0ZWQgdGhpcyBjaHVuayBvZlxuLy8gICAgICAgICAgICAgY29kZS5cbi8vICAgICB9XG4vL1xuLy8gQWxsIHByb3BlcnRpZXMgZXhjZXB0IGZvciBgZ2VuZXJhdGVkTGluZWAgYW5kIGBnZW5lcmF0ZWRDb2x1bW5gIGNhbiBiZVxuLy8gYG51bGxgLlxuLy9cbi8vIGBfZ2VuZXJhdGVkTWFwcGluZ3NgIGlzIG9yZGVyZWQgYnkgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMuXG4vL1xuLy8gYF9vcmlnaW5hbE1hcHBpbmdzYCBpcyBvcmRlcmVkIGJ5IHRoZSBvcmlnaW5hbCBwb3NpdGlvbnMuXG5cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX2dlbmVyYXRlZE1hcHBpbmdzID0gbnVsbDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfZ2VuZXJhdGVkTWFwcGluZ3MnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzKSB7XG4gICAgICB0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLCB0aGlzLnNvdXJjZVJvb3QpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gIH1cbn0pO1xuXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX19vcmlnaW5hbE1hcHBpbmdzID0gbnVsbDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfb3JpZ2luYWxNYXBwaW5ncycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncykge1xuICAgICAgdGhpcy5fcGFyc2VNYXBwaW5ncyh0aGlzLl9tYXBwaW5ncywgdGhpcy5zb3VyY2VSb290KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fX29yaWdpbmFsTWFwcGluZ3M7XG4gIH1cbn0pO1xuXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yKGFTdHIsIGluZGV4KSB7XG4gICAgdmFyIGMgPSBhU3RyLmNoYXJBdChpbmRleCk7XG4gICAgcmV0dXJuIGMgPT09IFwiO1wiIHx8IGMgPT09IFwiLFwiO1xuICB9O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyhhU3RyLCBhU291cmNlUm9vdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnQgX3BhcnNlTWFwcGluZ3NcIik7XG4gIH07XG5cblNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUiA9IDE7XG5Tb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUiA9IDI7XG5cblNvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EID0gMTtcblNvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EID0gMjtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgZWFjaCBtYXBwaW5nIGJldHdlZW4gYW4gb3JpZ2luYWwgc291cmNlL2xpbmUvY29sdW1uIGFuZCBhXG4gKiBnZW5lcmF0ZWQgbGluZS9jb2x1bW4gaW4gdGhpcyBzb3VyY2UgbWFwLlxuICpcbiAqIEBwYXJhbSBGdW5jdGlvbiBhQ2FsbGJhY2tcbiAqICAgICAgICBUaGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBlYWNoIG1hcHBpbmcuXG4gKiBAcGFyYW0gT2JqZWN0IGFDb250ZXh0XG4gKiAgICAgICAgT3B0aW9uYWwuIElmIHNwZWNpZmllZCwgdGhpcyBvYmplY3Qgd2lsbCBiZSB0aGUgdmFsdWUgb2YgYHRoaXNgIGV2ZXJ5XG4gKiAgICAgICAgdGltZSB0aGF0IGBhQ2FsbGJhY2tgIGlzIGNhbGxlZC5cbiAqIEBwYXJhbSBhT3JkZXJcbiAqICAgICAgICBFaXRoZXIgYFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUmAgb3JcbiAqICAgICAgICBgU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVJgLiBTcGVjaWZpZXMgd2hldGhlciB5b3Ugd2FudCB0b1xuICogICAgICAgIGl0ZXJhdGUgb3ZlciB0aGUgbWFwcGluZ3Mgc29ydGVkIGJ5IHRoZSBnZW5lcmF0ZWQgZmlsZSdzIGxpbmUvY29sdW1uXG4gKiAgICAgICAgb3JkZXIgb3IgdGhlIG9yaWdpbmFsJ3Mgc291cmNlL2xpbmUvY29sdW1uIG9yZGVyLCByZXNwZWN0aXZlbHkuIERlZmF1bHRzIHRvXG4gKiAgICAgICAgYFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUmAuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5lYWNoTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2VhY2hNYXBwaW5nKGFDYWxsYmFjaywgYUNvbnRleHQsIGFPcmRlcikge1xuICAgIHZhciBjb250ZXh0ID0gYUNvbnRleHQgfHwgbnVsbDtcbiAgICB2YXIgb3JkZXIgPSBhT3JkZXIgfHwgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSO1xuXG4gICAgdmFyIG1hcHBpbmdzO1xuICAgIHN3aXRjaCAob3JkZXIpIHtcbiAgICBjYXNlIFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjpcbiAgICAgIG1hcHBpbmdzID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSOlxuICAgICAgbWFwcGluZ3MgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3JkZXIgb2YgaXRlcmF0aW9uLlwiKTtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlUm9vdCA9IHRoaXMuc291cmNlUm9vdDtcbiAgICBtYXBwaW5ncy5tYXAoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBtYXBwaW5nLnNvdXJjZSA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLl9zb3VyY2VzLmF0KG1hcHBpbmcuc291cmNlKTtcbiAgICAgIGlmIChzb3VyY2UgIT0gbnVsbCAmJiBzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlID0gdXRpbC5qb2luKHNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgZ2VuZXJhdGVkTGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lLFxuICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uLFxuICAgICAgICBvcmlnaW5hbExpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICBvcmlnaW5hbENvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgbmFtZTogbWFwcGluZy5uYW1lID09PSBudWxsID8gbnVsbCA6IHRoaXMuX25hbWVzLmF0KG1hcHBpbmcubmFtZSlcbiAgICAgIH07XG4gICAgfSwgdGhpcykuZm9yRWFjaChhQ2FsbGJhY2ssIGNvbnRleHQpO1xuICB9O1xuXG4vKipcbiAqIFJldHVybnMgYWxsIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gKiBsaW5lLCBhbmQgY29sdW1uIHByb3ZpZGVkLiBJZiBubyBjb2x1bW4gaXMgcHJvdmlkZWQsIHJldHVybnMgYWxsIG1hcHBpbmdzXG4gKiBjb3JyZXNwb25kaW5nIHRvIGEgZWl0aGVyIHRoZSBsaW5lIHdlIGFyZSBzZWFyY2hpbmcgZm9yIG9yIHRoZSBuZXh0XG4gKiBjbG9zZXN0IGxpbmUgdGhhdCBoYXMgYW55IG1hcHBpbmdzLiBPdGhlcndpc2UsIHJldHVybnMgYWxsIG1hcHBpbmdzXG4gKiBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBsaW5lIGFuZCBlaXRoZXIgdGhlIGNvbHVtbiB3ZSBhcmUgc2VhcmNoaW5nIGZvclxuICogb3IgdGhlIG5leHQgY2xvc2VzdCBjb2x1bW4gdGhhdCBoYXMgYW55IG9mZnNldHMuXG4gKlxuICogVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGNvbHVtbjogT3B0aW9uYWwuIHRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKlxuICogYW5kIGFuIGFycmF5IG9mIG9iamVjdHMgaXMgcmV0dXJuZWQsIGVhY2ggd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yKGFBcmdzKSB7XG4gICAgdmFyIGxpbmUgPSB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKTtcblxuICAgIC8vIFdoZW4gdGhlcmUgaXMgbm8gZXhhY3QgbWF0Y2gsIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kTWFwcGluZ1xuICAgIC8vIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBjbG9zZXN0IG1hcHBpbmcgbGVzcyB0aGFuIHRoZSBuZWVkbGUuIEJ5XG4gICAgLy8gc2V0dGluZyBuZWVkbGUub3JpZ2luYWxDb2x1bW4gdG8gMCwgd2UgdGh1cyBmaW5kIHRoZSBsYXN0IG1hcHBpbmcgZm9yXG4gICAgLy8gdGhlIGdpdmVuIGxpbmUsIHByb3ZpZGVkIHN1Y2ggYSBtYXBwaW5nIGV4aXN0cy5cbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgc291cmNlOiB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpLFxuICAgICAgb3JpZ2luYWxMaW5lOiBsaW5lLFxuICAgICAgb3JpZ2luYWxDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJywgMClcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBuZWVkbGUuc291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIG5lZWRsZS5zb3VyY2UpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3NvdXJjZXMuaGFzKG5lZWRsZS5zb3VyY2UpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIG5lZWRsZS5zb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmluZGV4T2YobmVlZGxlLnNvdXJjZSk7XG5cbiAgICB2YXIgbWFwcGluZ3MgPSBbXTtcblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKG5lZWRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3JpZ2luYWxMaW5lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbENvbHVtblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgaWYgKGFBcmdzLmNvbHVtbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZTtcblxuICAgICAgICAvLyBJdGVyYXRlIHVudGlsIGVpdGhlciB3ZSBydW4gb3V0IG9mIG1hcHBpbmdzLCBvciB3ZSBydW4gaW50b1xuICAgICAgICAvLyBhIG1hcHBpbmcgZm9yIGEgZGlmZmVyZW50IGxpbmUgdGhhbiB0aGUgb25lIHdlIGZvdW5kLiBTaW5jZVxuICAgICAgICAvLyBtYXBwaW5ncyBhcmUgc29ydGVkLCB0aGlzIGlzIGd1YXJhbnRlZWQgdG8gZmluZCBhbGwgbWFwcGluZ3MgZm9yXG4gICAgICAgIC8vIHRoZSBsaW5lIHdlIGZvdW5kLlxuICAgICAgICB3aGlsZSAobWFwcGluZyAmJiBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gb3JpZ2luYWxMaW5lKSB7XG4gICAgICAgICAgbWFwcGluZ3MucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkTGluZScsIG51bGwpLFxuICAgICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1srK2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICAvLyBJdGVyYXRlIHVudGlsIGVpdGhlciB3ZSBydW4gb3V0IG9mIG1hcHBpbmdzLCBvciB3ZSBydW4gaW50b1xuICAgICAgICAvLyBhIG1hcHBpbmcgZm9yIGEgZGlmZmVyZW50IGxpbmUgdGhhbiB0aGUgb25lIHdlIHdlcmUgc2VhcmNoaW5nIGZvci5cbiAgICAgICAgLy8gU2luY2UgbWFwcGluZ3MgYXJlIHNvcnRlZCwgdGhpcyBpcyBndWFyYW50ZWVkIHRvIGZpbmQgYWxsIG1hcHBpbmdzIGZvclxuICAgICAgICAvLyB0aGUgbGluZSB3ZSBhcmUgc2VhcmNoaW5nIGZvci5cbiAgICAgICAgd2hpbGUgKG1hcHBpbmcgJiZcbiAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSBsaW5lICYmXG4gICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID09IG9yaWdpbmFsQ29sdW1uKSB7XG4gICAgICAgICAgbWFwcGluZ3MucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkTGluZScsIG51bGwpLFxuICAgICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1srK2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXBwaW5ncztcbiAgfTtcblxuZXhwb3J0cy5Tb3VyY2VNYXBDb25zdW1lciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4vKipcbiAqIEEgQmFzaWNTb3VyY2VNYXBDb25zdW1lciBpbnN0YW5jZSByZXByZXNlbnRzIGEgcGFyc2VkIHNvdXJjZSBtYXAgd2hpY2ggd2UgY2FuXG4gKiBxdWVyeSBmb3IgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9yaWdpbmFsIGZpbGUgcG9zaXRpb25zIGJ5IGdpdmluZyBpdCBhIGZpbGVcbiAqIHBvc2l0aW9uIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICpcbiAqIFRoZSBvbmx5IHBhcmFtZXRlciBpcyB0aGUgcmF3IHNvdXJjZSBtYXAgKGVpdGhlciBhcyBhIEpTT04gc3RyaW5nLCBvclxuICogYWxyZWFkeSBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjLCBzb3VyY2UgbWFwcyBoYXZlIHRoZVxuICogZm9sbG93aW5nIGF0dHJpYnV0ZXM6XG4gKlxuICogICAtIHZlcnNpb246IFdoaWNoIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXAgc3BlYyB0aGlzIG1hcCBpcyBmb2xsb3dpbmcuXG4gKiAgIC0gc291cmNlczogQW4gYXJyYXkgb2YgVVJMcyB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGVzLlxuICogICAtIG5hbWVzOiBBbiBhcnJheSBvZiBpZGVudGlmaWVycyB3aGljaCBjYW4gYmUgcmVmZXJyZW5jZWQgYnkgaW5kaXZpZHVhbCBtYXBwaW5ncy5cbiAqICAgLSBzb3VyY2VSb290OiBPcHRpb25hbC4gVGhlIFVSTCByb290IGZyb20gd2hpY2ggYWxsIHNvdXJjZXMgYXJlIHJlbGF0aXZlLlxuICogICAtIHNvdXJjZXNDb250ZW50OiBPcHRpb25hbC4gQW4gYXJyYXkgb2YgY29udGVudHMgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcy5cbiAqICAgLSBtYXBwaW5nczogQSBzdHJpbmcgb2YgYmFzZTY0IFZMUXMgd2hpY2ggY29udGFpbiB0aGUgYWN0dWFsIG1hcHBpbmdzLlxuICogICAtIGZpbGU6IE9wdGlvbmFsLiBUaGUgZ2VuZXJhdGVkIGZpbGUgdGhpcyBzb3VyY2UgbWFwIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAqXG4gKiBIZXJlIGlzIGFuIGV4YW1wbGUgc291cmNlIG1hcCwgdGFrZW4gZnJvbSB0aGUgc291cmNlIG1hcCBzcGVjWzBdOlxuICpcbiAqICAgICB7XG4gKiAgICAgICB2ZXJzaW9uIDogMyxcbiAqICAgICAgIGZpbGU6IFwib3V0LmpzXCIsXG4gKiAgICAgICBzb3VyY2VSb290IDogXCJcIixcbiAqICAgICAgIHNvdXJjZXM6IFtcImZvby5qc1wiLCBcImJhci5qc1wiXSxcbiAqICAgICAgIG5hbWVzOiBbXCJzcmNcIiwgXCJtYXBzXCIsIFwiYXJlXCIsIFwiZnVuXCJdLFxuICogICAgICAgbWFwcGluZ3M6IFwiQUEsQUI7O0FCQ0RFO1wiXG4gKiAgICAgfVxuICpcbiAqIFswXTogaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xVTFSR0FlaFF3UnlwVVRvdkYxS1JscGlPRnplMGItXzJnYzZmQUgwS1kway9lZGl0P3BsaT0xI1xuICovXG5mdW5jdGlvbiBCYXNpY1NvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXApIHtcbiAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICBzb3VyY2VNYXAgPSBKU09OLnBhcnNlKGFTb3VyY2VNYXAucmVwbGFjZSgvXlxcKVxcXVxcfScvLCAnJykpO1xuICB9XG5cbiAgdmFyIHZlcnNpb24gPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICd2ZXJzaW9uJyk7XG4gIHZhciBzb3VyY2VzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlcycpO1xuICAvLyBTYXNzIDMuMyBsZWF2ZXMgb3V0IHRoZSAnbmFtZXMnIGFycmF5LCBzbyB3ZSBkZXZpYXRlIGZyb20gdGhlIHNwZWMgKHdoaWNoXG4gIC8vIHJlcXVpcmVzIHRoZSBhcnJheSkgdG8gcGxheSBuaWNlIGhlcmUuXG4gIHZhciBuYW1lcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ25hbWVzJywgW10pO1xuICB2YXIgc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZVJvb3QnLCBudWxsKTtcbiAgdmFyIHNvdXJjZXNDb250ZW50ID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlc0NvbnRlbnQnLCBudWxsKTtcbiAgdmFyIG1hcHBpbmdzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnbWFwcGluZ3MnKTtcbiAgdmFyIGZpbGUgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdmaWxlJywgbnVsbCk7XG5cbiAgLy8gT25jZSBhZ2FpbiwgU2FzcyBkZXZpYXRlcyBmcm9tIHRoZSBzcGVjIGFuZCBzdXBwbGllcyB0aGUgdmVyc2lvbiBhcyBhXG4gIC8vIHN0cmluZyByYXRoZXIgdGhhbiBhIG51bWJlciwgc28gd2UgdXNlIGxvb3NlIGVxdWFsaXR5IGNoZWNraW5nIGhlcmUuXG4gIGlmICh2ZXJzaW9uICE9IHRoaXMuX3ZlcnNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgfVxuXG4gIHNvdXJjZXMgPSBzb3VyY2VzXG4gICAgLm1hcChTdHJpbmcpXG4gICAgLy8gU29tZSBzb3VyY2UgbWFwcyBwcm9kdWNlIHJlbGF0aXZlIHNvdXJjZSBwYXRocyBsaWtlIFwiLi9mb28uanNcIiBpbnN0ZWFkIG9mXG4gICAgLy8gXCJmb28uanNcIi4gIE5vcm1hbGl6ZSB0aGVzZSBmaXJzdCBzbyB0aGF0IGZ1dHVyZSBjb21wYXJpc29ucyB3aWxsIHN1Y2NlZWQuXG4gICAgLy8gU2VlIGJ1Z3ppbC5sYS8xMDkwNzY4LlxuICAgIC5tYXAodXRpbC5ub3JtYWxpemUpXG4gICAgLy8gQWx3YXlzIGVuc3VyZSB0aGF0IGFic29sdXRlIHNvdXJjZXMgYXJlIGludGVybmFsbHkgc3RvcmVkIHJlbGF0aXZlIHRvXG4gICAgLy8gdGhlIHNvdXJjZSByb290LCBpZiB0aGUgc291cmNlIHJvb3QgaXMgYWJzb2x1dGUuIE5vdCBkb2luZyB0aGlzIHdvdWxkXG4gICAgLy8gYmUgcGFydGljdWxhcmx5IHByb2JsZW1hdGljIHdoZW4gdGhlIHNvdXJjZSByb290IGlzIGEgcHJlZml4IG9mIHRoZVxuICAgIC8vIHNvdXJjZSAodmFsaWQsIGJ1dCB3aHk/PykuIFNlZSBnaXRodWIgaXNzdWUgIzE5OSBhbmQgYnVnemlsLmxhLzExODg5ODIuXG4gICAgLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gc291cmNlUm9vdCAmJiB1dGlsLmlzQWJzb2x1dGUoc291cmNlUm9vdCkgJiYgdXRpbC5pc0Fic29sdXRlKHNvdXJjZSlcbiAgICAgICAgPyB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZSlcbiAgICAgICAgOiBzb3VyY2U7XG4gICAgfSk7XG5cbiAgLy8gUGFzcyBgdHJ1ZWAgYmVsb3cgdG8gYWxsb3cgZHVwbGljYXRlIG5hbWVzIGFuZCBzb3VyY2VzLiBXaGlsZSBzb3VyY2UgbWFwc1xuICAvLyBhcmUgaW50ZW5kZWQgdG8gYmUgY29tcHJlc3NlZCBhbmQgZGVkdXBsaWNhdGVkLCB0aGUgVHlwZVNjcmlwdCBjb21waWxlclxuICAvLyBzb21ldGltZXMgZ2VuZXJhdGVzIHNvdXJjZSBtYXBzIHdpdGggZHVwbGljYXRlcyBpbiB0aGVtLiBTZWUgR2l0aHViIGlzc3VlXG4gIC8vICM3MiBhbmQgYnVnemlsLmxhLzg4OTQ5Mi5cbiAgdGhpcy5fbmFtZXMgPSBBcnJheVNldC5mcm9tQXJyYXkobmFtZXMubWFwKFN0cmluZyksIHRydWUpO1xuICB0aGlzLl9zb3VyY2VzID0gQXJyYXlTZXQuZnJvbUFycmF5KHNvdXJjZXMsIHRydWUpO1xuXG4gIHRoaXMuc291cmNlUm9vdCA9IHNvdXJjZVJvb3Q7XG4gIHRoaXMuc291cmNlc0NvbnRlbnQgPSBzb3VyY2VzQ29udGVudDtcbiAgdGhpcy5fbWFwcGluZ3MgPSBtYXBwaW5ncztcbiAgdGhpcy5maWxlID0gZmlsZTtcbn1cblxuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb25zdW1lciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4vKipcbiAqIENyZWF0ZSBhIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgZnJvbSBhIFNvdXJjZU1hcEdlbmVyYXRvci5cbiAqXG4gKiBAcGFyYW0gU291cmNlTWFwR2VuZXJhdG9yIGFTb3VyY2VNYXBcbiAqICAgICAgICBUaGUgc291cmNlIG1hcCB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG4gKiBAcmV0dXJucyBCYXNpY1NvdXJjZU1hcENvbnN1bWVyXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcCkge1xuICAgIHZhciBzbWMgPSBPYmplY3QuY3JlYXRlKEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcblxuICAgIHZhciBuYW1lcyA9IHNtYy5fbmFtZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoYVNvdXJjZU1hcC5fbmFtZXMudG9BcnJheSgpLCB0cnVlKTtcbiAgICB2YXIgc291cmNlcyA9IHNtYy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShhU291cmNlTWFwLl9zb3VyY2VzLnRvQXJyYXkoKSwgdHJ1ZSk7XG4gICAgc21jLnNvdXJjZVJvb3QgPSBhU291cmNlTWFwLl9zb3VyY2VSb290O1xuICAgIHNtYy5zb3VyY2VzQ29udGVudCA9IGFTb3VyY2VNYXAuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoc21jLl9zb3VyY2VzLnRvQXJyYXkoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtYy5zb3VyY2VSb290KTtcbiAgICBzbWMuZmlsZSA9IGFTb3VyY2VNYXAuX2ZpbGU7XG5cbiAgICAvLyBCZWNhdXNlIHdlIGFyZSBtb2RpZnlpbmcgdGhlIGVudHJpZXMgKGJ5IGNvbnZlcnRpbmcgc3RyaW5nIHNvdXJjZXMgYW5kXG4gICAgLy8gbmFtZXMgdG8gaW5kaWNlcyBpbnRvIHRoZSBzb3VyY2VzIGFuZCBuYW1lcyBBcnJheVNldHMpLCB3ZSBoYXZlIHRvIG1ha2VcbiAgICAvLyBhIGNvcHkgb2YgdGhlIGVudHJ5IG9yIGVsc2UgYmFkIHRoaW5ncyBoYXBwZW4uIFNoYXJlZCBtdXRhYmxlIHN0YXRlXG4gICAgLy8gc3RyaWtlcyBhZ2FpbiEgU2VlIGdpdGh1YiBpc3N1ZSAjMTkxLlxuXG4gICAgdmFyIGdlbmVyYXRlZE1hcHBpbmdzID0gYVNvdXJjZU1hcC5fbWFwcGluZ3MudG9BcnJheSgpLnNsaWNlKCk7XG4gICAgdmFyIGRlc3RHZW5lcmF0ZWRNYXBwaW5ncyA9IHNtYy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgdmFyIGRlc3RPcmlnaW5hbE1hcHBpbmdzID0gc21jLl9fb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc3JjTWFwcGluZyA9IGdlbmVyYXRlZE1hcHBpbmdzW2ldO1xuICAgICAgdmFyIGRlc3RNYXBwaW5nID0gbmV3IE1hcHBpbmc7XG4gICAgICBkZXN0TWFwcGluZy5nZW5lcmF0ZWRMaW5lID0gc3JjTWFwcGluZy5nZW5lcmF0ZWRMaW5lO1xuICAgICAgZGVzdE1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uID0gc3JjTWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG5cbiAgICAgIGlmIChzcmNNYXBwaW5nLnNvdXJjZSkge1xuICAgICAgICBkZXN0TWFwcGluZy5zb3VyY2UgPSBzb3VyY2VzLmluZGV4T2Yoc3JjTWFwcGluZy5zb3VyY2UpO1xuICAgICAgICBkZXN0TWFwcGluZy5vcmlnaW5hbExpbmUgPSBzcmNNYXBwaW5nLm9yaWdpbmFsTGluZTtcbiAgICAgICAgZGVzdE1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBzcmNNYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgIGlmIChzcmNNYXBwaW5nLm5hbWUpIHtcbiAgICAgICAgICBkZXN0TWFwcGluZy5uYW1lID0gbmFtZXMuaW5kZXhPZihzcmNNYXBwaW5nLm5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVzdE9yaWdpbmFsTWFwcGluZ3MucHVzaChkZXN0TWFwcGluZyk7XG4gICAgICB9XG5cbiAgICAgIGRlc3RHZW5lcmF0ZWRNYXBwaW5ncy5wdXNoKGRlc3RNYXBwaW5nKTtcbiAgICB9XG5cbiAgICBxdWlja1NvcnQoc21jLl9fb3JpZ2luYWxNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG5cbiAgICByZXR1cm4gc21jO1xuICB9O1xuXG4vKipcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4vKipcbiAqIFRoZSBsaXN0IG9mIG9yaWdpbmFsIHNvdXJjZXMuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ3NvdXJjZXMnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zb3VyY2VzLnRvQXJyYXkoKS5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCA/IHV0aWwuam9pbih0aGlzLnNvdXJjZVJvb3QsIHMpIDogcztcbiAgICB9LCB0aGlzKTtcbiAgfVxufSk7XG5cbi8qKlxuICogUHJvdmlkZSB0aGUgSklUIHdpdGggYSBuaWNlIHNoYXBlIC8gaGlkZGVuIGNsYXNzLlxuICovXG5mdW5jdGlvbiBNYXBwaW5nKCkge1xuICB0aGlzLmdlbmVyYXRlZExpbmUgPSAwO1xuICB0aGlzLmdlbmVyYXRlZENvbHVtbiA9IDA7XG4gIHRoaXMuc291cmNlID0gbnVsbDtcbiAgdGhpcy5vcmlnaW5hbExpbmUgPSBudWxsO1xuICB0aGlzLm9yaWdpbmFsQ29sdW1uID0gbnVsbDtcbiAgdGhpcy5uYW1lID0gbnVsbDtcbn1cblxuLyoqXG4gKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyhhU3RyLCBhU291cmNlUm9vdCkge1xuICAgIHZhciBnZW5lcmF0ZWRMaW5lID0gMTtcbiAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsTGluZSA9IDA7XG4gICAgdmFyIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSAwO1xuICAgIHZhciBwcmV2aW91c1NvdXJjZSA9IDA7XG4gICAgdmFyIHByZXZpb3VzTmFtZSA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IGFTdHIubGVuZ3RoO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGNhY2hlZFNlZ21lbnRzID0ge307XG4gICAgdmFyIHRlbXAgPSB7fTtcbiAgICB2YXIgb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuICAgIHZhciBnZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgIHZhciBtYXBwaW5nLCBzdHIsIHNlZ21lbnQsIGVuZCwgdmFsdWU7XG5cbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChhU3RyLmNoYXJBdChpbmRleCkgPT09ICc7Jykge1xuICAgICAgICBnZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFTdHIuY2hhckF0KGluZGV4KSA9PT0gJywnKSB7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbWFwcGluZyA9IG5ldyBNYXBwaW5nKCk7XG4gICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9IGdlbmVyYXRlZExpbmU7XG5cbiAgICAgICAgLy8gQmVjYXVzZSBlYWNoIG9mZnNldCBpcyBlbmNvZGVkIHJlbGF0aXZlIHRvIHRoZSBwcmV2aW91cyBvbmUsXG4gICAgICAgIC8vIG1hbnkgc2VnbWVudHMgb2Z0ZW4gaGF2ZSB0aGUgc2FtZSBlbmNvZGluZy4gV2UgY2FuIGV4cGxvaXQgdGhpc1xuICAgICAgICAvLyBmYWN0IGJ5IGNhY2hpbmcgdGhlIHBhcnNlZCB2YXJpYWJsZSBsZW5ndGggZmllbGRzIG9mIGVhY2ggc2VnbWVudCxcbiAgICAgICAgLy8gYWxsb3dpbmcgdXMgdG8gYXZvaWQgYSBzZWNvbmQgcGFyc2UgaWYgd2UgZW5jb3VudGVyIHRoZSBzYW1lXG4gICAgICAgIC8vIHNlZ21lbnQgYWdhaW4uXG4gICAgICAgIGZvciAoZW5kID0gaW5kZXg7IGVuZCA8IGxlbmd0aDsgZW5kKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5fY2hhcklzTWFwcGluZ1NlcGFyYXRvcihhU3RyLCBlbmQpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RyID0gYVN0ci5zbGljZShpbmRleCwgZW5kKTtcblxuICAgICAgICBzZWdtZW50ID0gY2FjaGVkU2VnbWVudHNbc3RyXTtcbiAgICAgICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAgICBpbmRleCArPSBzdHIubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlZ21lbnQgPSBbXTtcbiAgICAgICAgICB3aGlsZSAoaW5kZXggPCBlbmQpIHtcbiAgICAgICAgICAgIGJhc2U2NFZMUS5kZWNvZGUoYVN0ciwgaW5kZXgsIHRlbXApO1xuICAgICAgICAgICAgdmFsdWUgPSB0ZW1wLnZhbHVlO1xuICAgICAgICAgICAgaW5kZXggPSB0ZW1wLnJlc3Q7XG4gICAgICAgICAgICBzZWdtZW50LnB1c2godmFsdWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCBhIHNvdXJjZSwgYnV0IG5vIGxpbmUgYW5kIGNvbHVtbicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCBhIHNvdXJjZSBhbmQgbGluZSwgYnV0IG5vIGNvbHVtbicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhY2hlZFNlZ21lbnRzW3N0cl0gPSBzZWdtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2VuZXJhdGVkIGNvbHVtbi5cbiAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gPSBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiArIHNlZ21lbnRbMF07XG4gICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG5cbiAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID4gMSkge1xuICAgICAgICAgIC8vIE9yaWdpbmFsIHNvdXJjZS5cbiAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHByZXZpb3VzU291cmNlICsgc2VnbWVudFsxXTtcbiAgICAgICAgICBwcmV2aW91c1NvdXJjZSArPSBzZWdtZW50WzFdO1xuXG4gICAgICAgICAgLy8gT3JpZ2luYWwgbGluZS5cbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9IHByZXZpb3VzT3JpZ2luYWxMaW5lICsgc2VnbWVudFsyXTtcbiAgICAgICAgICBwcmV2aW91c09yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lO1xuICAgICAgICAgIC8vIExpbmVzIGFyZSBzdG9yZWQgMC1iYXNlZFxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lICs9IDE7XG5cbiAgICAgICAgICAvLyBPcmlnaW5hbCBjb2x1bW4uXG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gKyBzZWdtZW50WzNdO1xuICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID4gNCkge1xuICAgICAgICAgICAgLy8gT3JpZ2luYWwgbmFtZS5cbiAgICAgICAgICAgIG1hcHBpbmcubmFtZSA9IHByZXZpb3VzTmFtZSArIHNlZ21lbnRbNF07XG4gICAgICAgICAgICBwcmV2aW91c05hbWUgKz0gc2VnbWVudFs0XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBnZW5lcmF0ZWRNYXBwaW5ncy5wdXNoKG1hcHBpbmcpO1xuICAgICAgICBpZiAodHlwZW9mIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIG9yaWdpbmFsTWFwcGluZ3MucHVzaChtYXBwaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHF1aWNrU29ydChnZW5lcmF0ZWRNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCk7XG4gICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gZ2VuZXJhdGVkTWFwcGluZ3M7XG5cbiAgICBxdWlja1NvcnQob3JpZ2luYWxNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG4gICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MgPSBvcmlnaW5hbE1hcHBpbmdzO1xuICB9O1xuXG4vKipcbiAqIEZpbmQgdGhlIG1hcHBpbmcgdGhhdCBiZXN0IG1hdGNoZXMgdGhlIGh5cG90aGV0aWNhbCBcIm5lZWRsZVwiIG1hcHBpbmcgdGhhdFxuICogd2UgYXJlIHNlYXJjaGluZyBmb3IgaW4gdGhlIGdpdmVuIFwiaGF5c3RhY2tcIiBvZiBtYXBwaW5ncy5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2ZpbmRNYXBwaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZmluZE1hcHBpbmcoYU5lZWRsZSwgYU1hcHBpbmdzLCBhTGluZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFDb2x1bW5OYW1lLCBhQ29tcGFyYXRvciwgYUJpYXMpIHtcbiAgICAvLyBUbyByZXR1cm4gdGhlIHBvc2l0aW9uIHdlIGFyZSBzZWFyY2hpbmcgZm9yLCB3ZSBtdXN0IGZpcnN0IGZpbmQgdGhlXG4gICAgLy8gbWFwcGluZyBmb3IgdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCB0aGVuIHJldHVybiB0aGUgb3Bwb3NpdGUgcG9zaXRpb24gaXRcbiAgICAvLyBwb2ludHMgdG8uIEJlY2F1c2UgdGhlIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHdlIGNhbiB1c2UgYmluYXJ5IHNlYXJjaCB0b1xuICAgIC8vIGZpbmQgdGhlIGJlc3QgbWFwcGluZy5cblxuICAgIGlmIChhTmVlZGxlW2FMaW5lTmFtZV0gPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTGluZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxLCBnb3QgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICArIGFOZWVkbGVbYUxpbmVOYW1lXSk7XG4gICAgfVxuICAgIGlmIChhTmVlZGxlW2FDb2x1bW5OYW1lXSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvbHVtbiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwLCBnb3QgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICArIGFOZWVkbGVbYUNvbHVtbk5hbWVdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmluYXJ5U2VhcmNoLnNlYXJjaChhTmVlZGxlLCBhTWFwcGluZ3MsIGFDb21wYXJhdG9yLCBhQmlhcyk7XG4gIH07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgbGFzdCBjb2x1bW4gZm9yIGVhY2ggZ2VuZXJhdGVkIG1hcHBpbmcuIFRoZSBsYXN0IGNvbHVtbiBpc1xuICogaW5jbHVzaXZlLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb21wdXRlQ29sdW1uU3BhbnMgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9jb21wdXRlQ29sdW1uU3BhbnMoKSB7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIC8vIE1hcHBpbmdzIGRvIG5vdCBjb250YWluIGEgZmllbGQgZm9yIHRoZSBsYXN0IGdlbmVyYXRlZCBjb2x1bW50LiBXZVxuICAgICAgLy8gY2FuIGNvbWUgdXAgd2l0aCBhbiBvcHRpbWlzdGljIGVzdGltYXRlLCBob3dldmVyLCBieSBhc3N1bWluZyB0aGF0XG4gICAgICAvLyBtYXBwaW5ncyBhcmUgY29udGlndW91cyAoaS5lLiBnaXZlbiB0d28gY29uc2VjdXRpdmUgbWFwcGluZ3MsIHRoZVxuICAgICAgLy8gZmlyc3QgbWFwcGluZyBlbmRzIHdoZXJlIHRoZSBzZWNvbmQgb25lIHN0YXJ0cykuXG4gICAgICBpZiAoaW5kZXggKyAxIDwgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MubGVuZ3RoKSB7XG4gICAgICAgIHZhciBuZXh0TWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4ICsgMV07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9PT0gbmV4dE1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIG1hcHBpbmcubGFzdEdlbmVyYXRlZENvbHVtbiA9IG5leHRNYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtIDE7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGxhc3QgbWFwcGluZyBmb3IgZWFjaCBsaW5lIHNwYW5zIHRoZSBlbnRpcmUgbGluZS5cbiAgICAgIG1hcHBpbmcubGFzdEdlbmVyYXRlZENvbHVtbiA9IEluZmluaXR5O1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UsIGxpbmUsIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBnZW5lcmF0ZWRcbiAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdFxuICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICogICAtIGJpYXM6IEVpdGhlciAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ1NvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqICAgICBEZWZhdWx0cyB0byAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlLCBvciBudWxsLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgLSBuYW1lOiBUaGUgb3JpZ2luYWwgaWRlbnRpZmllciwgb3IgbnVsbC5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUub3JpZ2luYWxQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX29yaWdpbmFsUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgZ2VuZXJhdGVkTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICBnZW5lcmF0ZWRDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICB9O1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcoXG4gICAgICBuZWVkbGUsXG4gICAgICB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncyxcbiAgICAgIFwiZ2VuZXJhdGVkTGluZVwiLFxuICAgICAgXCJnZW5lcmF0ZWRDb2x1bW5cIixcbiAgICAgIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQsXG4gICAgICB1dGlsLmdldEFyZyhhQXJncywgJ2JpYXMnLCBTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORClcbiAgICApO1xuXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lID09PSBuZWVkbGUuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcobWFwcGluZywgJ3NvdXJjZScsIG51bGwpO1xuICAgICAgICBpZiAoc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgc291cmNlID0gdGhpcy5fc291cmNlcy5hdChzb3VyY2UpO1xuICAgICAgICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgc291cmNlID0gdXRpbC5qb2luKHRoaXMuc291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hbWUgPSB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbmFtZScsIG51bGwpO1xuICAgICAgICBpZiAobmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIG5hbWUgPSB0aGlzLl9uYW1lcy5hdChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdvcmlnaW5hbExpbmUnLCBudWxsKSxcbiAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdvcmlnaW5hbENvbHVtbicsIG51bGwpLFxuICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc291cmNlOiBudWxsLFxuICAgICAgbGluZTogbnVsbCxcbiAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgIG5hbWU6IG51bGxcbiAgICB9O1xuICB9O1xuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHdlIGhhdmUgdGhlIHNvdXJjZSBjb250ZW50IGZvciBldmVyeSBzb3VyY2UgaW4gdGhlIHNvdXJjZVxuICogbWFwLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzID1cbiAgZnVuY3Rpb24gQmFzaWNTb3VyY2VNYXBDb25zdW1lcl9oYXNDb250ZW50c09mQWxsU291cmNlcygpIHtcbiAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnQubGVuZ3RoID49IHRoaXMuX3NvdXJjZXMuc2l6ZSgpICYmXG4gICAgICAhdGhpcy5zb3VyY2VzQ29udGVudC5zb21lKGZ1bmN0aW9uIChzYykgeyByZXR1cm4gc2MgPT0gbnVsbDsgfSk7XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlIGNvbnRlbnQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIHRoZSB1cmwgb2YgdGhlXG4gKiBvcmlnaW5hbCBzb3VyY2UgZmlsZS4gUmV0dXJucyBudWxsIGlmIG5vIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50IGlzXG4gKiBhdmFpbGFibGUuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIG51bGxPbk1pc3NpbmcpIHtcbiAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgYVNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCBhU291cmNlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc291cmNlcy5oYXMoYVNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihhU291cmNlKV07XG4gICAgfVxuXG4gICAgdmFyIHVybDtcbiAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGxcbiAgICAgICAgJiYgKHVybCA9IHV0aWwudXJsUGFyc2UodGhpcy5zb3VyY2VSb290KSkpIHtcbiAgICAgIC8vIFhYWDogZmlsZTovLyBVUklzIGFuZCBhYnNvbHV0ZSBwYXRocyBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3IgZm9yXG4gICAgICAvLyBtYW55IHVzZXJzLiBXZSBjYW4gaGVscCB0aGVtIG91dCB3aGVuIHRoZXkgZXhwZWN0IGZpbGU6Ly8gVVJJcyB0b1xuICAgICAgLy8gYmVoYXZlIGxpa2UgaXQgd291bGQgaWYgdGhleSB3ZXJlIHJ1bm5pbmcgYSBsb2NhbCBIVFRQIHNlcnZlci4gU2VlXG4gICAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD04ODU1OTcuXG4gICAgICB2YXIgZmlsZVVyaUFic1BhdGggPSBhU291cmNlLnJlcGxhY2UoL15maWxlOlxcL1xcLy8sIFwiXCIpO1xuICAgICAgaWYgKHVybC5zY2hlbWUgPT0gXCJmaWxlXCJcbiAgICAgICAgICAmJiB0aGlzLl9zb3VyY2VzLmhhcyhmaWxlVXJpQWJzUGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKGZpbGVVcmlBYnNQYXRoKV1cbiAgICAgIH1cblxuICAgICAgaWYgKCghdXJsLnBhdGggfHwgdXJsLnBhdGggPT0gXCIvXCIpXG4gICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoXCIvXCIgKyBhU291cmNlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoXCIvXCIgKyBhU291cmNlKV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHJlY3Vyc2l2ZWx5IGZyb21cbiAgICAvLyBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IuIEluIHRoYXQgY2FzZSwgd2VcbiAgICAvLyBkb24ndCB3YW50IHRvIHRocm93IGlmIHdlIGNhbid0IGZpbmQgdGhlIHNvdXJjZSAtIHdlIGp1c3Qgd2FudCB0b1xuICAgIC8vIHJldHVybiBudWxsLCBzbyB3ZSBwcm92aWRlIGEgZmxhZyB0byBleGl0IGdyYWNlZnVsbHkuXG4gICAgaWYgKG51bGxPbk1pc3NpbmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYVNvdXJjZSArICdcIiBpcyBub3QgaW4gdGhlIFNvdXJjZU1hcC4nKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAqIGxpbmUsIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aFxuICogdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBiaWFzOiBFaXRoZXIgJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdTb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gKiAgICAgRGVmYXVsdHMgdG8gJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZ2VuZXJhdGVkUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncykge1xuICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpO1xuICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fc291cmNlcy5oYXMoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgICBsYXN0Q29sdW1uOiBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICBzb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmluZGV4T2Yoc291cmNlKTtcblxuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgIG9yaWdpbmFsTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICBvcmlnaW5hbENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgIH07XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhcbiAgICAgIG5lZWRsZSxcbiAgICAgIHRoaXMuX29yaWdpbmFsTWFwcGluZ3MsXG4gICAgICBcIm9yaWdpbmFsTGluZVwiLFxuICAgICAgXCJvcmlnaW5hbENvbHVtblwiLFxuICAgICAgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyxcbiAgICAgIHV0aWwuZ2V0QXJnKGFBcmdzLCAnYmlhcycsIFNvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EKVxuICAgICk7XG5cbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgaWYgKG1hcHBpbmcuc291cmNlID09PSBuZWVkbGUuc291cmNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmU6IG51bGwsXG4gICAgICBjb2x1bW46IG51bGwsXG4gICAgICBsYXN0Q29sdW1uOiBudWxsXG4gICAgfTtcbiAgfTtcblxuZXhwb3J0cy5CYXNpY1NvdXJjZU1hcENvbnN1bWVyID0gQmFzaWNTb3VyY2VNYXBDb25zdW1lcjtcblxuLyoqXG4gKiBBbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIgaW5zdGFuY2UgcmVwcmVzZW50cyBhIHBhcnNlZCBzb3VyY2UgbWFwIHdoaWNoXG4gKiB3ZSBjYW4gcXVlcnkgZm9yIGluZm9ybWF0aW9uLiBJdCBkaWZmZXJzIGZyb20gQmFzaWNTb3VyY2VNYXBDb25zdW1lciBpblxuICogdGhhdCBpdCB0YWtlcyBcImluZGV4ZWRcIiBzb3VyY2UgbWFwcyAoaS5lLiBvbmVzIHdpdGggYSBcInNlY3Rpb25zXCIgZmllbGQpIGFzXG4gKiBpbnB1dC5cbiAqXG4gKiBUaGUgb25seSBwYXJhbWV0ZXIgaXMgYSByYXcgc291cmNlIG1hcCAoZWl0aGVyIGFzIGEgSlNPTiBzdHJpbmcsIG9yIGFscmVhZHlcbiAqIHBhcnNlZCB0byBhbiBvYmplY3QpLiBBY2NvcmRpbmcgdG8gdGhlIHNwZWMgZm9yIGluZGV4ZWQgc291cmNlIG1hcHMsIHRoZXlcbiAqIGhhdmUgdGhlIGZvbGxvd2luZyBhdHRyaWJ1dGVzOlxuICpcbiAqICAgLSB2ZXJzaW9uOiBXaGljaCB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwIHNwZWMgdGhpcyBtYXAgaXMgZm9sbG93aW5nLlxuICogICAtIGZpbGU6IE9wdGlvbmFsLiBUaGUgZ2VuZXJhdGVkIGZpbGUgdGhpcyBzb3VyY2UgbWFwIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAqICAgLSBzZWN0aW9uczogQSBsaXN0IG9mIHNlY3Rpb24gZGVmaW5pdGlvbnMuXG4gKlxuICogRWFjaCB2YWx1ZSB1bmRlciB0aGUgXCJzZWN0aW9uc1wiIGZpZWxkIGhhcyB0d28gZmllbGRzOlxuICogICAtIG9mZnNldDogVGhlIG9mZnNldCBpbnRvIHRoZSBvcmlnaW5hbCBzcGVjaWZpZWQgYXQgd2hpY2ggdGhpcyBzZWN0aW9uXG4gKiAgICAgICBiZWdpbnMgdG8gYXBwbHksIGRlZmluZWQgYXMgYW4gb2JqZWN0IHdpdGggYSBcImxpbmVcIiBhbmQgXCJjb2x1bW5cIlxuICogICAgICAgZmllbGQuXG4gKiAgIC0gbWFwOiBBIHNvdXJjZSBtYXAgZGVmaW5pdGlvbi4gVGhpcyBzb3VyY2UgbWFwIGNvdWxkIGFsc28gYmUgaW5kZXhlZCxcbiAqICAgICAgIGJ1dCBkb2Vzbid0IGhhdmUgdG8gYmUuXG4gKlxuICogSW5zdGVhZCBvZiB0aGUgXCJtYXBcIiBmaWVsZCwgaXQncyBhbHNvIHBvc3NpYmxlIHRvIGhhdmUgYSBcInVybFwiIGZpZWxkXG4gKiBzcGVjaWZ5aW5nIGEgVVJMIHRvIHJldHJpZXZlIGEgc291cmNlIG1hcCBmcm9tLCBidXQgdGhhdCdzIGN1cnJlbnRseVxuICogdW5zdXBwb3J0ZWQuXG4gKlxuICogSGVyZSdzIGFuIGV4YW1wbGUgc291cmNlIG1hcCwgdGFrZW4gZnJvbSB0aGUgc291cmNlIG1hcCBzcGVjWzBdLCBidXRcbiAqIG1vZGlmaWVkIHRvIG9taXQgYSBzZWN0aW9uIHdoaWNoIHVzZXMgdGhlIFwidXJsXCIgZmllbGQuXG4gKlxuICogIHtcbiAqICAgIHZlcnNpb24gOiAzLFxuICogICAgZmlsZTogXCJhcHAuanNcIixcbiAqICAgIHNlY3Rpb25zOiBbe1xuICogICAgICBvZmZzZXQ6IHtsaW5lOjEwMCwgY29sdW1uOjEwfSxcbiAqICAgICAgbWFwOiB7XG4gKiAgICAgICAgdmVyc2lvbiA6IDMsXG4gKiAgICAgICAgZmlsZTogXCJzZWN0aW9uLmpzXCIsXG4gKiAgICAgICAgc291cmNlczogW1wiZm9vLmpzXCIsIFwiYmFyLmpzXCJdLFxuICogICAgICAgIG5hbWVzOiBbXCJzcmNcIiwgXCJtYXBzXCIsIFwiYXJlXCIsIFwiZnVuXCJdLFxuICogICAgICAgIG1hcHBpbmdzOiBcIkFBQUEsRTs7QUJDREU7XCJcbiAqICAgICAgfVxuICogICAgfV0sXG4gKiAgfVxuICpcbiAqIFswXTogaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xVTFSR0FlaFF3UnlwVVRvdkYxS1JscGlPRnplMGItXzJnYzZmQUgwS1kway9lZGl0I2hlYWRpbmc9aC41MzVlczN4ZXByZ3RcbiAqL1xuZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXApIHtcbiAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICBzb3VyY2VNYXAgPSBKU09OLnBhcnNlKGFTb3VyY2VNYXAucmVwbGFjZSgvXlxcKVxcXVxcfScvLCAnJykpO1xuICB9XG5cbiAgdmFyIHZlcnNpb24gPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICd2ZXJzaW9uJyk7XG4gIHZhciBzZWN0aW9ucyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NlY3Rpb25zJyk7XG5cbiAgaWYgKHZlcnNpb24gIT0gdGhpcy5fdmVyc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdmVyc2lvbjogJyArIHZlcnNpb24pO1xuICB9XG5cbiAgdGhpcy5fc291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICB0aGlzLl9uYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuXG4gIHZhciBsYXN0T2Zmc2V0ID0ge1xuICAgIGxpbmU6IC0xLFxuICAgIGNvbHVtbjogMFxuICB9O1xuICB0aGlzLl9zZWN0aW9ucyA9IHNlY3Rpb25zLm1hcChmdW5jdGlvbiAocykge1xuICAgIGlmIChzLnVybCkge1xuICAgICAgLy8gVGhlIHVybCBmaWVsZCB3aWxsIHJlcXVpcmUgc3VwcG9ydCBmb3IgYXN5bmNocm9uaWNpdHkuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9pc3N1ZXMvMTZcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3VwcG9ydCBmb3IgdXJsIGZpZWxkIGluIHNlY3Rpb25zIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICB9XG4gICAgdmFyIG9mZnNldCA9IHV0aWwuZ2V0QXJnKHMsICdvZmZzZXQnKTtcbiAgICB2YXIgb2Zmc2V0TGluZSA9IHV0aWwuZ2V0QXJnKG9mZnNldCwgJ2xpbmUnKTtcbiAgICB2YXIgb2Zmc2V0Q29sdW1uID0gdXRpbC5nZXRBcmcob2Zmc2V0LCAnY29sdW1uJyk7XG5cbiAgICBpZiAob2Zmc2V0TGluZSA8IGxhc3RPZmZzZXQubGluZSB8fFxuICAgICAgICAob2Zmc2V0TGluZSA9PT0gbGFzdE9mZnNldC5saW5lICYmIG9mZnNldENvbHVtbiA8IGxhc3RPZmZzZXQuY29sdW1uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZWN0aW9uIG9mZnNldHMgbXVzdCBiZSBvcmRlcmVkIGFuZCBub24tb3ZlcmxhcHBpbmcuJyk7XG4gICAgfVxuICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZ2VuZXJhdGVkT2Zmc2V0OiB7XG4gICAgICAgIC8vIFRoZSBvZmZzZXQgZmllbGRzIGFyZSAwLWJhc2VkLCBidXQgd2UgdXNlIDEtYmFzZWQgaW5kaWNlcyB3aGVuXG4gICAgICAgIC8vIGVuY29kaW5nL2RlY29kaW5nIGZyb20gVkxRLlxuICAgICAgICBnZW5lcmF0ZWRMaW5lOiBvZmZzZXRMaW5lICsgMSxcbiAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBvZmZzZXRDb2x1bW4gKyAxXG4gICAgICB9LFxuICAgICAgY29uc3VtZXI6IG5ldyBTb3VyY2VNYXBDb25zdW1lcih1dGlsLmdldEFyZyhzLCAnbWFwJykpXG4gICAgfVxuICB9KTtcbn1cblxuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4vKipcbiAqIFRoZSBsaXN0IG9mIG9yaWdpbmFsIHNvdXJjZXMuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnc291cmNlcycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNvdXJjZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuX3NlY3Rpb25zW2ldLmNvbnN1bWVyLnNvdXJjZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgc291cmNlcy5wdXNoKHRoaXMuX3NlY3Rpb25zW2ldLmNvbnN1bWVyLnNvdXJjZXNbal0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc291cmNlcztcbiAgfVxufSk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlLCBsaW5lLCBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgZ2VuZXJhdGVkXG4gKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3RcbiAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSwgb3IgbnVsbC5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUub3JpZ2luYWxQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9vcmlnaW5hbFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIGdlbmVyYXRlZExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgZ2VuZXJhdGVkQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgfTtcblxuICAgIC8vIEZpbmQgdGhlIHNlY3Rpb24gY29udGFpbmluZyB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uIHdlJ3JlIHRyeWluZyB0byBtYXBcbiAgICAvLyB0byBhbiBvcmlnaW5hbCBwb3NpdGlvbi5cbiAgICB2YXIgc2VjdGlvbkluZGV4ID0gYmluYXJ5U2VhcmNoLnNlYXJjaChuZWVkbGUsIHRoaXMuX3NlY3Rpb25zLFxuICAgICAgZnVuY3Rpb24obmVlZGxlLCBzZWN0aW9uKSB7XG4gICAgICAgIHZhciBjbXAgPSBuZWVkbGUuZ2VuZXJhdGVkTGluZSAtIHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmU7XG4gICAgICAgIGlmIChjbXApIHtcbiAgICAgICAgICByZXR1cm4gY21wO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChuZWVkbGUuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgfSk7XG4gICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tzZWN0aW9uSW5kZXhdO1xuXG4gICAgaWYgKCFzZWN0aW9uKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgbmFtZTogbnVsbFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VjdGlvbi5jb25zdW1lci5vcmlnaW5hbFBvc2l0aW9uRm9yKHtcbiAgICAgIGxpbmU6IG5lZWRsZS5nZW5lcmF0ZWRMaW5lIC1cbiAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgIGNvbHVtbjogbmVlZGxlLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBuZWVkbGUuZ2VuZXJhdGVkTGluZVxuICAgICAgICAgPyBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4gLSAxXG4gICAgICAgICA6IDApLFxuICAgICAgYmlhczogYUFyZ3MuYmlhc1xuICAgIH0pO1xuICB9O1xuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHdlIGhhdmUgdGhlIHNvdXJjZSBjb250ZW50IGZvciBldmVyeSBzb3VyY2UgaW4gdGhlIHNvdXJjZVxuICogbWFwLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlY3Rpb25zLmV2ZXJ5KGZ1bmN0aW9uIChzKSB7XG4gICAgICByZXR1cm4gcy5jb25zdW1lci5oYXNDb250ZW50c09mQWxsU291cmNlcygpO1xuICAgIH0pO1xuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50LiBUaGUgb25seSBhcmd1bWVudCBpcyB0aGUgdXJsIG9mIHRoZVxuICogb3JpZ2luYWwgc291cmNlIGZpbGUuIFJldHVybnMgbnVsbCBpZiBubyBvcmlnaW5hbCBzb3VyY2UgY29udGVudCBpc1xuICogYXZhaWxhYmxlLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfc291cmNlQ29udGVudEZvcihhU291cmNlLCBudWxsT25NaXNzaW5nKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tpXTtcblxuICAgICAgdmFyIGNvbnRlbnQgPSBzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgdHJ1ZSk7XG4gICAgICBpZiAoY29udGVudCkge1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG51bGxPbk1pc3NpbmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYVNvdXJjZSArICdcIiBpcyBub3QgaW4gdGhlIFNvdXJjZU1hcC4nKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAqIGxpbmUsIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aFxuICogdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5nZW5lcmF0ZWRQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG5cbiAgICAgIC8vIE9ubHkgY29uc2lkZXIgdGhpcyBzZWN0aW9uIGlmIHRoZSByZXF1ZXN0ZWQgc291cmNlIGlzIGluIHRoZSBsaXN0IG9mXG4gICAgICAvLyBzb3VyY2VzIG9mIHRoZSBjb25zdW1lci5cbiAgICAgIGlmIChzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZXMuaW5kZXhPZih1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpKSA9PT0gLTEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgZ2VuZXJhdGVkUG9zaXRpb24gPSBzZWN0aW9uLmNvbnN1bWVyLmdlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKTtcbiAgICAgIGlmIChnZW5lcmF0ZWRQb3NpdGlvbikge1xuICAgICAgICB2YXIgcmV0ID0ge1xuICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZFBvc2l0aW9uLmxpbmUgK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZFBvc2l0aW9uLmNvbHVtbiArXG4gICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gZ2VuZXJhdGVkUG9zaXRpb24ubGluZVxuICAgICAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgICAgIDogMClcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGluZTogbnVsbCxcbiAgICAgIGNvbHVtbjogbnVsbFxuICAgIH07XG4gIH07XG5cbi8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG4gICAgICB2YXIgc2VjdGlvbk1hcHBpbmdzID0gc2VjdGlvbi5jb25zdW1lci5fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlY3Rpb25NYXBwaW5ncy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgbWFwcGluZyA9IHNlY3Rpb25NYXBwaW5nc1tqXTtcblxuICAgICAgICB2YXIgc291cmNlID0gc2VjdGlvbi5jb25zdW1lci5fc291cmNlcy5hdChtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgIGlmIChzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZVJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2UgPSB1dGlsLmpvaW4oc2VjdGlvbi5jb25zdW1lci5zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICAgIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZihzb3VyY2UpO1xuXG4gICAgICAgIHZhciBuYW1lID0gc2VjdGlvbi5jb25zdW1lci5fbmFtZXMuYXQobWFwcGluZy5uYW1lKTtcbiAgICAgICAgdGhpcy5fbmFtZXMuYWRkKG5hbWUpO1xuICAgICAgICBuYW1lID0gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKTtcblxuICAgICAgICAvLyBUaGUgbWFwcGluZ3MgY29taW5nIGZyb20gdGhlIGNvbnN1bWVyIGZvciB0aGUgc2VjdGlvbiBoYXZlXG4gICAgICAgIC8vIGdlbmVyYXRlZCBwb3NpdGlvbnMgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBzZWN0aW9uLCBzbyB3ZVxuICAgICAgICAvLyBuZWVkIHRvIG9mZnNldCB0aGVtIHRvIGJlIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgY29uY2F0ZW5hdGVkXG4gICAgICAgIC8vIGdlbmVyYXRlZCBmaWxlLlxuICAgICAgICB2YXIgYWRqdXN0ZWRNYXBwaW5nID0ge1xuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIGdlbmVyYXRlZExpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSArXG4gICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSAtIDEpLFxuICAgICAgICAgIGdlbmVyYXRlZENvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IG1hcHBpbmcuZ2VuZXJhdGVkTGluZVxuICAgICAgICAgICAgPyBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4gLSAxXG4gICAgICAgICAgICA6IDApLFxuICAgICAgICAgIG9yaWdpbmFsTGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgb3JpZ2luYWxDb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncy5wdXNoKGFkanVzdGVkTWFwcGluZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYWRqdXN0ZWRNYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncy5wdXNoKGFkanVzdGVkTWFwcGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBxdWlja1NvcnQodGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKTtcbiAgICBxdWlja1NvcnQodGhpcy5fX29yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuICB9O1xuXG5leHBvcnRzLkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lciA9IEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcjtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBBcnJheVNldCA9IHJlcXVpcmUoJy4vYXJyYXktc2V0JykuQXJyYXlTZXQ7XG52YXIgTWFwcGluZ0xpc3QgPSByZXF1aXJlKCcuL21hcHBpbmctbGlzdCcpLk1hcHBpbmdMaXN0O1xuXG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IgcmVwcmVzZW50cyBhIHNvdXJjZSBtYXAgd2hpY2ggaXNcbiAqIGJlaW5nIGJ1aWx0IGluY3JlbWVudGFsbHkuIFlvdSBtYXkgcGFzcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gKiBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBmaWxlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKiAgIC0gc291cmNlUm9vdDogQSByb290IGZvciBhbGwgcmVsYXRpdmUgVVJMcyBpbiB0aGlzIHNvdXJjZSBtYXAuXG4gKi9cbmZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncykge1xuICBpZiAoIWFBcmdzKSB7XG4gICAgYUFyZ3MgPSB7fTtcbiAgfVxuICB0aGlzLl9maWxlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdmaWxlJywgbnVsbCk7XG4gIHRoaXMuX3NvdXJjZVJvb3QgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZVJvb3QnLCBudWxsKTtcbiAgdGhpcy5fc2tpcFZhbGlkYXRpb24gPSB1dGlsLmdldEFyZyhhQXJncywgJ3NraXBWYWxpZGF0aW9uJywgZmFsc2UpO1xuICB0aGlzLl9zb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gIHRoaXMuX25hbWVzID0gbmV3IEFycmF5U2V0KCk7XG4gIHRoaXMuX21hcHBpbmdzID0gbmV3IE1hcHBpbmdMaXN0KCk7XG4gIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IG51bGw7XG59XG5cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgU291cmNlTWFwR2VuZXJhdG9yIGJhc2VkIG9uIGEgU291cmNlTWFwQ29uc3VtZXJcbiAqXG4gKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBTb3VyY2VNYXAuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5mcm9tU291cmNlTWFwID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcENvbnN1bWVyKSB7XG4gICAgdmFyIHNvdXJjZVJvb3QgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlUm9vdDtcbiAgICB2YXIgZ2VuZXJhdG9yID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcih7XG4gICAgICBmaWxlOiBhU291cmNlTWFwQ29uc3VtZXIuZmlsZSxcbiAgICAgIHNvdXJjZVJvb3Q6IHNvdXJjZVJvb3RcbiAgICB9KTtcbiAgICBhU291cmNlTWFwQ29uc3VtZXIuZWFjaE1hcHBpbmcoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgIHZhciBuZXdNYXBwaW5nID0ge1xuICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICBsaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUsXG4gICAgICAgICAgY29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtblxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3TWFwcGluZy5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIG5ld01hcHBpbmcuc291cmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld01hcHBpbmcub3JpZ2luYWwgPSB7XG4gICAgICAgICAgbGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgY29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3TWFwcGluZy5uYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGdlbmVyYXRvci5hZGRNYXBwaW5nKG5ld01hcHBpbmcpO1xuICAgIH0pO1xuICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIGdlbmVyYXRvci5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH07XG5cbi8qKlxuICogQWRkIGEgc2luZ2xlIG1hcHBpbmcgZnJvbSBvcmlnaW5hbCBzb3VyY2UgbGluZSBhbmQgY29sdW1uIHRvIHRoZSBnZW5lcmF0ZWRcbiAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBmb3IgdGhpcyBzb3VyY2UgbWFwIGJlaW5nIGNyZWF0ZWQuIFRoZSBtYXBwaW5nXG4gKiBvYmplY3Qgc2hvdWxkIGhhdmUgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBnZW5lcmF0ZWQ6IEFuIG9iamVjdCB3aXRoIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAqICAgLSBvcmlnaW5hbDogQW4gb2JqZWN0IHdpdGggdGhlIG9yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMuXG4gKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUgKHJlbGF0aXZlIHRvIHRoZSBzb3VyY2VSb290KS5cbiAqICAgLSBuYW1lOiBBbiBvcHRpb25hbCBvcmlnaW5hbCB0b2tlbiBuYW1lIGZvciB0aGlzIG1hcHBpbmcuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYWRkTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hZGRNYXBwaW5nKGFBcmdzKSB7XG4gICAgdmFyIGdlbmVyYXRlZCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnZ2VuZXJhdGVkJyk7XG4gICAgdmFyIG9yaWdpbmFsID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdvcmlnaW5hbCcsIG51bGwpO1xuICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScsIG51bGwpO1xuICAgIHZhciBuYW1lID0gdXRpbC5nZXRBcmcoYUFyZ3MsICduYW1lJywgbnVsbCk7XG5cbiAgICBpZiAoIXRoaXMuX3NraXBWYWxpZGF0aW9uKSB7XG4gICAgICB0aGlzLl92YWxpZGF0ZU1hcHBpbmcoZ2VuZXJhdGVkLCBvcmlnaW5hbCwgc291cmNlLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZSA9IFN0cmluZyhzb3VyY2UpO1xuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgIT0gbnVsbCkge1xuICAgICAgbmFtZSA9IFN0cmluZyhuYW1lKTtcbiAgICAgIGlmICghdGhpcy5fbmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIHRoaXMuX25hbWVzLmFkZChuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9tYXBwaW5ncy5hZGQoe1xuICAgICAgZ2VuZXJhdGVkTGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICBnZW5lcmF0ZWRDb2x1bW46IGdlbmVyYXRlZC5jb2x1bW4sXG4gICAgICBvcmlnaW5hbExpbmU6IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwubGluZSxcbiAgICAgIG9yaWdpbmFsQ29sdW1uOiBvcmlnaW5hbCAhPSBudWxsICYmIG9yaWdpbmFsLmNvbHVtbixcbiAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgbmFtZTogbmFtZVxuICAgIH0pO1xuICB9O1xuXG4vKipcbiAqIFNldCB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGEgc291cmNlIGZpbGUuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuc2V0U291cmNlQ29udGVudCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9zZXRTb3VyY2VDb250ZW50KGFTb3VyY2VGaWxlLCBhU291cmNlQ29udGVudCkge1xuICAgIHZhciBzb3VyY2UgPSBhU291cmNlRmlsZTtcbiAgICBpZiAodGhpcy5fc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuX3NvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgfVxuXG4gICAgaWYgKGFTb3VyY2VDb250ZW50ICE9IG51bGwpIHtcbiAgICAgIC8vIEFkZCB0aGUgc291cmNlIGNvbnRlbnQgdG8gdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwLlxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IF9zb3VyY2VzQ29udGVudHMgbWFwIGlmIHRoZSBwcm9wZXJ0eSBpcyBudWxsLlxuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgIC8vIFJlbW92ZSB0aGUgc291cmNlIGZpbGUgZnJvbSB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAuXG4gICAgICAvLyBJZiB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAgaXMgZW1wdHksIHNldCB0aGUgcHJvcGVydHkgdG8gbnVsbC5cbiAgICAgIGRlbGV0ZSB0aGlzLl9zb3VyY2VzQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhzb3VyY2UpXTtcbiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLl9zb3VyY2VzQ29udGVudHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBBcHBsaWVzIHRoZSBtYXBwaW5ncyBvZiBhIHN1Yi1zb3VyY2UtbWFwIGZvciBhIHNwZWNpZmljIHNvdXJjZSBmaWxlIHRvIHRoZVxuICogc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQuIEVhY2ggbWFwcGluZyB0byB0aGUgc3VwcGxpZWQgc291cmNlIGZpbGUgaXNcbiAqIHJld3JpdHRlbiB1c2luZyB0aGUgc3VwcGxpZWQgc291cmNlIG1hcC4gTm90ZTogVGhlIHJlc29sdXRpb24gZm9yIHRoZVxuICogcmVzdWx0aW5nIG1hcHBpbmdzIGlzIHRoZSBtaW5pbWl1bSBvZiB0aGlzIG1hcCBhbmQgdGhlIHN1cHBsaWVkIG1hcC5cbiAqXG4gKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBzb3VyY2UgbWFwIHRvIGJlIGFwcGxpZWQuXG4gKiBAcGFyYW0gYVNvdXJjZUZpbGUgT3B0aW9uYWwuIFRoZSBmaWxlbmFtZSBvZiB0aGUgc291cmNlIGZpbGUuXG4gKiAgICAgICAgSWYgb21pdHRlZCwgU291cmNlTWFwQ29uc3VtZXIncyBmaWxlIHByb3BlcnR5IHdpbGwgYmUgdXNlZC5cbiAqIEBwYXJhbSBhU291cmNlTWFwUGF0aCBPcHRpb25hbC4gVGhlIGRpcm5hbWUgb2YgdGhlIHBhdGggdG8gdGhlIHNvdXJjZSBtYXBcbiAqICAgICAgICB0byBiZSBhcHBsaWVkLiBJZiByZWxhdGl2ZSwgaXQgaXMgcmVsYXRpdmUgdG8gdGhlIFNvdXJjZU1hcENvbnN1bWVyLlxuICogICAgICAgIFRoaXMgcGFyYW1ldGVyIGlzIG5lZWRlZCB3aGVuIHRoZSB0d28gc291cmNlIG1hcHMgYXJlbid0IGluIHRoZSBzYW1lXG4gKiAgICAgICAgZGlyZWN0b3J5LCBhbmQgdGhlIHNvdXJjZSBtYXAgdG8gYmUgYXBwbGllZCBjb250YWlucyByZWxhdGl2ZSBzb3VyY2VcbiAqICAgICAgICBwYXRocy4gSWYgc28sIHRob3NlIHJlbGF0aXZlIHNvdXJjZSBwYXRocyBuZWVkIHRvIGJlIHJld3JpdHRlblxuICogICAgICAgIHJlbGF0aXZlIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYXBwbHlTb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfYXBwbHlTb3VyY2VNYXAoYVNvdXJjZU1hcENvbnN1bWVyLCBhU291cmNlRmlsZSwgYVNvdXJjZU1hcFBhdGgpIHtcbiAgICB2YXIgc291cmNlRmlsZSA9IGFTb3VyY2VGaWxlO1xuICAgIC8vIElmIGFTb3VyY2VGaWxlIGlzIG9taXR0ZWQsIHdlIHdpbGwgdXNlIHRoZSBmaWxlIHByb3BlcnR5IG9mIHRoZSBTb3VyY2VNYXBcbiAgICBpZiAoYVNvdXJjZUZpbGUgPT0gbnVsbCkge1xuICAgICAgaWYgKGFTb3VyY2VNYXBDb25zdW1lci5maWxlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwIHJlcXVpcmVzIGVpdGhlciBhbiBleHBsaWNpdCBzb3VyY2UgZmlsZSwgJyArXG4gICAgICAgICAgJ29yIHRoZSBzb3VyY2UgbWFwXFwncyBcImZpbGVcIiBwcm9wZXJ0eS4gQm90aCB3ZXJlIG9taXR0ZWQuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgc291cmNlRmlsZSA9IGFTb3VyY2VNYXBDb25zdW1lci5maWxlO1xuICAgIH1cbiAgICB2YXIgc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgLy8gTWFrZSBcInNvdXJjZUZpbGVcIiByZWxhdGl2ZSBpZiBhbiBhYnNvbHV0ZSBVcmwgaXMgcGFzc2VkLlxuICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgIH1cbiAgICAvLyBBcHBseWluZyB0aGUgU291cmNlTWFwIGNhbiBhZGQgYW5kIHJlbW92ZSBpdGVtcyBmcm9tIHRoZSBzb3VyY2VzIGFuZFxuICAgIC8vIHRoZSBuYW1lcyBhcnJheS5cbiAgICB2YXIgbmV3U291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICAgIHZhciBuZXdOYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuXG4gICAgLy8gRmluZCBtYXBwaW5ncyBmb3IgdGhlIFwic291cmNlRmlsZVwiXG4gICAgdGhpcy5fbWFwcGluZ3MudW5zb3J0ZWRGb3JFYWNoKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgPT09IHNvdXJjZUZpbGUgJiYgbWFwcGluZy5vcmlnaW5hbExpbmUgIT0gbnVsbCkge1xuICAgICAgICAvLyBDaGVjayBpZiBpdCBjYW4gYmUgbWFwcGVkIGJ5IHRoZSBzb3VyY2UgbWFwLCB0aGVuIHVwZGF0ZSB0aGUgbWFwcGluZy5cbiAgICAgICAgdmFyIG9yaWdpbmFsID0gYVNvdXJjZU1hcENvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe1xuICAgICAgICAgIGxpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9yaWdpbmFsLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gQ29weSBtYXBwaW5nXG4gICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBvcmlnaW5hbC5zb3VyY2U7XG4gICAgICAgICAgaWYgKGFTb3VyY2VNYXBQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdXRpbC5qb2luKGFTb3VyY2VNYXBQYXRoLCBtYXBwaW5nLnNvdXJjZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPSBvcmlnaW5hbC5saW5lO1xuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBvcmlnaW5hbC5jb2x1bW47XG4gICAgICAgICAgaWYgKG9yaWdpbmFsLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFwcGluZy5uYW1lID0gb3JpZ2luYWwubmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgaWYgKHNvdXJjZSAhPSBudWxsICYmICFuZXdTb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgIG5ld1NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgaWYgKG5hbWUgIT0gbnVsbCAmJiAhbmV3TmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIG5ld05hbWVzLmFkZChuYW1lKTtcbiAgICAgIH1cblxuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMuX3NvdXJjZXMgPSBuZXdTb3VyY2VzO1xuICAgIHRoaXMuX25hbWVzID0gbmV3TmFtZXM7XG5cbiAgICAvLyBDb3B5IHNvdXJjZXNDb250ZW50cyBvZiBhcHBsaWVkIG1hcC5cbiAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYVNvdXJjZU1hcFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLmpvaW4oYVNvdXJjZU1hcFBhdGgsIHNvdXJjZUZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2VGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH07XG5cbi8qKlxuICogQSBtYXBwaW5nIGNhbiBoYXZlIG9uZSBvZiB0aGUgdGhyZWUgbGV2ZWxzIG9mIGRhdGE6XG4gKlxuICogICAxLiBKdXN0IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb24uXG4gKiAgIDIuIFRoZSBHZW5lcmF0ZWQgcG9zaXRpb24sIG9yaWdpbmFsIHBvc2l0aW9uLCBhbmQgb3JpZ2luYWwgc291cmNlLlxuICogICAzLiBHZW5lcmF0ZWQgYW5kIG9yaWdpbmFsIHBvc2l0aW9uLCBvcmlnaW5hbCBzb3VyY2UsIGFzIHdlbGwgYXMgYSBuYW1lXG4gKiAgICAgIHRva2VuLlxuICpcbiAqIFRvIG1haW50YWluIGNvbnNpc3RlbmN5LCB3ZSB2YWxpZGF0ZSB0aGF0IGFueSBuZXcgbWFwcGluZyBiZWluZyBhZGRlZCBmYWxsc1xuICogaW4gdG8gb25lIG9mIHRoZXNlIGNhdGVnb3JpZXMuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZhbGlkYXRlTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl92YWxpZGF0ZU1hcHBpbmcoYUdlbmVyYXRlZCwgYU9yaWdpbmFsLCBhU291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFOYW1lKSB7XG4gICAgaWYgKGFHZW5lcmF0ZWQgJiYgJ2xpbmUnIGluIGFHZW5lcmF0ZWQgJiYgJ2NvbHVtbicgaW4gYUdlbmVyYXRlZFxuICAgICAgICAmJiBhR2VuZXJhdGVkLmxpbmUgPiAwICYmIGFHZW5lcmF0ZWQuY29sdW1uID49IDBcbiAgICAgICAgJiYgIWFPcmlnaW5hbCAmJiAhYVNvdXJjZSAmJiAhYU5hbWUpIHtcbiAgICAgIC8vIENhc2UgMS5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSBpZiAoYUdlbmVyYXRlZCAmJiAnbGluZScgaW4gYUdlbmVyYXRlZCAmJiAnY29sdW1uJyBpbiBhR2VuZXJhdGVkXG4gICAgICAgICAgICAgJiYgYU9yaWdpbmFsICYmICdsaW5lJyBpbiBhT3JpZ2luYWwgJiYgJ2NvbHVtbicgaW4gYU9yaWdpbmFsXG4gICAgICAgICAgICAgJiYgYUdlbmVyYXRlZC5saW5lID4gMCAmJiBhR2VuZXJhdGVkLmNvbHVtbiA+PSAwXG4gICAgICAgICAgICAgJiYgYU9yaWdpbmFsLmxpbmUgPiAwICYmIGFPcmlnaW5hbC5jb2x1bW4gPj0gMFxuICAgICAgICAgICAgICYmIGFTb3VyY2UpIHtcbiAgICAgIC8vIENhc2VzIDIgYW5kIDMuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1hcHBpbmc6ICcgKyBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGdlbmVyYXRlZDogYUdlbmVyYXRlZCxcbiAgICAgICAgc291cmNlOiBhU291cmNlLFxuICAgICAgICBvcmlnaW5hbDogYU9yaWdpbmFsLFxuICAgICAgICBuYW1lOiBhTmFtZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBTZXJpYWxpemUgdGhlIGFjY3VtdWxhdGVkIG1hcHBpbmdzIGluIHRvIHRoZSBzdHJlYW0gb2YgYmFzZSA2NCBWTFFzXG4gKiBzcGVjaWZpZWQgYnkgdGhlIHNvdXJjZSBtYXAgZm9ybWF0LlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl9zZXJpYWxpemVNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9zZXJpYWxpemVNYXBwaW5ncygpIHtcbiAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZExpbmUgPSAxO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbExpbmUgPSAwO1xuICAgIHZhciBwcmV2aW91c05hbWUgPSAwO1xuICAgIHZhciBwcmV2aW91c1NvdXJjZSA9IDA7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBuZXh0O1xuICAgIHZhciBtYXBwaW5nO1xuICAgIHZhciBuYW1lSWR4O1xuICAgIHZhciBzb3VyY2VJZHg7XG5cbiAgICB2YXIgbWFwcGluZ3MgPSB0aGlzLl9tYXBwaW5ncy50b0FycmF5KCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG1hcHBpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBtYXBwaW5nID0gbWFwcGluZ3NbaV07XG4gICAgICBuZXh0ID0gJydcblxuICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSAhPT0gcHJldmlvdXNHZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgd2hpbGUgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSAhPT0gcHJldmlvdXNHZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgbmV4dCArPSAnOyc7XG4gICAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICBpZiAoIXV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZywgbWFwcGluZ3NbaSAtIDFdKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHQgKz0gJywnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLmdlbmVyYXRlZENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c0dlbmVyYXRlZENvbHVtbik7XG4gICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBzb3VyY2VJZHggPSB0aGlzLl9zb3VyY2VzLmluZGV4T2YobWFwcGluZy5zb3VyY2UpO1xuICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUoc291cmNlSWR4IC0gcHJldmlvdXNTb3VyY2UpO1xuICAgICAgICBwcmV2aW91c1NvdXJjZSA9IHNvdXJjZUlkeDtcblxuICAgICAgICAvLyBsaW5lcyBhcmUgc3RvcmVkIDAtYmFzZWQgaW4gU291cmNlTWFwIHNwZWMgdmVyc2lvbiAzXG4gICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLm9yaWdpbmFsTGluZSAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c09yaWdpbmFsTGluZSk7XG4gICAgICAgIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmUgLSAxO1xuXG4gICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbENvbHVtbik7XG4gICAgICAgIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgIG5hbWVJZHggPSB0aGlzLl9uYW1lcy5pbmRleE9mKG1hcHBpbmcubmFtZSk7XG4gICAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKG5hbWVJZHggLSBwcmV2aW91c05hbWUpO1xuICAgICAgICAgIHByZXZpb3VzTmFtZSA9IG5hbWVJZHg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzdWx0ICs9IG5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KGFTb3VyY2VzLCBhU291cmNlUm9vdCkge1xuICAgIHJldHVybiBhU291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoYVNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKGFTb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgfVxuICAgICAgdmFyIGtleSA9IHV0aWwudG9TZXRTdHJpbmcoc291cmNlKTtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fc291cmNlc0NvbnRlbnRzLCBrZXkpXG4gICAgICAgID8gdGhpcy5fc291cmNlc0NvbnRlbnRzW2tleV1cbiAgICAgICAgOiBudWxsO1xuICAgIH0sIHRoaXMpO1xuICB9O1xuXG4vKipcbiAqIEV4dGVybmFsaXplIHRoZSBzb3VyY2UgbWFwLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvSlNPTiA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl90b0pTT04oKSB7XG4gICAgdmFyIG1hcCA9IHtcbiAgICAgIHZlcnNpb246IHRoaXMuX3ZlcnNpb24sXG4gICAgICBzb3VyY2VzOiB0aGlzLl9zb3VyY2VzLnRvQXJyYXkoKSxcbiAgICAgIG5hbWVzOiB0aGlzLl9uYW1lcy50b0FycmF5KCksXG4gICAgICBtYXBwaW5nczogdGhpcy5fc2VyaWFsaXplTWFwcGluZ3MoKVxuICAgIH07XG4gICAgaWYgKHRoaXMuX2ZpbGUgIT0gbnVsbCkge1xuICAgICAgbWFwLmZpbGUgPSB0aGlzLl9maWxlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBtYXAuc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgIG1hcC5zb3VyY2VzQ29udGVudCA9IHRoaXMuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQobWFwLnNvdXJjZXMsIG1hcC5zb3VyY2VSb290KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFwO1xuICB9O1xuXG4vKipcbiAqIFJlbmRlciB0aGUgc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQgdG8gYSBzdHJpbmcuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9TdHJpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKCkpO1xuICB9O1xuXG5leHBvcnRzLlNvdXJjZU1hcEdlbmVyYXRvciA9IFNvdXJjZU1hcEdlbmVyYXRvcjtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIFNvdXJjZU1hcEdlbmVyYXRvciA9IHJlcXVpcmUoJy4vc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vLyBNYXRjaGVzIGEgV2luZG93cy1zdHlsZSBgXFxyXFxuYCBuZXdsaW5lIG9yIGEgYFxcbmAgbmV3bGluZSB1c2VkIGJ5IGFsbCBvdGhlclxuLy8gb3BlcmF0aW5nIHN5c3RlbXMgdGhlc2UgZGF5cyAoY2FwdHVyaW5nIHRoZSByZXN1bHQpLlxudmFyIFJFR0VYX05FV0xJTkUgPSAvKFxccj9cXG4pLztcblxuLy8gTmV3bGluZSBjaGFyYWN0ZXIgY29kZSBmb3IgY2hhckNvZGVBdCgpIGNvbXBhcmlzb25zXG52YXIgTkVXTElORV9DT0RFID0gMTA7XG5cbi8vIFByaXZhdGUgc3ltYm9sIGZvciBpZGVudGlmeWluZyBgU291cmNlTm9kZWBzIHdoZW4gbXVsdGlwbGUgdmVyc2lvbnMgb2Zcbi8vIHRoZSBzb3VyY2UtbWFwIGxpYnJhcnkgYXJlIGxvYWRlZC4gVGhpcyBNVVNUIE5PVCBDSEFOR0UgYWNyb3NzXG4vLyB2ZXJzaW9ucyFcbnZhciBpc1NvdXJjZU5vZGUgPSBcIiQkJGlzU291cmNlTm9kZSQkJFwiO1xuXG4vKipcbiAqIFNvdXJjZU5vZGVzIHByb3ZpZGUgYSB3YXkgdG8gYWJzdHJhY3Qgb3ZlciBpbnRlcnBvbGF0aW5nL2NvbmNhdGVuYXRpbmdcbiAqIHNuaXBwZXRzIG9mIGdlbmVyYXRlZCBKYXZhU2NyaXB0IHNvdXJjZSBjb2RlIHdoaWxlIG1haW50YWluaW5nIHRoZSBsaW5lIGFuZFxuICogY29sdW1uIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgb3JpZ2luYWwgc291cmNlIGNvZGUuXG4gKlxuICogQHBhcmFtIGFMaW5lIFRoZSBvcmlnaW5hbCBsaW5lIG51bWJlci5cbiAqIEBwYXJhbSBhQ29sdW1uIFRoZSBvcmlnaW5hbCBjb2x1bW4gbnVtYmVyLlxuICogQHBhcmFtIGFTb3VyY2UgVGhlIG9yaWdpbmFsIHNvdXJjZSdzIGZpbGVuYW1lLlxuICogQHBhcmFtIGFDaHVua3MgT3B0aW9uYWwuIEFuIGFycmF5IG9mIHN0cmluZ3Mgd2hpY2ggYXJlIHNuaXBwZXRzIG9mXG4gKiAgICAgICAgZ2VuZXJhdGVkIEpTLCBvciBvdGhlciBTb3VyY2VOb2Rlcy5cbiAqIEBwYXJhbSBhTmFtZSBUaGUgb3JpZ2luYWwgaWRlbnRpZmllci5cbiAqL1xuZnVuY3Rpb24gU291cmNlTm9kZShhTGluZSwgYUNvbHVtbiwgYVNvdXJjZSwgYUNodW5rcywgYU5hbWUpIHtcbiAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICB0aGlzLnNvdXJjZUNvbnRlbnRzID0ge307XG4gIHRoaXMubGluZSA9IGFMaW5lID09IG51bGwgPyBudWxsIDogYUxpbmU7XG4gIHRoaXMuY29sdW1uID0gYUNvbHVtbiA9PSBudWxsID8gbnVsbCA6IGFDb2x1bW47XG4gIHRoaXMuc291cmNlID0gYVNvdXJjZSA9PSBudWxsID8gbnVsbCA6IGFTb3VyY2U7XG4gIHRoaXMubmFtZSA9IGFOYW1lID09IG51bGwgPyBudWxsIDogYU5hbWU7XG4gIHRoaXNbaXNTb3VyY2VOb2RlXSA9IHRydWU7XG4gIGlmIChhQ2h1bmtzICE9IG51bGwpIHRoaXMuYWRkKGFDaHVua3MpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBTb3VyY2VOb2RlIGZyb20gZ2VuZXJhdGVkIGNvZGUgYW5kIGEgU291cmNlTWFwQ29uc3VtZXIuXG4gKlxuICogQHBhcmFtIGFHZW5lcmF0ZWRDb2RlIFRoZSBnZW5lcmF0ZWQgY29kZVxuICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgU291cmNlTWFwIGZvciB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAqIEBwYXJhbSBhUmVsYXRpdmVQYXRoIE9wdGlvbmFsLiBUaGUgcGF0aCB0aGF0IHJlbGF0aXZlIHNvdXJjZXMgaW4gdGhlXG4gKiAgICAgICAgU291cmNlTWFwQ29uc3VtZXIgc2hvdWxkIGJlIHJlbGF0aXZlIHRvLlxuICovXG5Tb3VyY2VOb2RlLmZyb21TdHJpbmdXaXRoU291cmNlTWFwID1cbiAgZnVuY3Rpb24gU291cmNlTm9kZV9mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcChhR2VuZXJhdGVkQ29kZSwgYVNvdXJjZU1hcENvbnN1bWVyLCBhUmVsYXRpdmVQYXRoKSB7XG4gICAgLy8gVGhlIFNvdXJjZU5vZGUgd2Ugd2FudCB0byBmaWxsIHdpdGggdGhlIGdlbmVyYXRlZCBjb2RlXG4gICAgLy8gYW5kIHRoZSBTb3VyY2VNYXBcbiAgICB2YXIgbm9kZSA9IG5ldyBTb3VyY2VOb2RlKCk7XG5cbiAgICAvLyBBbGwgZXZlbiBpbmRpY2VzIG9mIHRoaXMgYXJyYXkgYXJlIG9uZSBsaW5lIG9mIHRoZSBnZW5lcmF0ZWQgY29kZSxcbiAgICAvLyB3aGlsZSBhbGwgb2RkIGluZGljZXMgYXJlIHRoZSBuZXdsaW5lcyBiZXR3ZWVuIHR3byBhZGphY2VudCBsaW5lc1xuICAgIC8vIChzaW5jZSBgUkVHRVhfTkVXTElORWAgY2FwdHVyZXMgaXRzIG1hdGNoKS5cbiAgICAvLyBQcm9jZXNzZWQgZnJhZ21lbnRzIGFyZSByZW1vdmVkIGZyb20gdGhpcyBhcnJheSwgYnkgY2FsbGluZyBgc2hpZnROZXh0TGluZWAuXG4gICAgdmFyIHJlbWFpbmluZ0xpbmVzID0gYUdlbmVyYXRlZENvZGUuc3BsaXQoUkVHRVhfTkVXTElORSk7XG4gICAgdmFyIHNoaWZ0TmV4dExpbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsaW5lQ29udGVudHMgPSByZW1haW5pbmdMaW5lcy5zaGlmdCgpO1xuICAgICAgLy8gVGhlIGxhc3QgbGluZSBvZiBhIGZpbGUgbWlnaHQgbm90IGhhdmUgYSBuZXdsaW5lLlxuICAgICAgdmFyIG5ld0xpbmUgPSByZW1haW5pbmdMaW5lcy5zaGlmdCgpIHx8IFwiXCI7XG4gICAgICByZXR1cm4gbGluZUNvbnRlbnRzICsgbmV3TGluZTtcbiAgICB9O1xuXG4gICAgLy8gV2UgbmVlZCB0byByZW1lbWJlciB0aGUgcG9zaXRpb24gb2YgXCJyZW1haW5pbmdMaW5lc1wiXG4gICAgdmFyIGxhc3RHZW5lcmF0ZWRMaW5lID0gMSwgbGFzdEdlbmVyYXRlZENvbHVtbiA9IDA7XG5cbiAgICAvLyBUaGUgZ2VuZXJhdGUgU291cmNlTm9kZXMgd2UgbmVlZCBhIGNvZGUgcmFuZ2UuXG4gICAgLy8gVG8gZXh0cmFjdCBpdCBjdXJyZW50IGFuZCBsYXN0IG1hcHBpbmcgaXMgdXNlZC5cbiAgICAvLyBIZXJlIHdlIHN0b3JlIHRoZSBsYXN0IG1hcHBpbmcuXG4gICAgdmFyIGxhc3RNYXBwaW5nID0gbnVsbDtcblxuICAgIGFTb3VyY2VNYXBDb25zdW1lci5lYWNoTWFwcGluZyhmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgaWYgKGxhc3RNYXBwaW5nICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFdlIGFkZCB0aGUgY29kZSBmcm9tIFwibGFzdE1hcHBpbmdcIiB0byBcIm1hcHBpbmdcIjpcbiAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlcmUgaXMgYSBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICBpZiAobGFzdEdlbmVyYXRlZExpbmUgPCBtYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICAvLyBBc3NvY2lhdGUgZmlyc3QgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgc2hpZnROZXh0TGluZSgpKTtcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkTGluZSsrO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgICAgIC8vIFRoZSByZW1haW5pbmcgY29kZSBpcyBhZGRlZCB3aXRob3V0IG1hcHBpbmdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGVyZSBpcyBubyBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICAgIC8vIEFzc29jaWF0ZSB0aGUgY29kZSBiZXR3ZWVuIFwibGFzdEdlbmVyYXRlZENvbHVtblwiIGFuZFxuICAgICAgICAgIC8vIFwibWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cIiB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzWzBdO1xuICAgICAgICAgIHZhciBjb2RlID0gbmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICByZW1haW5pbmdMaW5lc1swXSA9IG5leHRMaW5lLnN1YnN0cihtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgY29kZSk7XG4gICAgICAgICAgLy8gTm8gbW9yZSByZW1haW5pbmcgY29kZSwgY29udGludWVcbiAgICAgICAgICBsYXN0TWFwcGluZyA9IG1hcHBpbmc7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBXZSBhZGQgdGhlIGdlbmVyYXRlZCBjb2RlIHVudGlsIHRoZSBmaXJzdCBtYXBwaW5nXG4gICAgICAvLyB0byB0aGUgU291cmNlTm9kZSB3aXRob3V0IGFueSBtYXBwaW5nLlxuICAgICAgLy8gRWFjaCBsaW5lIGlzIGFkZGVkIGFzIHNlcGFyYXRlIHN0cmluZy5cbiAgICAgIHdoaWxlIChsYXN0R2VuZXJhdGVkTGluZSA8IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICBub2RlLmFkZChzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgICBsYXN0R2VuZXJhdGVkTGluZSsrO1xuICAgICAgfVxuICAgICAgaWYgKGxhc3RHZW5lcmF0ZWRDb2x1bW4gPCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbikge1xuICAgICAgICB2YXIgbmV4dExpbmUgPSByZW1haW5pbmdMaW5lc1swXTtcbiAgICAgICAgbm9kZS5hZGQobmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSk7XG4gICAgICAgIHJlbWFpbmluZ0xpbmVzWzBdID0gbmV4dExpbmUuc3Vic3RyKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgfVxuICAgICAgbGFzdE1hcHBpbmcgPSBtYXBwaW5nO1xuICAgIH0sIHRoaXMpO1xuICAgIC8vIFdlIGhhdmUgcHJvY2Vzc2VkIGFsbCBtYXBwaW5ncy5cbiAgICBpZiAocmVtYWluaW5nTGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKGxhc3RNYXBwaW5nKSB7XG4gICAgICAgIC8vIEFzc29jaWF0ZSB0aGUgcmVtYWluaW5nIGNvZGUgaW4gdGhlIGN1cnJlbnQgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICB9XG4gICAgICAvLyBhbmQgYWRkIHRoZSByZW1haW5pbmcgbGluZXMgd2l0aG91dCBhbnkgbWFwcGluZ1xuICAgICAgbm9kZS5hZGQocmVtYWluaW5nTGluZXMuam9pbihcIlwiKSk7XG4gICAgfVxuXG4gICAgLy8gQ29weSBzb3VyY2VzQ29udGVudCBpbnRvIFNvdXJjZU5vZGVcbiAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYVJlbGF0aXZlUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwuam9pbihhUmVsYXRpdmVQYXRoLCBzb3VyY2VGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbm9kZTtcblxuICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmdXaXRoQ29kZShtYXBwaW5nLCBjb2RlKSB7XG4gICAgICBpZiAobWFwcGluZyA9PT0gbnVsbCB8fCBtYXBwaW5nLnNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5vZGUuYWRkKGNvZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFSZWxhdGl2ZVBhdGhcbiAgICAgICAgICA/IHV0aWwuam9pbihhUmVsYXRpdmVQYXRoLCBtYXBwaW5nLnNvdXJjZSlcbiAgICAgICAgICA6IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBub2RlLmFkZChuZXcgU291cmNlTm9kZShtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm5hbWUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbi8qKlxuICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoaXMgc291cmNlIG5vZGUuXG4gKlxuICogQHBhcmFtIGFDaHVuayBBIHN0cmluZyBzbmlwcGV0IG9mIGdlbmVyYXRlZCBKUyBjb2RlLCBhbm90aGVyIGluc3RhbmNlIG9mXG4gKiAgICAgICAgU291cmNlTm9kZSwgb3IgYW4gYXJyYXkgd2hlcmUgZWFjaCBtZW1iZXIgaXMgb25lIG9mIHRob3NlIHRoaW5ncy5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gU291cmNlTm9kZV9hZGQoYUNodW5rKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFDaHVuaykpIHtcbiAgICBhQ2h1bmsuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIHRoaXMuYWRkKGNodW5rKTtcbiAgICB9LCB0aGlzKTtcbiAgfVxuICBlbHNlIGlmIChhQ2h1bmtbaXNTb3VyY2VOb2RlXSB8fCB0eXBlb2YgYUNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKGFDaHVuaykge1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGFDaHVuayk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBzb3VyY2Ugbm9kZS5cbiAqXG4gKiBAcGFyYW0gYUNodW5rIEEgc3RyaW5nIHNuaXBwZXQgb2YgZ2VuZXJhdGVkIEpTIGNvZGUsIGFub3RoZXIgaW5zdGFuY2Ugb2ZcbiAqICAgICAgICBTb3VyY2VOb2RlLCBvciBhbiBhcnJheSB3aGVyZSBlYWNoIG1lbWJlciBpcyBvbmUgb2YgdGhvc2UgdGhpbmdzLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24gU291cmNlTm9kZV9wcmVwZW5kKGFDaHVuaykge1xuICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgZm9yICh2YXIgaSA9IGFDaHVuay5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRoaXMucHJlcGVuZChhQ2h1bmtbaV0pO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChhQ2h1bmtbaXNTb3VyY2VOb2RlXSB8fCB0eXBlb2YgYUNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgdGhpcy5jaGlsZHJlbi51bnNoaWZ0KGFDaHVuayk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIFwiRXhwZWN0ZWQgYSBTb3VyY2VOb2RlLCBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIFNvdXJjZU5vZGVzIGFuZCBzdHJpbmdzLiBHb3QgXCIgKyBhQ2h1bmtcbiAgICApO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBXYWxrIG92ZXIgdGhlIHRyZWUgb2YgSlMgc25pcHBldHMgaW4gdGhpcyBub2RlIGFuZCBpdHMgY2hpbGRyZW4uIFRoZVxuICogd2Fsa2luZyBmdW5jdGlvbiBpcyBjYWxsZWQgb25jZSBmb3IgZWFjaCBzbmlwcGV0IG9mIEpTIGFuZCBpcyBwYXNzZWQgdGhhdFxuICogc25pcHBldCBhbmQgdGhlIGl0cyBvcmlnaW5hbCBhc3NvY2lhdGVkIHNvdXJjZSdzIGxpbmUvY29sdW1uIGxvY2F0aW9uLlxuICpcbiAqIEBwYXJhbSBhRm4gVGhlIHRyYXZlcnNhbCBmdW5jdGlvbi5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfd2FsayhhRm4pIHtcbiAgdmFyIGNodW5rO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNodW5rID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICBpZiAoY2h1bmtbaXNTb3VyY2VOb2RlXSkge1xuICAgICAgY2h1bmsud2FsayhhRm4pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChjaHVuayAhPT0gJycpIHtcbiAgICAgICAgYUZuKGNodW5rLCB7IHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBMaWtlIGBTdHJpbmcucHJvdG90eXBlLmpvaW5gIGV4Y2VwdCBmb3IgU291cmNlTm9kZXMuIEluc2VydHMgYGFTdHJgIGJldHdlZW5cbiAqIGVhY2ggb2YgYHRoaXMuY2hpbGRyZW5gLlxuICpcbiAqIEBwYXJhbSBhU2VwIFRoZSBzZXBhcmF0b3IuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBTb3VyY2VOb2RlX2pvaW4oYVNlcCkge1xuICB2YXIgbmV3Q2hpbGRyZW47XG4gIHZhciBpO1xuICB2YXIgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG4gIGlmIChsZW4gPiAwKSB7XG4gICAgbmV3Q2hpbGRyZW4gPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuLTE7IGkrKykge1xuICAgICAgbmV3Q2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTtcbiAgICAgIG5ld0NoaWxkcmVuLnB1c2goYVNlcCk7XG4gICAgfVxuICAgIG5ld0NoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XG4gICAgdGhpcy5jaGlsZHJlbiA9IG5ld0NoaWxkcmVuO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSBvbiB0aGUgdmVyeSByaWdodC1tb3N0IHNvdXJjZSBzbmlwcGV0LiBVc2VmdWxcbiAqIGZvciB0cmltbWluZyB3aGl0ZXNwYWNlIGZyb20gdGhlIGVuZCBvZiBhIHNvdXJjZSBub2RlLCBldGMuXG4gKlxuICogQHBhcmFtIGFQYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHJlcGxhY2UuXG4gKiBAcGFyYW0gYVJlcGxhY2VtZW50IFRoZSB0aGluZyB0byByZXBsYWNlIHRoZSBwYXR0ZXJuIHdpdGguXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnJlcGxhY2VSaWdodCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfcmVwbGFjZVJpZ2h0KGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpIHtcbiAgdmFyIGxhc3RDaGlsZCA9IHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgaWYgKGxhc3RDaGlsZFtpc1NvdXJjZU5vZGVdKSB7XG4gICAgbGFzdENoaWxkLnJlcGxhY2VSaWdodChhUGF0dGVybiwgYVJlcGxhY2VtZW50KTtcbiAgfVxuICBlbHNlIGlmICh0eXBlb2YgbGFzdENoaWxkID09PSAnc3RyaW5nJykge1xuICAgIHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXSA9IGxhc3RDaGlsZC5yZXBsYWNlKGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMuY2hpbGRyZW4ucHVzaCgnJy5yZXBsYWNlKGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS4gVGhpcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3JcbiAqIGluIHRoZSBzb3VyY2VzQ29udGVudCBmaWVsZC5cbiAqXG4gKiBAcGFyYW0gYVNvdXJjZUZpbGUgVGhlIGZpbGVuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZVxuICogQHBhcmFtIGFTb3VyY2VDb250ZW50IFRoZSBjb250ZW50IG9mIHRoZSBzb3VyY2UgZmlsZVxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50ID1cbiAgZnVuY3Rpb24gU291cmNlTm9kZV9zZXRTb3VyY2VDb250ZW50KGFTb3VyY2VGaWxlLCBhU291cmNlQ29udGVudCkge1xuICAgIHRoaXMuc291cmNlQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhhU291cmNlRmlsZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gIH07XG5cbi8qKlxuICogV2FsayBvdmVyIHRoZSB0cmVlIG9mIFNvdXJjZU5vZGVzLiBUaGUgd2Fsa2luZyBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIGVhY2hcbiAqIHNvdXJjZSBmaWxlIGNvbnRlbnQgYW5kIGlzIHBhc3NlZCB0aGUgZmlsZW5hbWUgYW5kIHNvdXJjZSBjb250ZW50LlxuICpcbiAqIEBwYXJhbSBhRm4gVGhlIHRyYXZlcnNhbCBmdW5jdGlvbi5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUud2Fsa1NvdXJjZUNvbnRlbnRzID1cbiAgZnVuY3Rpb24gU291cmNlTm9kZV93YWxrU291cmNlQ29udGVudHMoYUZuKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldW2lzU291cmNlTm9kZV0pIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbltpXS53YWxrU291cmNlQ29udGVudHMoYUZuKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc291cmNlcyA9IE9iamVjdC5rZXlzKHRoaXMuc291cmNlQ29udGVudHMpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhRm4odXRpbC5mcm9tU2V0U3RyaW5nKHNvdXJjZXNbaV0pLCB0aGlzLnNvdXJjZUNvbnRlbnRzW3NvdXJjZXNbaV1dKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzb3VyY2Ugbm9kZS4gV2Fsa3Mgb3ZlciB0aGUgdHJlZVxuICogYW5kIGNvbmNhdGVuYXRlcyBhbGwgdGhlIHZhcmlvdXMgc25pcHBldHMgdG9nZXRoZXIgdG8gb25lIHN0cmluZy5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3RvU3RyaW5nKCkge1xuICB2YXIgc3RyID0gXCJcIjtcbiAgdGhpcy53YWxrKGZ1bmN0aW9uIChjaHVuaykge1xuICAgIHN0ciArPSBjaHVuaztcbiAgfSk7XG4gIHJldHVybiBzdHI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNvdXJjZSBub2RlIGFsb25nIHdpdGggYSBzb3VyY2VcbiAqIG1hcC5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUudG9TdHJpbmdXaXRoU291cmNlTWFwID0gZnVuY3Rpb24gU291cmNlTm9kZV90b1N0cmluZ1dpdGhTb3VyY2VNYXAoYUFyZ3MpIHtcbiAgdmFyIGdlbmVyYXRlZCA9IHtcbiAgICBjb2RlOiBcIlwiLFxuICAgIGxpbmU6IDEsXG4gICAgY29sdW1uOiAwXG4gIH07XG4gIHZhciBtYXAgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKGFBcmdzKTtcbiAgdmFyIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgdmFyIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gIHZhciBsYXN0T3JpZ2luYWxMaW5lID0gbnVsbDtcbiAgdmFyIGxhc3RPcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gIHZhciBsYXN0T3JpZ2luYWxOYW1lID0gbnVsbDtcbiAgdGhpcy53YWxrKGZ1bmN0aW9uIChjaHVuaywgb3JpZ2luYWwpIHtcbiAgICBnZW5lcmF0ZWQuY29kZSArPSBjaHVuaztcbiAgICBpZiAob3JpZ2luYWwuc291cmNlICE9PSBudWxsXG4gICAgICAgICYmIG9yaWdpbmFsLmxpbmUgIT09IG51bGxcbiAgICAgICAgJiYgb3JpZ2luYWwuY29sdW1uICE9PSBudWxsKSB7XG4gICAgICBpZihsYXN0T3JpZ2luYWxTb3VyY2UgIT09IG9yaWdpbmFsLnNvdXJjZVxuICAgICAgICAgfHwgbGFzdE9yaWdpbmFsTGluZSAhPT0gb3JpZ2luYWwubGluZVxuICAgICAgICAgfHwgbGFzdE9yaWdpbmFsQ29sdW1uICE9PSBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgIHx8IGxhc3RPcmlnaW5hbE5hbWUgIT09IG9yaWdpbmFsLm5hbWUpIHtcbiAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgIHNvdXJjZTogb3JpZ2luYWwuc291cmNlLFxuICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICBsaW5lOiBvcmlnaW5hbC5saW5lLFxuICAgICAgICAgICAgY29sdW1uOiBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICB9LFxuICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICB9LFxuICAgICAgICAgIG5hbWU6IG9yaWdpbmFsLm5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBvcmlnaW5hbC5zb3VyY2U7XG4gICAgICBsYXN0T3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgIGxhc3RPcmlnaW5hbENvbHVtbiA9IG9yaWdpbmFsLmNvbHVtbjtcbiAgICAgIGxhc3RPcmlnaW5hbE5hbWUgPSBvcmlnaW5hbC5uYW1lO1xuICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChzb3VyY2VNYXBwaW5nQWN0aXZlKSB7XG4gICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICAgIGZvciAodmFyIGlkeCA9IDAsIGxlbmd0aCA9IGNodW5rLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgaWYgKGNodW5rLmNoYXJDb2RlQXQoaWR4KSA9PT0gTkVXTElORV9DT0RFKSB7XG4gICAgICAgIGdlbmVyYXRlZC5saW5lKys7XG4gICAgICAgIGdlbmVyYXRlZC5jb2x1bW4gPSAwO1xuICAgICAgICAvLyBNYXBwaW5ncyBlbmQgYXQgZW9sXG4gICAgICAgIGlmIChpZHggKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VNYXBwaW5nQWN0aXZlKSB7XG4gICAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgICAgc291cmNlOiBvcmlnaW5hbC5zb3VyY2UsXG4gICAgICAgICAgICBvcmlnaW5hbDoge1xuICAgICAgICAgICAgICBsaW5lOiBvcmlnaW5hbC5saW5lLFxuICAgICAgICAgICAgICBjb2x1bW46IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmFtZTogb3JpZ2luYWwubmFtZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZW5lcmF0ZWQuY29sdW1uKys7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdGhpcy53YWxrU291cmNlQ29udGVudHMoZnVuY3Rpb24gKHNvdXJjZUZpbGUsIHNvdXJjZUNvbnRlbnQpIHtcbiAgICBtYXAuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHsgY29kZTogZ2VuZXJhdGVkLmNvZGUsIG1hcDogbWFwIH07XG59O1xuXG5leHBvcnRzLlNvdXJjZU5vZGUgPSBTb3VyY2VOb2RlO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG4vKipcbiAqIFRoaXMgaXMgYSBoZWxwZXIgZnVuY3Rpb24gZm9yIGdldHRpbmcgdmFsdWVzIGZyb20gcGFyYW1ldGVyL29wdGlvbnNcbiAqIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIGFyZ3MgVGhlIG9iamVjdCB3ZSBhcmUgZXh0cmFjdGluZyB2YWx1ZXMgZnJvbVxuICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHdlIGFyZSBnZXR0aW5nLlxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSBBbiBvcHRpb25hbCB2YWx1ZSB0byByZXR1cm4gaWYgdGhlIHByb3BlcnR5IGlzIG1pc3NpbmdcbiAqIGZyb20gdGhlIG9iamVjdC4gSWYgdGhpcyBpcyBub3Qgc3BlY2lmaWVkIGFuZCB0aGUgcHJvcGVydHkgaXMgbWlzc2luZywgYW5cbiAqIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICovXG5mdW5jdGlvbiBnZXRBcmcoYUFyZ3MsIGFOYW1lLCBhRGVmYXVsdFZhbHVlKSB7XG4gIGlmIChhTmFtZSBpbiBhQXJncykge1xuICAgIHJldHVybiBhQXJnc1thTmFtZV07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHJldHVybiBhRGVmYXVsdFZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYU5hbWUgKyAnXCIgaXMgYSByZXF1aXJlZCBhcmd1bWVudC4nKTtcbiAgfVxufVxuZXhwb3J0cy5nZXRBcmcgPSBnZXRBcmc7XG5cbnZhciB1cmxSZWdleHAgPSAvXig/OihbXFx3K1xcLS5dKyk6KT9cXC9cXC8oPzooXFx3KzpcXHcrKUApPyhbXFx3Ll0qKSg/OjooXFxkKykpPyhcXFMqKSQvO1xudmFyIGRhdGFVcmxSZWdleHAgPSAvXmRhdGE6LitcXCwuKyQvO1xuXG5mdW5jdGlvbiB1cmxQYXJzZShhVXJsKSB7XG4gIHZhciBtYXRjaCA9IGFVcmwubWF0Y2godXJsUmVnZXhwKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgc2NoZW1lOiBtYXRjaFsxXSxcbiAgICBhdXRoOiBtYXRjaFsyXSxcbiAgICBob3N0OiBtYXRjaFszXSxcbiAgICBwb3J0OiBtYXRjaFs0XSxcbiAgICBwYXRoOiBtYXRjaFs1XVxuICB9O1xufVxuZXhwb3J0cy51cmxQYXJzZSA9IHVybFBhcnNlO1xuXG5mdW5jdGlvbiB1cmxHZW5lcmF0ZShhUGFyc2VkVXJsKSB7XG4gIHZhciB1cmwgPSAnJztcbiAgaWYgKGFQYXJzZWRVcmwuc2NoZW1lKSB7XG4gICAgdXJsICs9IGFQYXJzZWRVcmwuc2NoZW1lICsgJzonO1xuICB9XG4gIHVybCArPSAnLy8nO1xuICBpZiAoYVBhcnNlZFVybC5hdXRoKSB7XG4gICAgdXJsICs9IGFQYXJzZWRVcmwuYXV0aCArICdAJztcbiAgfVxuICBpZiAoYVBhcnNlZFVybC5ob3N0KSB7XG4gICAgdXJsICs9IGFQYXJzZWRVcmwuaG9zdDtcbiAgfVxuICBpZiAoYVBhcnNlZFVybC5wb3J0KSB7XG4gICAgdXJsICs9IFwiOlwiICsgYVBhcnNlZFVybC5wb3J0XG4gIH1cbiAgaWYgKGFQYXJzZWRVcmwucGF0aCkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLnBhdGg7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cbmV4cG9ydHMudXJsR2VuZXJhdGUgPSB1cmxHZW5lcmF0ZTtcblxuLyoqXG4gKiBOb3JtYWxpemVzIGEgcGF0aCwgb3IgdGhlIHBhdGggcG9ydGlvbiBvZiBhIFVSTDpcbiAqXG4gKiAtIFJlcGxhY2VzIGNvbnNlY3V0aXZlIHNsYXNoZXMgd2l0aCBvbmUgc2xhc2guXG4gKiAtIFJlbW92ZXMgdW5uZWNlc3NhcnkgJy4nIHBhcnRzLlxuICogLSBSZW1vdmVzIHVubmVjZXNzYXJ5ICc8ZGlyPi8uLicgcGFydHMuXG4gKlxuICogQmFzZWQgb24gY29kZSBpbiB0aGUgTm9kZS5qcyAncGF0aCcgY29yZSBtb2R1bGUuXG4gKlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIHVybCB0byBub3JtYWxpemUuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZShhUGF0aCkge1xuICB2YXIgcGF0aCA9IGFQYXRoO1xuICB2YXIgdXJsID0gdXJsUGFyc2UoYVBhdGgpO1xuICBpZiAodXJsKSB7XG4gICAgaWYgKCF1cmwucGF0aCkge1xuICAgICAgcmV0dXJuIGFQYXRoO1xuICAgIH1cbiAgICBwYXRoID0gdXJsLnBhdGg7XG4gIH1cbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCk7XG5cbiAgdmFyIHBhcnRzID0gcGF0aC5zcGxpdCgvXFwvKy8pO1xuICBmb3IgKHZhciBwYXJ0LCB1cCA9IDAsIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICBpZiAocGFydCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChwYXJ0ID09PSAnLi4nKSB7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXAgPiAwKSB7XG4gICAgICBpZiAocGFydCA9PT0gJycpIHtcbiAgICAgICAgLy8gVGhlIGZpcnN0IHBhcnQgaXMgYmxhbmsgaWYgdGhlIHBhdGggaXMgYWJzb2x1dGUuIFRyeWluZyB0byBnb1xuICAgICAgICAvLyBhYm92ZSB0aGUgcm9vdCBpcyBhIG5vLW9wLiBUaGVyZWZvcmUgd2UgY2FuIHJlbW92ZSBhbGwgJy4uJyBwYXJ0c1xuICAgICAgICAvLyBkaXJlY3RseSBhZnRlciB0aGUgcm9vdC5cbiAgICAgICAgcGFydHMuc3BsaWNlKGkgKyAxLCB1cCk7XG4gICAgICAgIHVwID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnRzLnNwbGljZShpLCAyKTtcbiAgICAgICAgdXAtLTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcGF0aCA9IHBhcnRzLmpvaW4oJy8nKTtcblxuICBpZiAocGF0aCA9PT0gJycpIHtcbiAgICBwYXRoID0gaXNBYnNvbHV0ZSA/ICcvJyA6ICcuJztcbiAgfVxuXG4gIGlmICh1cmwpIHtcbiAgICB1cmwucGF0aCA9IHBhdGg7XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKHVybCk7XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcblxuLyoqXG4gKiBKb2lucyB0d28gcGF0aHMvVVJMcy5cbiAqXG4gKiBAcGFyYW0gYVJvb3QgVGhlIHJvb3QgcGF0aCBvciBVUkwuXG4gKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgVVJMIHRvIGJlIGpvaW5lZCB3aXRoIHRoZSByb290LlxuICpcbiAqIC0gSWYgYVBhdGggaXMgYSBVUkwgb3IgYSBkYXRhIFVSSSwgYVBhdGggaXMgcmV0dXJuZWQsIHVubGVzcyBhUGF0aCBpcyBhXG4gKiAgIHNjaGVtZS1yZWxhdGl2ZSBVUkw6IFRoZW4gdGhlIHNjaGVtZSBvZiBhUm9vdCwgaWYgYW55LCBpcyBwcmVwZW5kZWRcbiAqICAgZmlyc3QuXG4gKiAtIE90aGVyd2lzZSBhUGF0aCBpcyBhIHBhdGguIElmIGFSb290IGlzIGEgVVJMLCB0aGVuIGl0cyBwYXRoIHBvcnRpb25cbiAqICAgaXMgdXBkYXRlZCB3aXRoIHRoZSByZXN1bHQgYW5kIGFSb290IGlzIHJldHVybmVkLiBPdGhlcndpc2UgdGhlIHJlc3VsdFxuICogICBpcyByZXR1cm5lZC5cbiAqICAgLSBJZiBhUGF0aCBpcyBhYnNvbHV0ZSwgdGhlIHJlc3VsdCBpcyBhUGF0aC5cbiAqICAgLSBPdGhlcndpc2UgdGhlIHR3byBwYXRocyBhcmUgam9pbmVkIHdpdGggYSBzbGFzaC5cbiAqIC0gSm9pbmluZyBmb3IgZXhhbXBsZSAnaHR0cDovLycgYW5kICd3d3cuZXhhbXBsZS5jb20nIGlzIGFsc28gc3VwcG9ydGVkLlxuICovXG5mdW5jdGlvbiBqb2luKGFSb290LCBhUGF0aCkge1xuICBpZiAoYVJvb3QgPT09IFwiXCIpIHtcbiAgICBhUm9vdCA9IFwiLlwiO1xuICB9XG4gIGlmIChhUGF0aCA9PT0gXCJcIikge1xuICAgIGFQYXRoID0gXCIuXCI7XG4gIH1cbiAgdmFyIGFQYXRoVXJsID0gdXJsUGFyc2UoYVBhdGgpO1xuICB2YXIgYVJvb3RVcmwgPSB1cmxQYXJzZShhUm9vdCk7XG4gIGlmIChhUm9vdFVybCkge1xuICAgIGFSb290ID0gYVJvb3RVcmwucGF0aCB8fCAnLyc7XG4gIH1cblxuICAvLyBgam9pbihmb28sICcvL3d3dy5leGFtcGxlLm9yZycpYFxuICBpZiAoYVBhdGhVcmwgJiYgIWFQYXRoVXJsLnNjaGVtZSkge1xuICAgIGlmIChhUm9vdFVybCkge1xuICAgICAgYVBhdGhVcmwuc2NoZW1lID0gYVJvb3RVcmwuc2NoZW1lO1xuICAgIH1cbiAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVBhdGhVcmwpO1xuICB9XG5cbiAgaWYgKGFQYXRoVXJsIHx8IGFQYXRoLm1hdGNoKGRhdGFVcmxSZWdleHApKSB7XG4gICAgcmV0dXJuIGFQYXRoO1xuICB9XG5cbiAgLy8gYGpvaW4oJ2h0dHA6Ly8nLCAnd3d3LmV4YW1wbGUuY29tJylgXG4gIGlmIChhUm9vdFVybCAmJiAhYVJvb3RVcmwuaG9zdCAmJiAhYVJvb3RVcmwucGF0aCkge1xuICAgIGFSb290VXJsLmhvc3QgPSBhUGF0aDtcbiAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVJvb3RVcmwpO1xuICB9XG5cbiAgdmFyIGpvaW5lZCA9IGFQYXRoLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgPyBhUGF0aFxuICAgIDogbm9ybWFsaXplKGFSb290LnJlcGxhY2UoL1xcLyskLywgJycpICsgJy8nICsgYVBhdGgpO1xuXG4gIGlmIChhUm9vdFVybCkge1xuICAgIGFSb290VXJsLnBhdGggPSBqb2luZWQ7XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKGFSb290VXJsKTtcbiAgfVxuICByZXR1cm4gam9pbmVkO1xufVxuZXhwb3J0cy5qb2luID0gam9pbjtcblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24gKGFQYXRoKSB7XG4gIHJldHVybiBhUGF0aC5jaGFyQXQoMCkgPT09ICcvJyB8fCAhIWFQYXRoLm1hdGNoKHVybFJlZ2V4cCk7XG59O1xuXG4vKipcbiAqIE1ha2UgYSBwYXRoIHJlbGF0aXZlIHRvIGEgVVJMIG9yIGFub3RoZXIgcGF0aC5cbiAqXG4gKiBAcGFyYW0gYVJvb3QgVGhlIHJvb3QgcGF0aCBvciBVUkwuXG4gKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgVVJMIHRvIGJlIG1hZGUgcmVsYXRpdmUgdG8gYVJvb3QuXG4gKi9cbmZ1bmN0aW9uIHJlbGF0aXZlKGFSb290LCBhUGF0aCkge1xuICBpZiAoYVJvb3QgPT09IFwiXCIpIHtcbiAgICBhUm9vdCA9IFwiLlwiO1xuICB9XG5cbiAgYVJvb3QgPSBhUm9vdC5yZXBsYWNlKC9cXC8kLywgJycpO1xuXG4gIC8vIEl0IGlzIHBvc3NpYmxlIGZvciB0aGUgcGF0aCB0byBiZSBhYm92ZSB0aGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBzaW1wbHlcbiAgLy8gY2hlY2tpbmcgd2hldGhlciB0aGUgcm9vdCBpcyBhIHByZWZpeCBvZiB0aGUgcGF0aCB3b24ndCB3b3JrLiBJbnN0ZWFkLCB3ZVxuICAvLyBuZWVkIHRvIHJlbW92ZSBjb21wb25lbnRzIGZyb20gdGhlIHJvb3Qgb25lIGJ5IG9uZSwgdW50aWwgZWl0aGVyIHdlIGZpbmRcbiAgLy8gYSBwcmVmaXggdGhhdCBmaXRzLCBvciB3ZSBydW4gb3V0IG9mIGNvbXBvbmVudHMgdG8gcmVtb3ZlLlxuICB2YXIgbGV2ZWwgPSAwO1xuICB3aGlsZSAoYVBhdGguaW5kZXhPZihhUm9vdCArICcvJykgIT09IDApIHtcbiAgICB2YXIgaW5kZXggPSBhUm9vdC5sYXN0SW5kZXhPZihcIi9cIik7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuIGFQYXRoO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBvbmx5IHBhcnQgb2YgdGhlIHJvb3QgdGhhdCBpcyBsZWZ0IGlzIHRoZSBzY2hlbWUgKGkuZS4gaHR0cDovLyxcbiAgICAvLyBmaWxlOi8vLywgZXRjLiksIG9uZSBvciBtb3JlIHNsYXNoZXMgKC8pLCBvciBzaW1wbHkgbm90aGluZyBhdCBhbGwsIHdlXG4gICAgLy8gaGF2ZSBleGhhdXN0ZWQgYWxsIGNvbXBvbmVudHMsIHNvIHRoZSBwYXRoIGlzIG5vdCByZWxhdGl2ZSB0byB0aGUgcm9vdC5cbiAgICBhUm9vdCA9IGFSb290LnNsaWNlKDAsIGluZGV4KTtcbiAgICBpZiAoYVJvb3QubWF0Y2goL14oW15cXC9dKzpcXC8pP1xcLyokLykpIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG5cbiAgICArK2xldmVsO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIHdlIGFkZCBhIFwiLi4vXCIgZm9yIGVhY2ggY29tcG9uZW50IHdlIHJlbW92ZWQgZnJvbSB0aGUgcm9vdC5cbiAgcmV0dXJuIEFycmF5KGxldmVsICsgMSkuam9pbihcIi4uL1wiKSArIGFQYXRoLnN1YnN0cihhUm9vdC5sZW5ndGggKyAxKTtcbn1cbmV4cG9ydHMucmVsYXRpdmUgPSByZWxhdGl2ZTtcblxudmFyIHN1cHBvcnRzTnVsbFByb3RvID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAhKCdfX3Byb3RvX18nIGluIG9iaik7XG59KCkpO1xuXG5mdW5jdGlvbiBpZGVudGl0eSAocykge1xuICByZXR1cm4gcztcbn1cblxuLyoqXG4gKiBCZWNhdXNlIGJlaGF2aW9yIGdvZXMgd2Fja3kgd2hlbiB5b3Ugc2V0IGBfX3Byb3RvX19gIG9uIG9iamVjdHMsIHdlXG4gKiBoYXZlIHRvIHByZWZpeCBhbGwgdGhlIHN0cmluZ3MgaW4gb3VyIHNldCB3aXRoIGFuIGFyYml0cmFyeSBjaGFyYWN0ZXIuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvcHVsbC8zMSBhbmRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvaXNzdWVzLzMwXG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbmZ1bmN0aW9uIHRvU2V0U3RyaW5nKGFTdHIpIHtcbiAgaWYgKGlzUHJvdG9TdHJpbmcoYVN0cikpIHtcbiAgICByZXR1cm4gJyQnICsgYVN0cjtcbiAgfVxuXG4gIHJldHVybiBhU3RyO1xufVxuZXhwb3J0cy50b1NldFN0cmluZyA9IHN1cHBvcnRzTnVsbFByb3RvID8gaWRlbnRpdHkgOiB0b1NldFN0cmluZztcblxuZnVuY3Rpb24gZnJvbVNldFN0cmluZyhhU3RyKSB7XG4gIGlmIChpc1Byb3RvU3RyaW5nKGFTdHIpKSB7XG4gICAgcmV0dXJuIGFTdHIuc2xpY2UoMSk7XG4gIH1cblxuICByZXR1cm4gYVN0cjtcbn1cbmV4cG9ydHMuZnJvbVNldFN0cmluZyA9IHN1cHBvcnRzTnVsbFByb3RvID8gaWRlbnRpdHkgOiBmcm9tU2V0U3RyaW5nO1xuXG5mdW5jdGlvbiBpc1Byb3RvU3RyaW5nKHMpIHtcbiAgaWYgKCFzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9IHMubGVuZ3RoO1xuXG4gIGlmIChsZW5ndGggPCA5IC8qIFwiX19wcm90b19fXCIubGVuZ3RoICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHMuY2hhckNvZGVBdChsZW5ndGggLSAxKSAhPT0gOTUgIC8qICdfJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDIpICE9PSA5NSAgLyogJ18nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gMykgIT09IDExMSAvKiAnbycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA0KSAhPT0gMTE2IC8qICd0JyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDUpICE9PSAxMTEgLyogJ28nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNikgIT09IDExNCAvKiAncicgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA3KSAhPT0gMTEyIC8qICdwJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDgpICE9PSA5NSAgLyogJ18nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gOSkgIT09IDk1ICAvKiAnXycgKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBpID0gbGVuZ3RoIC0gMTA7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKHMuY2hhckNvZGVBdChpKSAhPT0gMzYgLyogJyQnICovKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aGVyZSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAqXG4gKiBPcHRpb25hbGx5IHBhc3MgaW4gYHRydWVgIGFzIGBvbmx5Q29tcGFyZUdlbmVyYXRlZGAgdG8gY29uc2lkZXIgdHdvXG4gKiBtYXBwaW5ncyB3aXRoIHRoZSBzYW1lIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiwgYnV0IGRpZmZlcmVudCBnZW5lcmF0ZWRcbiAqIGxpbmUgYW5kIGNvbHVtbiB0aGUgc2FtZS4gVXNlZnVsIHdoZW4gc2VhcmNoaW5nIGZvciBhIG1hcHBpbmcgd2l0aCBhXG4gKiBzdHViYmVkIG91dCBtYXBwaW5nLlxuICovXG5mdW5jdGlvbiBjb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyhtYXBwaW5nQSwgbWFwcGluZ0IsIG9ubHlDb21wYXJlT3JpZ2luYWwpIHtcbiAgdmFyIGNtcCA9IG1hcHBpbmdBLnNvdXJjZSAtIG1hcHBpbmdCLnNvdXJjZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCB8fCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICByZXR1cm4gbWFwcGluZ0EubmFtZSAtIG1hcHBpbmdCLm5hbWU7XG59XG5leHBvcnRzLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zID0gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnM7XG5cbi8qKlxuICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aXRoIGRlZmxhdGVkIHNvdXJjZSBhbmQgbmFtZSBpbmRpY2VzIHdoZXJlXG4gKiB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gKlxuICogT3B0aW9uYWxseSBwYXNzIGluIGB0cnVlYCBhcyBgb25seUNvbXBhcmVHZW5lcmF0ZWRgIHRvIGNvbnNpZGVyIHR3b1xuICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uLCBidXQgZGlmZmVyZW50XG4gKiBzb3VyY2UvbmFtZS9vcmlnaW5hbCBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYVxuICogbWFwcGluZyB3aXRoIGEgc3R1YmJlZCBvdXQgbWFwcGluZy5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZUdlbmVyYXRlZCkge1xuICB2YXIgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICBpZiAoY21wICE9PSAwIHx8IG9ubHlDb21wYXJlR2VuZXJhdGVkKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLnNvdXJjZSAtIG1hcHBpbmdCLnNvdXJjZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICByZXR1cm4gbWFwcGluZ0EubmFtZSAtIG1hcHBpbmdCLm5hbWU7XG59XG5leHBvcnRzLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkID0gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQ7XG5cbmZ1bmN0aW9uIHN0cmNtcChhU3RyMSwgYVN0cjIpIHtcbiAgaWYgKGFTdHIxID09PSBhU3RyMikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKGFTdHIxID4gYVN0cjIpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdpdGggaW5mbGF0ZWQgc291cmNlIGFuZCBuYW1lIHN0cmluZ3Mgd2hlcmVcbiAqIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZ0EsIG1hcHBpbmdCKSB7XG4gIHZhciBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gc3RyY21wKG1hcHBpbmdBLnNvdXJjZSwgbWFwcGluZ0Iuc291cmNlKTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICByZXR1cm4gc3RyY21wKG1hcHBpbmdBLm5hbWUsIG1hcHBpbmdCLm5hbWUpO1xufVxuZXhwb3J0cy5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZCA9IGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDA5LTIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLnR4dCBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3IgPSByZXF1aXJlKCcuL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvcicpLlNvdXJjZU1hcEdlbmVyYXRvcjtcbmV4cG9ydHMuU291cmNlTWFwQ29uc3VtZXIgPSByZXF1aXJlKCcuL2xpYi9zb3VyY2UtbWFwLWNvbnN1bWVyJykuU291cmNlTWFwQ29uc3VtZXI7XG5leHBvcnRzLlNvdXJjZU5vZGUgPSByZXF1aXJlKCcuL2xpYi9zb3VyY2Utbm9kZScpLlNvdXJjZU5vZGU7XG4iLCIoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyBVbml2ZXJzYWwgTW9kdWxlIERlZmluaXRpb24gKFVNRCkgdG8gc3VwcG9ydCBBTUQsIENvbW1vbkpTL05vZGUuanMsIFJoaW5vLCBhbmQgYnJvd3NlcnMuXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKCdzdGFjay1nZW5lcmF0b3InLCBbJ3N0YWNrZnJhbWUnXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ3N0YWNrZnJhbWUnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5TdGFja0dlbmVyYXRvciA9IGZhY3Rvcnkocm9vdC5TdGFja0ZyYW1lKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uKFN0YWNrRnJhbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBiYWNrdHJhY2U6IGZ1bmN0aW9uIFN0YWNrR2VuZXJhdG9yJCRiYWNrdHJhY2Uob3B0cykge1xuICAgICAgICAgICAgdmFyIHN0YWNrID0gW107XG4gICAgICAgICAgICB2YXIgbWF4U3RhY2tTaXplID0gMTA7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9wdHMubWF4U3RhY2tTaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIG1heFN0YWNrU2l6ZSA9IG9wdHMubWF4U3RhY2tTaXplO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY3VyciA9IGFyZ3VtZW50cy5jYWxsZWU7XG4gICAgICAgICAgICB3aGlsZSAoY3VyciAmJiBzdGFjay5sZW5ndGggPCBtYXhTdGFja1NpemUgJiYgY3VyclsnYXJndW1lbnRzJ10pIHtcbiAgICAgICAgICAgICAgICAvLyBBbGxvdyBWOCBvcHRpbWl6YXRpb25zXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoY3VyclsnYXJndW1lbnRzJ10ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tpXSA9IGN1cnJbJ2FyZ3VtZW50cyddW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoL2Z1bmN0aW9uKD86XFxzKyhbXFx3JF0rKSkrXFxzKlxcKC8udGVzdChjdXJyLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gobmV3IFN0YWNrRnJhbWUoe2Z1bmN0aW9uTmFtZTogUmVnRXhwLiQxIHx8IHVuZGVmaW5lZCwgYXJnczogYXJnc30pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKG5ldyBTdGFja0ZyYW1lKHthcmdzOiBhcmdzfSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnIgPSBjdXJyLmNhbGxlcjtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdGFjaztcbiAgICAgICAgfVxuICAgIH07XG59KSk7XG4iLCIoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyBVbml2ZXJzYWwgTW9kdWxlIERlZmluaXRpb24gKFVNRCkgdG8gc3VwcG9ydCBBTUQsIENvbW1vbkpTL05vZGUuanMsIFJoaW5vLCBhbmQgYnJvd3NlcnMuXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKCdzdGFja2ZyYW1lJywgW10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuU3RhY2tGcmFtZSA9IGZhY3RvcnkoKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBmdW5jdGlvbiBfaXNOdW1iZXIobikge1xuICAgICAgICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jYXBpdGFsaXplKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZ2V0dGVyKHApIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbcF07XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGJvb2xlYW5Qcm9wcyA9IFsnaXNDb25zdHJ1Y3RvcicsICdpc0V2YWwnLCAnaXNOYXRpdmUnLCAnaXNUb3BsZXZlbCddO1xuICAgIHZhciBudW1lcmljUHJvcHMgPSBbJ2NvbHVtbk51bWJlcicsICdsaW5lTnVtYmVyJ107XG4gICAgdmFyIHN0cmluZ1Byb3BzID0gWydmaWxlTmFtZScsICdmdW5jdGlvbk5hbWUnLCAnc291cmNlJ107XG4gICAgdmFyIGFycmF5UHJvcHMgPSBbJ2FyZ3MnXTtcbiAgICB2YXIgb2JqZWN0UHJvcHMgPSBbJ2V2YWxPcmlnaW4nXTtcblxuICAgIHZhciBwcm9wcyA9IGJvb2xlYW5Qcm9wcy5jb25jYXQobnVtZXJpY1Byb3BzLCBzdHJpbmdQcm9wcywgYXJyYXlQcm9wcywgb2JqZWN0UHJvcHMpO1xuXG4gICAgZnVuY3Rpb24gU3RhY2tGcmFtZShvYmopIHtcbiAgICAgICAgaWYgKCFvYmopIHJldHVybjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG9ialtwcm9wc1tpXV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXNbJ3NldCcgKyBfY2FwaXRhbGl6ZShwcm9wc1tpXSldKG9ialtwcm9wc1tpXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgU3RhY2tGcmFtZS5wcm90b3R5cGUgPSB7XG4gICAgICAgIGdldEFyZ3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXJncztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0QXJnczogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2KSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3MgbXVzdCBiZSBhbiBBcnJheScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hcmdzID0gdjtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRFdmFsT3JpZ2luOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV2YWxPcmlnaW47XG4gICAgICAgIH0sXG4gICAgICAgIHNldEV2YWxPcmlnaW46IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIGlmICh2IGluc3RhbmNlb2YgU3RhY2tGcmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZhbE9yaWdpbiA9IHY7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2YWxPcmlnaW4gPSBuZXcgU3RhY2tGcmFtZSh2KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXZhbCBPcmlnaW4gbXVzdCBiZSBhbiBPYmplY3Qgb3IgU3RhY2tGcmFtZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBmaWxlTmFtZSA9IHRoaXMuZ2V0RmlsZU5hbWUoKSB8fCAnJztcbiAgICAgICAgICAgIHZhciBsaW5lTnVtYmVyID0gdGhpcy5nZXRMaW5lTnVtYmVyKCkgfHwgJyc7XG4gICAgICAgICAgICB2YXIgY29sdW1uTnVtYmVyID0gdGhpcy5nZXRDb2x1bW5OdW1iZXIoKSB8fCAnJztcbiAgICAgICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSB0aGlzLmdldEZ1bmN0aW9uTmFtZSgpIHx8ICcnO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0SXNFdmFsKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbZXZhbF0gKCcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnOicgKyBjb2x1bW5OdW1iZXIgKyAnKSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAnW2V2YWxdOicgKyBsaW5lTnVtYmVyICsgJzonICsgY29sdW1uTnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZ1bmN0aW9uTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbk5hbWUgKyAnICgnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJzonICsgY29sdW1uTnVtYmVyICsgJyknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICc6JyArIGNvbHVtbk51bWJlcjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTdGFja0ZyYW1lLmZyb21TdHJpbmcgPSBmdW5jdGlvbiBTdGFja0ZyYW1lJCRmcm9tU3RyaW5nKHN0cikge1xuICAgICAgICB2YXIgYXJnc1N0YXJ0SW5kZXggPSBzdHIuaW5kZXhPZignKCcpO1xuICAgICAgICB2YXIgYXJnc0VuZEluZGV4ID0gc3RyLmxhc3RJbmRleE9mKCcpJyk7XG5cbiAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IHN0ci5zdWJzdHJpbmcoMCwgYXJnc1N0YXJ0SW5kZXgpO1xuICAgICAgICB2YXIgYXJncyA9IHN0ci5zdWJzdHJpbmcoYXJnc1N0YXJ0SW5kZXggKyAxLCBhcmdzRW5kSW5kZXgpLnNwbGl0KCcsJyk7XG4gICAgICAgIHZhciBsb2NhdGlvblN0cmluZyA9IHN0ci5zdWJzdHJpbmcoYXJnc0VuZEluZGV4ICsgMSk7XG5cbiAgICAgICAgaWYgKGxvY2F0aW9uU3RyaW5nLmluZGV4T2YoJ0AnKSA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gL0AoLis/KSg/OjooXFxkKykpPyg/OjooXFxkKykpPyQvLmV4ZWMobG9jYXRpb25TdHJpbmcsICcnKTtcbiAgICAgICAgICAgIHZhciBmaWxlTmFtZSA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgdmFyIGxpbmVOdW1iZXIgPSBwYXJ0c1syXTtcbiAgICAgICAgICAgIHZhciBjb2x1bW5OdW1iZXIgPSBwYXJ0c1szXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgU3RhY2tGcmFtZSh7XG4gICAgICAgICAgICBmdW5jdGlvbk5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgIGFyZ3M6IGFyZ3MgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgZmlsZU5hbWU6IGZpbGVOYW1lLFxuICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlciB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICBjb2x1bW5OdW1iZXI6IGNvbHVtbk51bWJlciB8fCB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9vbGVhblByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIFN0YWNrRnJhbWUucHJvdG90eXBlWydnZXQnICsgX2NhcGl0YWxpemUoYm9vbGVhblByb3BzW2ldKV0gPSBfZ2V0dGVyKGJvb2xlYW5Qcm9wc1tpXSk7XG4gICAgICAgIFN0YWNrRnJhbWUucHJvdG90eXBlWydzZXQnICsgX2NhcGl0YWxpemUoYm9vbGVhblByb3BzW2ldKV0gPSAoZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICB0aGlzW3BdID0gQm9vbGVhbih2KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKGJvb2xlYW5Qcm9wc1tpXSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1lcmljUHJvcHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgU3RhY2tGcmFtZS5wcm90b3R5cGVbJ2dldCcgKyBfY2FwaXRhbGl6ZShudW1lcmljUHJvcHNbal0pXSA9IF9nZXR0ZXIobnVtZXJpY1Byb3BzW2pdKTtcbiAgICAgICAgU3RhY2tGcmFtZS5wcm90b3R5cGVbJ3NldCcgKyBfY2FwaXRhbGl6ZShudW1lcmljUHJvcHNbal0pXSA9IChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAgIGlmICghX2lzTnVtYmVyKHYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IocCArICcgbXVzdCBiZSBhIE51bWJlcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzW3BdID0gTnVtYmVyKHYpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkobnVtZXJpY1Byb3BzW2pdKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IHN0cmluZ1Byb3BzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIFN0YWNrRnJhbWUucHJvdG90eXBlWydnZXQnICsgX2NhcGl0YWxpemUoc3RyaW5nUHJvcHNba10pXSA9IF9nZXR0ZXIoc3RyaW5nUHJvcHNba10pO1xuICAgICAgICBTdGFja0ZyYW1lLnByb3RvdHlwZVsnc2V0JyArIF9jYXBpdGFsaXplKHN0cmluZ1Byb3BzW2tdKV0gPSAoZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICB0aGlzW3BdID0gU3RyaW5nKHYpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoc3RyaW5nUHJvcHNba10pO1xuICAgIH1cblxuICAgIHJldHVybiBTdGFja0ZyYW1lO1xufSkpO1xuIiwiKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uIChVTUQpIHRvIHN1cHBvcnQgQU1ELCBDb21tb25KUy9Ob2RlLmpzLCBSaGlubywgYW5kIGJyb3dzZXJzLlxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZSgnc3RhY2t0cmFjZS1ncHMnLCBbJ3NvdXJjZS1tYXAnLCAnc3RhY2tmcmFtZSddLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnc291cmNlLW1hcC9saWIvc291cmNlLW1hcC1jb25zdW1lcicpLCByZXF1aXJlKCdzdGFja2ZyYW1lJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuU3RhY2tUcmFjZUdQUyA9IGZhY3Rvcnkocm9vdC5Tb3VyY2VNYXAgfHwgcm9vdC5zb3VyY2VNYXAsIHJvb3QuU3RhY2tGcmFtZSk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbihTb3VyY2VNYXAsIFN0YWNrRnJhbWUpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGEgWC1Eb21haW4gcmVxdWVzdCB0byB1cmwgYW5kIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSB3aXRoIHJlc3BvbnNlIHRleHQgaWYgZnVsZmlsbGVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gX3hkcih1cmwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgcmVxLm9wZW4oJ2dldCcsIHVybCk7XG4gICAgICAgICAgICByZXEub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgICAgIHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiBvbnJlYWR5c3RhdGVjaGFuZ2UoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcS5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgocmVxLnN0YXR1cyA+PSAyMDAgJiYgcmVxLnN0YXR1cyA8IDMwMCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICh1cmwuc3Vic3RyKDAsIDcpID09PSAnZmlsZTovLycgJiYgcmVxLnJlc3BvbnNlVGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVxLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdIVFRQIHN0YXR1czogJyArIHJlcS5zdGF0dXMgKyAnIHJldHJpZXZpbmcgJyArIHVybCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlcS5zZW5kKCk7XG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIEJhc2U2NC1lbmNvZGVkIHN0cmluZyBpbnRvIGl0cyBvcmlnaW5hbCByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBVc2VkIGZvciBpbmxpbmUgc291cmNlbWFwcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBiNjRzdHIgQmFzZS02NCBlbmNvZGVkIHN0cmluZ1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IG9yaWdpbmFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBiYXNlNjQtZW5jb2RlZCBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2F0b2IoYjY0c3RyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuYXRvYikge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5hdG9iKGI2NHN0cik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHN1cHBseSBhIHBvbHlmaWxsIGZvciB3aW5kb3cuYXRvYiBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfcGFyc2VKc29uKHN0cmluZykge1xuICAgICAgICBpZiAodHlwZW9mIEpTT04gIT09ICd1bmRlZmluZWQnICYmIEpTT04ucGFyc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHN0cmluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHN1cHBseSBhIHBvbHlmaWxsIGZvciBKU09OLnBhcnNlIGluIHRoaXMgZW52aXJvbm1lbnQnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9maW5kRnVuY3Rpb25OYW1lKHNvdXJjZSwgbGluZU51bWJlci8qLCBjb2x1bW5OdW1iZXIqLykge1xuICAgICAgICB2YXIgc3ludGF4ZXMgPSBbXG4gICAgICAgICAgICAvLyB7bmFtZX0gPSBmdW5jdGlvbiAoe2FyZ3N9KSBUT0RPIGFyZ3MgY2FwdHVyZVxuICAgICAgICAgICAgL1snXCJdPyhbJF9BLVphLXpdWyRfQS1aYS16MC05XSopWydcIl0/XFxzKls6PV1cXHMqZnVuY3Rpb25cXGIvLFxuICAgICAgICAgICAgLy8gZnVuY3Rpb24ge25hbWV9KHthcmdzfSkgbVsxXT1uYW1lIG1bMl09YXJnc1xuICAgICAgICAgICAgL2Z1bmN0aW9uXFxzKyhbXignXCJgXSo/KVxccypcXCgoW14pXSopXFwpLyxcbiAgICAgICAgICAgIC8vIHtuYW1lfSA9IGV2YWwoKVxuICAgICAgICAgICAgL1snXCJdPyhbJF9BLVphLXpdWyRfQS1aYS16MC05XSopWydcIl0/XFxzKls6PV1cXHMqKD86ZXZhbHxuZXcgRnVuY3Rpb24pXFxiLyxcbiAgICAgICAgICAgIC8vIGZuX25hbWUoKSB7XG4gICAgICAgICAgICAvXFxiKD8hKD86aWZ8Zm9yfHN3aXRjaHx3aGlsZXx3aXRofGNhdGNoKVxcYikoPzooPzpzdGF0aWMpXFxzKyk/KFxcUyspXFxzKlxcKC4qP1xcKVxccypcXHsvLFxuICAgICAgICAgICAgLy8ge25hbWV9ID0gKCkgPT4ge1xuICAgICAgICAgICAgL1snXCJdPyhbJF9BLVphLXpdWyRfQS1aYS16MC05XSopWydcIl0/XFxzKls6PV1cXHMqXFwoLio/XFwpXFxzKj0+L1xuICAgICAgICBdO1xuICAgICAgICB2YXIgbGluZXMgPSBzb3VyY2Uuc3BsaXQoJ1xcbicpO1xuXG4gICAgICAgIC8vIFdhbGsgYmFja3dhcmRzIGluIHRoZSBzb3VyY2UgbGluZXMgdW50aWwgd2UgZmluZCB0aGUgbGluZSB3aGljaCBtYXRjaGVzIG9uZSBvZiB0aGUgcGF0dGVybnMgYWJvdmVcbiAgICAgICAgdmFyIGNvZGUgPSAnJztcbiAgICAgICAgdmFyIG1heExpbmVzID0gTWF0aC5taW4obGluZU51bWJlciwgMjApO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heExpbmVzOyArK2kpIHtcbiAgICAgICAgICAgIC8vIGxpbmVObyBpcyAxLWJhc2VkLCBzb3VyY2VbXSBpcyAwLWJhc2VkXG4gICAgICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2xpbmVOdW1iZXIgLSBpIC0gMV07XG4gICAgICAgICAgICB2YXIgY29tbWVudFBvcyA9IGxpbmUuaW5kZXhPZignLy8nKTtcbiAgICAgICAgICAgIGlmIChjb21tZW50UG9zID49IDApIHtcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5zdWJzdHIoMCwgY29tbWVudFBvcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IGxpbmUgKyBjb2RlO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBzeW50YXhlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbjsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IHN5bnRheGVzW2luZGV4XS5leGVjKGNvZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobSAmJiBtWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbVsxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9lbnN1cmVTdXBwb3J0ZWRFbnZpcm9ubWVudCgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZGVmaW5lUHJvcGVydHkgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIE9iamVjdC5jcmVhdGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGNvbnN1bWUgc291cmNlIG1hcHMgaW4gb2xkZXIgYnJvd3NlcnMnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9lbnN1cmVTdGFja0ZyYW1lSXNMZWdpdChzdGFja2ZyYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhY2tmcmFtZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0dpdmVuIFN0YWNrRnJhbWUgaXMgbm90IGFuIG9iamVjdCcpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdGFja2ZyYW1lLmZpbGVOYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignR2l2ZW4gZmlsZSBuYW1lIGlzIG5vdCBhIFN0cmluZycpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdGFja2ZyYW1lLmxpbmVOdW1iZXIgIT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICBzdGFja2ZyYW1lLmxpbmVOdW1iZXIgJSAxICE9PSAwIHx8XG4gICAgICAgICAgICBzdGFja2ZyYW1lLmxpbmVOdW1iZXIgPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdHaXZlbiBsaW5lIG51bWJlciBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdGFja2ZyYW1lLmNvbHVtbk51bWJlciAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgICAgIHN0YWNrZnJhbWUuY29sdW1uTnVtYmVyICUgMSAhPT0gMCB8fFxuICAgICAgICAgICAgc3RhY2tmcmFtZS5jb2x1bW5OdW1iZXIgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdHaXZlbiBjb2x1bW4gbnVtYmVyIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlcicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9maW5kU291cmNlTWFwcGluZ1VSTChzb3VyY2UpIHtcbiAgICAgICAgdmFyIHNvdXJjZU1hcHBpbmdVcmxSZWdFeHAgPSAvXFwvXFwvWyNAXSA/c291cmNlTWFwcGluZ1VSTD0oW15cXHMnXCJdKylcXHMqJC9tZztcbiAgICAgICAgdmFyIGxhc3RTb3VyY2VNYXBwaW5nVXJsO1xuICAgICAgICB2YXIgbWF0Y2hTb3VyY2VNYXBwaW5nVXJsO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICAgICAgd2hpbGUgKG1hdGNoU291cmNlTWFwcGluZ1VybCA9IHNvdXJjZU1hcHBpbmdVcmxSZWdFeHAuZXhlYyhzb3VyY2UpKSB7XG4gICAgICAgICAgICBsYXN0U291cmNlTWFwcGluZ1VybCA9IG1hdGNoU291cmNlTWFwcGluZ1VybFsxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdFNvdXJjZU1hcHBpbmdVcmwpIHtcbiAgICAgICAgICAgIHJldHVybiBsYXN0U291cmNlTWFwcGluZ1VybDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc291cmNlTWFwcGluZ1VSTCBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9leHRyYWN0TG9jYXRpb25JbmZvRnJvbVNvdXJjZU1hcFNvdXJjZShzdGFja2ZyYW1lLCBzb3VyY2VNYXBDb25zdW1lciwgc291cmNlQ2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIGxvYyA9IHNvdXJjZU1hcENvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe1xuICAgICAgICAgICAgICAgIGxpbmU6IHN0YWNrZnJhbWUubGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBjb2x1bW46IHN0YWNrZnJhbWUuY29sdW1uTnVtYmVyXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGxvYy5zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAvLyBjYWNoZSBtYXBwZWQgc291cmNlc1xuICAgICAgICAgICAgICAgIHZhciBtYXBwZWRTb3VyY2UgPSBzb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKGxvYy5zb3VyY2UpO1xuICAgICAgICAgICAgICAgIGlmIChtYXBwZWRTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlQ2FjaGVbbG9jLnNvdXJjZV0gPSBtYXBwZWRTb3VyY2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2l2ZW4gc3RhY2tmcmFtZSBhbmQgc291cmNlIGxvY2F0aW9uLCB1cGRhdGUgc3RhY2tmcmFtZVxuICAgICAgICAgICAgICAgICAgICBuZXcgU3RhY2tGcmFtZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IGxvYy5uYW1lIHx8IHN0YWNrZnJhbWUuZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogc3RhY2tmcmFtZS5hcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWU6IGxvYy5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsb2MubGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbk51bWJlcjogbG9jLmNvbHVtblxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgb3JpZ2luYWwgc291cmNlIGZvciBnaXZlbiBzdGFja2ZyYW1lIGFuZCBzb3VyY2UgbWFwJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqICAgICAgb3B0cy5zb3VyY2VDYWNoZSA9IHt1cmw6IFwiU291cmNlIFN0cmluZ1wifSA9PiBwcmVsb2FkIHNvdXJjZSBjYWNoZVxuICAgICAqICAgICAgb3B0cy5zb3VyY2VNYXBDb25zdW1lckNhY2hlID0gey9wYXRoL2ZpbGUuanMubWFwOiBTb3VyY2VNYXBDb25zdW1lcn1cbiAgICAgKiAgICAgIG9wdHMub2ZmbGluZSA9IFRydWUgdG8gcHJldmVudCBuZXR3b3JrIHJlcXVlc3RzLlxuICAgICAqICAgICAgICAgICAgICBCZXN0IGVmZm9ydCB3aXRob3V0IHNvdXJjZXMgb3Igc291cmNlIG1hcHMuXG4gICAgICogICAgICBvcHRzLmFqYXggPSBQcm9taXNlIHJldHVybmluZyBmdW5jdGlvbiB0byBtYWtlIFgtRG9tYWluIHJlcXVlc3RzXG4gICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uIFN0YWNrVHJhY2VHUFMob3B0cykge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3RhY2tUcmFjZUdQUykpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RhY2tUcmFjZUdQUyhvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgICAgICB0aGlzLnNvdXJjZUNhY2hlID0gb3B0cy5zb3VyY2VDYWNoZSB8fCB7fTtcbiAgICAgICAgdGhpcy5zb3VyY2VNYXBDb25zdW1lckNhY2hlID0gb3B0cy5zb3VyY2VNYXBDb25zdW1lckNhY2hlIHx8IHt9O1xuXG4gICAgICAgIHRoaXMuYWpheCA9IG9wdHMuYWpheCB8fCBfeGRyO1xuXG4gICAgICAgIHRoaXMuX2F0b2IgPSBvcHRzLmF0b2IgfHwgX2F0b2I7XG5cbiAgICAgICAgdGhpcy5fZ2V0ID0gZnVuY3Rpb24gX2dldChsb2NhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBpc0RhdGFVcmwgPSBsb2NhdGlvbi5zdWJzdHIoMCwgNSkgPT09ICdkYXRhOic7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlQ2FjaGVbbG9jYXRpb25dKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5zb3VyY2VDYWNoZVtsb2NhdGlvbl0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0cy5vZmZsaW5lICYmICFpc0RhdGFVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignQ2Fubm90IG1ha2UgbmV0d29yayByZXF1ZXN0cyBpbiBvZmZsaW5lIG1vZGUnKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGF0YVVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGF0YSBVUkxzIGNhbiBoYXZlIHBhcmFtZXRlcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZWUgaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjM5N1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1cHBvcnRlZEVuY29kaW5nUmVnZXhwID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvXmRhdGE6YXBwbGljYXRpb25cXC9qc29uOyhbXFx3PTpcIi1dKzspKmJhc2U2NCwvO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gbG9jYXRpb24ubWF0Y2goc3VwcG9ydGVkRW5jb2RpbmdSZWdleHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZU1hcFN0YXJ0ID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmNvZGVkU291cmNlID0gbG9jYXRpb24uc3Vic3RyKHNvdXJjZU1hcFN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gdGhpcy5fYXRvYihlbmNvZGVkU291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZUNhY2hlW2xvY2F0aW9uXSA9IHNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1RoZSBlbmNvZGluZyBvZiB0aGUgaW5saW5lIHNvdXJjZW1hcCBpcyBub3Qgc3VwcG9ydGVkJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhoclByb21pc2UgPSB0aGlzLmFqYXgobG9jYXRpb24sIHttZXRob2Q6ICdnZXQnfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSB0aGUgUHJvbWlzZSB0byBwcmV2ZW50IGR1cGxpY2F0ZSBpbi1mbGlnaHQgcmVxdWVzdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc291cmNlQ2FjaGVbbG9jYXRpb25dID0geGhyUHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoclByb21pc2UudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRpbmcgU291cmNlTWFwQ29uc3VtZXJzIGlzIGV4cGVuc2l2ZSwgc28gdGhpcyB3cmFwcyB0aGUgY3JlYXRpb24gb2YgYVxuICAgICAgICAgKiBTb3VyY2VNYXBDb25zdW1lciBpbiBhIHBlci1pbnN0YW5jZSBjYWNoZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNvdXJjZU1hcHBpbmdVUkwgPSBVUkwgdG8gZmV0Y2ggc291cmNlIG1hcCBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkZWZhdWx0U291cmNlUm9vdCA9IERlZmF1bHQgc291cmNlIHJvb3QgZm9yIHNvdXJjZSBtYXAgaWYgdW5kZWZpbmVkXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSB0aGF0IHJlc29sdmVzIGEgU291cmNlTWFwQ29uc3VtZXJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2dldFNvdXJjZU1hcENvbnN1bWVyID0gZnVuY3Rpb24gX2dldFNvdXJjZU1hcENvbnN1bWVyKHNvdXJjZU1hcHBpbmdVUkwsIGRlZmF1bHRTb3VyY2VSb290KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZU1hcENvbnN1bWVyQ2FjaGVbc291cmNlTWFwcGluZ1VSTF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnNvdXJjZU1hcENvbnN1bWVyQ2FjaGVbc291cmNlTWFwcGluZ1VSTF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VNYXBDb25zdW1lclByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXQoc291cmNlTWFwcGluZ1VSTCkudGhlbihmdW5jdGlvbihzb3VyY2VNYXBTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZU1hcFNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlTWFwU291cmNlID0gX3BhcnNlSnNvbihzb3VyY2VNYXBTb3VyY2UucmVwbGFjZSgvXlxcKVxcXVxcfScvLCAnJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZU1hcFNvdXJjZS5zb3VyY2VSb290ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VNYXBTb3VyY2Uuc291cmNlUm9vdCA9IGRlZmF1bHRTb3VyY2VSb290O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobmV3IFNvdXJjZU1hcC5Tb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXBTb3VyY2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc291cmNlTWFwQ29uc3VtZXJDYWNoZVtzb3VyY2VNYXBwaW5nVVJMXSA9IHNvdXJjZU1hcENvbnN1bWVyUHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzb3VyY2VNYXBDb25zdW1lclByb21pc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIGEgU3RhY2tGcmFtZSwgZW5oYW5jZSBmdW5jdGlvbiBuYW1lIGFuZCB1c2Ugc291cmNlIG1hcHMgZm9yIGFcbiAgICAgICAgICogYmV0dGVyIFN0YWNrRnJhbWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RhY2tGcmFtZX0gc3RhY2tmcmFtZSBvYmplY3RcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IHRoYXQgcmVzb2x2ZXMgd2l0aCB3aXRoIHNvdXJjZS1tYXBwZWQgU3RhY2tGcmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5waW5wb2ludCA9IGZ1bmN0aW9uIFN0YWNrVHJhY2VHUFMkJHBpbnBvaW50KHN0YWNrZnJhbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldE1hcHBlZExvY2F0aW9uKHN0YWNrZnJhbWUpLnRoZW4oZnVuY3Rpb24obWFwcGVkU3RhY2tGcmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiByZXNvbHZlTWFwcGVkU3RhY2tGcmFtZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobWFwcGVkU3RhY2tGcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmRGdW5jdGlvbk5hbWUobWFwcGVkU3RhY2tGcmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKHJlc29sdmUsIHJlc29sdmVNYXBwZWRTdGFja0ZyYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICBbJ2NhdGNoJ10ocmVzb2x2ZU1hcHBlZFN0YWNrRnJhbWUpO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIGEgU3RhY2tGcmFtZSwgZ3Vlc3MgZnVuY3Rpb24gbmFtZSBmcm9tIGxvY2F0aW9uIGluZm9ybWF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0YWNrRnJhbWV9IHN0YWNrZnJhbWVcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IHRoYXQgcmVzb2x2ZXMgd2l0aCBlbmhhbmNlZCBTdGFja0ZyYW1lLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maW5kRnVuY3Rpb25OYW1lID0gZnVuY3Rpb24gU3RhY2tUcmFjZUdQUyQkZmluZEZ1bmN0aW9uTmFtZShzdGFja2ZyYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgX2Vuc3VyZVN0YWNrRnJhbWVJc0xlZ2l0KHN0YWNrZnJhbWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2dldChzdGFja2ZyYW1lLmZpbGVOYW1lKS50aGVuKGZ1bmN0aW9uIGdldFNvdXJjZUNhbGxiYWNrKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZU51bWJlciA9IHN0YWNrZnJhbWUubGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbHVtbk51bWJlciA9IHN0YWNrZnJhbWUuY29sdW1uTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ3Vlc3NlZEZ1bmN0aW9uTmFtZSA9IF9maW5kRnVuY3Rpb25OYW1lKHNvdXJjZSwgbGluZU51bWJlciwgY29sdW1uTnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSByZXBsYWNlIGZ1bmN0aW9uTmFtZSBpZiB3ZSBmb3VuZCBzb21ldGhpbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKGd1ZXNzZWRGdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogZ3Vlc3NlZEZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBzdGFja2ZyYW1lLmFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWU6IHN0YWNrZnJhbWUuZmlsZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5OdW1iZXI6IGNvbHVtbk51bWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzdGFja2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHJlamVjdClbJ2NhdGNoJ10ocmVqZWN0KTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIGEgU3RhY2tGcmFtZSwgc2VlayBzb3VyY2UtbWFwcGVkIGxvY2F0aW9uIGFuZCByZXR1cm4gbmV3IGVuaGFuY2VkIFN0YWNrRnJhbWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RhY2tGcmFtZX0gc3RhY2tmcmFtZVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gdGhhdCByZXNvbHZlcyB3aXRoIGVuaGFuY2VkIFN0YWNrRnJhbWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldE1hcHBlZExvY2F0aW9uID0gZnVuY3Rpb24gU3RhY2tUcmFjZUdQUyQkZ2V0TWFwcGVkTG9jYXRpb24oc3RhY2tmcmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIF9lbnN1cmVTdXBwb3J0ZWRFbnZpcm9ubWVudCgpO1xuICAgICAgICAgICAgICAgIF9lbnN1cmVTdGFja0ZyYW1lSXNMZWdpdChzdGFja2ZyYW1lKTtcblxuICAgICAgICAgICAgICAgIHZhciBzb3VyY2VDYWNoZSA9IHRoaXMuc291cmNlQ2FjaGU7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGVOYW1lID0gc3RhY2tmcmFtZS5maWxlTmFtZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9nZXQoZmlsZU5hbWUpLnRoZW4oZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VNYXBwaW5nVVJMID0gX2ZpbmRTb3VyY2VNYXBwaW5nVVJMKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpc0RhdGFVcmwgPSBzb3VyY2VNYXBwaW5nVVJMLnN1YnN0cigwLCA1KSA9PT0gJ2RhdGE6JztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRTb3VyY2VSb290ID0gZmlsZU5hbWUuc3Vic3RyaW5nKDAsIGZpbGVOYW1lLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlTWFwcGluZ1VSTFswXSAhPT0gJy8nICYmICFpc0RhdGFVcmwgJiYgISgvXmh0dHBzPzpcXC9cXC98XlxcL1xcLy9pKS50ZXN0KHNvdXJjZU1hcHBpbmdVUkwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VNYXBwaW5nVVJMID0gZGVmYXVsdFNvdXJjZVJvb3QgKyBzb3VyY2VNYXBwaW5nVVJMO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFNvdXJjZU1hcENvbnN1bWVyKHNvdXJjZU1hcHBpbmdVUkwsIGRlZmF1bHRTb3VyY2VSb290KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oc291cmNlTWFwQ29uc3VtZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2V4dHJhY3RMb2NhdGlvbkluZm9Gcm9tU291cmNlTWFwU291cmNlKHN0YWNrZnJhbWUsIHNvdXJjZU1hcENvbnN1bWVyLCBzb3VyY2VDYWNoZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZSlbJ2NhdGNoJ10oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHN0YWNrZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgcmVqZWN0KVsnY2F0Y2gnXShyZWplY3QpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfTtcbiAgICB9O1xufSkpO1xuIiwiKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uIChVTUQpIHRvIHN1cHBvcnQgQU1ELCBDb21tb25KUy9Ob2RlLmpzLCBSaGlubywgYW5kIGJyb3dzZXJzLlxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZSgnc3RhY2t0cmFjZScsIFsnZXJyb3Itc3RhY2stcGFyc2VyJywgJ3N0YWNrLWdlbmVyYXRvcicsICdzdGFja3RyYWNlLWdwcyddLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnZXJyb3Itc3RhY2stcGFyc2VyJyksIHJlcXVpcmUoJ3N0YWNrLWdlbmVyYXRvcicpLCByZXF1aXJlKCdzdGFja3RyYWNlLWdwcycpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LlN0YWNrVHJhY2UgPSBmYWN0b3J5KHJvb3QuRXJyb3JTdGFja1BhcnNlciwgcm9vdC5TdGFja0dlbmVyYXRvciwgcm9vdC5TdGFja1RyYWNlR1BTKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uIFN0YWNrVHJhY2UoRXJyb3JTdGFja1BhcnNlciwgU3RhY2tHZW5lcmF0b3IsIFN0YWNrVHJhY2VHUFMpIHtcbiAgICB2YXIgX29wdGlvbnMgPSB7XG4gICAgICAgIGZpbHRlcjogZnVuY3Rpb24oc3RhY2tmcmFtZSkge1xuICAgICAgICAgICAgLy8gRmlsdGVyIG91dCBzdGFja2ZyYW1lcyBmb3IgdGhpcyBsaWJyYXJ5IGJ5IGRlZmF1bHRcbiAgICAgICAgICAgIHJldHVybiAoc3RhY2tmcmFtZS5mdW5jdGlvbk5hbWUgfHwgJycpLmluZGV4T2YoJ1N0YWNrVHJhY2UkJCcpID09PSAtMSAmJlxuICAgICAgICAgICAgICAgIChzdGFja2ZyYW1lLmZ1bmN0aW9uTmFtZSB8fCAnJykuaW5kZXhPZignRXJyb3JTdGFja1BhcnNlciQkJykgPT09IC0xICYmXG4gICAgICAgICAgICAgICAgKHN0YWNrZnJhbWUuZnVuY3Rpb25OYW1lIHx8ICcnKS5pbmRleE9mKCdTdGFja1RyYWNlR1BTJCQnKSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICAoc3RhY2tmcmFtZS5mdW5jdGlvbk5hbWUgfHwgJycpLmluZGV4T2YoJ1N0YWNrR2VuZXJhdG9yJCQnKSA9PT0gLTE7XG4gICAgICAgIH0sXG4gICAgICAgIHNvdXJjZUNhY2hlOiB7fVxuICAgIH07XG5cbiAgICB2YXIgX2dlbmVyYXRlRXJyb3IgPSBmdW5jdGlvbiBTdGFja1RyYWNlJCRHZW5lcmF0ZUVycm9yKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gRXJyb3IgbXVzdCBiZSB0aHJvd24gdG8gZ2V0IHN0YWNrIGluIElFXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1lcmdlIDIgZ2l2ZW4gT2JqZWN0cy4gSWYgYSBjb25mbGljdCBvY2N1cnMgdGhlIHNlY29uZCBvYmplY3Qgd2lucy5cbiAgICAgKiBEb2VzIG5vdCBkbyBkZWVwIG1lcmdlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmaXJzdCBiYXNlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZWNvbmQgb3ZlcnJpZGVzXG4gICAgICogQHJldHVybnMge09iamVjdH0gbWVyZ2VkIGZpcnN0IGFuZCBzZWNvbmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9tZXJnZShmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB7fTtcblxuICAgICAgICBbZmlyc3QsIHNlY29uZF0uZm9yRWFjaChmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9pc1NoYXBlZExpa2VQYXJzYWJsZUVycm9yKGVycikge1xuICAgICAgICByZXR1cm4gZXJyLnN0YWNrIHx8IGVyclsnb3BlcmEjc291cmNlbG9jJ107XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2ZpbHRlcmVkKHN0YWNrZnJhbWVzLCBmaWx0ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFja2ZyYW1lcy5maWx0ZXIoZmlsdGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhY2tmcmFtZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhIGJhY2t0cmFjZSBmcm9tIGludm9jYXRpb24gcG9pbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheX0gb2YgU3RhY2tGcmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBTdGFja1RyYWNlJCRnZXQob3B0cykge1xuICAgICAgICAgICAgdmFyIGVyciA9IF9nZW5lcmF0ZUVycm9yKCk7XG4gICAgICAgICAgICByZXR1cm4gX2lzU2hhcGVkTGlrZVBhcnNhYmxlRXJyb3IoZXJyKSA/IHRoaXMuZnJvbUVycm9yKGVyciwgb3B0cykgOiB0aGlzLmdlbmVyYXRlQXJ0aWZpY2lhbGx5KG9wdHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYSBiYWNrdHJhY2UgZnJvbSBpbnZvY2F0aW9uIHBvaW50LlxuICAgICAgICAgKiBJTVBPUlRBTlQ6IERvZXMgbm90IGhhbmRsZSBzb3VyY2UgbWFwcyBvciBndWVzcyBmdW5jdGlvbiBuYW1lcyFcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgICAgICogQHJldHVybnMge0FycmF5fSBvZiBTdGFja0ZyYW1lXG4gICAgICAgICAqL1xuICAgICAgICBnZXRTeW5jOiBmdW5jdGlvbiBTdGFja1RyYWNlJCRnZXRTeW5jKG9wdHMpIHtcbiAgICAgICAgICAgIG9wdHMgPSBfbWVyZ2UoX29wdGlvbnMsIG9wdHMpO1xuICAgICAgICAgICAgdmFyIGVyciA9IF9nZW5lcmF0ZUVycm9yKCk7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBfaXNTaGFwZWRMaWtlUGFyc2FibGVFcnJvcihlcnIpID8gRXJyb3JTdGFja1BhcnNlci5wYXJzZShlcnIpIDogU3RhY2tHZW5lcmF0b3IuYmFja3RyYWNlKG9wdHMpO1xuICAgICAgICAgICAgcmV0dXJuIF9maWx0ZXJlZChzdGFjaywgb3B0cy5maWx0ZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlbiBhbiBlcnJvciBvYmplY3QsIHBhcnNlIGl0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Vycm9yfSBlcnJvciBvYmplY3RcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IGZvciBBcnJheVtTdGFja0ZyYW1lfVxuICAgICAgICAgKi9cbiAgICAgICAgZnJvbUVycm9yOiBmdW5jdGlvbiBTdGFja1RyYWNlJCRmcm9tRXJyb3IoZXJyb3IsIG9wdHMpIHtcbiAgICAgICAgICAgIG9wdHMgPSBfbWVyZ2UoX29wdGlvbnMsIG9wdHMpO1xuICAgICAgICAgICAgdmFyIGdwcyA9IG5ldyBTdGFja1RyYWNlR1BTKG9wdHMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2tmcmFtZXMgPSBfZmlsdGVyZWQoRXJyb3JTdGFja1BhcnNlci5wYXJzZShlcnJvciksIG9wdHMuZmlsdGVyKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKFByb21pc2UuYWxsKHN0YWNrZnJhbWVzLm1hcChmdW5jdGlvbihzZikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZU9yaWdpbmFsKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoc2YpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBncHMucGlucG9pbnQoc2YpLnRoZW4ocmVzb2x2ZSwgcmVzb2x2ZU9yaWdpbmFsKVsnY2F0Y2gnXShyZXNvbHZlT3JpZ2luYWwpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXNlIFN0YWNrR2VuZXJhdG9yIHRvIGdlbmVyYXRlIGEgYmFja3RyYWNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gb2YgQXJyYXlbU3RhY2tGcmFtZV1cbiAgICAgICAgICovXG4gICAgICAgIGdlbmVyYXRlQXJ0aWZpY2lhbGx5OiBmdW5jdGlvbiBTdGFja1RyYWNlJCRnZW5lcmF0ZUFydGlmaWNpYWxseShvcHRzKSB7XG4gICAgICAgICAgICBvcHRzID0gX21lcmdlKF9vcHRpb25zLCBvcHRzKTtcbiAgICAgICAgICAgIHZhciBzdGFja0ZyYW1lcyA9IFN0YWNrR2VuZXJhdG9yLmJhY2t0cmFjZShvcHRzKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0cy5maWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBzdGFja0ZyYW1lcyA9IHN0YWNrRnJhbWVzLmZpbHRlcihvcHRzLmZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHN0YWNrRnJhbWVzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2l2ZW4gYSBmdW5jdGlvbiwgd3JhcCBpdCBzdWNoIHRoYXQgaW52b2NhdGlvbnMgdHJpZ2dlciBhIGNhbGxiYWNrIHRoYXRcbiAgICAgICAgICogaXMgY2FsbGVkIHdpdGggYSBzdGFjayB0cmFjZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gdG8gYmUgaW5zdHJ1bWVudGVkXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGNhbGwgd2l0aCBhIHN0YWNrIHRyYWNlIG9uIGludm9jYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXJyYmFjayBvcHRpb25hbCBmdW5jdGlvbiB0byBjYWxsIHdpdGggZXJyb3IgaWYgdW5hYmxlIHRvIGdldCBzdGFjayB0cmFjZS5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHRoaXNBcmcgb3B0aW9uYWwgY29udGV4dCBvYmplY3QgKGUuZy4gd2luZG93KVxuICAgICAgICAgKi9cbiAgICAgICAgaW5zdHJ1bWVudDogZnVuY3Rpb24gU3RhY2tUcmFjZSQkaW5zdHJ1bWVudChmbiwgY2FsbGJhY2ssIGVycmJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnN0cnVtZW50IG5vbi1mdW5jdGlvbiBvYmplY3QnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZuLl9fc3RhY2t0cmFjZU9yaWdpbmFsRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBBbHJlYWR5IGluc3RydW1lbnRlZCwgcmV0dXJuIGdpdmVuIEZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaW5zdHJ1bWVudGVkID0gZnVuY3Rpb24gU3RhY2tUcmFjZSQkaW5zdHJ1bWVudGVkKCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0KCkudGhlbihjYWxsYmFjaywgZXJyYmFjaylbJ2NhdGNoJ10oZXJyYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnIHx8IHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2lzU2hhcGVkTGlrZVBhcnNhYmxlRXJyb3IoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZnJvbUVycm9yKGUpLnRoZW4oY2FsbGJhY2ssIGVycmJhY2spWydjYXRjaCddKGVycmJhY2spO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgaW5zdHJ1bWVudGVkLl9fc3RhY2t0cmFjZU9yaWdpbmFsRm4gPSBmbjtcblxuICAgICAgICAgICAgcmV0dXJuIGluc3RydW1lbnRlZDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2l2ZW4gYSBmdW5jdGlvbiB0aGF0IGhhcyBiZWVuIGluc3RydW1lbnRlZCxcbiAgICAgICAgICogcmV2ZXJ0IHRoZSBmdW5jdGlvbiB0byBpdCdzIG9yaWdpbmFsIChub24taW5zdHJ1bWVudGVkKSBzdGF0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gdG8gZGUtaW5zdHJ1bWVudFxuICAgICAgICAgKi9cbiAgICAgICAgZGVpbnN0cnVtZW50OiBmdW5jdGlvbiBTdGFja1RyYWNlJCRkZWluc3RydW1lbnQoZm4pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBkZS1pbnN0cnVtZW50IG5vbi1mdW5jdGlvbiBvYmplY3QnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZuLl9fc3RhY2t0cmFjZU9yaWdpbmFsRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uX19zdGFja3RyYWNlT3JpZ2luYWxGbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRnVuY3Rpb24gbm90IGluc3RydW1lbnRlZCwgcmV0dXJuIG9yaWdpbmFsXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlbiBhbiBlcnJvciBtZXNzYWdlIGFuZCBBcnJheSBvZiBTdGFja0ZyYW1lcywgc2VyaWFsaXplIGFuZCBQT1NUIHRvIGdpdmVuIFVSTC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gc3RhY2tmcmFtZXNcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXJyb3JNc2dcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHJlcXVlc3RPcHRpb25zXG4gICAgICAgICAqL1xuICAgICAgICByZXBvcnQ6IGZ1bmN0aW9uIFN0YWNrVHJhY2UkJHJlcG9ydChzdGFja2ZyYW1lcywgdXJsLCBlcnJvck1zZywgcmVxdWVzdE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgICAgICAgICAgcmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIG9ucmVhZHlzdGF0ZWNoYW5nZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcS5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxLnN0YXR1cyA+PSAyMDAgJiYgcmVxLnN0YXR1cyA8IDQwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVxLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1BPU1QgdG8gJyArIHVybCArICcgZmFpbGVkIHdpdGggc3RhdHVzOiAnICsgcmVxLnN0YXR1cykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXEub3BlbigncG9zdCcsIHVybCk7XG5cbiAgICAgICAgICAgICAgICAvLyBTZXQgcmVxdWVzdCBoZWFkZXJzXG4gICAgICAgICAgICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3RPcHRpb25zICYmIHR5cGVvZiByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGVhZGVycyA9IHJlcXVlc3RPcHRpb25zLmhlYWRlcnM7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGhlYWRlciBpbiBoZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhlYWRlcnMsIGhlYWRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXIsIGhlYWRlcnNbaGVhZGVyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVwb3J0UGF5bG9hZCA9IHtzdGFjazogc3RhY2tmcmFtZXN9O1xuICAgICAgICAgICAgICAgIGlmIChlcnJvck1zZyAhPT0gdW5kZWZpbmVkICYmIGVycm9yTXNnICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcG9ydFBheWxvYWQubWVzc2FnZSA9IGVycm9yTXNnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlcS5zZW5kKEpTT04uc3RyaW5naWZ5KHJlcG9ydFBheWxvYWQpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn0pKTtcbiIsIi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xudmFyIGJ5dGVUb0hleCA9IFtdO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXhbaV0gPSAoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpO1xufVxuXG5mdW5jdGlvbiBieXRlc1RvVXVpZChidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IG9mZnNldCB8fCAwO1xuICB2YXIgYnRoID0gYnl0ZVRvSGV4O1xuICAvLyBqb2luIHVzZWQgdG8gZml4IG1lbW9yeSBpc3N1ZSBjYXVzZWQgYnkgY29uY2F0ZW5hdGlvbjogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzE3NSNjNFxuICByZXR1cm4gKFtcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXVxuICBdKS5qb2luKCcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBieXRlc1RvVXVpZDtcbiIsIi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuICBJbiB0aGVcbi8vIGJyb3dzZXIgdGhpcyBpcyBhIGxpdHRsZSBjb21wbGljYXRlZCBkdWUgdG8gdW5rbm93biBxdWFsaXR5IG9mIE1hdGgucmFuZG9tKClcbi8vIGFuZCBpbmNvbnNpc3RlbnQgc3VwcG9ydCBmb3IgdGhlIGBjcnlwdG9gIEFQSS4gIFdlIGRvIHRoZSBiZXN0IHdlIGNhbiB2aWFcbi8vIGZlYXR1cmUtZGV0ZWN0aW9uXG5cbi8vIGdldFJhbmRvbVZhbHVlcyBuZWVkcyB0byBiZSBpbnZva2VkIGluIGEgY29udGV4dCB3aGVyZSBcInRoaXNcIiBpcyBhIENyeXB0b1xuLy8gaW1wbGVtZW50YXRpb24uIEFsc28sIGZpbmQgdGhlIGNvbXBsZXRlIGltcGxlbWVudGF0aW9uIG9mIGNyeXB0byBvbiBJRTExLlxudmFyIGdldFJhbmRvbVZhbHVlcyA9ICh0eXBlb2YoY3J5cHRvKSAhPSAndW5kZWZpbmVkJyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChjcnlwdG8pKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YobXNDcnlwdG8pICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cubXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09ICdmdW5jdGlvbicgJiYgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQobXNDcnlwdG8pKTtcblxuaWYgKGdldFJhbmRvbVZhbHVlcykge1xuICAvLyBXSEFUV0cgY3J5cHRvIFJORyAtIGh0dHA6Ly93aWtpLndoYXR3Zy5vcmcvd2lraS9DcnlwdG9cbiAgdmFyIHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB3aGF0d2dSTkcoKSB7XG4gICAgZ2V0UmFuZG9tVmFsdWVzKHJuZHM4KTtcbiAgICByZXR1cm4gcm5kczg7XG4gIH07XG59IGVsc2Uge1xuICAvLyBNYXRoLnJhbmRvbSgpLWJhc2VkIChSTkcpXG4gIC8vXG4gIC8vIElmIGFsbCBlbHNlIGZhaWxzLCB1c2UgTWF0aC5yYW5kb20oKS4gIEl0J3MgZmFzdCwgYnV0IGlzIG9mIHVuc3BlY2lmaWVkXG4gIC8vIHF1YWxpdHkuXG4gIHZhciBybmRzID0gbmV3IEFycmF5KDE2KTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1hdGhSTkcoKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIHI7IGkgPCAxNjsgaSsrKSB7XG4gICAgICBpZiAoKGkgJiAweDAzKSA9PT0gMCkgciA9IE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAwMDtcbiAgICAgIHJuZHNbaV0gPSByID4+PiAoKGkgJiAweDAzKSA8PCAzKSAmIDB4ZmY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJuZHM7XG4gIH07XG59XG4iLCJ2YXIgcm5nID0gcmVxdWlyZSgnLi9saWIvcm5nJyk7XG52YXIgYnl0ZXNUb1V1aWQgPSByZXF1aXJlKCcuL2xpYi9ieXRlc1RvVXVpZCcpO1xuXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcblxuICBpZiAodHlwZW9mKG9wdGlvbnMpID09ICdzdHJpbmcnKSB7XG4gICAgYnVmID0gb3B0aW9ucyA9PT0gJ2JpbmFyeScgPyBuZXcgQXJyYXkoMTYpIDogbnVsbDtcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7XG5cbiAgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuICBybmRzWzZdID0gKHJuZHNbNl0gJiAweDBmKSB8IDB4NDA7XG4gIHJuZHNbOF0gPSAocm5kc1s4XSAmIDB4M2YpIHwgMHg4MDtcblxuICAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcbiAgaWYgKGJ1Zikge1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCAxNjsgKytpaSkge1xuICAgICAgYnVmW2kgKyBpaV0gPSBybmRzW2lpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmIHx8IGJ5dGVzVG9VdWlkKHJuZHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHY0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5LYXRhbE1ldHJpY3NEcml2ZXJTdXNoaSA9IHZvaWQgMDtcblxudmFyIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIikpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY3NEcml2ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGFtem4va2F0YWwtbWV0cmljcy9saWIvZHJpdmVyL0thdGFsTWV0cmljc0RyaXZlclwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNUeXBlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGFtem4va2F0YWwtbWV0cmljcy9saWIvbWV0cmljT2JqZWN0L0thdGFsTWV0cmljVHlwZVwiKSk7XG5cbnZhciBfa2F0YWxTdXNoaUNsaWVudCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBhbXpuL2thdGFsLXN1c2hpLWNsaWVudFwiKSk7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIuZGVmYXVsdCkodGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIEtBVF9TVEFOREFMT05FX05FWFVTX1BST0RVQ0VSX0lEID0gJ2thdGFsJztcbnZhciBLQVRfU1RBTkRBTE9ORV9ERUZBVUxUX1NPVVJDRV9HUk9VUFMgPSB7XG4gIHRlc3Q6ICdjb20uYW1hem9uLmVlbC5rYXRhbC5tZXRyaWNzLmNvcmUubmV4dXMuZ2FtbWEnLFxuICBwcm9kOiAnY29tLmFtYXpvbi5lZWwua2F0YWwubWV0cmljcy5jb3JlLm5leHVzJ1xufTtcblxudmFyIEthdGFsTWV0cmljc0RyaXZlclN1c2hpQnVpbGRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEthdGFsTWV0cmljc0RyaXZlclN1c2hpQnVpbGRlcigpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBLYXRhbE1ldHJpY3NEcml2ZXJTdXNoaUJ1aWxkZXIpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiY29udGV4dFwiLCB7fSk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShLYXRhbE1ldHJpY3NEcml2ZXJTdXNoaUJ1aWxkZXIsIFt7XG4gICAga2V5OiBcIndpdGhTdXNoaUNsaWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoU3VzaGlDbGllbnQoc3VzaGlDbGllbnQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCd3aXRoU3VzaGkgY2xpZW50Li4uJyk7XG4gICAgICB0aGlzLmNvbnRleHQuc3VzaGlDbGllbnQgPSBzdXNoaUNsaWVudDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3aXRoRG9tYWluUmVhbG1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aERvbWFpblJlYWxtKGRvbWFpbiwgcmVhbG0pIHtcbiAgICAgIHRoaXMuY29udGV4dC5kb21haW4gPSBkb21haW47XG4gICAgICB0aGlzLmNvbnRleHQucmVhbG0gPSByZWFsbTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3aXRoQ3VzdG9tUHJvZHVjZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aEN1c3RvbVByb2R1Y2VyKHN1c2hpUHJvZHVjZXJJZCkge1xuICAgICAgdGhpcy5jb250ZXh0LnN1c2hpUHJvZHVjZXIgPSBzdXNoaVByb2R1Y2VySWQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aEN1c3RvbVNvdXJjZUdyb3VwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhDdXN0b21Tb3VyY2VHcm91cChzb3VyY2VHcm91cElkKSB7XG4gICAgICB0aGlzLmNvbnRleHQuc291cmNlR3JvdXBJZCA9IHNvdXJjZUdyb3VwSWQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aEVycm9ySGFuZGxlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoRXJyb3JIYW5kbGVyKGVycm9ySGFuZGxlcikge1xuICAgICAgdGhpcy5jb250ZXh0LmVycm9ySGFuZGxlciA9IGVycm9ySGFuZGxlcjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3aXRoU3VzaGlDbGllbnRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhTdXNoaUNsaWVudE9wdGlvbnMoc3VzaGlDbGllbnRPcHRpb25zKSB7XG4gICAgICB0aGlzLmNvbnRleHQuc3VzaGlDbGllbnRPcHRpb25zID0gc3VzaGlDbGllbnRPcHRpb25zO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhTdXNoaUNsaWVudFRyYW5zcG9ydE92ZXJyaWRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhTdXNoaUNsaWVudFRyYW5zcG9ydE92ZXJyaWRlKHN1c2hpQ2xpZW50VHJhbnNwb3J0T3ZlcnJpZGUpIHtcbiAgICAgIHRoaXMuY29udGV4dC5zdXNoaUNsaWVudFRyYW5zcG9ydE92ZXJyaWRlID0gc3VzaGlDbGllbnRUcmFuc3BvcnRPdmVycmlkZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJidWlsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZCgpIHtcbiAgICAgIHJldHVybiBuZXcgS2F0YWxNZXRyaWNzRHJpdmVyU3VzaGkodGhpcy5jb250ZXh0KTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEthdGFsTWV0cmljc0RyaXZlclN1c2hpQnVpbGRlcjtcbn0oKTtcblxudmFyIEthdGFsTWV0cmljc0RyaXZlclN1c2hpID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfS2F0YWxNZXRyaWNzRHJpdmVyKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEthdGFsTWV0cmljc0RyaXZlclN1c2hpLCBfS2F0YWxNZXRyaWNzRHJpdmVyKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEthdGFsTWV0cmljc0RyaXZlclN1c2hpKTtcblxuICBmdW5jdGlvbiBLYXRhbE1ldHJpY3NEcml2ZXJTdXNoaShvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgS2F0YWxNZXRyaWNzRHJpdmVyU3VzaGkpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzKSwgXCJzdXNoaVwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpcyksIFwicHJvZHVjZXJJZFwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpcyksIFwic291cmNlR3JvdXBJZFwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpcyksIFwiZXJyb3JIYW5kbGVyXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzKSwgXCJjb21iaW5lZEVycm9ySGFuZGxlclwiLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoX3RoaXMuZXJyb3JIYW5kbGVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgX3RoaXMuZXJyb3JIYW5kbGVyKGVycik7IC8vIFJldHVybiB0byBhdm9pZCBmYWxsaW5nIHRocm91Z2ggdG8gZGVmYXVsdCBlcnJvciBoYW5kbGVyXG5cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBjYXRjaCAobmV4dEVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBoYW5kbGluZyBlcnJvciBwdWJsaXNoaW5nIG1ldHJpY3M6XCIpO1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IobmV4dEVycik7IC8vIEZhbGwgdGhyb3VnaFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmRlZmF1bHRFcnJvckhhbmRsZXIoZXJyKTtcbiAgICB9KTtcbiAgICB2YXIgZG9tYWluID0gb3B0aW9ucy5kb21haW4sXG4gICAgICAgIHJlYWxtID0gb3B0aW9ucy5yZWFsbSxcbiAgICAgICAgZXJyb3JIYW5kbGVyID0gb3B0aW9ucy5lcnJvckhhbmRsZXIsXG4gICAgICAgIHN1c2hpQ2xpZW50ID0gb3B0aW9ucy5zdXNoaUNsaWVudCxcbiAgICAgICAgX29wdGlvbnMkc3VzaGlQcm9kdWNlID0gb3B0aW9ucy5zdXNoaVByb2R1Y2VyLFxuICAgICAgICBwcm9kdWNlcklkID0gX29wdGlvbnMkc3VzaGlQcm9kdWNlID09PSB2b2lkIDAgPyBLQVRfU1RBTkRBTE9ORV9ORVhVU19QUk9EVUNFUl9JRCA6IF9vcHRpb25zJHN1c2hpUHJvZHVjZSxcbiAgICAgICAgc3VzaGlDbGllbnRPcHRpb25zID0gb3B0aW9ucy5zdXNoaUNsaWVudE9wdGlvbnMsXG4gICAgICAgIHN1c2hpQ2xpZW50VHJhbnNwb3J0T3ZlcnJpZGUgPSBvcHRpb25zLnN1c2hpQ2xpZW50VHJhbnNwb3J0T3ZlcnJpZGU7IC8vIGN1c3RvbSBzb3VyY2UgZ3JvdXAgYWx3YXlzIG92ZXJyaWRlcyBkZWZhdWx0c1xuXG4gICAgdmFyIHNvdXJjZUdyb3VwSWQgPSBvcHRpb25zLnNvdXJjZUdyb3VwSWQgfHwgS0FUX1NUQU5EQUxPTkVfREVGQVVMVF9TT1VSQ0VfR1JPVVBTW2RvbWFpbl0gfHwgS0FUX1NUQU5EQUxPTkVfREVGQVVMVF9TT1VSQ0VfR1JPVVBTWyd0ZXN0J107XG4gICAgX3RoaXMuc3VzaGkgPSBzdXNoaUNsaWVudCB8fCBfdGhpcy5idWlsZFN1c2hpQ2xpZW50KGRvbWFpbiwgcmVhbG0sIHNvdXJjZUdyb3VwSWQsIHN1c2hpQ2xpZW50T3B0aW9ucywgc3VzaGlDbGllbnRUcmFuc3BvcnRPdmVycmlkZSk7XG4gICAgX3RoaXMuZXJyb3JIYW5kbGVyID0gZXJyb3JIYW5kbGVyO1xuICAgIF90aGlzLnByb2R1Y2VySWQgPSBwcm9kdWNlcklkO1xuICAgIF90aGlzLnNvdXJjZUdyb3VwSWQgPSBzb3VyY2VHcm91cElkO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEthdGFsTWV0cmljc0RyaXZlclN1c2hpLCBbe1xuICAgIGtleTogXCJiZWZvcmVVbmxvYWRcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCByaWdodCBiZWZvcmUgdGhlIHBhZ2UgdW5sb2Fkcy4gVGhpc1xuICAgICAqIGFsbG93cyBmb3IgYW55IGZpbmFsIG1ldHJpY3MsIHN1Y2ggYXMgcGFnZSB2aXNpdCBkdXJhdGlvbiwgdG8gYmUgc2VudFxuICAgICAqIGJlZm9yZSB0aGUgdXNlciBuYXZpZ2F0ZXMgYXdheSBmcm9tIHRoZSBwYWdlIG9yIGNsb3NlcyB0aGUgdGFiLlxuICAgICAqIE5PVEU6IFRoaXMgaXMgYW4gZXhwZXJpbWVudGFsIEFQSSBhbmQgbWF5IGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuICAgICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgdG8gY2FsbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiZWZvcmVVbmxvYWQoY2IpIHtcbiAgICAgIHRoaXMuc3VzaGkub25TdXNoaVVubG9hZChjYik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgZXJyb3IgaGFuZGxlciBpZiB0aGUgdXNlci1zdXBwbGllZCBlcnJvciBoYW5kbGVyIGZhaWxzIG9yIGlzIHVuc2V0LiAgU2hvdWxkIG5ldmVyIGJlIGNhbGxlZCB1bmxlc3NcbiAgICAgKiB1c2VyLXByb3ZpZGVkIGVycm9yIGhhbmRsZXIgbWlzYmVoYXZlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlcnIgVW5oYW5kbGVkIGVycm9yIG9iamVjdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVmYXVsdEVycm9ySGFuZGxlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWZhdWx0RXJyb3JIYW5kbGVyKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHB1Ymxpc2hpbmcgbWV0cmljczpcIik7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGwgdGhlIGVycm9yLWhhbmRsZXIgc3VwcGxpZWQgYnkgdGhlIHVzZXIgd2hlbiB0aGlzIG9iamVjdCB3YXMgY29uc3RydWN0ZWQ7IGlmIHRoYXQgaXMgdW5zZXQgb3IgaXRzZWxmIHRocm93c1xuICAgICAqIGFuIGV4Y2VwdGlvbiwgY2FsbHMgdGhlIGRlZmF1bHQgZXJyb3IgaGFuZGxlciBhcyBhIGZhbGxiYWNrLCB3aGljaCB3aWxsIGp1c3QgbG9nIHRoZSBlcnJvciB0byB0aGUgY29uc29sZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlcnIgRXJyb3Igb2JqZWN0IHRvIGhhbmRsZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aEVycm9ySGFuZGxpbmdcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIHdyYXAgYSBmdW5jdGlvbiBpbiB0aGUgZXJyb3IgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkb1RoZVRoaW5nIEZ1bmN0aW9uIHRvIHJ1biB1bmRlciB0aGUgd3JhcHBlclxuICAgICAqIEByZXR1cm4gUmV0dXJuIHZhbHVlIGZyb20gY2FsbGVkIGZ1bmN0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2l0aEVycm9ySGFuZGxpbmcoZG9UaGVUaGluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRvVGhlVGhpbmcoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLmNvbWJpbmVkRXJyb3JIYW5kbGVyKGVycik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJ1aWxkU3VzaGlDbGllbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGRTdXNoaUNsaWVudChkb21haW4sIHJlYWxtLCBzb3VyY2VHcm91cElkLCBzdXNoaUNsaWVudE9wdGlvbnMsIHN1c2hpQ2xpZW50VHJhbnNwb3J0T3ZlcnJpZGUpIHtcbiAgICAgIGlmICghZG9tYWluIHx8ICFyZWFsbSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0thdGFsTWV0cmljc0RyaXZlclN1c2hpIHJlcXVpcmVzIGEgZG9tYWluIGFuZCByZWFsbSB0byBidWlsZCBhIHN1c2hpIGNsaWVudC4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBfa2F0YWxTdXNoaUNsaWVudC5kZWZhdWx0KEthdGFsTWV0cmljc0RyaXZlclN1c2hpLmdldFJlYWxtTmFtZShyZWFsbSksIHNvdXJjZUdyb3VwSWQsIHRoaXMuY29tYmluZWRFcnJvckhhbmRsZXIsIHN1c2hpQ2xpZW50T3B0aW9ucywgc3VzaGlDbGllbnRUcmFuc3BvcnRPdmVycmlkZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInB1Ymxpc2hcIixcbiAgICB2YWx1ZTogLy8gVE9ETzogZXJyb3JIYW5kbGVyIGluIHRoaXMgbWV0aG9kIGlzIGRlcHJlY2F0ZWQgYW5kIGlzIG5vdCByZWZlcmVuY2VkLlxuICAgIC8vIFRlY2ggZGVidDogaHR0cHM6Ly9pc3N1ZXMuYW1hem9uLmNvbS9pc3N1ZXMvS0FULTg3NVxuICAgIGZ1bmN0aW9uIHB1Ymxpc2gobWV0cmljT2JqZWN0LCBlcnJvckhhbmRsZXIsIGNvbnRleHQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAvLyBTdXBwb3J0IGZvciBuZXcgMi1hcmd1bWVudCBmb3JtIG9mIHB1Ymxpc2gsIHdoaWNoIGRvZXMgbm90IHBhc3MgdGhlIHVudXNlZCBlcnJvckhhbmRsZXIgb2JqZWN0IChLQVQtODc1KVxuICAgICAgdmFyIG1ldHJpY3NDb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyBhcmd1bWVudHNbMV0gOiBhcmd1bWVudHNbMl07XG4gICAgICB0aGlzLndpdGhFcnJvckhhbmRsaW5nKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBsb2dpYyBpcyBub3cgbW92ZWQgaW50byBLYXRhbE1ldHJpY3NQdWJsaXNoZXIsIG9uY2UgZXZlcnlib2R5IGhhcyB0aGF0IHVwZGF0ZSB3ZSBjYW4gcmVtb3ZlIHRoaXMuXG4gICAgICAgIC8vIFRlY2ggZGVidDogaHR0cHM6Ly9pc3N1ZXMuYW1hem9uLmNvbS9pc3N1ZXMvS0FULTg3NlxuICAgICAgICBpZiAoX0thdGFsTWV0cmljVHlwZS5kZWZhdWx0Lkxpc3QgPT09IG1ldHJpY09iamVjdC50eXBlKSB7XG4gICAgICAgICAgbWV0cmljT2JqZWN0Lm1ldHJpY0xpc3QuZm9yRWFjaChmdW5jdGlvbiAobWV0cmljKSB7XG4gICAgICAgICAgICBfdGhpczIucHVibGlzaChtZXRyaWMsIG1ldHJpY3NDb250ZXh0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV4dXNTY2hlbWEgPSBfdGhpczIubWFwT2JqZWN0VHlwZVRvTmV4dXNTY2hlbWEobWV0cmljT2JqZWN0LnR5cGUpO1xuXG4gICAgICAgIHZhciBmaWVsZHMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG1ldHJpY3NDb250ZXh0LmNvbnRleHQpLCB7fSwge1xuICAgICAgICAgIG1ldHJpY0tleTogbWV0cmljT2JqZWN0Lm5hbWUsXG4gICAgICAgICAgdmFsdWU6IG1ldHJpY09iamVjdC52YWx1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobWV0cmljT2JqZWN0LmlzTW9uaXRvcikge1xuICAgICAgICAgIGZpZWxkcy5pc01vbml0b3IgPSB0cnVlO1xuICAgICAgICB9IC8vIERlbGV0aW5nIGNsb3VkV2F0Y2hEaW1lbnNpb25zIGZpZWxkIGlmIGV4aXN0cyBhcyBpdCBhcHBsaWVzIG9ubHkgZm9yIEthdGFsTW9uaXRvcmluZ0FXU0RyaXZlci5cblxuXG4gICAgICAgIGlmIChmaWVsZHMuY2xvdWRXYXRjaERpbWVuc2lvbnMpIHtcbiAgICAgICAgICBkZWxldGUgZmllbGRzLmNsb3VkV2F0Y2hEaW1lbnNpb25zO1xuICAgICAgICB9IC8vIFJlc2V0IHRoZSBldmVudCBjb3VudCBiYWNrIHRvIDAsIG90aGVyd2lzZSBTdXNoaSB3aWxsIHN0b3AgcHVibGlzaGluZyBhZnRlciAxSyBpdGVtcyAoaHR0cHM6Ly9pc3N1ZXMuYW1hem9uLmNvbS9pc3N1ZXMvS0FULTE1MzQpXG5cblxuICAgICAgICBfdGhpczIuc3VzaGkucmVzZXQoKTtcblxuICAgICAgICBfdGhpczIuc3VzaGkuZXZlbnQoZmllbGRzLCBfdGhpczIucHJvZHVjZXJJZCwgbmV4dXNTY2hlbWEsIHtcbiAgICAgICAgICBcInNzZFwiOiAxXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hcE9iamVjdFR5cGVUb05leHVzU2NoZW1hXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcE9iamVjdFR5cGVUb05leHVzU2NoZW1hKG9iamVjdFR5cGUpIHtcbiAgICAgIHN3aXRjaCAob2JqZWN0VHlwZSkge1xuICAgICAgICBjYXNlIF9LYXRhbE1ldHJpY1R5cGUuZGVmYXVsdC5TdHJpbmc6XG4gICAgICAgICAgcmV0dXJuICdrYXRhbC5jbGllbnQubWV0cmljcy5TdHJpbmcuMic7XG5cbiAgICAgICAgY2FzZSBfS2F0YWxNZXRyaWNUeXBlLmRlZmF1bHQuQ291bnRlcjpcbiAgICAgICAgICByZXR1cm4gJ2thdGFsLmNsaWVudC5tZXRyaWNzLkNvdW50ZXIuMyc7XG5cbiAgICAgICAgY2FzZSBfS2F0YWxNZXRyaWNUeXBlLmRlZmF1bHQuVGltZXI6XG4gICAgICAgICAgcmV0dXJuICdrYXRhbC5jbGllbnQubWV0cmljcy5UaW1lci4yJztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHlwZSBcIi5jb25jYXQob2JqZWN0VHlwZSwgXCIgd2hlbiBwdWJsaXNoaW5nIG1ldHJpYyBvYmplY3QuXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJnZXRSZWFsbU5hbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmVhbG1OYW1lKHJlYWxtKSB7XG4gICAgICBzd2l0Y2ggKHJlYWxtKSB7XG4gICAgICAgIGNhc2UgJ05BQW1hem9uJzpcbiAgICAgICAgY2FzZSAnVVNBbWF6b24nOlxuICAgICAgICAgIHJldHVybiBfa2F0YWxTdXNoaUNsaWVudC5kZWZhdWx0LlJFR0lPTlMuTkE7XG5cbiAgICAgICAgY2FzZSAnRVVBbWF6b24nOlxuICAgICAgICAgIHJldHVybiBfa2F0YWxTdXNoaUNsaWVudC5kZWZhdWx0LlJFR0lPTlMuRVU7XG5cbiAgICAgICAgY2FzZSAnRkVBbWF6b24nOlxuICAgICAgICBjYXNlICdKUEFtYXpvbic6XG4gICAgICAgICAgcmV0dXJuIF9rYXRhbFN1c2hpQ2xpZW50LmRlZmF1bHQuUkVHSU9OUy5GRTtcblxuICAgICAgICBjYXNlICdDTkFtYXpvbic6XG4gICAgICAgICAgcmV0dXJuIF9rYXRhbFN1c2hpQ2xpZW50LmRlZmF1bHQuUkVHSU9OUy5DTjtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIExldCB0aGUgU3VzaGlDbGllbnQgZGVjaWRlIGlmIHRoaXMgaXMgYm9ndXMgb3Igbm90LlxuICAgICAgICAgIHJldHVybiByZWFsbTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEthdGFsTWV0cmljc0RyaXZlclN1c2hpO1xufShfS2F0YWxNZXRyaWNzRHJpdmVyMi5kZWZhdWx0KTtcblxuZXhwb3J0cy5LYXRhbE1ldHJpY3NEcml2ZXJTdXNoaSA9IEthdGFsTWV0cmljc0RyaXZlclN1c2hpO1xuKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoS2F0YWxNZXRyaWNzRHJpdmVyU3VzaGksIFwiQnVpbGRlclwiLCBLYXRhbE1ldHJpY3NEcml2ZXJTdXNoaUJ1aWxkZXIpOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG5yZXF1aXJlKFwiLi9ub2RlanNTaGltc1wiKTtcblxudmFyIF9LYXRhbE1ldHJpY3NEcml2ZXJTdXNoaSA9IHJlcXVpcmUoXCIuL0thdGFsTWV0cmljc0RyaXZlclN1c2hpXCIpO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZmlsZSAqL1xudmFyIF9kZWZhdWx0ID0gX0thdGFsTWV0cmljc0RyaXZlclN1c2hpLkthdGFsTWV0cmljc0RyaXZlclN1c2hpO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX1ZhbGlkYXRlU2ltcGxlU3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9oZWxwZXIvVmFsaWRhdGVTaW1wbGVTdHJpbmdcIikpO1xuXG52YXIgX3ZhbGlkYXRlQ2xvdWRXYXRjaERpbWVuc2lvbnMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2hlbHBlci92YWxpZGF0ZUNsb3VkV2F0Y2hEaW1lbnNpb25zXCIpKTtcblxudmFyIF9GaXJzdE1hcCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaGVscGVyL0ZpcnN0TWFwXCIpKTtcblxudmFyIF9tZXJnZUxpc3RzID0gcmVxdWlyZShcIi4vaGVscGVyL21lcmdlTGlzdHNcIik7XG5cbnZhciBfZW1iZWRSZXF1ZXN0SWQgPSByZXF1aXJlKFwiLi9oZWxwZXIvZW1iZWRSZXF1ZXN0SWRcIik7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgUkVRVUlSRURfRklFTERTID0gWydzaXRlJywgJ3NlcnZpY2VOYW1lJywgJ21ldGhvZE5hbWUnXTtcblxudmFyIEthdGFsTWV0cmljc0NvbnRleHQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IG1ldHJpY3MgY29udGV4dCB3aXRoIHRoZSBnaXZlbiBmaWVsZHMuXG4gICAqXG4gICAqIEBwYXJhbSBjb250ZXh0RmllbGRzIENvbnRleHQgZmllbGRzIHZhbHVlIChkZWZhdWx0IGVtcHR5KVxuICAgKi9cbiAgZnVuY3Rpb24gS2F0YWxNZXRyaWNzQ29udGV4dCgpIHtcbiAgICB2YXIgY29udGV4dEZpZWxkcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgS2F0YWxNZXRyaWNzQ29udGV4dCk7XG4gICAgLy8gQ29weSBmaWVsZHMgc28gdGhpcyBpcyBpbW11dGFibGVcbiAgICB0aGlzLmNvbnRleHQgPSBfb2JqZWN0U3ByZWFkKHt9LCBjb250ZXh0RmllbGRzKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGEgbmV3IEthdGFsTWV0cmljc0NvbnRleHQgd2hpY2ggaXMgYSBjb3B5IG9mIHRoaXMgY29udGV4dCwgd2l0aCB2YWx1ZXMgYWRkZWQgb3Igb3ZlcnJpZGRlbiBmcm9tXG4gICAqIHRoZSBnaXZlbiBjb250ZXh0LlxuICAgKlxuICAgKiBJZiB0aGUgZ2l2ZW4gY29udGV4dCBpcyBudWxsIG9yIGVtcHR5LCB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvcmlnaW5hbCBvYmplY3QgYXMgYW4gb3B0aW1pemF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gdGhhdENvbnRleHQgQ29udGV4dCB0byBtZXJnZSB2YWx1ZXMgZnJvbVxuICAgKiBAcmV0dXJuIE5ldyBjb250ZXh0IHdpdGggZGVmYXVsdCB2YWx1ZXMgZnJvbSB0aGlzIGNvbnRleHQsIGFuZCB2YWx1ZXMgb3ZlcnJpZGRlbiBvciBhZGRlZCBieSB0aGUgZ2l2ZW4gY29udGV4dC5cbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShLYXRhbE1ldHJpY3NDb250ZXh0LCBbe1xuICAgIGtleTogXCJtZXJnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtZXJnZSh0aGF0Q29udGV4dCkge1xuICAgICAgaWYgKCF0aGF0Q29udGV4dCkgcmV0dXJuIHRoaXM7IC8vIENoZWNrIGZvciBhIGNvbW1vbiBlcnJvclxuXG4gICAgICBpZiAodGhhdENvbnRleHQgaW5zdGFuY2VvZiBLYXRhbE1ldHJpY3NDb250ZXh0LkJ1aWxkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2F0YWxNZXRyaWNzQ29udGV4dC5CdWlsZGVyIG9iamVjdCBwYXNzZWQgaW5zdGVhZCBvZiBLYXRhbE1ldHJpY3NDb250ZXh0LiAgVHJ5IGNhbGxpbmcgLmJ1aWxkKCkgbWV0aG9kLlwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGF0Q29udGV4dCBpbnN0YW5jZW9mIEthdGFsTWV0cmljc0NvbnRleHQgPyB0aGF0Q29udGV4dC5jb250ZXh0IDogdGhhdENvbnRleHQ7XG5cbiAgICAgIHZhciBuZXdDb250ZXh0ID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRoaXMuY29udGV4dCksIGNvbnRleHQpLCB7fSwge1xuICAgICAgICByZWxhdGVkTWV0cmljczogKDAsIF9tZXJnZUxpc3RzLm1lcmdlTGlzdHMpKHRoaXMuY29udGV4dC5yZWxhdGVkTWV0cmljcywgY29udGV4dC5yZWxhdGVkTWV0cmljcyksXG4gICAgICAgIHJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uOiAoMCwgX21lcmdlTGlzdHMubWVyZ2VMaXN0cykodGhpcy5jb250ZXh0LnJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uLCBjb250ZXh0LnJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uKSxcbiAgICAgICAgLy8gQ29tYmluZXMgdGhlIGRpbWVuc2lvbnMgZnJvbSBiYXNlIHB1Ymxpc2hlciB3aXRoIGFueSBjaGlsZCBwdWJsaXNoZXIuXG4gICAgICAgIGNsb3VkV2F0Y2hEaW1lbnNpb25zOiAoMCwgX21lcmdlTGlzdHMubWVyZ2VMaXN0cykodGhpcy5jb250ZXh0LmNsb3VkV2F0Y2hEaW1lbnNpb25zLCBjb250ZXh0LmNsb3VkV2F0Y2hEaW1lbnNpb25zKVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBuZXcgS2F0YWxNZXRyaWNzQ29udGV4dChuZXdDb250ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbmV3IGNvbnRleHQgd2hpY2ggaXMgYSBjb3B5IG9mIHRoaXMgY29udGV4dCB3aXRoIHJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uIHJlbW92ZWQuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGludGVuZGVkIHRvIGJlIGNhbGxlZCB3aGVuIGNyZWF0aW5nIGEgbmV3IGNoaWxkIHB1Ymxpc2hlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gQ29weSBvZiB0aGlzIGNvbnRleHQsIHdpdGggcmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb24gcmVtb3ZlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aG91dFJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhvdXRSZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgS2F0YWxNZXRyaWNzQ29udGV4dChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRoaXMuY29udGV4dCksIHt9LCB7XG4gICAgICAgIHJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uOiB1bmRlZmluZWRcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgY29udGV4dCBzdWl0YWJsZSBmb3IgcHVibGljYXRpb24gdG8gdGhlIGRyaXZlci5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHN0cmlwcyBvdXQgYW55IHByaXZhdGUgZmllbGRzLCBhbmQgbGVhdmVzIG9ubHkgZmllbGRzIGZyb20gdGhlIHNjaGVtYSB0aGF0IHRoZSBkcml2ZXIgc2hvdWxkIHB1Ymxpc2guXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIENvbnRleHQgc3VpdGFibGUgZm9yIGRyaXZlciBwdWJsaWNhdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJpdmVyQ29udGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcml2ZXJDb250ZXh0KCkge1xuICAgICAgLy8gRG9uJ3QgcHVibGlzaCByZWxhdGVkTWV0cmljcyB0byB0aGUgZHJpdmVyXG4gICAgICB2YXIgbmV3Q29udGV4dEZpZWxkcyA9IF9vYmplY3RTcHJlYWQoe30sIHRoaXMuY29udGV4dCk7XG5cbiAgICAgIGRlbGV0ZSBuZXdDb250ZXh0RmllbGRzW1wicmVsYXRlZE1ldHJpY3NcIl07XG4gICAgICBkZWxldGUgbmV3Q29udGV4dEZpZWxkc1tcInJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uXCJdO1xuICAgICAgZGVsZXRlIG5ld0NvbnRleHRGaWVsZHNbXCJyZXF1ZXN0SWRcIl07XG5cbiAgICAgIGlmICh0aGlzLmNvbnRleHQucmVxdWVzdElkKSB7XG4gICAgICAgIG5ld0NvbnRleHRGaWVsZHMuYWN0aW9uSWQgPSAoMCwgX2VtYmVkUmVxdWVzdElkLmVtYmVkUmVxdWVzdElkKShuZXdDb250ZXh0RmllbGRzLmFjdGlvbklkLCB0aGlzLmNvbnRleHQucmVxdWVzdElkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBLYXRhbE1ldHJpY3NDb250ZXh0KG5ld0NvbnRleHRGaWVsZHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzaW1wbGUgSmF2YVNjcmlwdCBvYmplY3Qgd2l0aCBhIGNvcHkgb2YgdGhlIGZpZWxkcyBmb3IgdGhpcyBjb250ZXh0LlxuICAgICAqXG4gICAgICogQHJldHVybiBTaW1wbGUgSmF2YXNjcmlwdCBvYmplY3Qgd2l0aCBhIGNvcHkgb2YgdGhlIGZpZWxkcyBmb3IgdGhpcyBjb250ZXh0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRGaWVsZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RmllbGRzKCkge1xuICAgICAgLy8gQ29weSBmaWVsZHMgc28gdGhpcyByZW1haW5zIGltbXV0YWJsZVxuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe30sIHRoaXMuY29udGV4dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGZvciBhIHZhbGlkYXRpb24gZXJyb3Igb24gdGhpcyBjb250ZXh0LlxuICAgICAqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgdmFsaWRhdGlvbiBlcnJvciBlbmNvdW50ZXJlZCBpZiBvbmUgaXMgZm91bmQsIG90aGVyd2lzZSB1bmRlZmluZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBFcnJvcnMgZm91bmQgd2l0aCB0aGlzIGNvbnRleHRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInZhbGlkYXRpb25FcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0aW9uRXJyb3IoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgZXJyOyAvLyBGaWVsZHMg4oCcc2l0ZeKAnSwg4oCcc2VydmljZU5hbWXigJ0sIOKAnG1ldGhvZE5hbWXigJ0sIGFuZCDigJxtZXRyaWNLZXnigJ0gYXJlIHJlcXVpcmVkLlxuXG4gICAgICBlcnIgPSAoMCwgX0ZpcnN0TWFwLmRlZmF1bHQpKFJFUVVJUkVEX0ZJRUxEUywgZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIGlmIChfdGhpcy5jb250ZXh0W2ZpZWxkXSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFwiRmllbGQgXCIuY29uY2F0KGZpZWxkLCBcIiBpcyByZXF1aXJlZCwgYnV0IGl0IGlzIFwiKS5jb25jYXQoX3RoaXMuY29udGV4dFtmaWVsZF0pKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gZXJyO1xuICAgICAgcmV0dXJuICgwLCBfRmlyc3RNYXAuZGVmYXVsdCkoT2JqZWN0LmtleXModGhpcy5jb250ZXh0KSwgZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy52YWxpZGF0ZUZpZWxkKGZpZWxkKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSBhbiBpbmRpdmlkdWFsIGNvbnRleHQgZmllbGQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmllbGQgTmFtZSBvZiBmaWVsZCB0byB2YWxpZGF0ZVxuICAgICAqIEByZXR1cm5zIEVycm9yIGZvdW5kIHdpdGggdGhpcyBmaWVsZCwgb3IgdW5kZWZpbmVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ2YWxpZGF0ZUZpZWxkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRlRmllbGQoZmllbGQpIHtcbiAgICAgIHZhciB2YWwgPSB0aGlzLmNvbnRleHRbZmllbGRdO1xuICAgICAgdmFyIG5hbWVGb3JFcnJvciA9IFwiZmllbGQgXCIuY29uY2F0KGZpZWxkKTtcblxuICAgICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgICAvLyBTdHJpbmdzIHdoaWNoIGNvdWxkIGJlIHVzZWQgYXMgcGFydGl0aW9uIGtleXMgKFwic2l0ZVwiIGFuZCBcInNlcnZpY2VOYW1lXCIpIGNhbm5vdCBjb250YWluIHNsYXNoZXMsIGluXG4gICAgICAgIC8vIGFkZGl0aW9uIHRvIHRoZSBvdGhlciByZXN0aWN0aW9ucyBiZWxvdy5cbiAgICAgICAgY2FzZSAnc2l0ZSc6XG4gICAgICAgIGNhc2UgJ3NlcnZpY2VOYW1lJzpcbiAgICAgICAgICBpZiAodmFsLmluZGV4T2YoJy8nKSA+IC0xKSByZXR1cm4gbmV3IEVycm9yKFwiRXhwZWN0ZWQgXCIuY29uY2F0KG5hbWVGb3JFcnJvciwgXCIgdG8gY29udGFpbiBvbmx5IHZhbGlkIGNoYXJhY3RlcnMsIGJ1dCBpdCB3YXMgXCIpLmNvbmNhdCh2YWwsIFwiLiAgSXQgY2Fubm90IGNvbnRhaW4gYSBzbGFzaC5cIikpO1xuICAgICAgICAvLyBFbHNlIGZhbGwgdGhyb3VnaFxuICAgICAgICAvLyBTdHJpbmdzIGZvciBmaWVsZHMg4oCcc2l0ZeKAnSwg4oCcc2VydmljZU5hbWXigJ0sIOKAnG1ldGhvZE5hbWXigJ0sIOKAnG1ldHJpY0tleeKAnSBtdXN0IG1hdGNoIGJlIHZhbGlkIFBNRVQgZmllbGQgbmFtZXM6XG4gICAgICAgIC8vIG1heGltdW0gbGVuZ3RoIG9mIDI1Niwgb25seSBsZXR0ZXJzLCBudW1iZXJzLCBhbmQgdGhlIGRvdCwgY29sb24sIGF0LXNpZ24sIHVuZGVyc2NvcmUsIGZvcndhcmQtc2xhc2gsXG4gICAgICAgIC8vIGFuZCBzbGFzaCBjaGFyYWN0ZXJzIChpbiBzaG9ydCB0aGUgcmVnZXggXltBLVphLXowLTkuOkBfLy1dKyQpLlxuXG4gICAgICAgIGNhc2UgJ21ldGhvZE5hbWUnOlxuICAgICAgICBjYXNlICdhY3Rpb25JZCc6XG4gICAgICAgICAgcmV0dXJuICgwLCBfVmFsaWRhdGVTaW1wbGVTdHJpbmcuZGVmYXVsdCkodmFsLCBuYW1lRm9yRXJyb3IpO1xuXG4gICAgICAgIGNhc2UgJ2Nsb3VkV2F0Y2hEaW1lbnNpb25zJzpcbiAgICAgICAgICByZXR1cm4gKDAsIF92YWxpZGF0ZUNsb3VkV2F0Y2hEaW1lbnNpb25zLmRlZmF1bHQpKHZhbCB8fCBbXSk7XG4gICAgICB9IC8vIE5vIGVycm9yIGZvdW5kLCBpbXBsaWNpdGx5IHJldHVybiB1bmRlZmluZWRcblxuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWlsZGVyIGNsYXNzIGZvciBLYXRhbE1ldHJpY3NDb250ZXh0XG4gICAgICovXG5cbiAgfV0pO1xuICByZXR1cm4gS2F0YWxNZXRyaWNzQ29udGV4dDtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gS2F0YWxNZXRyaWNzQ29udGV4dDtcbigwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKEthdGFsTWV0cmljc0NvbnRleHQsIFwiQnVpbGRlclwiLCAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBfY2xhc3MyKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIF9jbGFzczIpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiY29udGV4dFwiLCB7fSk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShfY2xhc3MyLCBbe1xuICAgIGtleTogXCJ3aXRoU2l0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoU2l0ZShzaXRlKSB7XG4gICAgICB0aGlzLmNvbnRleHQuc2l0ZSA9IHNpdGU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aFNlcnZpY2VOYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhTZXJ2aWNlTmFtZShzZXJ2aWNlTmFtZSkge1xuICAgICAgdGhpcy5jb250ZXh0LnNlcnZpY2VOYW1lID0gc2VydmljZU5hbWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aE1ldGhvZE5hbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aE1ldGhvZE5hbWUobWV0aG9kTmFtZSkge1xuICAgICAgdGhpcy5jb250ZXh0Lm1ldGhvZE5hbWUgPSBtZXRob2ROYW1lO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhBY3Rpb25JZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoQWN0aW9uSWQoYWN0aW9uSWQpIHtcbiAgICAgIHRoaXMuY29udGV4dC5hY3Rpb25JZCA9IGFjdGlvbklkO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhSZXF1ZXN0SWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aFJlcXVlc3RJZChyZXF1ZXN0SWQpIHtcbiAgICAgIHRoaXMuY29udGV4dC5yZXF1ZXN0SWQgPSByZXF1ZXN0SWQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aENsb3VkV2F0Y2hEaW1lbnNpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhDbG91ZFdhdGNoRGltZW5zaW9ucyhkaW1lbnNpb25zKSB7XG4gICAgICB0aGlzLmNvbnRleHQuY2xvdWRXYXRjaERpbWVuc2lvbnMgPSBkaW1lbnNpb25zO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcGxhY2UgYW55IHJlbGF0ZWQgbWV0cmljcyB3aXRoIHRoZSBnaXZlbiBsaXN0IChzZWUgYWRkUmVsYXRlZE1ldHJpY3MgdG8gYWRkIGluc3RlYWQgb2YgcmVwbGFjZSkuXG4gICAgICpcbiAgICAgKiBSZWxhdGVkIG1ldHJpY3MgYXJlIG1ldHJpY3MgdGhhdCBhcmUgcHVibGlzaGVkIHdoZW5ldmVyIGEgbmV3IGFjdGlvbiBpcyBzdGFydGVkLiAgVGhleSBhcmUgdXNlZCB0byByZWxhdGUgdGhlXG4gICAgICogYWN0aW9uIGJhY2sgdG8gdGhlIGNvbnRleHQgd2hlcmUgaXQgaXMgaGFwcGVuaW5nLCBmb3IgZXhhbXBsZSBhIHJlcXVlc3QgSUQgb3IgYSB1c2VyIGlkZW50aXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlbGF0ZWRNZXRyaWNzIFJlbGF0ZWQgbWV0cmljcyB0byBwdWJsaXNoIHdoZW4gYSBuZXcgYWN0aW9uIGlzIHN0YXJ0ZWQgZm9yIHRoaXMgY29udGV4dFxuICAgICAqIEByZXR1cm5zIFRoaXMgYnVpbGRlciBvYmplY3QgdG8gY29udGludWUgYnVpbGRpbmdcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndpdGhSZWxhdGVkTWV0cmljc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoUmVsYXRlZE1ldHJpY3MoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVsYXRlZE1ldHJpY3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIHJlbGF0ZWRNZXRyaWNzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbnRleHQucmVsYXRlZE1ldHJpY3MgPSByZWxhdGVkTWV0cmljcztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYWRkaXRpb25hbCByZWxhdGVkIG1ldHJpY3MgdG8gdGhpcyBidWlsZGVyLiAgU2VlIHdpdGhSZWxhdGVkTWV0cmljcyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWxhdGVkTWV0cmljcyBBZGRpdGlvbmFsIHJlbGF0ZWQgbWV0cmljcyB0byBwdWJsaXNoIHdoZW4gYSBuZXcgYWN0aW9uIGlzIHN0YXJ0ZWQgZm9yIHRoaXMgY29udGV4dFxuICAgICAqIEByZXR1cm5zIFRoaXMgYnVpbGRlciBvYmplY3QgdG8gY29udGludWUgYnVpbGRpbmdcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZFJlbGF0ZWRNZXRyaWNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFJlbGF0ZWRNZXRyaWNzKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCByZWxhdGVkTWV0cmljcyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICByZWxhdGVkTWV0cmljc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbnRleHQucmVsYXRlZE1ldHJpY3MgPSAoMCwgX21lcmdlTGlzdHMubWVyZ2VMaXN0cykodGhpcy5jb250ZXh0LnJlbGF0ZWRNZXRyaWNzLCByZWxhdGVkTWV0cmljcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVwbGFjZSBzaW5nbGUtYWN0aW9uIHJlbGF0ZWQgbWV0cmljcyB3aXRoIHRoZSBnaXZlbiBsaXN0IChzZWUgYWRkUmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb24gdG8gYWRkIGluc3RlYWQgb2YgcmVwbGFjZSxcbiAgICAgKiBhbmQgd2l0aFJlbGF0ZWRNZXRyaWNzIGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHJlbGF0ZWQgbWV0cmljcykuXG4gICAgICpcbiAgICAgKiBTaW5nbGUtYWN0aW9uIHJlbGF0ZWQgbWV0cmljcyBhcmUgcHVibGlzaGVkIHdoZW4gYSBuZXcgY2hpbGQgbWV0cmljIHB1Ymxpc2hlciBpcyBjcmVhdGVkLCBidXQgbm90IGluY2x1ZGVkIGFzXG4gICAgICogcmVsYXRlZCBtZXRyaWNzIGZvciB0aGUgbmV3IGNoaWxkIG1ldHJpYyBwdWJsaXNoZXIsIHNvIGFyZSBub3QgcHVibGlzaGVkIGFnYWluIGlmIHRoZSBjaGlsZCBtZXRyaWMgcHVibGlzaGVyXG4gICAgICogY3JlYXRlcyBncmFuZGNoaWxkIHB1Ymxpc2hlZCBtZXRyaWNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1ldHJpY3MgUmVsYXRlZCBtZXRyaWNzXG4gICAgICogQHJldHVybnMgVGhpcyBidWlsZGVyIG9iamVjdCB0byBjb250aW51ZSBidWlsZGluZ1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aFJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhSZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbigpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgbWV0cmljcyA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICBtZXRyaWNzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29udGV4dC5yZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbiA9IG1ldHJpY3M7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGFkZGl0aW9uYWwgc2luZ2xlLWFjdGlvbiByZWxhdGVkIG1ldHJpY3MgdG8gdGhpcyBidWlsZGVyLiAgU2VlIGFkZFJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1ldHJpY3MgUmVsYXRlZCBtZXRyaWNzXG4gICAgICogQHJldHVybnMgVGhpcyBidWlsZGVyIG9iamVjdCB0byBjb250aW51ZSBidWlsZGluZ1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkUmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIG1ldHJpY3MgPSBuZXcgQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICAgICAgbWV0cmljc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbnRleHQucmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb24gPSAoMCwgX21lcmdlTGlzdHMubWVyZ2VMaXN0cykodGhpcy5jb250ZXh0LnJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uLCBtZXRyaWNzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUYWtlIHRoZSBmaWVsZHMgc2V0IGluIHRoaXMgYnVpbGRlciBhbmQgdXNlIHRoZW0gdG8gY3JlYXRlIGEgbmV3IEthdGFsTWV0cmljc0NvbnRleHQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIEthdGFsTWV0cmljc0NvbnRleHQgb2JqZWN0IGJ1aWx0IHdpdGggdGhlIHBhcmFtZXRlcnMgZ2l2ZW4gdG8gdGhpcyBidWlsZGVyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJidWlsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZCgpIHtcbiAgICAgIHJldHVybiBuZXcgS2F0YWxNZXRyaWNzQ29udGV4dCh0aGlzLmNvbnRleHQpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gX2NsYXNzMjtcbn0oKSk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX3YgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJ1dWlkL3Y0XCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY3NDb250ZXh0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY3NDb250ZXh0XCIpKTtcblxudmFyIF9tZXRyaWNPYmplY3QgPSByZXF1aXJlKFwiLi9tZXRyaWNPYmplY3RcIik7XG5cbnZhciBfbWVyZ2VMaXN0cyA9IHJlcXVpcmUoXCIuL2hlbHBlci9tZXJnZUxpc3RzXCIpO1xuXG52YXIgX21ldHJpY3NFeHRlbnNpb24gPSByZXF1aXJlKFwiLi9oZWxwZXIvbWV0cmljc0V4dGVuc2lvblwiKTtcblxudmFyIF9lbWJlZFJlcXVlc3RJZCA9IHJlcXVpcmUoXCIuL2hlbHBlci9lbWJlZFJlcXVlc3RJZFwiKTtcblxudmFyIElOSVRJQUxJWkFUSU9OX01FVEhPRF9OQU1FID0gJ0luaXRpYWxpemF0aW9uJztcblxuLyoqXG4gKiBEZWZhdWx0IGVycm9yIGhhbmRsZXIgaWYgdGhlIHVzZXItc3VwcGxpZWQgZXJyb3IgaGFuZGxlciBmYWlscyBvciBpcyB1bnNldC5cbiAqIFNob3VsZCBuZXZlciBiZSBjYWxsZWQgdW5sZXNzIHVzZXItcHJvdmlkZWQgZXJyb3IgaGFuZGxlciBtaXNiZWhhdmVzLlxuICovXG52YXIgREVGQVVMVF9FUlJPUl9IQU5ETEVSID0gZnVuY3Rpb24gREVGQVVMVF9FUlJPUl9IQU5ETEVSKGVycikge1xuICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcHVibGlzaGluZyBtZXRyaWNzOlwiKTtcbiAgY29uc29sZS5lcnJvcihlcnIpO1xufTtcblxudmFyIFBBUkVOVF9BQ1RJT05fSURfTkFNRSA9ICdwYXJlbnRBY3Rpb25JZCc7XG5cbnZhciBnZXRDb250ZXh0RmllbGRzID0gZnVuY3Rpb24gZ2V0Q29udGV4dEZpZWxkcyhjb250ZXh0KSB7XG4gIGlmIChjb250ZXh0LmNvbnRleHQpIHtcbiAgICByZXR1cm4gY29udGV4dC5jb250ZXh0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG59O1xuLyoqXG4gKiBDbGFzcyB1c2VkIGZvciBwdWJsaXNoaW5nIG1ldHJpY3MgdG8gS2F0YWwuICBDb250YWlucyBhIGRyaXZlciBhbmQgYSBjb250ZXh0LlxuICpcbiAqIFRoaXMgY2xhc3Mga25vd3MgaG93IHRvIHB1Ymxpc2ggbWV0cmljcywgYW5kIGhvdyB0byBjcmVhdGUgbmV3IHB1Ymxpc2hlcnMgd2l0aCBhIG1vZGlmaWVkIGNvbnRleHQuXG4gKi9cblxuXG52YXIgS2F0YWxNZXRyaWNzUHVibGlzaGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBtZXRyaWNzIHB1Ymxpc2hlciB3aXRoIHRoZSBnaXZlbiBkcml2ZXIgYW5kIGNvbnRleHRcbiAgICpcbiAgICogQHBhcmFtIGRyaXZlciBTdWJjbGFzcyBvZiBLYXRhbE1ldHJpY3NEcml2ZXIgdXNlZCB0byBwdWJsaXNoIHRoZSBtZXRyaWNzXG4gICAqIEBwYXJhbSBlcnJvckhhbmRsZXIgSGFuZGxlciBmb3IgZXJyb3JzIHRoYXQgb2NjdXIgd2hpbGUgdXNpbmcgdGhpcyBwdWJsaXNoZXJcbiAgICogQHBhcmFtIGNvbnRleHQgQ29udGV4dCBmb3IgdGhpcyBtZXRyaWNzIHB1Ymxpc2hlcjsgY29udGFpbnMgZGF0YSB0byBiZSBpbmNsdWRlZCB3aXRoIGV2ZXJ5XG4gICAqICAgICBtZXRyaWMgcHVibGlzaGVkIHVzaW5nIHRoaXMgcHVibGlzaGVyIG9iamVjdC4gIERlZmF1bHQgaXMgYW4gZW1wdHkgY29udGV4dC5cbiAgICovXG4gIGZ1bmN0aW9uIEthdGFsTWV0cmljc1B1Ymxpc2hlcihkcml2ZXIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGVycm9ySGFuZGxlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogREVGQVVMVF9FUlJPUl9IQU5ETEVSO1xuICAgIHZhciBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBuZXcgX0thdGFsTWV0cmljc0NvbnRleHQuZGVmYXVsdCgpO1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEthdGFsTWV0cmljc1B1Ymxpc2hlcik7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJjb21iaW5lZEVycm9ySGFuZGxlclwiLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICB0cnkge1xuICAgICAgICBfdGhpcy5lcnJvckhhbmRsZXIoZXJyKTtcbiAgICAgIH0gY2F0Y2ggKG5leHRFcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGhhbmRsaW5nIGVycm9yIHB1Ymxpc2hpbmcgbWV0cmljczpcIik7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobmV4dEVycik7XG4gICAgICAgIERFRkFVTFRfRVJST1JfSEFORExFUihlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ2hlY2sgZm9yIGEgY29tbW9uIGVycm9yXG4gICAgaWYgKGNvbnRleHQgaW5zdGFuY2VvZiBfS2F0YWxNZXRyaWNzQ29udGV4dC5kZWZhdWx0LkJ1aWxkZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkthdGFsTWV0cmljc0NvbnRleHQuQnVpbGRlciBvYmplY3QgcGFzc2VkIGluc3RlYWQgb2YgS2F0YWxNZXRyaWNzQ29udGV4dC4gIFRyeSBjYWxsaW5nIC5idWlsZCgpIG1ldGhvZC5cIik7XG4gICAgfVxuXG4gICAgdGhpcy5kcml2ZXIgPSBkcml2ZXI7XG4gICAgdGhpcy5lcnJvckhhbmRsZXIgPSBlcnJvckhhbmRsZXI7XG4gICAgdGhpcy5jb250ZXh0ID0gIShjb250ZXh0IGluc3RhbmNlb2YgX0thdGFsTWV0cmljc0NvbnRleHQuZGVmYXVsdCkgPyBuZXcgX0thdGFsTWV0cmljc0NvbnRleHQuZGVmYXVsdChjb250ZXh0KSA6IGNvbnRleHQ7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgdGhlIGVycm9yLWhhbmRsZXIgc3VwcGxpZWQgYnkgdGhlIHVzZXIgd2hlbiB0aGlzIG9iamVjdCB3YXMgY29uc3RydWN0ZWQ7IGlmIHRoYXQgaXMgdW5zZXQgb3IgaXRzZWxmIHRocm93c1xuICAgKiBhbiBleGNlcHRpb24sIGNhbGxzIHRoZSBkZWZhdWx0IGVycm9yIGhhbmRsZXIgYXMgYSBmYWxsYmFjaywgd2hpY2ggd2lsbCBqdXN0IGxvZyB0aGUgZXJyb3IgdG8gdGhlIGNvbnNvbGUuXG4gICAqXG4gICAqIEBwYXJhbSBlcnIgRXJyb3Igb2JqZWN0IHRvIGhhbmRsZVxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEthdGFsTWV0cmljc1B1Ymxpc2hlciwgW3tcbiAgICBrZXk6IFwid2l0aEVycm9ySGFuZGxpbmdcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIHdyYXAgYSBmdW5jdGlvbiBpbiB0aGUgZXJyb3IgaGFuZGxlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkb1RoZVRoaW5nIEZ1bmN0aW9uIHRvIHJ1biB1bmRlciB0aGUgd3JhcHBlclxuICAgICAqIEByZXR1cm4gUmV0dXJuIHZhbHVlIGZyb20gY2FsbGVkIGZ1bmN0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2l0aEVycm9ySGFuZGxpbmcoZG9UaGVUaGluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRvVGhlVGhpbmcoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLmNvbWJpbmVkRXJyb3JIYW5kbGVyKGVycik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gcmV0dXJuIGFsbCB0aGUgcmVsYXRlZCBtZXRyaWNzIG9mIGJhc2UgcHVibGlzaGVyIGFuZCBhZGRpdGlvbmFsQ29udGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsQ29udGV4dCBBZGRpdGlvbmFsIGNvbnRleHQgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIG5ldyBwdWJsaXNoZXJcbiAgICAgKiBAcmV0dXJuIFJldHVybiBhbGwgcmVsYXRlZCBtZXRyaWNzIGZyb20gYmFzZSBwdWJsaXNoZXIgYW5kIGFkZGl0aW9uYWxDb250ZXh0LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QWRkaXRpb25hbFJlbGF0ZWRNZXRyaWNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFkZGl0aW9uYWxSZWxhdGVkTWV0cmljcyhhZGRpdGlvbmFsQ29udGV4dCkge1xuICAgICAgdmFyIG5ld0NvbnRleHQgPSBhZGRpdGlvbmFsQ29udGV4dCBpbnN0YW5jZW9mIF9LYXRhbE1ldHJpY3NDb250ZXh0LmRlZmF1bHQgPyBhZGRpdGlvbmFsQ29udGV4dC5jb250ZXh0IDogYWRkaXRpb25hbENvbnRleHQ7XG4gICAgICB2YXIgYmFzZVJlbGF0ZWRNZXRyaWNzID0gdGhpcy5nZXRCYXNlUmVsYXRlZE1ldHJpY3MoKTtcbiAgICAgIHJldHVybiAoMCwgX21lcmdlTGlzdHMubWVyZ2VMaXN0cykoYmFzZVJlbGF0ZWRNZXRyaWNzLCBuZXdDb250ZXh0LnJlbGF0ZWRNZXRyaWNzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byByZXR1cm4gYWxsIHRoZSByZWxhdGVkIG1ldHJpY3Mgb2YgYmFzZSBwdWJsaXNoZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIFJldHVybiBhbGwgcmVsYXRlZCBtZXRyaWNzIGZyb20gdGhlIGJhc2UgcHVibGlzaGVyLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QmFzZVJlbGF0ZWRNZXRyaWNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJhc2VSZWxhdGVkTWV0cmljcygpIHtcbiAgICAgIHJldHVybiAoMCwgX21lcmdlTGlzdHMubWVyZ2VMaXN0cykodGhpcy5jb250ZXh0LmNvbnRleHQucmVsYXRlZE1ldHJpY3MsIHRoaXMuY29udGV4dC5jb250ZXh0LnJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGlzaCB0aGUgZ2l2ZW4gbWV0cmljIG9iamVjdC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGd1YXJhbnRlZWQgbmV2ZXIgdG8gdGhyb3cgYW4gZXhjZXB0aW9uLiAgSWYgdGhlIG1ldHJpYyBvYmplY3Qgb3IgY29udGV4dCBhcmUgaW52YWxpZCxcbiAgICAgKiBvciBhbnkgb3RoZXIgZXhjZXB0aW9uIGlzIHRocm93biB3aGlsZSBwdWJsaXNoaW5nLCB0aGUgcHVibGlzaGVyJ3MgZXJyb3IgaGFuZGxlciBpcyBjYWxsZWQuICBJZiB0aGVcbiAgICAgKiBwdWJsaXNoZXIncyBlcnJvciBoYW5kbGVyIGlzIHVuc2V0IG9yIGZhaWxzLCB0aGUgZGVmYXVsdCBlcnJvciBoYW5kbGVyIGlzIGNhbGxlZCAoc2VlIGRlZmF1bHRFcnJvckhhbmRsZXIpLlxuICAgICAqXG4gICAgICogQHBhcmFtIGthdGFsTWV0cmljT2JqZWN0IE1ldHJpYyBvYmplY3QgdG8gcHVibGlzaFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHVibGlzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdWJsaXNoKGthdGFsTWV0cmljT2JqZWN0KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy53aXRoRXJyb3JIYW5kbGluZyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICgha2F0YWxNZXRyaWNPYmplY3QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcHVibGlzaCB1bmRlZmluZWQvbnVsbCBtZXRyaWMgb2JqZWN0XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9tZXRyaWNPYmplY3QuT2JqZWN0LlR5cGVzLkxpc3QgPT09IGthdGFsTWV0cmljT2JqZWN0LnR5cGUpIHtcbiAgICAgICAgICBrYXRhbE1ldHJpY09iamVjdC5tZXRyaWNMaXN0LmZvckVhY2goZnVuY3Rpb24gKG1ldHJpYykge1xuICAgICAgICAgICAgX3RoaXMyLnB1Ymxpc2gobWV0cmljKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZHJpdmVyQ29udGV4dCA9IF90aGlzMi5jb250ZXh0LmRyaXZlckNvbnRleHQoKTtcblxuICAgICAgICAgIHZhciBjb250ZXh0RXJyb3IgPSBkcml2ZXJDb250ZXh0LnZhbGlkYXRpb25FcnJvcigpO1xuICAgICAgICAgIGlmIChjb250ZXh0RXJyb3IpIHRocm93IGNvbnRleHRFcnJvcjtcbiAgICAgICAgICB2YXIgb2JqZWN0RXJyb3IgPSBrYXRhbE1ldHJpY09iamVjdC52YWxpZGF0aW9uRXJyb3IoKTtcbiAgICAgICAgICBpZiAob2JqZWN0RXJyb3IpIHRocm93IG9iamVjdEVycm9yO1xuICAgICAgICAgICgwLCBfbWV0cmljc0V4dGVuc2lvbi5kaXNwYXRjaE1ldHJpY0V2ZW50KShrYXRhbE1ldHJpY09iamVjdCwgZHJpdmVyQ29udGV4dCk7XG5cbiAgICAgICAgICBfdGhpczIuZHJpdmVyLnB1Ymxpc2goa2F0YWxNZXRyaWNPYmplY3QsIGRyaXZlckNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHB1Ymxpc2hlciB3aGljaCBpcyBpZGVudGljYWwgdG8gdGhpcyBwdWJsaXNoZXIsIGJ1dCB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGZpZWxkcyBtZXJnZWQgaW50b1xuICAgICAqIHRoZSBuZXcgcHVibGlzaGVyJ3MgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsQ29udGV4dCBBZGRpdGlvbmFsIGNvbnRleHQgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIG5ldyBwdWJsaXNoZXJcbiAgICAgKiBAcmV0dXJucyBOZXcgcHVibGlzaGVyIGlkZW50aWNhbCB0byB0aGlzIG9uZSwgYnV0IHdpdGggYW4gdXBkYXRlZCBjb250ZXh0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJuZXdDaGlsZFB1Ymxpc2hlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXdDaGlsZFB1Ymxpc2hlcihhZGRpdGlvbmFsQ29udGV4dCkge1xuICAgICAgcmV0dXJuIG5ldyBLYXRhbE1ldHJpY3NQdWJsaXNoZXIodGhpcy5kcml2ZXIsIHRoaXMuZXJyb3JIYW5kbGVyLCB0aGlzLmNvbnRleHQubWVyZ2UoYWRkaXRpb25hbENvbnRleHQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmVnaW4gYSBuZXcgYWN0aW9uLCBhbmQgcmV0dXJuIGEgbmV3IHB1Ymxpc2hlciBmb3IgbWV0cmljcyByZWxhdGVkIHRvIHRoYXQgYWN0aW9uLlxuICAgICAqXG4gICAgICogQmVnaW5uaW5nIGEgbmV3IGFjdGlvbiBpbnZvbHZlcyB0aGUgZm9sbG93aW5nIHN0ZXBzOlxuICAgICAqICAgMS4gR2VuZXJhdGUgYSBuZXcgYWN0aW9uSWQgZm9yIHRoZSBhY3Rpb24sIHJhbmRvbWx5IGluIHRoZSBicm93c2VyXG4gICAgICogICAyLiBJZiB0aGVyZSBhcmUgYW55IHJlbGF0ZWQgbWV0cmljcyBpbiB0aGUgY29udGV4dCwgcHVibGlzaCB0aGVtXG4gICAgICogICAzLiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBwdWJsaXNoZXIgd2l0aCB0aGlzIG9iamVjdCdzIGNvbnRleHQsIG1lcmdlZCB3aXRoIGFueSBhZGRpdGlvbmFsIGNvbnRleHQgZ2l2ZW4sXG4gICAgICogICAgICBtZXJnZWQgd2l0aCB0aGUgYWN0aW9uSWQgZ2VuZXJhdGVkIGFib3ZlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxDb250ZXh0IEFkZGl0aW9uYWwgY29udGV4dCB0byBiZSBpbmNsdWRlZCBpbiB0aGUgbmV3IHB1Ymxpc2hlclxuICAgICAqIEByZXR1cm5zIE5ldyBwdWJsaXNoZXIgaWRlbnRpY2FsIHRvIHRoaXMgb25lLCBidXQgd2l0aCBhbiB1cGRhdGVkIGNvbnRleHRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm5ld0NoaWxkQWN0aW9uUHVibGlzaGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5ld0NoaWxkQWN0aW9uUHVibGlzaGVyKGFkZGl0aW9uYWxDb250ZXh0KSB7XG4gICAgICB2YXIgYWN0aW9uSWQgPSB0aGlzLl9nZW5lcmF0ZUFjdGlvbmlkKGFkZGl0aW9uYWxDb250ZXh0KTtcblxuICAgICAgdmFyIG5ld0NvbnRleHQgPSB0aGlzLmNvbnRleHQud2l0aG91dFJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uKCkubWVyZ2Uoe1xuICAgICAgICBhY3Rpb25JZDogYWN0aW9uSWRcbiAgICAgIH0pLm1lcmdlKGFkZGl0aW9uYWxDb250ZXh0KTtcbiAgICAgIHZhciBuZXdQdWJsaXNoZXIgPSBuZXcgS2F0YWxNZXRyaWNzUHVibGlzaGVyKHRoaXMuZHJpdmVyLCB0aGlzLmVycm9ySGFuZGxlciwgbmV3Q29udGV4dCk7XG4gICAgICB2YXIgYWxsUmVsYXRlZE1ldHJpY3MgPSBhZGRpdGlvbmFsQ29udGV4dCAmJiAhKGFkZGl0aW9uYWxDb250ZXh0IGluc3RhbmNlb2YgX0thdGFsTWV0cmljc0NvbnRleHQuZGVmYXVsdC5CdWlsZGVyKSA/IHRoaXMuZ2V0QWRkaXRpb25hbFJlbGF0ZWRNZXRyaWNzKGFkZGl0aW9uYWxDb250ZXh0KSA6IHRoaXMuZ2V0QmFzZVJlbGF0ZWRNZXRyaWNzKCk7XG5cbiAgICAgIGlmIChhbGxSZWxhdGVkTWV0cmljcykge1xuICAgICAgICBhbGxSZWxhdGVkTWV0cmljcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRyaWMpIHtcbiAgICAgICAgICBuZXdQdWJsaXNoZXIucHVibGlzaChtZXRyaWMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld1B1Ymxpc2hlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmVnaW4gYSBuZXcgY2hhaW5lZCBjaGlsZCBhY3Rpb24sIGFuZCByZXR1cm4gYSBuZXcgcHVibGlzaGVyIGZvciBtZXRyaWNzIHJlbGF0ZWQgdG8gdGhhdCBhY3Rpb24uXG4gICAgICpcbiAgICAgKiBBIGNoYWluZWQgYWN0aW9uIGlzIGhhbmRsZWQgdGhlIHNhbWUgd2F5IGFzIGluIG5ld0NoaWxkQWN0aW9uUHVibGlzaGVyLCBidXQgYWRkaXRpb25hbGx5LFxuICAgICAqIHRoZSByZXR1cm5lZCBwdWJsaXNoZXIgaGFzIGEgcmVsYXRlZE1ldHJpY05vSW5oZXJpdCBuYW1lZCBcInBhcmVudEFjdGlvbklkXCIsIHdpdGggdGhlIG5ld2x5XG4gICAgICogZ2VuZXJhdGVkIGFjdGlvbklkIGFzIGl0cyB2YWx1ZS5cbiAgICAgKlxuICAgICAqIFRoZSBlZmZlY3Qgb2YgdGhpcyBpcyB0aGF0IGFueSBmdXJ0aGVyIGNoYWluZWQgY2hpbGQgYWN0aW9ucyBjYW4gYmUgY29ubmVjdGVkIGJhY2sgdG8gdGhpc1xuICAgICAqIGFjdGlvbiB0aHJvdWdoIHRoZSBwYXJlbnRBY3Rpb25JZCwgYW5kIHNvIG9uIHJlY3Vyc2l2ZWx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxDb250ZXh0IEFkZGl0aW9uYWwgY29udGV4dCB0byBiZSBpbmNsdWRlZCBpbiB0aGUgbmV3IHB1Ymxpc2hlclxuICAgICAqIEByZXR1cm5zIE5ldyBwdWJsaXNoZXIgaWRlbnRpY2FsIHRvIHRoaXMgb25lLCBidXQgd2l0aCBhbiB1cGRhdGVkIGNvbnRleHRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm5ld0NoaWxkQWN0aW9uUHVibGlzaGVyQ2hhaW5lZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXdDaGlsZEFjdGlvblB1Ymxpc2hlckNoYWluZWQoYWRkaXRpb25hbENvbnRleHQpIHtcbiAgICAgIHZhciBhY3Rpb25JZCA9IHRoaXMuX2dlbmVyYXRlQWN0aW9uaWQoYWRkaXRpb25hbENvbnRleHQpO1xuXG4gICAgICB2YXIgcGFyZW50QWN0aW9uSWQgPSAoMCwgX2VtYmVkUmVxdWVzdElkLmVtYmVkUmVxdWVzdElkKShhY3Rpb25JZCwgdGhpcy5jb250ZXh0LmNvbnRleHQucmVxdWVzdElkKTtcbiAgICAgIHZhciByZWxhdGVkTWV0cmljc1NpbmdsZUFjdGlvbiA9IFtuZXcgX21ldHJpY09iamVjdC5TdHJpbmcoUEFSRU5UX0FDVElPTl9JRF9OQU1FLCBwYXJlbnRBY3Rpb25JZCldO1xuICAgICAgdmFyIG5ld0NvbnRleHQgPSBuZXcgX0thdGFsTWV0cmljc0NvbnRleHQuZGVmYXVsdCh7XG4gICAgICAgIGFjdGlvbklkOiBhY3Rpb25JZCxcbiAgICAgICAgcmVsYXRlZE1ldHJpY3NTaW5nbGVBY3Rpb246IHJlbGF0ZWRNZXRyaWNzU2luZ2xlQWN0aW9uXG4gICAgICB9KS5tZXJnZShhZGRpdGlvbmFsQ29udGV4dCk7XG4gICAgICByZXR1cm4gdGhpcy5uZXdDaGlsZEFjdGlvblB1Ymxpc2hlcihuZXdDb250ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgY2hhaW5lZCBjaGlsZCBhY3Rpb24gcHVibGlzaGVyIHdpdGggdGhlIGdpdmVuIHZhbHVlIGZvciBtZXRob2ROYW1lLlxuICAgICAqXG4gICAgICogQXBhcnQgZnJvbSBzZXR0aW5nIHRoZSBtZXRob2ROYW1lIGluIHRoZSBjaGlsZCBjb250ZXh0LCB0aGlzIG1ldGhvZCBpcyBpZGVudGljYWwgdG8gbmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXJDaGFpbmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1ldGhvZE5hbWUgTWV0aG9kIG5hbWUgZm9yIG5ldyBwdWJsaXNoZXIgY29udGV4dFxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsQ29udGV4dCBBZGRpdGlvbmFsIGNvbnRleHQgdG8gc3VwcGx5IChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJucyBOZXcgcHVibGlzaGVyIGlkZW50aWNhbCB0byB0aGlzIG9uZSwgYnV0IHdpdGggYW4gdXBkYXRlZCBjb250ZXh0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJuZXdDaGlsZEFjdGlvblB1Ymxpc2hlckNoYWluZWRGb3JNZXRob2RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXJDaGFpbmVkRm9yTWV0aG9kKG1ldGhvZE5hbWUsIGFkZGl0aW9uYWxDb250ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXdDaGlsZEFjdGlvblB1Ymxpc2hlckNoYWluZWQobmV3IF9LYXRhbE1ldHJpY3NDb250ZXh0LmRlZmF1bHQoe1xuICAgICAgICBtZXRob2ROYW1lOiBtZXRob2ROYW1lXG4gICAgICB9KS5tZXJnZShhZGRpdGlvbmFsQ29udGV4dCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBhY3Rpb24gcHVibGlzaGVyIHdpdGggdGhlIGdpdmVuIHZhbHVlIGZvciBtZXRob2ROYW1lLlxuICAgICAqXG4gICAgICogQXBhcnQgZnJvbSBzZXR0aW5nIHRoZSBtZXRob2ROYW1lIGluIHRoZSBjaGlsZCBjb250ZXh0LCB0aGlzIG1ldGhvZCBpcyBpZGVudGljYWwgdG8gbmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXJGb3JNZXRob2QuXG4gICAgICogQHBhcmFtIG1ldGhvZE5hbWUgTWV0aG9kIG5hbWUgZm9yIG5ldyBwdWJsaXNoZXIgY29udGV4dFxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsQ29udGV4dCBBZGRpdGlvbmFsIGNvbnRleHQgdG8gc3VwcGx5IChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJucyBOZXcgcHVibGlzaGVyIGlkZW50aWNhbCB0byB0aGlzIG9uZSwgYnV0IHdpdGggYW4gdXBkYXRlZCBjb250ZXh0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJuZXdDaGlsZEFjdGlvblB1Ymxpc2hlckZvck1ldGhvZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXdDaGlsZEFjdGlvblB1Ymxpc2hlckZvck1ldGhvZChtZXRob2ROYW1lLCBhZGRpdGlvbmFsQ29udGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMubmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXIobmV3IF9LYXRhbE1ldHJpY3NDb250ZXh0LmRlZmF1bHQoe1xuICAgICAgICBtZXRob2ROYW1lOiBtZXRob2ROYW1lXG4gICAgICB9KS5tZXJnZShhZGRpdGlvbmFsQ29udGV4dCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBhY3Rpb24gZm9yIGFwcGxpY2F0aW9uIGluaXRpYWxpemF0aW9uLiAgSXQgd2lsbCBhbHdheXMgaGF2ZSBhIG1ldGhvZE5hbWVcbiAgICAgKiBvZiBcIkluaXRpYWxpemF0aW9uXCI7IG90aGVyd2lzZSB0aGlzIG1ldGhvZCBpcyBpZGVudGljYWwgdG8gbmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXJGb3JNZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbENvbnRleHQgQWRkaXRpb25hbCBjb250ZXh0IHRvIGJlIGluY2x1ZGVkIGluIHRoZSBuZXcgcHVibGlzaGVyXG4gICAgICogQHJldHVybnMgTmV3IHB1Ymxpc2hlciBpZGVudGljYWwgdG8gdGhpcyBvbmUsIGJ1dCB3aXRoIGFuIHVwZGF0ZWQgY29udGV4dFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibmV3Q2hpbGRBY3Rpb25QdWJsaXNoZXJGb3JJbml0aWFsaXphdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXdDaGlsZEFjdGlvblB1Ymxpc2hlckZvckluaXRpYWxpemF0aW9uKGFkZGl0aW9uYWxDb250ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXdDaGlsZEFjdGlvblB1Ymxpc2hlckZvck1ldGhvZChJTklUSUFMSVpBVElPTl9NRVRIT0RfTkFNRSwgYWRkaXRpb25hbENvbnRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIHB1Ymxpc2ggYSBzdHJpbmcgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBhbmQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBNZXRyaWMgbmFtZVxuICAgICAqIEBwYXJhbSB2YWx1ZSBTdHJpbmcgdmFsdWVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInB1Ymxpc2hTdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVibGlzaFN0cmluZyhuYW1lLCB2YWx1ZSkge1xuICAgICAgdGhpcy5wdWJsaXNoKG5ldyBfbWV0cmljT2JqZWN0LlN0cmluZyhuYW1lLCB2YWx1ZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIHB1Ymxpc2ggYSBzdHJpbmcgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBhbmQgdmFsdWUsIHRydW5jYXRlZCB0byB0aGUgbWF4aW11bSBzaXplIGFsbG93ZWQgYnkgdGhlXG4gICAgICogc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgTWV0cmljIG5hbWVcbiAgICAgKiBAcGFyYW0gdmFsdWUgU3RyaW5nIHZhbHVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwdWJsaXNoU3RyaW5nVHJ1bmNhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVibGlzaFN0cmluZ1RydW5jYXRlKG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YXIgb2JqZWN0ID0gbmV3IF9tZXRyaWNPYmplY3QuU3RyaW5nKG5hbWUsIHZhbHVlKTtcbiAgICAgIG9iamVjdC50cnVuY2F0ZSA9IHRydWU7XG4gICAgICB0aGlzLnB1Ymxpc2gob2JqZWN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBwdWJsaXNoIGEgY291bnRlciB3aXRoIHRoZSBnaXZlbiBuYW1lIGFuZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIE1ldHJpYyBuYW1lXG4gICAgICogQHBhcmFtIHZhbHVlIENvdW50ZXIgdmFsdWVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInB1Ymxpc2hDb3VudGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1Ymxpc2hDb3VudGVyKG5hbWUsIHZhbHVlKSB7XG4gICAgICB0aGlzLnB1Ymxpc2gobmV3IF9tZXRyaWNPYmplY3QuQ291bnRlcihuYW1lLCB2YWx1ZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIHB1Ymxpc2ggYSB0aW1lciB3aXRoIHRoZSBnaXZlbiBuYW1lIGFuZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIE1ldHJpYyBuYW1lXG4gICAgICogQHBhcmFtIHZhbHVlIFRpbWVyIHZhbHVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwdWJsaXNoVGltZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVibGlzaFRpbWVyKG5hbWUsIHZhbHVlKSB7XG4gICAgICB0aGlzLnB1Ymxpc2gobmV3IF9tZXRyaWNPYmplY3QuVGltZXIobmFtZSwgdmFsdWUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBwdWJsaXNoIGEgY291bnRlciB3aXRoIHRoZSBpc01vbml0b3IgZmxhZyBzZXQsIGFuZCB0aGUgZ2l2ZW4gbmFtZSBhbmQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBNZXRyaWMgbmFtZVxuICAgICAqIEBwYXJhbSB2YWx1ZSBDb3VudGVyIHZhbHVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwdWJsaXNoQ291bnRlck1vbml0b3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVibGlzaENvdW50ZXJNb25pdG9yKG5hbWUsIHZhbHVlKSB7XG4gICAgICB0aGlzLnB1Ymxpc2gobmV3IF9tZXRyaWNPYmplY3QuQ291bnRlcihuYW1lLCB2YWx1ZSkud2l0aE1vbml0b3IoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gcHVibGlzaCBhIHRpbWVyIHdpdGggdGhlIGlzTW9uaXRvciBmbGFnIHNldCwgYW5kIHRoZSBnaXZlbiBuYW1lIGFuZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIE1ldHJpYyBuYW1lXG4gICAgICogQHBhcmFtIHZhbHVlIFRpbWVyIHZhbHVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwdWJsaXNoVGltZXJNb25pdG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1Ymxpc2hUaW1lck1vbml0b3IobmFtZSwgdmFsdWUpIHtcbiAgICAgIHRoaXMucHVibGlzaChuZXcgX21ldHJpY09iamVjdC5UaW1lcihuYW1lLCB2YWx1ZSkud2l0aE1vbml0b3IoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByaXZhdGUgaGVscGVyIG1ldGhvZCB0byBleHRyYWN0IGFuIGFjdGlvbklkIGZyb20gYSBjb250ZXh0IGlmIG9uZSBpcyBwcm92aWRlZCwgYW5kIG90aGVyd2lzZSBnZW5lcmF0ZSBhIG5ldyBvbmUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBY3Rpb24gSUQgc3RyaW5nXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2VuZXJhdGVBY3Rpb25pZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2VuZXJhdGVBY3Rpb25pZChjb250ZXh0KSB7XG4gICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICB2YXIgZmllbGRzID0gZ2V0Q29udGV4dEZpZWxkcyhjb250ZXh0KTtcblxuICAgICAgICBpZiAoZmllbGRzLmFjdGlvbklkKSB7XG4gICAgICAgICAgcmV0dXJuIGZpZWxkcy5hY3Rpb25JZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gKDAsIF92LmRlZmF1bHQpKCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBLYXRhbE1ldHJpY3NQdWJsaXNoZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEthdGFsTWV0cmljc1B1Ymxpc2hlcjsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuREVGQVVMVF9FUlJPUl9IQU5ETEVSID0gdm9pZCAwO1xuXG52YXIgREVGQVVMVF9FUlJPUl9IQU5ETEVSID0gZnVuY3Rpb24gREVGQVVMVF9FUlJPUl9IQU5ETEVSKGVycikge1xuICB0aHJvdyBlcnI7XG59O1xuXG5leHBvcnRzLkRFRkFVTFRfRVJST1JfSEFORExFUiA9IERFRkFVTFRfRVJST1JfSEFORExFUjsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbi8qKlxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgYSBLYXRhbCBtZXRyaWNzIGRyaXZlci5cbiAqL1xudmFyIEthdGFsTWV0cmljc0RyaXZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEthdGFsTWV0cmljc0RyaXZlcigpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBLYXRhbE1ldHJpY3NEcml2ZXIpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoS2F0YWxNZXRyaWNzRHJpdmVyLCBbe1xuICAgIGtleTogXCJwdWJsaXNoXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogUHVibGlzaCB0aGUgZ2l2ZW4gbWV0cmljIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBlcnJvciBoYW5kbGVyIGFuZCBjb250ZXh0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG1ldHJpY09iamVjdCBNZXRyaWMgb2JqZWN0IHRvIHB1Ymxpc2guICBDb250YWlucyBtZXRyaWNLZXksIGlzTW9uaXRvciwgdHlwZSwgYW5kIHZhbHVlLlxuICAgICAqIEBwYXJhbSBjb250ZXh0IENvbnRleHQgZm9yIHB1Ymxpc2hpbmcgdGhpcyBtZXRyaWMuICBDb250YWlucyBhbGwgb3RoZXIgZmllbGRzIHRvIGJlIHB1Ymxpc2hlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdWJsaXNoKG1ldHJpY09iamVjdCwgY29udGV4dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdLYXRhbE1ldHJpY3NEcml2ZXIgaXMgYW4gYWJzdHJhY3QgY2xhc3MsIHBsZWFzZSBjaG9vc2UgYSBkcml2ZXIgYW5kIHVzZSB0aGF0IGluc3RlYWQnKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEthdGFsTWV0cmljc0RyaXZlcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gS2F0YWxNZXRyaWNzRHJpdmVyOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZmlyc3RNYXA7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3Qgbm9uLXVuZGVmaW5lZCB2YWx1ZSB0aGF0IHJlc3VsdHMgZnJvbSBydW5uaW5nIGVhY2ggdmFsdWVcbiAqIGluIHRoZSBnaXZlbiBhcnJheSB0aHJvdWdoIHRoZSBtYXBwZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0gYXJyYXkgQW4gYXJyYXkgb2YgdmFsdWVzLlxuICogQHBhcmFtIG1hcHBlciBBIG1hcHBlciBmdW5jdGlvbiB0aGF0IHNob3VsZCByZXR1cm4gYSB2YWx1ZSBvciB1bmRlZmluZWQuXG4gKiBAcmV0dXJucyBUaGUgZmlyc3Qgbm9uLXVuZGVmaW5lZCB2YWx1ZSBmcm9tIHRoZSBtYXBwZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGZpcnN0TWFwKGFycmF5LCBtYXBwZXIpIHtcbiAgdmFyIHRvUmV0dXJuID0gdW5kZWZpbmVkO1xuICBhcnJheS5zb21lKGZ1bmN0aW9uICh2YWwpIHtcbiAgICB0b1JldHVybiA9IG1hcHBlcih2YWwpO1xuICAgIHJldHVybiB0b1JldHVybiAhPSBudWxsO1xuICB9KTtcbiAgcmV0dXJuIHRvUmV0dXJuO1xufVxuXG47IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgb2JqZWN0VmFsdWVzID0gT2JqZWN0LnZhbHVlcyA/IE9iamVjdC52YWx1ZXMgOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICB9KTtcbn07XG52YXIgX2RlZmF1bHQgPSBvYmplY3RWYWx1ZXM7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2YWxpZGF0ZVNpbXBsZUludDtcblxudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIikpO1xuXG4vKipcbiAqIE51bWJlci5pc0ludGVnZXIgaXMgbm90IGluIElFMTEsIGFuZCBsZXR0aW5nIEJhYmVsIHBvbHlmaWxsIGl0IGFkZGVkIHRvbyBtdWNoIHdlaWdodC5cbiAqIEFkYXB0ZWQgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvaXNJbnRlZ2VyXG4gKi9cbnZhciBpc0ludGVnZXIgPSBmdW5jdGlvbiBpc0ludGVnZXIodmFsKSB7XG4gIHJldHVybiBpc0Zpbml0ZSh2YWwpICYmIE1hdGguZmxvb3IodmFsKSA9PT0gdmFsO1xufTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIHZhbGlkIHRvIGJlIHB1Ymxpc2hlZCB0byBLYXRhbE1ldHJpY3MgYXMgYW4gaW50ZWdlciAoQ291bnRlciBvciBUaW1lciksXG4gKiBhbmQgcmV0dXJuIGVpdGhlciB1bmRlZmluZWQgKG5vIGVycm9yKSwgb3IgYW4gRXJyb3Igb2JqZWN0IGRlc2NyaWJpbmcgdGhlIHByb2JsZW0uXG4gKlxuICogQHBhcmFtIHZhbCBWYWx1ZSB0byBjaGVja1xuICogQHBhcmFtIG5hbWVGb3JFcnJvciBOYW1lIHRvIHVzZSB3aGVuIGNvbnN0cnVjdGluZyB0aGUgZXJyb3IgbWVzc2FnZSwgaWYgbmVjZXNzYXJ5XG4gKiBAcmV0dXJucyBFcnJvciwgb3IgdW5kZWZpbmVkIGlmIG5vIGVycm9yXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVNpbXBsZUludCh2YWwsIG5hbWVGb3JFcnJvcikge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiRXhwZWN0ZWQgXCIuY29uY2F0KG5hbWVGb3JFcnJvciwgXCIgdG8gaGF2ZSB0eXBlICdudW1iZXInLCBidXQgaXQgd2FzIHR5cGUgJ1wiKS5jb25jYXQoKDAsIF90eXBlb2YyLmRlZmF1bHQpKHZhbCksIFwiJ1wiKSk7XG4gIH1cblxuICBpZiAodmFsIDwgMCkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJFeHBlY3RlZCBcIi5jb25jYXQobmFtZUZvckVycm9yLCBcIiB0byBiZSBwb3NpdGl2ZSwgYnV0IGl0IHdhcyBcIikuY29uY2F0KHZhbCkpO1xuICB9IC8vIFRoaXMgd2lsbCBhbHNvIGNhdGNoIE5hTiBhbmQgSW5maW5pdHlcblxuXG4gIGlmICghaXNJbnRlZ2VyKHZhbCkpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiRXhwZWN0ZWQgXCIuY29uY2F0KG5hbWVGb3JFcnJvciwgXCIgdG8gYmUgYW4gaW50ZWdlciwgYnV0IGl0IHdhcyBcIikuY29uY2F0KHZhbCkpO1xuICB9IC8vIENvdWxkbid0IGZpbmQgYW55dGhpbmcgd3JvbmcsIGltcGxpY2l0bHkgcmV0dXJuIHVuZGVmaW5lZFxuXG59XG5cbjsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2YWxpZGF0ZVNpbXBsZVN0cmluZztcblxudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIikpO1xuXG52YXIgU0lNUExFX1NUUklOR19QQVQgPSAvXltBLVphLXowLTkuOkBfLy1dKyQvO1xudmFyIFNJTVBMRV9TVFJJTkdfTUFYX0xFTiA9IDEyNztcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIHZhbGlkIHRvIGJlIHB1Ymxpc2hlZCB0byBLYXRhbE1ldHJpY3MgYXMgYSBmaWVsZCB2YWx1ZSxcbiAqIHN1Y2ggYXMgc2l0ZSwgc2VydmljZU5hbWUsIG1ldGhvZE5hbWUsIG9yIGFjdGlvbklkIChub3RlIHRoaXMgaXMgbm90IHVzZWQgdG8gY2hlY2sgdmFsdWVzIGZvciBzdHJpbmcgbWV0cmljcykuXG4gKiBJdCByZXR1cm5zIGVpdGhlciB1bmRlZmluZWQgKG5vIGVycm9yKSwgb3IgYW4gRXJyb3Igb2JqZWN0IGRlc2NyaWJpbmcgdGhlIHByb2JsZW0uXG4gKlxuICogVG8gYmUgcHVibGlzaGVkLCBpdCBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZywgbGVzcyB0aGFuIDI1NiBjaGFyYWN0ZXJzLCBjb250YWluaW5nIG9ubHkgQVNDSUlcbiAqIGxldHRlcnMsIG51bWJlcnMsIG9yIHRoZXNlIGNoYXJhY3RlcnM6IC46QF8vLSAodGhvc2UgYXJlIHRoZSBQTUVUIGZpZWxkIHZhbHVlIHJlcXVpcmVtZW50cykuXG4gKlxuICogQHBhcmFtIHZhbCBTdHJpbmcgdmFsdWUgdG8gY2hlY2tcbiAqIEBwYXJhbSBuYW1lRm9yRXJyb3IgTmFtZSB0byB1c2UgaW4gdGhlIGVycm9yIG1lc3NhZ2UsIGlmIG9uZSBpcyBnZW5lcmF0ZWRcbiAqIEByZXR1cm5zIEVycm9yLCBvciB1bmRlZmluZWQgaWYgbm8gZXJyb3JcbiAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVNpbXBsZVN0cmluZyh2YWwsIG5hbWVGb3JFcnJvcikge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJFeHBlY3RlZCBcIi5jb25jYXQobmFtZUZvckVycm9yLCBcIiB0byBiZSBhIHN0cmluZywgYnV0IGl0IHdhcyBhIFwiKS5jb25jYXQoKDAsIF90eXBlb2YyLmRlZmF1bHQpKHZhbCkpKTtcbiAgfVxuXG4gIGlmICh2YWwubGVuZ3RoID4gU0lNUExFX1NUUklOR19NQVhfTEVOKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcIkV4cGVjdGVkIFwiLmNvbmNhdChuYW1lRm9yRXJyb3IsIFwiIHRvIGJlIGxlc3MgdGhhbiBcIikuY29uY2F0KFNJTVBMRV9TVFJJTkdfTUFYX0xFTiwgXCIgY2hhcmFjdGVycywgYnV0IGl0IHdhcyBcIikuY29uY2F0KHZhbC5sZW5ndGgsIFwiIGNoYXJhY3RlcnNcIikpO1xuICB9XG5cbiAgaWYgKHZhbC5sZW5ndGggPCAxKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcIkV4cGVjdGVkIFwiLmNvbmNhdChuYW1lRm9yRXJyb3IsIFwiIHRvIGJlIG5vbi1ibGFua1wiKSk7XG4gIH1cblxuICBpZiAoIVNJTVBMRV9TVFJJTkdfUEFULnRlc3QodmFsKSkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJFeHBlY3RlZCBcIi5jb25jYXQobmFtZUZvckVycm9yLCBcIiB0byBjb250YWluIG9ubHkgdmFsaWQgY2hhcmFjdGVycywgYnV0IGl0IHdhcyBcIikuY29uY2F0KHZhbCwgXCIuICBJdCBjYW4gb25seSBjb250YWluIGxldHRlcnMsIG51bWJlcnMsIGFuZCB0aGVzZSBzeW1ib2xzOiAuOkBfLy1cIikpO1xuICB9IC8vIENvdWxkbid0IGZpbmQgYW55dGhpbmcgd3JvbmcsIGltcGxpY2l0bHkgcmV0dXJuIHVuZGVmaW5lZFxuXG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmVtYmVkUmVxdWVzdElkID0gZW1iZWRSZXF1ZXN0SWQ7XG5cbi8vIHVudGlsIHdlIGNhbiBhZGQgYSByZXF1ZXN0SWQgZmllbGQgdG8gdGhlIGFuZGVzIHNjaGVtYSB3ZSB3aWxsIGVtYmVkIGl0IGluIHRoZSBhY3Rpb25JZFxuZnVuY3Rpb24gZW1iZWRSZXF1ZXN0SWQoYWN0aW9uSWQsIHJlcXVlc3RJZCkge1xuICBpZiAocmVxdWVzdElkKSB7XG4gICAgcmV0dXJuIFtyZXF1ZXN0SWQsIGFjdGlvbklkXS5qb2luKFwiOjpcIik7XG4gIH1cblxuICByZXR1cm4gYWN0aW9uSWQ7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5tZXJnZUxpc3RzID0gbWVyZ2VMaXN0cztcblxudmFyIF90b0NvbnN1bWFibGVBcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5XCIpKTtcblxuLy8gSGVscGVyIG1ldGhvZCB0byBtZXJnZSB0d28gbGlzdHMgd2hpY2ggY291bGQgYmUgdW5kZWZpbmVkXG4vLyBSZXR1cm5zIG1lcmdlZCBsaXN0cyBpZiBlaXRoZXIgaXMgZGVmaW5lZCwgb3RoZXJ3aXNlIHJldHVybnMgdW5kZWZpbmVkXG5mdW5jdGlvbiBtZXJnZUxpc3RzKGxpc3QxLCBsaXN0Mikge1xuICBpZiAobGlzdDEgfHwgbGlzdDIpIHtcbiAgICByZXR1cm4gW10uY29uY2F0KCgwLCBfdG9Db25zdW1hYmxlQXJyYXkyLmRlZmF1bHQpKGxpc3QxIHx8IFtdKSwgKDAsIF90b0NvbnN1bWFibGVBcnJheTIuZGVmYXVsdCkobGlzdDIgfHwgW10pKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbjsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGlzcGF0Y2hNZXRyaWNFdmVudCA9IGRpc3BhdGNoTWV0cmljRXZlbnQ7XG5cbi8qKlxuICogUHVibGlzaCB0byBleHRlcm5hbCBwYXJ0aWVzIHRoYXQgYXJlIFxuICogbGlzdGVuaW5nIGZvciBrYXRhbC5tZXRyaWNzLnB1Ymxpc2ggQ3VzdG9tIEV2ZW50c1xuICovXG5mdW5jdGlvbiBkaXNwYXRjaE1ldHJpY0V2ZW50KG1ldHJpYywgY29udGV4dCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBkaXNwYXRjaEN1c3RvbUV2ZW50KG1ldHJpYywgY29udGV4dCk7IC8vIGZvciBsZWdhY3kgcHVycG9zZXMsIGFsc28gcHVibGlzaCB0byBfX0tBVEFMX01FVFJJQ1NfRVhURU5TSU9OX19cblxuICBwdWJsaXNoVG9NZXRyaWNzRXh0ZW5zaW9uKG1ldHJpYywgY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoQ3VzdG9tRXZlbnQobWV0cmljLCBjb250ZXh0KSB7XG4gIGlmICh0eXBlb2YgQ3VzdG9tRXZlbnQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBldmVudCA9IG5ldyBDdXN0b21FdmVudCgna2F0YWwubWV0cmljcy5wdWJsaXNoJywge1xuICAgIGRldGFpbDoge1xuICAgICAgbWV0cmljOiBtZXRyaWMsXG4gICAgICBjb250ZXh0OiBjb250ZXh0LmdldEZpZWxkcygpXG4gICAgfVxuICB9KTtcbiAgd2luZG93LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufVxuLyoqXG4gKiBARGVwcmVjYXRlZFxuICogUHVibGlzaCB0byBodHRwczovL2NvZGUuYW1hem9uLmNvbS9wYWNrYWdlcy9LYXRhbE1ldHJpY3NFeHRlbnNpb25cbiAqIFRoZSBleHRlbnNpb24gaW5qZWN0cyBhIGdsb2JhbCBfX0tBVEFMX01FVFJJQ1NfRVhURU5TSU9OX18gb2JqZWN0IHdpdGggYVxuICogYHB1Ymxpc2hgIG1ldGhvZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHB1Ymxpc2hUb01ldHJpY3NFeHRlbnNpb24obWV0cmljLCBjb250ZXh0KSB7XG4gIHZhciBleHRlbnNpb24gPSB3aW5kb3cuX19LQVRBTF9NRVRSSUNTX0VYVEVOU0lPTl9fO1xuXG4gIGlmIChleHRlbnNpb24pIHtcbiAgICBleHRlbnNpb24ucHVibGlzaChtZXRyaWMsIGNvbnRleHQuZ2V0RmllbGRzKCkpO1xuICB9XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdmFsaWRhdGVDbG91ZFdhdGNoRGltZW5zaW9ucztcblxudmFyIF9GaXJzdE1hcCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vRmlyc3RNYXBcIikpO1xuXG52YXIgUFJJTlRBQkxFX0FTQ0lJX1BBVFRFUk4gPSAvXltcXHgyMC1cXHg3RV0rJC87XG52YXIgQVRfTEVBU1RfT05FX05PTl9XSElURVNQQUNFX1BBVFRFUk4gPSAvXi4qXFxTKy4qJC87XG52YXIgRElNRU5TSU9OX05BTUVfU1RSSU5HX01BWF9MRU4gPSAyNTU7XG52YXIgRElNRU5TSU9OX1ZBTFVFX1NUUklOR19NQVhfTEVOID0gMTAyNDtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGRpbWVuc2lvbnMgYXJlIHZhbGlkIHRvIGJlIHB1Ymxpc2hlZCB0byBLYXRhbE1vbml0b3JpbmcgYmFjay1lbmQuXG4gKiBJdCByZXR1cm5zIGVpdGhlciB1bmRlZmluZWQgKG5vIGVycm9yKSwgb3IgYW4gRXJyb3Igb2JqZWN0IGRlc2NyaWJpbmcgdGhlIHByb2JsZW0uXG4gKlxuICogVG8gYmUgcHVibGlzaGVkLCBuYW1lIGFuZCB2YWx1ZSBvZiBzdHJpbmcgbWV0cmljcyBtdXN0IGZvbGxvdyByZXN0cmljdGlvbnMgYXMgZGVzY3JpYmVkIGJ5XG4gKiBDbG91ZFdhdGNoIERpbWVuc2lvbiBBUEkgRG9jdW1lbnRhdGlvbjpcbiAqIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BbWF6b25DbG91ZFdhdGNoL2xhdGVzdC9BUElSZWZlcmVuY2UvQVBJX0RpbWVuc2lvbi5odG1sXG4gKlxuICogQHBhcmFtIGRpbWVuc2lvbnMgQXJyYXkgb2Ygc3RyaW5nIG1ldHJpY3MgdG8gY2hlY2tcbiAqIEByZXR1cm5zIEVycm9yLCBvciB1bmRlZmluZWQgaWYgbm8gZXJyb3JcbiAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZUNsb3VkV2F0Y2hEaW1lbnNpb25zKGRpbWVuc2lvbnMpIHtcbiAgcmV0dXJuICgwLCBfRmlyc3RNYXAuZGVmYXVsdCkoZGltZW5zaW9ucywgZnVuY3Rpb24gKGRpbWVuc2lvbikge1xuICAgIHZhciBuYW1lID0gZGltZW5zaW9uLm5hbWUsXG4gICAgICAgIHZhbHVlID0gZGltZW5zaW9uLnZhbHVlO1xuICAgIHJldHVybiB2YWxpZGF0ZUNsb3VkV2F0Y2hEaW1lbnNpb24obmFtZSwgdmFsdWUpO1xuICB9KTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGRpbWVuc2lvbiBpcyB2YWxpZCBhcyBkZXNjcmliZWQgYnkgQ2xvdWRXYXRjaCBkb2N1bWVudGF0aW9uLlxuICogaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FtYXpvbkNsb3VkV2F0Y2gvbGF0ZXN0L0FQSVJlZmVyZW5jZS9BUElfRGltZW5zaW9uLmh0bWxcbiAqXG4gKiBAcGFyYW0gbmFtZSBDbG91ZFdhdGNoIERpbWVuc2lvbiBOYW1lIFN0cmluZyB0byBjaGVja1xuICogQHBhcmFtIHZhbHVlIENsb3VkV2F0Y2ggRGltZW5zaW9uIFZhbHVlIFN0cmluZyB0byBjaGVja1xuICogQHJldHVybnMgRXJyb3IsIG9yIHVuZGVmaW5lZCBpZiBubyBlcnJvclxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDbG91ZFdhdGNoRGltZW5zaW9uKG5hbWUsIHZhbHVlKSB7XG4gIGlmIChuYW1lLmxlbmd0aCA+IERJTUVOU0lPTl9OQU1FX1NUUklOR19NQVhfTEVOKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcIkV4cGVjdGVkIERpbWVuc2lvbiBuYW1lIGZvciB2YWx1ZSBcIi5jb25jYXQodmFsdWUsIFwiIHRvIGJlIFwiKS5jb25jYXQoRElNRU5TSU9OX05BTUVfU1RSSU5HX01BWF9MRU4sIFwiIGNoYXJhY3RlcnMgb3IgbGVzcywgYnV0IGl0IHdhcyBcIikuY29uY2F0KG5hbWUubGVuZ3RoLCBcIiBjaGFyYWN0ZXJzXCIpKTtcbiAgfVxuXG4gIGlmIChuYW1lLmxlbmd0aCA8IDEpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiRXhwZWN0ZWQgRGltZW5zaW9uIG5hbWUgZm9yIHZhbHVlIFwiLmNvbmNhdCh2YWx1ZSwgXCIgdG8gYmUgbm9uLWJsYW5rXCIpKTtcbiAgfVxuXG4gIGlmICghUFJJTlRBQkxFX0FTQ0lJX1BBVFRFUk4udGVzdChuYW1lKSkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJFeHBlY3RlZCBEaW1lbnNpb24gbmFtZSBmb3IgdmFsdWUgXCIuY29uY2F0KHZhbHVlLCBcIiB0byBjb250YWluIG9ubHkgQVNDSUkgY2hhcmFjdGVycywgYnV0IGl0IHdhcyBcIikuY29uY2F0KG5hbWUpKTtcbiAgfVxuXG4gIGlmICghQVRfTEVBU1RfT05FX05PTl9XSElURVNQQUNFX1BBVFRFUk4udGVzdChuYW1lKSkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJFeHBlY3RlZCBEaW1lbnNpb24gbmFtZSBmb3IgdmFsdWUgXCIuY29uY2F0KHZhbHVlLCBcIiB0byBjb250YWluIGF0IGxlYXN0IG9uZSBub24gd2hpdGVzcGFjZSBjaGFyYWN0ZXIsIGJ1dCBpdCB3YXMgXCIpLmNvbmNhdChuYW1lKSk7XG4gIH1cblxuICBpZiAobmFtZS5zdGFydHNXaXRoKFwiOlwiKSkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJFeHBlY3RlZCBEaW1lbnNpb24gbmFtZSBmb3IgdmFsdWUgXCIuY29uY2F0KHZhbHVlLCBcIiB0byBub3Qgc3RhcnQgd2l0aCBhIGNvbG9uIChcXFwiOlxcXCIpLCBidXQgaXQgd2FzIFwiKS5jb25jYXQobmFtZSkpO1xuICB9XG5cbiAgaWYgKHZhbHVlLmxlbmd0aCA+IERJTUVOU0lPTl9WQUxVRV9TVFJJTkdfTUFYX0xFTikge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJFeHBlY3RlZCBEaW1lbnNpb24gdmFsdWUgZm9yIG5hbWUgXCIuY29uY2F0KG5hbWUsIFwiIHRvIGJlIFwiKS5jb25jYXQoRElNRU5TSU9OX1ZBTFVFX1NUUklOR19NQVhfTEVOLCBcIiBjaGFyYWN0ZXJzIG9yIGxlc3MsIGJ1dCBpdCB3YXMgXCIpLmNvbmNhdCh2YWx1ZS5sZW5ndGgsIFwiIGNoYXJhY3RlcnNcIikpO1xuICB9XG5cbiAgaWYgKHZhbHVlLmxlbmd0aCA8IDEpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiRXhwZWN0ZWQgRGltZW5zaW9uIHZhbHVlIGZvciBuYW1lIFwiLmNvbmNhdChuYW1lLCBcIiB0byBiZSBub24tYmxhbmtcIikpO1xuICB9XG5cbiAgaWYgKCFQUklOVEFCTEVfQVNDSUlfUEFUVEVSTi50ZXN0KHZhbHVlKSkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJFeHBlY3RlZCBEaW1lbnNpb24gdmFsdWUgZm9yIG5hbWUgXCIuY29uY2F0KG5hbWUsIFwiIHRvIGNvbnRhaW4gb25seSBBU0NJSSBjaGFyYWN0ZXJzLCBidXQgaXQgd2FzIFwiKS5jb25jYXQodmFsdWUpKTtcbiAgfVxuXG4gIGlmICghQVRfTEVBU1RfT05FX05PTl9XSElURVNQQUNFX1BBVFRFUk4udGVzdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiRXhwZWN0ZWQgRGltZW5zaW9uIHZhbHVlIGZvciBuYW1lIFwiLmNvbmNhdChuYW1lLCBcIiB0byBjb250YWluIGF0IGxlYXN0IG9uZSBub24gd2hpdGVzcGFjZSBjaGFyYWN0ZXIsIGJ1dCBpdCB3YXMgXCIpLmNvbmNhdCh2YWx1ZSwgXCJ9XCIpKTtcbiAgfSAvLyBDb3VsZG4ndCBmaW5kIGFueXRoaW5nIHdyb25nLCBpbXBsaWNpdGx5IHJldHVybiB1bmRlZmluZWRcblxufSIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxudmFyIF90eXBlb2YgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDbG91ZFdhdGNoRGltZW5zaW9uc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfQ2xvdWRXYXRjaERpbWVuc2lvbnMuQ2xvdWRXYXRjaERpbWVuc2lvbnM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29udGV4dFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfS2F0YWxNZXRyaWNzQ29udGV4dC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVycm9ySGFuZGxlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfRXJyb3JIYW5kbGVyLkVycm9ySGFuZGxlcjtcbiAgfVxufSk7XG5leHBvcnRzLk1ldHJpYyA9IHZvaWQgMDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1ldHJpY3NEcml2ZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0thdGFsTWV0cmljc0RyaXZlci5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlB1Ymxpc2hlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfS2F0YWxNZXRyaWNzUHVibGlzaGVyLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgTWV0cmljID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vbWV0cmljT2JqZWN0XCIpKTtcblxuZXhwb3J0cy5NZXRyaWMgPSBNZXRyaWM7XG5cbnZhciBfS2F0YWxNZXRyaWNzUHVibGlzaGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY3NQdWJsaXNoZXJcIikpO1xuXG52YXIgX0thdGFsTWV0cmljc0NvbnRleHQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljc0NvbnRleHRcIikpO1xuXG52YXIgX0thdGFsTWV0cmljc0RyaXZlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZHJpdmVyL0thdGFsTWV0cmljc0RyaXZlclwiKSk7XG5cbnZhciBfRXJyb3JIYW5kbGVyID0gcmVxdWlyZShcIi4vZHJpdmVyL0Vycm9ySGFuZGxlclwiKTtcblxudmFyIF9DbG91ZFdhdGNoRGltZW5zaW9ucyA9IHJlcXVpcmUoXCIuL3R5cGVzL0Nsb3VkV2F0Y2hEaW1lbnNpb25zXCIpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGVCYWJlbEludGVyb3AgPSBuZXcgV2Vha01hcCgpOyB2YXIgY2FjaGVOb2RlSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IHJldHVybiBub2RlSW50ZXJvcCA/IGNhY2hlTm9kZUludGVyb3AgOiBjYWNoZUJhYmVsSW50ZXJvcDsgfSkobm9kZUludGVyb3ApOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaiwgbm9kZUludGVyb3ApIHsgaWYgKCFub2RlSW50ZXJvcCAmJiBvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgZGVmYXVsdDogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoa2V5ICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2dldDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFwiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX0thdGFsTWV0cmljT2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNPYmplY3RcIikpO1xuXG52YXIgX1ZhbGlkYXRlU2ltcGxlSW50ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vaGVscGVyL1ZhbGlkYXRlU2ltcGxlSW50XCIpKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yLmRlZmF1bHQpKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbi8qKlxuICogQ291bnRlciB0eXBlLlxuICpcbiAqIENhbiBiZSB1c2VkIHRvIGNvdW50IHRoZSBudW1iZXIgb2YgdGltZXMgYW4gZXZlbnQgaGFwcGVuZWQgb24gYSBwYWdlLCBvciBhcyBhIHNpbXBsZSAxLzAgY291bnRlciB0byB0cmFja1xuICogc3VjY2VzcyBhbmQgZmFpbHVyZS5cbiAqL1xudmFyIEthdGFsTWV0cmljQ291bnRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0thdGFsTWV0cmljT2JqZWN0KSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEthdGFsTWV0cmljQ291bnRlciwgX0thdGFsTWV0cmljT2JqZWN0KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEthdGFsTWV0cmljQ291bnRlcik7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBjb3VudGVyIHdpdGggdGhlIGdpdmVuIG5hbWUgYW5kIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBDb3VudGVyIG5hbWVcbiAgICogQHBhcmFtIHZhbHVlIENvdW50ZXIgdmFsdWVcbiAgICovXG4gIGZ1bmN0aW9uIEthdGFsTWV0cmljQ291bnRlcihuYW1lKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgdmFyIHZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEthdGFsTWV0cmljQ291bnRlcik7XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lKTtcbiAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBmb3IgdGhpcyBjb3VudGVyXG4gICAqXG4gICAqIEByZXR1cm4gQ291bnRlciB2YWx1ZVxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEthdGFsTWV0cmljQ291bnRlciwgW3tcbiAgICBrZXk6IFwidmFsdWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IGEgbmV3IHZhbHVlIGZvciB0aGlzIGNvdW50ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBOZXcgdmFsdWUgZm9yIHRoaXMgY291bnRlclxuICAgICAqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgLy8gTWF0aC5yb3VuZCB3aWxsIGFsc28gY29lcmNlIGZyb20gYSBzdHJpbmcgaWYgbmVjZXNzYXJ5LCBhbmQgcmV0dXJuIE5hTiBpZiBpbnZhbGlkXG4gICAgICB0aGlzLl92YWx1ZSA9IE1hdGgucm91bmQodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB0eXBlIGZvciB0aGlzIGNvdW50ZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIEFsd2F5cyByZXR1cm5zIFwiQ291bnRlclwiLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidHlwZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9LYXRhbE1ldHJpY09iamVjdDIuZGVmYXVsdC5UeXBlcy5Db3VudGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBudW1iZXIgdG8gdGhpcyBjb3VudGVyLlxuICAgICAqXG4gICAgICogQ2FuIGFsc28gYmUgbmVnYXRpdmUgdG8gc3VidHJhY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkVmFsdWUgQW1vdW50IHRvIGFkZCB0byB0aGlzIGNvdW50ZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoYWRkVmFsdWUpIHtcbiAgICAgIHRoaXMudmFsdWUgKz0gYWRkVmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbk1vbml0b3JcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWxpZGF0aW9uRXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGlvbkVycm9yKCkge1xuICAgICAgdmFyIHN1cGVyRXJyb3IgPSAoMCwgX2dldDIuZGVmYXVsdCkoKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoS2F0YWxNZXRyaWNDb3VudGVyLnByb3RvdHlwZSksIFwidmFsaWRhdGlvbkVycm9yXCIsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICBpZiAoc3VwZXJFcnJvcikgcmV0dXJuIHN1cGVyRXJyb3I7XG4gICAgICByZXR1cm4gKDAsIF9WYWxpZGF0ZVNpbXBsZUludC5kZWZhdWx0KSh0aGlzLnZhbHVlLCBcImZpZWxkIHZhbHVlIGluIENvdW50ZXIgbWV0cmljcyBvYmplY3QgJ1wiLmNvbmNhdCh0aGlzLm5hbWUsIFwiJ1wiKSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBLYXRhbE1ldHJpY0NvdW50ZXI7XG59KF9LYXRhbE1ldHJpY09iamVjdDIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEthdGFsTWV0cmljQ291bnRlcjsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX0thdGFsTWV0cmljVGltZWRBdHRlbXB0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdFwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNTdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljU3RyaW5nXCIpKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yLmRlZmF1bHQpKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbi8qKlxuICogU3RhbmRhcmRpemVkIG1ldHJpYyBmb3IgaW5zdHJ1bWVudGluZyBIVFRQIHJlcXVlc3RzLlxuICpcbiAqIFVuZGVyIHRoZSBob29kIGl0IGlzIGEgS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQgd2l0aCB0aGUgbmFtZSB5b3UgcHJvdmlkZSBwcmVmaXhlZCB3aXRoIFwiSFRUUFJlcXVlc3QuXCIuXG4gKiBUaGF0IG9iamVjdCB3aWxsIGNvbnRhaW4gYSBtZXRyaWMgc3VmZml4ZWQgd2l0aCBcIi5MYXRlbmN5XCIgZm9yIHRoZSBsYXRlbmN5IG9mIHRoaXMgcmVxdWVzdCwgYW5kIGEgbWV0cmljIHN1ZmZpeGVkXG4gKiB3aXRoIFwiLkZhaWx1cmVcIiB0byByZWNvcmQgdGhlIGZhaWx1cmUgb3Igc3VjY2VzcyBvZiB0aGlzIHJlcXVlc3QuXG4gKlxuICogQnkgZGVmYXVsdCB0aGUgcmVxdWVzdCB3aWxsIGJlIHRyYWNrZWQgYXMgYSBmYWlsdXJlOyB0byBtYXJrIGl0IGFzIGEgc3VjY2VzcyBjYWxsIHRoZSBcInNldFN1Y2Nlc3MoKVwiIG1ldGhvZC5cbiAqXG4gKiBJdCBoYXMgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHdoaWNoIHdpbGwgYmUgZW1pdHRlZCBpZiBzZXQ7IHNlZSB1cmwsIHN0YXR1c0NvZGUsIGFuZCBzdGF0dXNUZXh0LlxuICpcbiAqIEZvciBleGFtcGxlLCBpZiB5b3UgZ2F2ZSB0aGUgbmFtZSBcIlNlYXJjaFwiLCB0aGVzZSBtZXRyaWNzIHdpbGwgYmUgY3JlYXRlZDpcbiAqICAgSFRUUFJlcXVlc3QuU2VhcmNoLkxhdGVuY3kgLSBMYXRlbmN5IGZvciB0aGlzIHJlcXVlc3RcbiAqICAgSFRUUFJlcXVlc3QuU2VhcmNoLkZhaWx1cmUgLSBGYWlsdXJlIGZvciB0aGlzIHJlcXVlc3QgKDEgZm9yIGZhaWx1cmUsIDAgZm9yIHN1Y2Nlc3MpXG4gKi9cbnZhciBLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfS2F0YWxNZXRyaWNUaW1lZEF0dGUpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoS2F0YWxNZXRyaWNIdHRwUmVxdWVzdCwgX0thdGFsTWV0cmljVGltZWRBdHRlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEthdGFsTWV0cmljSHR0cFJlcXVlc3QpO1xuXG4gIC8qKiBUaGUgcHJlZml4IGZvciB0aGlzIG1ldHJpYy4gKi9cblxuICAvKiogVGhlIHN1ZmZpeCBmb3IgVVJMIG1ldHJpY3Mgb2YgdGhpcyBjbGFzcy4gKi9cblxuICAvKiogVGhlIHN1ZmZpeCBmb3IgSFRUUCByZXNwb25zZSBjb2RlIG1ldHJpY3Mgb2YgdGhpcyBjbGFzcy4gKi9cblxuICAvKiogVGhlIHN1ZmZpeCBmb3IgSFRUUCByZXNwb25zZSB0ZXh0IG1ldHJpY3Mgb2YgdGhpcyBjbGFzcy4gKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IEhUVFAgUmVxdWVzdCB0aW1lZCBhdHRlbXB0IG1ldHJpYyBpbmNvcnBvcmF0aW5nIHRoZSBnaXZlbiBuYW1lLlxuICAgKlxuICAgKiBUaGUgbmFtZSB5b3UgZ2l2ZSB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlIGEgS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQgd2l0aCB0aGUgcHJvdmlkZWQgbmFtZSBwcmVmaXhlZCB3aXRoIFwiSFRUUFJlcXVlc3QuXCIuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhpcyBtZXRyaWM7IHJlc3VsdGluZyBtZXRyaWNzIHdpbGwgcHJlZml4IHRoaXMgbmFtZSB3aXRoIFwiSFRUUFJlcXVlc3QuXCJcbiAgICovXG4gIGZ1bmN0aW9uIEthdGFsTWV0cmljSHR0cFJlcXVlc3QobmFtZSkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEthdGFsTWV0cmljSHR0cFJlcXVlc3QpO1xuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBcIlwiLmNvbmNhdChLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LkhUVFBfUkVRVUVTVF9QUkVGSVgsIFwiLlwiKS5jb25jYXQobmFtZSkpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIHVybCBmb3IgdGhpcyBtZXRyaWMuXG4gICAqXG4gICAqIEEgc3RyaW5nIG1ldHJpYyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBsaXN0IG9mIG9iamVjdHMgdGhhdCB3aWxsIGJlIHB1Ymxpc2hlZCBmb3IgdGhpcyBtZXRyaWMuICBJdHMgbmFtZSB3aWxsXG4gICAqIGJlIHRoaXMgbWV0cmljcyBuYW1lIHN1ZmZpeGVkIHdpdGggJy5VUkwnLCBhbmQgaXRzIHZhbHVlIHdpbGwgYmUgdGhlIFVSTCB2YWx1ZSBnaXZlbiBoZXJlLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWUgVVJMIGZvciB0aGlzIG1ldHJpY1xuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEthdGFsTWV0cmljSHR0cFJlcXVlc3QsIFt7XG4gICAga2V5OiBcInVybFwiLFxuICAgIGdldDpcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIFVSTCBmb3IgdGhpcyBtZXRyaWMsIGlmIGRlZmluZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIFRoZSBVUkwgZm9yIHRoaXMgbWV0cmljLCBvciB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXROYW1lZE1ldHJpY1ZhbHVlKEthdGFsTWV0cmljSHR0cFJlcXVlc3QuVVJMX1NVRkZJWCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgVVJMIG1ldHJpYyBvYmplY3QgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbWV0cmljLCBpZiBkZWZpbmVkLlxuICAgICAqXG4gICAgICogQHJldHVybiBBc3NvY2lhdGVkIFVSTCBtZXRyaWMgb2JqZWN0LCBvciB1bmRlZmluZWRcbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0T3JEZWxldGVOYW1lZE1ldHJpY1ZhbHVlKEthdGFsTWV0cmljSHR0cFJlcXVlc3QuVVJMX1NVRkZJWCwgX0thdGFsTWV0cmljU3RyaW5nLmRlZmF1bHQsIHZhbHVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXJsTWV0cmljXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXROYW1lZE1ldHJpYyhLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LlVSTF9TVUZGSVgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGUgZm9yIHRoaXMgbWV0cmljLlxuICAgICAqXG4gICAgICogQSBzdHJpbmcgbWV0cmljIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGxpc3Qgb2Ygb2JqZWN0cyB0aGF0IHdpbGwgYmUgcHVibGlzaGVkIGZvciB0aGlzIG1ldHJpYy4gIEl0cyBuYW1lIHdpbGxcbiAgICAgKiBiZSB0aGlzIG1ldHJpY3MgbmFtZSBzdWZmaXhlZCB3aXRoICcuU3RhdHVzQ29kZScsIGFuZCBpdHMgdmFsdWUgd2lsbCBiZSB0aGUgc3RhdHVzIGNvZGUgdmFsdWUgZ2l2ZW4gaGVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBIVFRQIHJlc3BvbnNlIHN0YXR1cyBjb2RlIGZvciB0aGlzIG1ldHJpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3RhdHVzQ29kZVwiLFxuICAgIGdldDpcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGUgZm9yIHRoaXMgbWV0cmljLCBpZiBkZWZpbmVkLlxuICAgICAqXG4gICAgICogQHJldHVybiBBc3NvY2lhdGVkIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGUgbWV0cmljIG9iamVjdCwgb3IgdW5kZWZpbmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TmFtZWRNZXRyaWNWYWx1ZShLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LlNUQVRVU19DT0RFX1NVRkZJWCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgSFRUUCByZXNwb25zZSBzdGF0dXMgY29kZSBtZXRyaWMgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1ldHJpYywgaWYgZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gSFRUUCByZXNwb25zZSBzdGF0dXMgY29kZSBtZXRyaWMgb2JqZWN0LCBvciB1bmRlZmluZWRcbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0T3JEZWxldGVOYW1lZE1ldHJpY1ZhbHVlKEthdGFsTWV0cmljSHR0cFJlcXVlc3QuU1RBVFVTX0NPREVfU1VGRklYLCBfS2F0YWxNZXRyaWNTdHJpbmcuZGVmYXVsdCwgdmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGF0dXNDb2RlTWV0cmljXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXROYW1lZE1ldHJpYyhLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LlNUQVRVU19DT0RFX1NVRkZJWCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgSFRUUCByZXNwb25zZSBzdGF0dXMgdGV4dCBmb3IgdGhpcyBtZXRyaWMuXG4gICAgICpcbiAgICAgKiBBIHN0cmluZyBtZXRyaWMgd2lsbCBiZSBhZGRlZCB0byB0aGUgbGlzdCBvZiBvYmplY3RzIHRoYXQgd2lsbCBiZSBwdWJsaXNoZWQgZm9yIHRoaXMgbWV0cmljLiAgSXRzIG5hbWUgd2lsbFxuICAgICAqIGJlIHRoaXMgbWV0cmljcyBuYW1lIHN1ZmZpeGVkIHdpdGggJy5TdGF0dXNUZXh0JywgYW5kIGl0cyB2YWx1ZSB3aWxsIGJlIHRoZSBzdGF0dXMgdGV4dCB2YWx1ZSBnaXZlbiBoZXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXR1c1RleHQgSFRUUCByZXNwb25zZSBzdGF0dXMgdGV4dCBmb3IgdGhpcyBtZXRyaWMsIG9yIHVuZGVmaW5lZCB0byByZW1vdmVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN0YXR1c1RleHRcIixcbiAgICBnZXQ6XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBIVFRQIHJlc3BvbnNlIHN0YXR1cyB0ZXh0IGZvciB0aGlzIG1ldHJpYywgaWYgZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gQXNzb2NpYXRlZCBIVFRQIHJlc3BvbnNlIHN0YXR1cyB0ZXh0IG1ldHJpYyBvYmplY3QsIG9yIHVuZGVmaW5lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE5hbWVkTWV0cmljVmFsdWUoS2F0YWxNZXRyaWNIdHRwUmVxdWVzdC5TVEFUVVNfVEVYVF9TVUZGSVgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIHRleHQgZm9yIHRoaXMgbWV0cmljLCBpZiBkZWZpbmVkLlxuICAgICAqXG4gICAgICogQHJldHVybiBBc3NvY2lhdGVkIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIHRleHQgbWV0cmljIG9iamVjdCwgb3IgdW5kZWZpbmVkXG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLnNldE9yRGVsZXRlTmFtZWRNZXRyaWNWYWx1ZShLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LlNUQVRVU19URVhUX1NVRkZJWCwgX0thdGFsTWV0cmljU3RyaW5nLmRlZmF1bHQsIHZhbHVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhdHVzVGV4dE1ldHJpY1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TmFtZWRNZXRyaWMoS2F0YWxNZXRyaWNIdHRwUmVxdWVzdC5TVEFUVVNfVEVYVF9TVUZGSVgpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gS2F0YWxNZXRyaWNIdHRwUmVxdWVzdDtcbn0oX0thdGFsTWV0cmljVGltZWRBdHRlbXB0LmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0O1xuKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoS2F0YWxNZXRyaWNIdHRwUmVxdWVzdCwgXCJIVFRQX1JFUVVFU1RfUFJFRklYXCIsICdIVFRQUmVxdWVzdCcpO1xuKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoS2F0YWxNZXRyaWNIdHRwUmVxdWVzdCwgXCJVUkxfU1VGRklYXCIsICdVUkwnKTtcbigwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKEthdGFsTWV0cmljSHR0cFJlcXVlc3QsIFwiU1RBVFVTX0NPREVfU1VGRklYXCIsICdTdGF0dXNDb2RlJyk7XG4oMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KShLYXRhbE1ldHJpY0h0dHBSZXF1ZXN0LCBcIlNUQVRVU19URVhUX1NVRkZJWFwiLCAnU3RhdHVzVGV4dCcpOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljVGltZWRBdHRlbXB0XCIpKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yLmRlZmF1bHQpKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbi8qKlxuICogU3RhbmRhcmRpemVkIG1ldHJpYyBmb3IgaW5zdHJ1bWVudGluZyBhcHBsaWNhdGlvbiBpbml0aWFsaXphdGlvbi5cbiAqXG4gKiBVbmRlciB0aGUgaG9vZCBpdCBpcyBhIEthdGFsTWV0cmljVGltZWRBdHRlbXB0IHdpdGggdGhlIG5hbWUgXCJJbml0aWFsaXphdGlvblwiLlxuICogVGhhdCBvYmplY3Qgd2lsbCBjb250YWluIGEgbWV0cmljIHN1ZmZpeGVkIHdpdGggXCIuTGF0ZW5jeVwiIGZvciB0aGUgbGF0ZW5jeSBvZiB0aGlzIHJlcXVlc3QsIGFuZCBhIG1ldHJpYyBzdWZmaXhlZFxuICogd2l0aCBcIi5GYWlsdXJlXCIgdG8gcmVjb3JkIHRoZSBmYWlsdXJlIG9yIHN1Y2Nlc3Mgb2YgdGhpcyByZXF1ZXN0LlxuICpcbiAqIEJ5IGRlZmF1bHQgdGhlIHJlcXVlc3Qgd2lsbCBiZSB0cmFja2VkIGFzIGEgZmFpbHVyZTsgdG8gbWFyayBpdCBhcyBhIHN1Y2Nlc3MgY2FsbCB0aGUgXCJzZXRTdWNjZXNzKClcIiBtZXRob2QuXG4gKlxuICogQnkgZGVmYXVsdCwgdGhlc2UgbWV0cmljcyB3aWxsIGJlIGNyZWF0ZWQ6XG4gKiAgIEluaXRpYWxpemF0aW9uLkxhdGVuY3kgLSBMYXRlbmN5IGZvciBhcHBsaWNhdGlvbiBpbml0aWFsaXphdGlvblxuICogICBJbml0aWFsaXphdGlvbi5GYWlsdXJlIC0gRmFpbHVyZSBmb3IgdGhpcyBhcHBsaWNhdGlvbiBpbml0aWFsaXphdGlvbiAoMSBmb3IgZmFpbHVyZSwgMCBmb3Igc3VjY2VzcylcbiAqL1xudmFyIEthdGFsTWV0cmljSW5pdGlhbGl6YXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9LYXRhbE1ldHJpY1RpbWVkQXR0ZSkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShLYXRhbE1ldHJpY0luaXRpYWxpemF0aW9uLCBfS2F0YWxNZXRyaWNUaW1lZEF0dGUpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoS2F0YWxNZXRyaWNJbml0aWFsaXphdGlvbik7XG5cbiAgLyoqIFRoZSBuYW1lIGZvciB0aGlzIG1ldHJpYy4gKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHRpbWVkIGF0dGVtcHQgbWV0cmljIG5hbWVkIFwiSW5pdGlhbGl6YXRpb25cIiwgZm9yIHJlY29yZGluZyBsYXRlbmN5IGFuZCBmYWlsdXJlIGluZm9ybWF0aW9uIGFib3V0XG4gICAqIHlvdXIgYXBwbGljYXRpb24ncyBpbml0aWFsaXphdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIEthdGFsTWV0cmljSW5pdGlhbGl6YXRpb24oKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgS2F0YWxNZXRyaWNJbml0aWFsaXphdGlvbik7XG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIEthdGFsTWV0cmljSW5pdGlhbGl6YXRpb24uSU5JVElBTElaRV9NRVRSSUNfTkFNRSk7XG4gIH1cblxuICByZXR1cm4gS2F0YWxNZXRyaWNJbml0aWFsaXphdGlvbjtcbn0oX0thdGFsTWV0cmljVGltZWRBdHRlbXB0LmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBLYXRhbE1ldHJpY0luaXRpYWxpemF0aW9uO1xuKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoS2F0YWxNZXRyaWNJbml0aWFsaXphdGlvbiwgXCJJTklUSUFMSVpFX01FVFJJQ19OQU1FXCIsICdJbml0aWFsaXphdGlvbicpOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNPYmplY3RMaXN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY09iamVjdExpc3RcIikpO1xuXG52YXIgX09iamVjdFZhbHVlc1BvbnlmaWxsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vaGVscGVyL09iamVjdFZhbHVlc1BvbnlmaWxsXCIpKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yLmRlZmF1bHQpKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbi8qKlxuICogTWV0cmljIG9iamVjdCBsaXN0IHRoYXQgdHJhY2tzIG1ldHJpY3MgYnkgbmFtZSwgYW5kIGdlbmVyYXRlcyBtZXRyaWNzIHByZWZpeGVkIHdpdGggdGhlIG5hbWUgb2YgdGhpcyBvYmplY3QuXG4gKi9cbnZhciBLYXRhbE1ldHJpY05hbWVkT2JqZWN0TGlzdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0thdGFsTWV0cmljT2JqZWN0TGlzKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEthdGFsTWV0cmljTmFtZWRPYmplY3RMaXN0LCBfS2F0YWxNZXRyaWNPYmplY3RMaXMpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoS2F0YWxNZXRyaWNOYW1lZE9iamVjdExpc3QpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgbmFtZWQgb2JqZWN0IGxpc3QuXG4gICAqXG4gICAqIFRoZSBuYW1lIGdpdmVuIGhlcmUgd2lsbCBiZSB1c2VkIHRvIHByZWZpeCBhbGwgbWV0cmljcy5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGlzIG1ldHJpY1xuICAgKi9cbiAgZnVuY3Rpb24gS2F0YWxNZXRyaWNOYW1lZE9iamVjdExpc3QobmFtZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEthdGFsTWV0cmljTmFtZWRPYmplY3RMaXN0KTtcbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUpO1xuICAgIF90aGlzLm5hbWVkTWV0cmljcyA9IHt9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEthdGFsTWV0cmljTmFtZWRPYmplY3RMaXN0LCBbe1xuICAgIGtleTogXCJtZXRyaWNMaXN0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gKDAsIF9PYmplY3RWYWx1ZXNQb255ZmlsbC5kZWZhdWx0KSh0aGlzLm5hbWVkTWV0cmljcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcGxhY2UgdGhlIG1ldHJpYyB3aXRoIHRoZSBnaXZlbiBuYW1lIHdpdGggYSBuZXcgbWV0cmljIGdlbmVyYXRlZCBieSB0aGUgZ2l2ZW4gZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBJZiB0aGUgbmV3bHkgY3JlYXRlZCBtZXRyaWMgc3VwcG9ydHMgbW9uaXRvcmluZywgaXRzIGlzTW9uaXRvciBmbGFnIHdpbGwgYmUgc2V0IHRvIHRoZSB2YWx1ZSBvZiB0aGVcbiAgICAgKiBpc01vbml0b3IgZmxhZyBmb3IgdGhpcyBjb250YWluaW5nIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdWJOYW1lIE5hbWUgb2YgdGhpcyBzdWItbWV0cmljXG4gICAgICogQHBhcmFtIG1ldHJpY0NyZWF0b3IgRnVuY3Rpb24gd2hpY2ggdGFrZXMgdGhlIGZ1bGwgbmFtZSBmb3IgdGhpcyBtZXRyaWNcbiAgICAgKiAgICAgICAgYW5kIHJldHVybnMgYSBuZXdseSBjb25zdHJ1Y3RlZCBLYXRhbE1ldHJpY09iamVjdCB3aXRoIHRoaXMgbmFtZSBhbmQgYW4gYXBwcm9wcmlhdGUgdmFsdWVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldE5hbWVkTWV0cmljXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE5hbWVkTWV0cmljKHN1Yk5hbWUsIG1ldHJpY0NyZWF0b3IpIHtcbiAgICAgIHZhciBmdWxsTmFtZSA9IHRoaXMuZ2V0TmFtZUZvclN1Yk1ldHJpYyhzdWJOYW1lKTtcbiAgICAgIHZhciBtZXRyaWMgPSBtZXRyaWNDcmVhdG9yKGZ1bGxOYW1lKTtcblxuICAgICAgaWYgKG1ldHJpYy5jYW5Nb25pdG9yKSB7XG4gICAgICAgIG1ldHJpYy5pc01vbml0b3IgPSB0aGlzLmlzTW9uaXRvcjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5uYW1lZE1ldHJpY3Nbc3ViTmFtZV0gPSBtZXRyaWM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyB1bmRlZmluZWQgb3IgbnVsbCwgZGVsZXRlIHRoZSBtZXRyaWMgd2l0aCB0aGUgZ2l2ZSBuYW1lOyBvdGhlcndpc2UgaWYgdGhlIGdpdmVuIG5hbWVkXG4gICAgICogbWV0cmljIGFscmVhZHkgZXhpc3RzIHVwZGF0ZSBpdHMgdmFsdWU7IG90aGVyd2lzZSBjcmVhdGUgYSBuZXcgbWV0cmljIG9mIHRoZSBnaXZlbiB0eXBlIGFuZCBzZXQgaXRzIHZhbHVlLlxuICAgICAqXG4gICAgICogVGhpcyBzcGVjaWFsaXplZCBoZWxwZXIgbWV0aG9kIGlzIGRlc2lnbmVkIHRvIGRlYWwgd2l0aCB0aGUgY29tbW9uIGNhc2Ugb2YgYSB2YWx1ZSBzZXR0ZXIgaW4gYSBtb3JlIGNvbXBsZXhcbiAgICAgKiBtZXRyaWMuICBPdXRzaWRlIG9mIHN1YmNsYXNzZXMsIG90aGVyIG1ldGhvZHMgd2lsbCBwcm9iYWJseSBwcm92ZSBtb3JlIHVzZWZ1bC5cbiAgICAgKlxuICAgICAqIElmIHRoZSB2YWx1ZSBpcyBudWxsIHRoZSBtZXRyaWMgd2lsbCBhbHNvIGJlIGRlbGV0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3ViTmFtZSBOYW1lIG9mIG1ldHJpYyB0byBjcmVhdGUgb3IgZGVsZXRlXG4gICAgICogQHBhcmFtIG5ld1ZhbHVlQ2xhc3MgQ2xhc3Mgb2YgbmV3IG1ldHJpYyB0byBjcmVhdGVcbiAgICAgKiBAcGFyYW0gbmV3VmFsdWUgTmV3IHZhbHVlIGZvciB0aGlzIG1ldHJpYyAob3IgdW5kZWZpbmVkIHRvIGRlbGV0ZSB0aGUgbWV0cmljKVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3JEZWxldGVOYW1lZE1ldHJpY1ZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9yRGVsZXRlTmFtZWRNZXRyaWNWYWx1ZShzdWJOYW1lLCBuZXdWYWx1ZUNsYXNzLCBuZXdWYWx1ZSkge1xuICAgICAgaWYgKG5ld1ZhbHVlID09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmRlbGV0ZU5hbWVkTWV0cmljKHN1Yk5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG1ldHJpYyA9IHRoaXMuZ2V0T3JDcmVhdGVOYW1lZE1ldHJpYyhzdWJOYW1lLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIHJldHVybiBuZXcgbmV3VmFsdWVDbGFzcyhuYW1lLCBuZXdWYWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBtZXRyaWMudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzdWItbWV0cmljIHdpdGggdGhlIGdpdmVuIG5hbWUgaWYgaXQgZXhpc3RzLCBvdGhlcndpc2UgdXNlIHRoZSBnaXZlbiBmdW5jdGlvbiB0byBjcmVhdGUgYSBuZXcgbWV0cmljIGFuZFxuICAgICAqIHN0b3JlIGFuZCByZXR1cm4gdGhhdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdWJOYW1lIE5hbWUgb2YgdGhpcyBzdWItbWV0cmljXG4gICAgICogQHBhcmFtIG1ldHJpY0NyZWF0b3IgRnVuY3Rpb24gd2hpY2ggdGFrZXMgdGhlIGZ1bGwgbmFtZSBmb3IgdGhpcyBtZXRyaWNcbiAgICAgKiAgICAgICAgYW5kIHJldHVybnMgYSBuZXdseSBjb25zdHJ1Y3RlZCBLYXRhbE1ldHJpY09iamVjdCB3aXRoIHRoaXMgbmFtZSBhbmQgYW4gYXBwcm9wcmlhdGUgdmFsdWVcbiAgICAgKiBAcmV0dXJuIE1ldHJpYyBvYmplY3Qgd2hpY2ggd2FzIHJldHJpZXZlZCBvciBjcmVhdGVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRPckNyZWF0ZU5hbWVkTWV0cmljXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE9yQ3JlYXRlTmFtZWRNZXRyaWMoc3ViTmFtZSwgbWV0cmljQ3JlYXRvcikge1xuICAgICAgaWYgKCF0aGlzLm5hbWVkTWV0cmljc1tzdWJOYW1lXSkge1xuICAgICAgICB0aGlzLnNldE5hbWVkTWV0cmljKHN1Yk5hbWUsIG1ldHJpY0NyZWF0b3IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5uYW1lZE1ldHJpY3Nbc3ViTmFtZV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZ2l2ZW4gbmFtZWQgc3ViLW1ldHJpYywgaWYgaXQgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN1Yk5hbWUgTmFtZSBvZiB0aGlzIHN1Yi1tZXRyaWNcbiAgICAgKiBAcmV0dXJuIHtLYXRhbE1ldHJpY09iamVjdCB8IHVuZGVmaW5lZH0gTWV0cmljIG9iamVjdCB3aXRoIHRoaXMgbmFtZSBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSB1bmRlZmluZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldE5hbWVkTWV0cmljXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5hbWVkTWV0cmljKHN1Yk5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLm5hbWVkTWV0cmljc1tzdWJOYW1lXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIHRoZSBnaXZlbiBuYW1lZCBzdWItbWV0cmljLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN1Yk5hbWUgTmFtZSBvZiB0aGlzIHN1Yi1tZXRyaWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZU5hbWVkTWV0cmljXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZU5hbWVkTWV0cmljKHN1Yk5hbWUpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLm5hbWVkTWV0cmljc1tzdWJOYW1lXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB2YWx1ZSBmb3IgdGhlIGdpdmVuIG1ldHJpYywgb3IgdW5kZWZpbmVkIGlmIHRoZSBtZXRyaWMgZG9lcyBub3QgZXhpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3ViTmFtZSBOYW1lIG9mIHRoaXMgc3ViLW1ldHJpY1xuICAgICAqIEByZXR1cm4gVmFsdWUgZm9yIHRoZSBnaXZlbiBtZXRyaWMsIG9yIHVuZGVmaW5lZCBpZiB0aGUgbWV0cmljIGRvZXMgbm90IGV4aXN0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXROYW1lZE1ldHJpY1ZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5hbWVkTWV0cmljVmFsdWUoc3ViTmFtZSkge1xuICAgICAgdmFyIG1ldHJpYyA9IHRoaXMuZ2V0TmFtZWRNZXRyaWMoc3ViTmFtZSk7XG4gICAgICBpZiAoIW1ldHJpYykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBtZXRyaWMudmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGEgbmFtZSBmb3IgdGhlIGdpdmVuIHN1Yi1tZXRyaWMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3ViTmFtZSBOYW1lIG9mIHRoaXMgc3ViLW1ldHJpY1xuICAgICAqIEByZXR1cm4gRnVsbCBuYW1lIGZvciB0aGlzIHN1Yi1tZXRyaWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldE5hbWVGb3JTdWJNZXRyaWNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TmFtZUZvclN1Yk1ldHJpYyhzdWJOYW1lKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5uYW1lLCBcIi5cIikuY29uY2F0KHN1Yk5hbWUpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gS2F0YWxNZXRyaWNOYW1lZE9iamVjdExpc3Q7XG59KF9LYXRhbE1ldHJpY09iamVjdExpc3QuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEthdGFsTWV0cmljTmFtZWRPYmplY3RMaXN0OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX1ZhbGlkYXRlU2ltcGxlU3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vaGVscGVyL1ZhbGlkYXRlU2ltcGxlU3RyaW5nXCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY1R5cGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljVHlwZVwiKSk7XG5cbi8qKlxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgYSBzaW5nbGUgbWV0cmljIGluIEthdGFsLlxuICpcbiAqIEEgc2luZ2xlIG1ldHJpYyBjb250YWlucyB0aGUgbmFtZSAobWV0cmljS2V5KSwgdmFsdWUsIHR5cGUsIGFuZCB0aGUgaXNNb25pdG9yIGZsYWc7IGV2ZXJ5dGhpbmcgZWxzZSBpcyBpbiB0aGVcbiAqIEthdGFsTWV0cmljc0NvbnRleHQgaXQgaXMgcHVibGlzaGVkIHRvLlxuICovXG52YXIgS2F0YWxNZXRyaWNPYmplY3QgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogTWV0cmljIHR5cGVzLlxuICAgKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IEthdGFsTWV0cmljT2JqZWN0IHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIE5hbWUgZm9yIHRoaXMgbWV0cmljOyBwdWJsaXNoZWQgYXMgbWV0cmljS2V5IGZpZWxkXG4gICAqL1xuICBmdW5jdGlvbiBLYXRhbE1ldHJpY09iamVjdChuYW1lKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgS2F0YWxNZXRyaWNPYmplY3QpO1xuICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgIHRoaXMuX2lzTW9uaXRvciA9IGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWUgZm9yIHRoaXMgbWV0cmljLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIG5hbWUgaXMgaW1tdXRhYmxlLCBhbmQgdGhpcyBjYW5ub3QgYmUgc2V0LlxuICAgKlxuICAgKiBAcmV0dXJucyBOYW1lIGZvciB0aGlzIG1ldHJpY1xuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEthdGFsTWV0cmljT2JqZWN0LCBbe1xuICAgIGtleTogXCJuYW1lXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxpYXMgZm9yIG5hbWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBOYW1lIGZvciB0aGlzIG1ldHJpY1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibWV0cmljS2V5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBpc01vbml0b3IgZmxhZyBmb3IgdGhpcyBtZXRyaWMsIGFuZCByZXR1cm5zIHRoaXMgb2JqZWN0IGZvciBjb250aW51ZWQgdXNlLlxuICAgICAqXG4gICAgICogVGhpcyBmbGFnIGRldGVybWluZXMgaWYgdGhlIG1ldHJpYyBjYW4gYmUgdXNlZCBmb3IgZGFzaGJvYXJkcyBhbmQgYWxhcm1zIChpLmUuIGlmIGl0IHdpbGwgYmUgcHVibGlzaGVkIHRvIFBNRVQpXG4gICAgICogQHBhcmFtIGlzTW9uaXRvciBOZXcgdmFsdWUgZm9yIHRoZSBpc01vbml0b3IgZmxhZzsgZGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAqIEByZXR1cm5zIFRoaXMgb2JqZWN0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ3aXRoTW9uaXRvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoTW9uaXRvcigpIHtcbiAgICAgIHZhciBpc01vbml0b3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gICAgICB0aGlzLmlzTW9uaXRvciA9IGlzTW9uaXRvcjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGlzTW9uaXRvciBmbGFnIGZvciB0aGlzIG1ldHJpYy5cbiAgICAgKlxuICAgICAqIFRoZSB2YWx1ZSBpcyBmb3JjZWQgdG8gYSBib29sZWFuIGJhc2VkIG9uIGl0cyB0cnV0aGluZXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlzTW9uaXRvciBOZXcgdmFsdWUgZm9yIHRoZSBpc01vbml0b3IgZmxhZ1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNNb25pdG9yXCIsXG4gICAgZ2V0OlxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaXNNb25pdG9yIGZsYWcgZm9yIHRoaXMgbWV0cmljLlxuICAgICAqXG4gICAgICogQHJldHVybnMgaXNNb25pdG9yIGZsYWcgZm9yIHRoaXMgbWV0cmljLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pc01vbml0b3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgbWV0cmljIGNhbiBiZSBtZWFuaW5nZnVsbHkgbW9uaXRvcmVkLlxuICAgICAqXG4gICAgICogU3ViY2xhc3NlcyBtdXN0IG92ZXJyaWRlIHRoaXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIFdoZXRoZXIgdGhpcyBtZXRyaWMgY2FuIGJlIG1lYW5pbmdmdWxseSBtb25pdG9yZWRcbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoaXNNb25pdG9yKSB7XG4gICAgICB0aGlzLl9pc01vbml0b3IgPSAhIWlzTW9uaXRvcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FuTW9uaXRvclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdWJjbGFzcyBvZiBLYXRhbE1ldHJpY09iamVjdCBtdXN0IGltcGxlbWVudCBjYW5Nb25pdG9yJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdHlwZSBvZiB0aGlzIG1ldHJpYy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gVHlwZSBvZiB0aGlzIG1ldHJpYyAob25lIG9mOiBTdHJpbmcsIENvdW50ZXIsIFRpbWVyLCBMaXN0KVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidHlwZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdWJjbGFzcyBvZiBLYXRhbE1ldHJpY09iamVjdCBtdXN0IGltcGxlbWVudCB0eXBlIGdldHRlcicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBmb3IgYSB2YWxpZGF0aW9uIGVycm9yIG9uIHRoaXMgb2JqZWN0LlxuICAgICAqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgdmFsaWRhdGlvbiBlcnJvciBlbmNvdW50ZXJlZCBpZiBvbmUgaXMgZm91bmQsIG90aGVyd2lzZSB1bmRlZmluZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RXJyb3IgfCB1bmRlZmluZWR9IEVycm9yIGZvdW5kIHdpdGggdGhpcyBvYmplY3QsIG9yIHVuZGVmaW5lZCBpZiBubyBlcnJvciBpcyBmb3VuZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidmFsaWRhdGlvbkVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRpb25FcnJvcigpIHtcbiAgICAgIGlmICh0aGlzLmlzTW9uaXRvciAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB0aGlzLmlzTW9uaXRvciAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoXCJGaWVsZCBpc01vbml0b3Igc2hvdWxkIGJlIGEgYm9vbGVhbiwgYnV0IGl0IHdhcyBhIFwiLmNvbmNhdCgoMCwgX3R5cGVvZjIuZGVmYXVsdCkodGhpcy5pc01vbml0b3IpKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoMCwgX1ZhbGlkYXRlU2ltcGxlU3RyaW5nLmRlZmF1bHQpKHRoaXMubmFtZSwgJ2ZpZWxkIG5hbWUnKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEthdGFsTWV0cmljT2JqZWN0O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBLYXRhbE1ldHJpY09iamVjdDtcbigwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKEthdGFsTWV0cmljT2JqZWN0LCBcIlR5cGVzXCIsIF9LYXRhbE1ldHJpY1R5cGUuZGVmYXVsdCk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2dldDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFwiKSk7XG5cbnZhciBfc2V0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2V0XCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNPYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY09iamVjdFwiKSk7XG5cbnZhciBfRmlyc3RNYXAgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9oZWxwZXIvRmlyc3RNYXBcIikpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIuZGVmYXVsdCkodGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuLyoqXG4gKiBBYnN0cmFjdCBtZXRyaWMgdGhhdCBjb250YWlucyBhIGxpc3Qgb2Ygb3RoZXIgbWV0cmljczsgd2hlbiBpdCBpcyBwdWJsaXNoZWQsIHRoZSBsaXN0IG9mIG1ldHJpY3MgaXMgcmV0cmlldmVkLCBhbmQgYWxsXG4gKiBhcmUgcHVibGlzaGVkLlxuICovXG52YXIgS2F0YWxNZXRyaWNPYmplY3RMaXN0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfS2F0YWxNZXRyaWNPYmplY3QpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoS2F0YWxNZXRyaWNPYmplY3RMaXN0LCBfS2F0YWxNZXRyaWNPYmplY3QpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoS2F0YWxNZXRyaWNPYmplY3RMaXN0KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IEthdGFsTWV0cmljT2JqZWN0TGlzdC5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgTmFtZSBmb3IgdGhpcyBtZXRyaWMuICBOb3QgcmVhbGx5IHVzZWQsIGJ1dCBwcmVzZW50IGZvciBjb25zaXN0ZW5jeSB3aXRoIG90aGVyIG1ldHJpY3MuXG4gICAqL1xuICBmdW5jdGlvbiBLYXRhbE1ldHJpY09iamVjdExpc3QobmFtZSkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEthdGFsTWV0cmljT2JqZWN0TGlzdCk7XG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGxpc3Qgb2YgZm9yIHRoaXMgb2JqZWN0XG4gICAqXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIG1ldHJpY3MgZm9yIHRoaXMgb2JqZWN0XG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoS2F0YWxNZXRyaWNPYmplY3RMaXN0LCBbe1xuICAgIGtleTogXCJtZXRyaWNMaXN0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1YmNsYXNzIG9mIEthdGFsTWV0cmljT2JqZWN0TGlzdCBtdXN0IGltcGxlbWVudCBtZXRyaWNMaXN0IGdldHRlcicpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc01vbml0b3JcIixcbiAgICBnZXQ6IC8vIFRoaXMganVzdCBkZWxlZ2F0ZXMgdG8gdGhlIHN1cGVyY2xhc3MsIGJ1dCBpZiB3ZSBvdmVycmlkZSB0aGUgc2V0dGVyIHdpdGhvdXQgb3ZlcnJpZGluZyB0aGUgZ2V0dGVyXG4gICAgLy8gZ2V0dGluZyB0aGUgcHJvcGVydHkgd2lsbCBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZC5cbiAgICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gKDAsIF9nZXQyLmRlZmF1bHQpKCgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKEthdGFsTWV0cmljT2JqZWN0TGlzdC5wcm90b3R5cGUpLCBcImlzTW9uaXRvclwiLCB0aGlzKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGlzTW9uaXRvcikge1xuICAgICAgKDAsIF9zZXQyLmRlZmF1bHQpKCgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKEthdGFsTWV0cmljT2JqZWN0TGlzdC5wcm90b3R5cGUpLCBcImlzTW9uaXRvclwiLCBpc01vbml0b3IsIHRoaXMsIHRydWUpO1xuICAgICAgdGhpcy5tZXRyaWNMaXN0LmZvckVhY2goZnVuY3Rpb24gKG1ldHJpYykge1xuICAgICAgICBpZiAobWV0cmljLmNhbk1vbml0b3IpIHtcbiAgICAgICAgICBtZXRyaWMuaXNNb25pdG9yID0gaXNNb25pdG9yO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FuTW9uaXRvclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInR5cGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfS2F0YWxNZXRyaWNPYmplY3QyLmRlZmF1bHQuVHlwZXMuTGlzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgYW55IG9mIHRoZSBjb250YWluZWQgbWV0cmljcyBhcmUgaW52YWxpZCwgcmV0dXJuIHRoZSBmaXJzdCB2YWxpZGF0aW9uIGVycm9yIGVuY291bnRlcmVkOyBvdGhlcndpc2UgcmV0dXJuXG4gICAgICogdW5kZWZpbmVkLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoaXMgaXNuJ3QgY2FsbGVkIGJ5IHRoZSBwdWJsaXNoZXI7IGl0IHZhbGlkYXRlcyBlYWNoIHN1Yi1tZXRyaWMgb24gaXRzIG93bi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEVycm9yIGZvdW5kIHdpdGggc3VibWV0cmljLCBpZiBhbnk7IGVsc2UgdW5kZWZpbmVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ2YWxpZGF0aW9uRXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGlvbkVycm9yKCkge1xuICAgICAgLy8gRG9lc24ndCBtYWtlIHNlbnNlIHRvIGNoZWNrIHN1cGVyY2xhc3MgZXJyb3IgaGVyZSwgc2luY2UgaXQgaXMgdGhlIGNvbnRhaW5lZCBtZXRyaWNzIHRoYXQgbWF0dGVyLlxuICAgICAgcmV0dXJuICgwLCBfRmlyc3RNYXAuZGVmYXVsdCkodGhpcy5tZXRyaWNMaXN0LCBmdW5jdGlvbiAobWV0cmljKSB7XG4gICAgICAgIHJldHVybiBtZXRyaWMudmFsaWRhdGlvbkVycm9yKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEthdGFsTWV0cmljT2JqZWN0TGlzdDtcbn0oX0thdGFsTWV0cmljT2JqZWN0Mi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gS2F0YWxNZXRyaWNPYmplY3RMaXN0OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2Fzc2VydFRoaXNJbml0aWFsaXplZFwiKSk7XG5cbnZhciBfZ2V0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0XCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNPYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY09iamVjdFwiKSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG4vKipcbiAqIFN0cmluZyB0eXBlLlxuICpcbiAqIENhbiBiZSB1c2VkIHRvIHN0b3JlIGFyYml0cmFyeSBzdHJpbmdzIG9mIGRhdGEuXG4gKi9cbnZhciBLYXRhbE1ldHJpY1N0cmluZyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0thdGFsTWV0cmljT2JqZWN0KSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEthdGFsTWV0cmljU3RyaW5nLCBfS2F0YWxNZXRyaWNPYmplY3QpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoS2F0YWxNZXRyaWNTdHJpbmcpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBzdHJpbmcgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBhbmQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIFN0cmluZyBuYW1lXG4gICAqIEBwYXJhbSB2YWx1ZSBTdHJpbmcgdmFsdWVcbiAgICovXG4gIGZ1bmN0aW9uIEthdGFsTWV0cmljU3RyaW5nKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgS2F0YWxNZXRyaWNTdHJpbmcpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzKSwgXCJ0cnVuY2F0ZVwiLCBmYWxzZSk7XG4gICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgZm9yIHRoaXMgc3RyaW5nIG1ldHJpYy5cbiAgICpcbiAgICogQHJldHVybiBWYWx1ZSBmb3IgdGhpcyBtZXRyaWNcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShLYXRhbE1ldHJpY1N0cmluZywgW3tcbiAgICBrZXk6IFwidmFsdWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2YWx1ZSBmb3IgdGhpcyBzdHJpbmcgbWV0cmljLlxuICAgICAqXG4gICAgICogVGhlIG5ldyB2YWx1ZSBzaG91bGQgYmUgYSBzdHJpbmcsIGJ1dCBudW1iZXIgYW5kIGJvb2xlYW4gdHlwZXMgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBzdHJpbmdzLlxuICAgICAqIEZvciBvdGhlciB0eXBlcywgaW5jbHVkaW5nIHVuZGVmaW5lZCBhbmQgbnVsbCwgdGhlIHZhbHVlIHdpbGwgYmUgYWNjZXB0ZWQsIGJ1dCB3aWxsIGZhaWwgdmFsaWRhdGlvbiB3aGVuIHB1Ymxpc2hpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgTmV3IHZhbHVlIGZvciB0aGlzIG1ldHJpY1xuICAgICAqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJ1bmNhdGlvbiBmbGFnIGZvciB0aGlzIHN0cmluZyBtZXRyaWMuXG4gICAgICpcbiAgICAgKiBJZiBzZXQsIHRoZSB2YWx1ZSBoZXJlIHdpbGwgYmUgYXV0b21hdGljYWxseSB0cnVuY2F0ZWQgdG8gdGhlIG1heGltdW0gc2l6ZSBhbGxvd2VkIGJ5IHRoZSBjdXJyZW50IHNjaGVtYS5cbiAgICAgKiBPdGhlcndpc2UsIHNlbmRpbmcgYSB2YWx1ZSBsYXJnZXIgdGhhbiBhbGxvd2VkIHdpbGwgcmVzdWx0IGluIGEgZmFpbHVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUcnVlIHRvIGF1dG9tYXRpY2FsbHkgdHJ1bmNhdGUgbWV0cmljcywgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0eXBlXCIsXG4gICAgZ2V0OlxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHR5cGUgZm9yIHRoaXMgbWV0cmljLlxuICAgICAqXG4gICAgICogQHJldHVybiBBbHdheXMgcmV0dXJucyBcIlN0cmluZ1wiLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfS2F0YWxNZXRyaWNPYmplY3QyLmRlZmF1bHQuVHlwZXMuU3RyaW5nO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYW5Nb25pdG9yXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbGlkYXRpb25FcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0aW9uRXJyb3IoKSB7XG4gICAgICB2YXIgc3VwZXJFcnJvciA9ICgwLCBfZ2V0Mi5kZWZhdWx0KSgoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShLYXRhbE1ldHJpY1N0cmluZy5wcm90b3R5cGUpLCBcInZhbGlkYXRpb25FcnJvclwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgaWYgKHN1cGVyRXJyb3IpIHJldHVybiBzdXBlckVycm9yO1xuXG4gICAgICBpZiAodHlwZW9mIHRoaXMudmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoXCJFeHBlY3RlZCBmaWVsZCB2YWx1ZSBpbiBTdHJpbmcgbWV0cmljcyBvYmplY3QgJ1wiLmNvbmNhdCh0aGlzLm5hbWUsIFwiJyB0byBiZSB0eXBlIHN0cmluZywgYnV0IGl0IHdhcyBcIikuY29uY2F0KCgwLCBfdHlwZW9mMi5kZWZhdWx0KSh0aGlzLnZhbHVlKSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy52YWx1ZS5sZW5ndGggPiBLYXRhbE1ldHJpY1N0cmluZy5NQVhfU0laRSkge1xuICAgICAgICBpZiAodGhpcy50cnVuY2F0ZSkge1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlLnN1YnN0cmluZygwLCBLYXRhbE1ldHJpY1N0cmluZy5NQVhfU0laRSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcIkV4cGVjdGVkIGZpZWxkIHZhbHVlIGluIFN0cmluZyBtZXRyaWNzIG9iamVjdCAnXCIuY29uY2F0KHRoaXMubmFtZSwgXCInIHRvIGJlIFwiKS5jb25jYXQoS2F0YWxNZXRyaWNTdHJpbmcuTUFYX1NJWkUsIFwiIGNoYXJhY3RlcnMgb3IgbGVzcywgYnV0IGl0IHdhcyBcIikuY29uY2F0KHRoaXMudmFsdWUubGVuZ3RoLCBcIiBjaGFyYWN0ZXJzLlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gRGlkbid0IGZpbmQgYW55dGhpbmcgd3JvbmcsIGltcGxpY2l0bHkgcmV0dXJuIHVuZGVmaW5lZFxuXG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBLYXRhbE1ldHJpY1N0cmluZztcbn0oX0thdGFsTWV0cmljT2JqZWN0Mi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gS2F0YWxNZXRyaWNTdHJpbmc7XG4oMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KShLYXRhbE1ldHJpY1N0cmluZywgXCJNQVhfU0laRVwiLCAyNTYpOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfS2F0YWxNZXRyaWNOYW1lZE9iamVjdExpc3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljTmFtZWRPYmplY3RMaXN0XCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoXCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY0NvdW50ZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljQ291bnRlclwiKSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG4vKipcbiAqIE1ldHJpYyB0aGF0IHBhaXJzIGEgdGltZXIgYW5kIGEgZmFpbHVyZSBjb3VudGVyIHRvIHJlY29yZCB0aGUgdGltZSBhbmQgc3RhdHVzIG9mIGFuIGF0dGVtcHQgdG8gZG8gc29tZXRoaW5nLlxuICovXG52YXIgS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9LYXRhbE1ldHJpY05hbWVkT2JqZSkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdCwgX0thdGFsTWV0cmljTmFtZWRPYmplKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEthdGFsTWV0cmljVGltZWRBdHRlbXB0KTtcblxuICAvKiogVGhlIHN1Yi1tZXRyaWMgbmFtZSBmb3IgbGF0ZW5jeS4gKi9cblxuICAvKiogVGhlIHN1Yi1tZXRyaWMgbmFtZSBmb3IgZmFpbHVyZSBjb3VudC4gKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHRpbWVkIGF0dGVtcHQgd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuICAgKlxuICAgKiBUaGlzIHdpbGwgY3JlYXRlIHR3byBpbm5lciBtZXRyaWNzLCBhIEthdGFsTWV0cmljQ291bnRlciB0aGF0IGhhcyB0aGUgZ2l2ZW4gbmFtZSB3aXRoIFwiLkZhaWx1cmVcIiBhcHBlbmRlZCxcbiAgICogYW5kIGEgS2F0YWxNZXRyaWNUaW1lclN0b3B3YXRjaCB0aGF0IGhhcyB0aGUgZ2l2ZW4gbmFtZSB3aXRoIFwiLkxhdGVuY3lcIiBhcHBlbmRlZC5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGlzIGF0dGVtcHRcbiAgICovXG4gIGZ1bmN0aW9uIEthdGFsTWV0cmljVGltZWRBdHRlbXB0KG5hbWUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBLYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdCk7XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lKTtcblxuICAgIF90aGlzLnNldE5hbWVkTWV0cmljKEthdGFsTWV0cmljVGltZWRBdHRlbXB0LkxBVEVOQ1lfU1VGRklYLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIG5ldyBfS2F0YWxNZXRyaWNUaW1lclN0b3B3YXRjaC5kZWZhdWx0KG5hbWUpO1xuICAgIH0pO1xuXG4gICAgX3RoaXMuc2V0TmFtZWRNZXRyaWMoS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHQuRkFJTFVSRV9TVUZGSVgsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gbmV3IF9LYXRhbE1ldHJpY0NvdW50ZXIuZGVmYXVsdChuYW1lLCAxKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBmYWlsdXJlIGNvdW50ZXIgbWV0cmljIGJhc2VkIG9uIHRoZSBnaXZlbiBmYWlsdXJlIHN0YXR1cy5cbiAgICpcbiAgICogSWYgZmFpbHVyZSBpcyB0cnVlIHRoZSBjb3VudGVyIHdpbGwgaGF2ZSBhIHZhbHVlIG9mIDE7IGlmIGl0IGlzIGZhbHNlIHRoZSBjb3VudGVyIHdpbGwgaGF2ZSBhIHZhbHVlIG9mIDAuXG4gICAqXG4gICAqIEBwYXJhbSBmYWlsdXJlIFdoZXRoZXIgdGhpcyBpcyBhIGZhaWx1cmUgb3Igbm90OyBkZWZhdWx0IHRydWVcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdCwgW3tcbiAgICBrZXk6IFwic2V0RmFpbHVyZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRGYWlsdXJlKCkge1xuICAgICAgdmFyIGZhaWx1cmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gICAgICB2YXIgZmFpbHVyZUNvdW50ID0gZmFpbHVyZSA/IDEgOiAwO1xuICAgICAgdmFyIG1ldHJpYyA9IHRoaXMuZmFpbHVyZU1ldHJpYztcbiAgICAgIG1ldHJpYy52YWx1ZSA9IGZhaWx1cmVDb3VudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBmYWlsdXJlIHN0YXR1cyB0byBmYWxzZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFN1Y2Nlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U3VjY2VzcygpIHtcbiAgICAgIHRoaXMuc2V0RmFpbHVyZShmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbGF0ZW5jeSBtZXRyaWMgdG8gdGhlIGdpdmVuIHZhbHVlLCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICpcbiAgICAgKiBOb3RlIHlvdSBkb24ndCBub3JtYWxseSBoYXZlIHRvIHNldCB0aGlzLCB0aGUgdW5kZXJseWluZyBtZXRyaWMgaXMgYSBLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoIHRoYXQgd2lsbCBzdGFydFxuICAgICAqIGFuZCBzdG9wIGF1dG9tYXRpY2FsbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGF0ZW5jeU1zIExhdGVuY3kgaW4gbWlsbGlzZWNvbmRzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRMYXRlbmN5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldExhdGVuY3kobGF0ZW5jeU1zKSB7XG4gICAgICB2YXIgbWV0cmljID0gdGhpcy5sYXRlbmN5TWV0cmljO1xuICAgICAgbWV0cmljLnZhbHVlID0gbGF0ZW5jeU1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHRpbWVyIHN0b3B3YXRjaCBtZXRyaWMgZm9yIHRoaXMgYXR0ZW1wdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gVGltZXIgc3RvcHdhdGNoIG1ldHJpYyBmb3IgdGhpcyBhdHRlbXB0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsYXRlbmN5TWV0cmljXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXROYW1lZE1ldHJpYyhLYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdC5MQVRFTkNZX1NVRkZJWCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZmFpbHVyZSBjb3VudGVyIG1ldHJpYyBmb3IgdGhpcyBhdHRlbXB0LlxuICAgICAqXG4gICAgICogQHJldHVybiBGYWlsdXJlIGNvdW50ZXIgbWV0cmljIGZvciB0aGlzIGV2ZW50XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmYWlsdXJlTWV0cmljXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXROYW1lZE1ldHJpYyhLYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdC5GQUlMVVJFX1NVRkZJWCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBLYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdDtcbn0oX0thdGFsTWV0cmljTmFtZWRPYmplY3RMaXN0LmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBLYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdDtcbigwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKEthdGFsTWV0cmljVGltZWRBdHRlbXB0LCBcIkxBVEVOQ1lfU1VGRklYXCIsICdMYXRlbmN5Jyk7XG4oMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdCwgXCJGQUlMVVJFX1NVRkZJWFwiLCAnRmFpbHVyZScpOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9nZXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRcIikpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY09iamVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljT2JqZWN0XCIpKTtcblxudmFyIF9WYWxpZGF0ZVNpbXBsZUludCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2hlbHBlci9WYWxpZGF0ZVNpbXBsZUludFwiKSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG4vKipcbiAqIFRpbWVyIHR5cGUuXG4gKlxuICogQ2FuIGJlIHVzZWQgdG8gcmVjb3JkIGEgdGltZS4gIFRoaXMgY2xhc3MgcmVxdWlyZXMgZXhwbGljaXQgdmFsdWU7IHNlZSBLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoIGZvciBhdXRvbWF0aWNcbiAqIHRpbWluZy5cbiAqL1xudmFyIEthdGFsTWV0cmljVGltZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9LYXRhbE1ldHJpY09iamVjdCkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVyLCBfS2F0YWxNZXRyaWNPYmplY3QpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoS2F0YWxNZXRyaWNUaW1lcik7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyB0aW1lciBtZXRyaWMuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIE5hbWUgZm9yIHRoZSBtZXRyaWNcbiAgICogQHBhcmFtIHZhbHVlIFRpbWVyIHZhbHVlIGluIG1pbGxpc2Vjb25kc1xuICAgKi9cbiAgZnVuY3Rpb24gS2F0YWxNZXRyaWNUaW1lcihuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEthdGFsTWV0cmljVGltZXIpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSk7XG4gICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgZm9yIHRoaXMgdGltZXJcbiAgICpcbiAgICogQHJldHVybiBUaW1lciB2YWx1ZSBpbiBtaWxsaXNlY29uZHNcbiAgICovXG5cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVyLCBbe1xuICAgIGtleTogXCJ2YWx1ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHZhbHVlIGZvciB0aGlzIHRpbWVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgTmV3IHRpbWVyIHZhbHVlIGluIG1pbGxpc2Vjb25kc1xuICAgICAqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIE1hdGgucm91bmQgd2lsbCBhbHNvIGNvZXJjZSBmcm9tIGEgc3RyaW5nIGlmIG5lY2Vzc2FyeSwgYW5kIHJldHVybiBOYU4gaWYgaW52YWxpZFxuXG5cbiAgICAgIHRoaXMuX3ZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdHlwZSBmb3IgdGhpcyB0aW1lci5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gQWx3YXlzIHJldHVybnMgXCJUaW1lclwiLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidHlwZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9LYXRhbE1ldHJpY09iamVjdDIuZGVmYXVsdC5UeXBlcy5UaW1lcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FuTW9uaXRvclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbGlkYXRpb25FcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0aW9uRXJyb3IoKSB7XG4gICAgICB2YXIgc3VwZXJFcnJvciA9ICgwLCBfZ2V0Mi5kZWZhdWx0KSgoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVyLnByb3RvdHlwZSksIFwidmFsaWRhdGlvbkVycm9yXCIsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICBpZiAoc3VwZXJFcnJvcikgcmV0dXJuIHN1cGVyRXJyb3I7XG4gICAgICByZXR1cm4gKDAsIF9WYWxpZGF0ZVNpbXBsZUludC5kZWZhdWx0KSh0aGlzLnZhbHVlLCBcImZpZWxkIHZhbHVlIGluIFRpbWVyIG1ldHJpY3Mgb2JqZWN0ICdcIi5jb25jYXQodGhpcy5uYW1lLCBcIidcIikpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gS2F0YWxNZXRyaWNUaW1lcjtcbn0oX0thdGFsTWV0cmljT2JqZWN0Mi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gS2F0YWxNZXRyaWNUaW1lcjsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfc2V0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2V0XCIpKTtcblxudmFyIF9nZXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRcIikpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY1RpbWVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNUaW1lclwiKSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG4vKipcbiAqIFN1YmNsYXNzIG9mIEthdGFsTWV0cmljVGltZXIgdGhhdCBjYW4gYmUgc3RhcnRlZCBhbmQgc3RvcHBlZCwgYW5kIHdpbGwgcmVjb3JkIHRoZSBlbGFwc2VkIHRpbWUgYmV0d2VlbiBzdGFydGluZyBhbmRcbiAqIHN0b3BwaW5nLiAgQnkgZGVmYXVsdCBpdCB3aWxsIHN0YXJ0IHdoZW4gdGhlIG9iamVjdCBpcyBjcmVhdGVkLCBhbmQgc3RvcHBlZCB3aGVuIHRoZSB2YWx1ZSBpcyByZXRyaWV2ZWQgd2l0aFxuICogdGhlIGdldHRlciBcInZhbHVlXCIuXG4gKi9cbnZhciBLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfS2F0YWxNZXRyaWNUaW1lcikge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoLCBfS2F0YWxNZXRyaWNUaW1lcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoKTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHRpbWVyIHdpdGggdGhlIGdpdmVuIG5hbWUgYW5kIHN0YXJ0aW5nIHRpbWUuICBJZiBubyBzdGFydGluZyB0aW1lIGlzIGdpdmVuLCB0aGUgY3VycmVudCB0aW1lIGlzIHVzZWQuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIE5hbWUgZm9yIHRoaXMgdGltZXJcbiAgICogQHBhcmFtIHN0YXJ0VGltZSBNaWxsaXNlY29uZCBlcG9jaCB0aW1lIGZvciB0aGUgc3RhcnQgdGltZTsgZGVmYXVsdHMgdG8gbm93XG4gICAqL1xuICBmdW5jdGlvbiBLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoKG5hbWUsIHN0YXJ0VGltZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEthdGFsTWV0cmljVGltZXJTdG9wd2F0Y2gpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSwgdW5kZWZpbmVkKTtcblxuICAgIF90aGlzLnN0YXJ0KHN0YXJ0VGltZSk7XG5cbiAgICBfdGhpcy5fdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZS1zdGFydCB0aW1lciB3aXRoIHRoZSBnaXZlbiBzdGFydCB0aW1lLCBvciB0aGUgY3VycmVudCB0aW1lIGlmIG5vbmUgaXMgZ2l2ZW4uXG4gICAqXG4gICAqIEBwYXJhbSBzdGFydFRpbWUgV2hlbiB0aGUgdGltZXIgd2FzIHN0YXJ0ZWQsIGluIGVwb2NoIG1pbGxpc2Vjb25kczsgZGVmYXVsdHMgdG8gbm93XG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoS2F0YWxNZXRyaWNUaW1lclN0b3B3YXRjaCwgW3tcbiAgICBrZXk6IFwic3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoc3RhcnRUaW1lKSB7XG4gICAgICB0aGlzLl9zdGFydFRpbWUgPSBzdGFydFRpbWUgfHwgdGhpcy5ub3coKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcCB0aGUgdGltZXIgYW5kIHJlY29yZCB0aGUgZWxhcHNlZCB0aW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0b3BUaW1lIFdoZW4gdGhlIHRpbWVyIHdhcyBzdG9wcGVkLCBpbiBlcG9jaCBtaWxsaXNlY29uZHM7IGRlZmF1bHRzIHRvIG5vd1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3RvcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKHN0b3BUaW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RvcFRpbWUgPSBzdG9wVGltZSB8fCB0aGlzLm5vdygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgdGltZXIgaGFzIGJlZW4gc3RvcHBlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHRpbWVyIGhhcyBiZWVuIHN0b3BwZWQgeWV0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpc1N0b3BwZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdG9wVGltZSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGVsYXBzZWQgdGltZSBiZXR3ZWVuIHdoZW4gdGhlIHRpbWVyIHdhcyBzdGFydGVkIGFuZCBzdG9wcGVkOyBpZiB0aGUgdGltZXIgaGFzIG5vdCB5ZXQgYmVlbiBzdG9wcGVkLFxuICAgICAqIHN0b3AgaXQgZmlyc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBFbGFwc2VkIHRpbWUgYmV0d2VlbiB3aGVuIHRpbWVyIHdhcyBzdGFydGVkIGFuZCBzdG9wcGVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ2YWx1ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCgwLCBfZ2V0Mi5kZWZhdWx0KSgoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoLnByb3RvdHlwZSksIFwidmFsdWVcIiwgdGhpcykgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIH0gLy8gUmVseSBvbiBzdXBlci52YWx1ZSBzZXR0ZXIgdG8gcm91bmRcblxuXG4gICAgICAgICgwLCBfc2V0Mi5kZWZhdWx0KSgoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoLnByb3RvdHlwZSksIFwidmFsdWVcIiwgdGhpcy5zdG9wVGltZSAtIHRoaXMuc3RhcnRUaW1lLCB0aGlzLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICgwLCBfZ2V0Mi5kZWZhdWx0KSgoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShLYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoLnByb3RvdHlwZSksIFwidmFsdWVcIiwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB3aGVuIHRoaXMgdGltZXIgd2FzIHN0YXJ0ZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIFN0YXJ0IHRpbWUsIGluIGVwb2NoIG1pbGxpc2Vjb25kc1xuICAgICAqL1xuICAgICxcbiAgICBzZXQ6XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2YWx1ZSBmb3IgdGhpcyBtZXRyaWMuICBOb3RlIHRoaXMgd2lsbCBvdmVycmlkZSB0aGUgc3RvcHdhdGNoIGJlaGF2aW9yIGFuZCBqdXN0IHVzZSB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgVmFsdWUgZm9yIHRoaXMgbWV0cmljXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAoMCwgX3NldDIuZGVmYXVsdCkoKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoS2F0YWxNZXRyaWNUaW1lclN0b3B3YXRjaC5wcm90b3R5cGUpLCBcInZhbHVlXCIsIHZhbHVlLCB0aGlzLCB0cnVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRUaW1lXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RhcnRUaW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgd2hlbiB0aGlzIHRpbWVyIHdhcyBzdG9wcGVkIChvciB1bmRlZmluZWQgaWYgaXQgaXMgc3RpbGwgcnVubmluZylcbiAgICAgKlxuICAgICAqIEByZXR1cm4gU3RvcCB0aW1lLCBpbiBlcG9jaCBtaWxsc2Vjb25kcywgb3IgdW5kZWZpbmVkIGlmIHRoZSBzdG9wd2F0Y2ggaXMgc3RpbGwgcnVubmluZ1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3RvcFRpbWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdG9wVGltZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibm93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vdygpIHtcbiAgICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEthdGFsTWV0cmljVGltZXJTdG9wd2F0Y2g7XG59KF9LYXRhbE1ldHJpY1RpbWVyMi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gS2F0YWxNZXRyaWNUaW1lclN0b3B3YXRjaDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxuLyoqXG4gKiBNZXRyaWMgdHlwZXMuXG4gKi9cbnZhciBLYXRhbE1ldHJpY1R5cGU7XG5cbihmdW5jdGlvbiAoS2F0YWxNZXRyaWNUeXBlKSB7XG4gIEthdGFsTWV0cmljVHlwZVtcIlN0cmluZ1wiXSA9IFwiU3RyaW5nXCI7XG4gIEthdGFsTWV0cmljVHlwZVtcIkNvdW50ZXJcIl0gPSBcIkNvdW50ZXJcIjtcbiAgS2F0YWxNZXRyaWNUeXBlW1wiVGltZXJcIl0gPSBcIlRpbWVyXCI7XG4gIEthdGFsTWV0cmljVHlwZVtcIkxpc3RcIl0gPSBcIkxpc3RcIjtcbn0pKEthdGFsTWV0cmljVHlwZSB8fCAoS2F0YWxNZXRyaWNUeXBlID0ge30pKTtcblxuO1xudmFyIF9kZWZhdWx0ID0gS2F0YWxNZXRyaWNUeXBlO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ291bnRlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfS2F0YWxNZXRyaWNDb3VudGVyLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSHR0cFJlcXVlc3RcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0thdGFsTWV0cmljSHR0cFJlcXVlc3QuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbml0aWFsaXphdGlvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfS2F0YWxNZXRyaWNJbml0aWFsaXphdGlvbi5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk9iamVjdFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfS2F0YWxNZXRyaWNPYmplY3QuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTdHJpbmdcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0thdGFsTWV0cmljU3RyaW5nLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGltZWRBdHRlbXB0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9LYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRpbWVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9LYXRhbE1ldHJpY1RpbWVyLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGltZXJTdG9wd2F0Y2hcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0thdGFsTWV0cmljVGltZXJTdG9wd2F0Y2guZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfS2F0YWxNZXRyaWNPYmplY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljT2JqZWN0XCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY1N0cmluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNTdHJpbmdcIikpO1xuXG52YXIgX0thdGFsTWV0cmljQ291bnRlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNDb3VudGVyXCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY1RpbWVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY1RpbWVyXCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9LYXRhbE1ldHJpY1RpbWVyU3RvcHdhdGNoXCIpKTtcblxudmFyIF9LYXRhbE1ldHJpY1RpbWVkQXR0ZW1wdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vS2F0YWxNZXRyaWNUaW1lZEF0dGVtcHRcIikpO1xuXG52YXIgX0thdGFsTWV0cmljSW5pdGlhbGl6YXRpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljSW5pdGlhbGl6YXRpb25cIikpO1xuXG52YXIgX0thdGFsTWV0cmljSHR0cFJlcXVlc3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0thdGFsTWV0cmljSHR0cFJlcXVlc3RcIikpOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7ICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG4vKipcbiAqIFRoaXMgY2xhc3MgZW5jYXBzdWxhdGVzIHR3byBJSUZFcyB0aGF0IHRoZSBTdXNoaSBsaWJyYXJ5IGNvbnRhaW5zLiBBIGZha2UgQ1NNIGFuZCBXaW5kb3cgb2JqZWN0IGFyZSBjcmVhdGVkIGFuZCBwcm92aWRlZFxuICogdG8gdGhlIGZ1bmN0aW9ucyBzbyB0aGF0IHRoZXkgYWN0dWFsbHkgZXhlY3V0ZSBpbiBhIGNvbnRyb2xsZWQgZW52aXJvbm1lbnQgYXdheSBmcm9tIGFueSBDU00gY29kZSB0aGF0IG1pZ2h0IGJlIGV4ZWN1dGluZ1xuICogYXQgdGhlIHBsYXRmb3JtIGxldmVsIHdpdGhpbiB0aGUgcGFnZS5cbiAqXG4gKiBUaGUgYmFzaWMgcnVuIG9yZGVyIGlzIHRoZSBmb2xsb3dpbmc6XG4gKiAxLiBCdWlsZCB0aGUgbW9jayBDU00gb2JqZWN0LCB0aGVuIGJ1aWxkIGEgbW9jayBXaW5kb3cgb2JqZWN0IHRoYXQgcmVmZXJlbmNlcyB0aGUgQ1NNIG9iamVjdCBhcyB1ZV9jc21cbiAqIDIuIFJ1biB0aGUgdHJhbnNwb3J0YXRpb24tY2xpZW50cy5qcyBTY3JpcHQgZnJvbSBTdXNoaUphdmFzY3JpcHRDbGllbnQgcHJvdmlkaW5nIHRoZSBtb2Nrcy4gSXQgd2lsbCBtb2RpZnkgZ2xvYmFscyBvbiB0aGUgbW9jayBvYmplY3RzLlxuICogMy4gUnVuIHRoZSBzdXNoaS1jbGllbnQuanMgc2NyaXB0IGZyb20gU3VzaGlKYXZhU2NyaXB0Q2xpZW50IHByb3ZpZGluZyB0aGUgbW9ja3MuIEl0IHdpbGwgY3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoZSBzdXNoaSBjbGllbnQgYW5kIGluamVjdCBpdCBpbnRvIHRoZSBDU00gZ2xvYmFscyBpbiB0aGUgbW9ja3MuXG4gKiA0LiB3aGVuZXZlciBldmVudCgpIGlzIGNhbGxlZCwgcmVmZXIgdG8gdGhlIGVuY2Fwc3VsYXRlZCBjc20gb2JqZWN0IHRvIGFkZCB0aGUgZXZlbnQgdG8gdGhlIHF1ZXVlLlxuICovXG52YXIgU3VzaGlDbGllbnQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShTdXNoaUNsaWVudCwgbnVsbCwgW3tcbiAgICBrZXk6IFwiY3JlYXRlU3VzaGlVcmxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlU3VzaGlVcmwocmVnaW9uLCBzb3VyY2VHcm91cCkge1xuICAgICAgaWYgKCFzb3VyY2VHcm91cCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdXNoaSBEcml2ZXIgd2FzIG5vdCBwcm92aWRlZCB3aXRoIGEgc291cmNlIGdyb3VwLlwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRvbWFpbjtcblxuICAgICAgc3dpdGNoIChyZWdpb24pIHtcbiAgICAgICAgY2FzZSBTdXNoaUNsaWVudC5SRUdJT05TLk5BOlxuICAgICAgICAgIGRvbWFpbiA9IFwidW5hZ2ktbmFcIjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN1c2hpQ2xpZW50LlJFR0lPTlMuRVU6XG4gICAgICAgICAgZG9tYWluID0gXCJ1bmFnaS1ldVwiO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3VzaGlDbGllbnQuUkVHSU9OUy5GRTpcbiAgICAgICAgICBkb21haW4gPSBcInVuYWdpLWZlXCI7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTdXNoaUNsaWVudC5SRUdJT05TLkNOOlxuICAgICAgICAgIGRvbWFpbiA9IFwidW5hZ2ktY25cIjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCByZWdpb24gJ1wiLmNvbmNhdChyZWdpb24sIFwiJyBwcm92aWRlZCB0byBTdXNoaUNsaWVudC5cIikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gXCJodHRwczovL1wiLmNvbmNhdChkb21haW4sIFwiLmFtYXpvbi5jb20vMS9ldmVudHMvXCIpLmNvbmNhdChzb3VyY2VHcm91cCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZUNzbVVzZXJDb250ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUNzbVVzZXJDb250ZXh0KHN1c2hpVXJsKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZCh7XG4gICAgICAgIGhpUHJpRmx1c2hJbnRlcnZhbDogMTAwMCxcbiAgICAgICAgbG93UHJpRmx1c2hJbnRlcnZhbDogMTAwMDAsXG4gICAgICAgIHJlcXVlc3RJZDogXCIxXCIsXG4gICAgICAgIGVycm9yQ2hhbm5lbDogXCJqc2VyclwiLFxuICAgICAgICBzZXNzaW9uU3RvcmFnZVdyYXBwZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgZXJyb3JIYW5kbGVyRnVuY3Rpb246IGNvbnNvbGUubG9nLFxuICAgICAgICBzdXNoaVVybDogc3VzaGlVcmxcbiAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBTdXNoaSBDbGllbnQgZm9yIGEgcmVnaW9uIGFuZCBzb3VyY2UgZ3JvdXBcbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWdpb24gUmVnaW9uIGluIFN1c2hpQ2xpZW50LlJFR0lPTlNcbiAgICAgKiBAcGFyYW0gc291cmNlR3JvdXAgU3VzaGkgRWVsIHNvdXJjZSBncm91cFxuICAgICAqIEBwYXJhbSBlcnJvckhhbmRsZXIgRXJyb3IgaGFuZGxlciBmdW5jdGlvblxuICAgICAqIEBwYXJhbSBvcHRpb25zIEFkZGl0aW9uYWwgQ1NNIGNvbnRleHQgb3ZlcnJpZGVzXG4gICAgICogQHBhcmFtIGNsaWVudE92ZXJyaWRlIEFuIG9wdGlvbmFsIHRyYW5zcG9ydGF0aW9uIGNsaWVudCBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdCBjbGllbnRzIChuYXZpZ2F0b3Iuc2VuZEJlYWNvbiBhbmQgWERvbWFpblJlcXVlc3Qgb3IgWE1MSHR0cFJlcXVlc3QpXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJSRUdJT05TXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBOQTogXCJOQVwiLFxuICAgICAgICBFVTogXCJFVVwiLFxuICAgICAgICBGRTogXCJGRVwiLFxuICAgICAgICBDTjogXCJDTlwiXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIGZ1bmN0aW9uIFN1c2hpQ2xpZW50KCkge1xuICAgIHZhciByZWdpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFN1c2hpQ2xpZW50LlJFR0lPTlMuTkE7XG4gICAgdmFyIHNvdXJjZUdyb3VwID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIGVycm9ySGFuZGxlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgICB2YXIgY2xpZW50T3ZlcnJpZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gNCA/IGFyZ3VtZW50c1s0XSA6IHVuZGVmaW5lZDtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBTdXNoaUNsaWVudCk7XG4gICAgdmFyIHN1c2hpVXJsID0gU3VzaGlDbGllbnQuY3JlYXRlU3VzaGlVcmwocmVnaW9uLCBzb3VyY2VHcm91cCk7XG4gICAgdmFyIGNzbVVzZXJDb250ZXh0ID0gU3VzaGlDbGllbnQuY3JlYXRlQ3NtVXNlckNvbnRleHQoc3VzaGlVcmwsIG9wdGlvbnMpO1xuICAgIHRoaXMudWVfY3NtID0gdGhpcy5zZXR1cE1vY2tDU01PYmplY3QoY3NtVXNlckNvbnRleHQpO1xuICAgIHRoaXMuZW5jYXBzdWxhdGVkV2luZG93ID0gdGhpcy5zZXR1cE1vY2tXaW5kb3codGhpcy51ZV9jc20pO1xuICAgIHRoaXMudHJhbnNwb3J0YXRpb25DbGllbnRDb2RlKHRoaXMudWVfY3NtLCB3aW5kb3cpO1xuXG4gICAgaWYgKGNsaWVudE92ZXJyaWRlKSB7XG4gICAgICB0aGlzLnVlX2NzbS51ZS5fc0JjbiA9IHtcbiAgICAgICAgaXNTdXBwb3J0ZWQ6IHRydWUsXG4gICAgICAgIHNlbmQ6IGZ1bmN0aW9uIHNlbmQoZW5kcG9pbnQsIHBheWxvYWQpIHtcbiAgICAgICAgICBjbGllbnRPdmVycmlkZShlbmRwb2ludCwgcGF5bG9hZCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5jbGllbnRDb2RlKHRoaXMudWVfY3NtLCB0aGlzLmVuY2Fwc3VsYXRlZFdpbmRvdyk7XG4gICAgdGhpcy5lcnJvckhhbmRsZXIgPSBlcnJvckhhbmRsZXI7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShTdXNoaUNsaWVudCwgW3tcbiAgICBrZXk6IFwiZXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXZlbnQoZGF0YSwgcHJvZHVjZXJJZCwgc2NoZW1hSWQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogZmFsc2U7XG5cbiAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlN1c2hpQ2xpZW50IHdyYXBwZXIgcHVibGlzaGluZyB0aGUgZm9sbG93aW5nOlwiLCB7XG4gICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICBwcm9kdWNlcklkOiBwcm9kdWNlcklkLFxuICAgICAgICAgIHNjaGVtYUlkOiBzY2hlbWFJZCxcbiAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy51ZV9jc20udWUuZXZlbnQoZGF0YSwgcHJvZHVjZXJJZCwgc2NoZW1hSWQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB5b3UgcGxhbiB0byBlbWl0IDEwMDAgb3IgbW9yZSBldmVudHMgcGVyIGluc3RhbnRpYXRlZCBjbGllbnQsXG4gICAgICogY2FsbCByZXNldCBhZnRlciBjYWxsaW5nIGV2ZW50IHRvIGFsbG93IHRoZSBDU00gY2xpZW50IHRvIGNvbnRpbnVlIHNlbmRpbmcgZXZlbnRzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0aGlzLnVlX2NzbS51ZS5ldmVudC5yZXNldCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQganVzdCBiZWZvcmUgZWFjaCB0aW1lIG1ldHJpY3MgYXJlXG4gICAgICogZmx1c2hlZCB0byB0aGUgbmV0d29yay5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgQSBmdW5jdGlvbiB0aGF0IHN1c2hpIHdpbGwgY2FsbCBiZWZvcmUgZmx1c2hlcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uU3VzaGlGbHVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblN1c2hpRmx1c2goY2FsbGJhY2spIHtcbiAgICAgIHRoaXMudWVfY3NtLnVlLm9uU3VzaGlGbHVzaChjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCBqdXN0IGJlZm9yZSB0aGUgcGFnZSB1bmxvYWRzLlxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gc2VuZCBhbnkgZmluYWwgbWV0cmljcyB0byBzdXNoaSwgc3VjaCBhcyBwYWdlIHZpc2l0XG4gICAgICogZHVyYXRpb24gb3IgYmF0Y2hlZCBjb3VudGVycy5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgQSBmdW5jdGlvbiB0aGF0IHN1c2hpIHdpbGwgY2FsbCBiZWZvcmUgdW5sb2FkLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25TdXNoaVVubG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblN1c2hpVW5sb2FkKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLnVlX2NzbS51ZS5vblN1c2hpVW5sb2FkKGNhbGxiYWNrKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0dXBNb2NrQ1NNT2JqZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldHVwTW9ja0NTTU9iamVjdChjc21Vc2VyQ29udGV4dCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGV4ZWNTdHViID0gZnVuY3Rpb24gZXhlY1N0dWIoY2FsbGJhY2ssIGF0dHJpYnV0aW9uKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaztcbiAgICAgIH07XG5cbiAgICAgIHZhciBldmVudFN0dWIgPSBmdW5jdGlvbiBldmVudFN0dWIobG9nLCBwcm9kdWNlciwgZXZlbnRUeXBlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlN1c2hpQ2xpZW50IENTTSBzdHViIGNhbGxlZCBpbiB1bnN1cHBvcnRlZCBtYW5uZXI6IGV2ZW50KClcIik7XG4gICAgICB9O1xuXG4gICAgICB2YXIgZXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gZXJyb3JIYW5kbGVyKGxvZ0V2ZW50LCBjaGFubmVsKSB7XG4gICAgICAgIGlmIChfdGhpcy5lcnJvckhhbmRsZXIpIHtcbiAgICAgICAgICBfdGhpcy5lcnJvckhhbmRsZXIobG9nRXZlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiQW4gZXJyb3IgaGFzIG9jY3VycmVkIGluIFN1c2hpQ2xpZW50IGNoYW5uZWwgXCIgKyBjaGFubmVsLCBsb2dFdmVudCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBhdHRhY2hIYW5kbGVyID0gZnVuY3Rpb24gYXR0YWNoSGFuZGxlcihldnQsIGhhbmRsZXIsIGNvbnRhaW5lcikge1xuICAgICAgICAvL1RPRE8gbWlnaHQgYmUgYWJsZSB0byBqdXN0IHVzZSB3aW5kb3cudWUuYXR0YWNoP1xuICAgICAgICBjb250YWluZXIgPSBjb250YWluZXIgfHwgd2luZG93OyAvL29rIHRvIHVzZSByZWFsIHdpbmRvdyBnbG9iYWwgaGVyZS5cblxuICAgICAgICBpZiAod2luZG93LkV2ZW50VGFyZ2V0ICYmIHdpbmRvdy5FdmVudFRhcmdldC5wcm90b3R5cGUgJiYgd2luZG93LkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgd2luZG93LkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyLmNhbGwoY29udGFpbmVyLCBldnQsIGhhbmRsZXIsICEhd2luZG93LnVlX2NsZik7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihldnQsIGhhbmRsZXIsICEhd2luZG93LnVlX2NsZik7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGFpbmVyLmF0dGFjaEV2ZW50KSB7XG4gICAgICAgICAgY29udGFpbmVyLmF0dGFjaEV2ZW50KFwib25cIiArIGV2dCwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVlX2hwc2k6IGNzbVVzZXJDb250ZXh0LmhpUHJpRmx1c2hJbnRlcnZhbCxcbiAgICAgICAgdWVfbHBzaTogY3NtVXNlckNvbnRleHQubG93UHJpRmx1c2hJbnRlcnZhbCxcbiAgICAgICAgdWU6IHtcbiAgICAgICAgICBzc3c6IGNzbVVzZXJDb250ZXh0LnNlc3Npb25TdG9yYWdlV3JhcHBlcixcbiAgICAgICAgICBsb2c6IGVycm9ySGFuZGxlcixcbiAgICAgICAgICBleGVjOiBleGVjU3R1YixcbiAgICAgICAgICBldmVudDogZXZlbnRTdHViLFxuICAgICAgICAgIGF0dGFjaDogYXR0YWNoSGFuZGxlclxuICAgICAgICB9LFxuICAgICAgICB1ZUxvZ0Vycm9yOiBjc21Vc2VyQ29udGV4dC5lcnJvckhhbmRsZXJGdW5jdGlvbixcbiAgICAgICAgdWVfc3VybDogY3NtVXNlckNvbnRleHQuc3VzaGlVcmwsXG4gICAgICAgIHVlX2lkOiBjc21Vc2VyQ29udGV4dC5yZXF1ZXN0SWQsXG4gICAgICAgIHVlX2Vycl9jaGFuOiBjc21Vc2VyQ29udGV4dC5lcnJvckNoYW5uZWxcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldHVwTW9ja1dpbmRvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cE1vY2tXaW5kb3codWVfY3NtKSB7XG4gICAgICAvL2FwcGFyZW50bHkgY2Fubm90IHJlZiB0aGUgc2V0VGltZW91dCBmdW5jdGlvbiBkaXJlY3RseSBpbiBzb21lIGJyb3dzZXJzIHNvIHdlIGhhdmUgdG8gd3JhcCBpdC5cbiAgICAgIHZhciB0aW1lb3V0V3JhcHBlciA9IGZ1bmN0aW9uIHRpbWVvdXRXcmFwcGVyKGZuLCB0aW1lb3V0KSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuc2V0VGltZW91dChmbiwgdGltZW91dCk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB1ZV9jc206IHVlX2NzbSxcbiAgICAgICAgdWVMb2dFcnJvcjogdWVfY3NtLnVlTG9nRXJyb3IsXG4gICAgICAgIHVlOiB1ZV9jc20udWUsXG4gICAgICAgIHNldFRpbWVvdXQ6IHRpbWVvdXRXcmFwcGVyXG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb2RlIHdpdGhpbiBmdW5jdGlvbiBwdWxsZWQgZGlyZWN0bHkgZnJvbVxuICAgICAqIGh0dHBzOi8vY29kZS5hbWF6b24uY29tL3BhY2thZ2VzL1N1c2hpSmF2YVNjcmlwdENsaWVudC9ibG9icy9tYWlubGluZS8tLS9qYXZhc2NyaXB0L3N1c2hpLWNsaWVudC5qc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xpZW50Q29kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGllbnRDb2RlKHVlX2NzbSwgd2luZG93KSB7XG4gICAgICB1ZV9jc20udWUuZXhlYyhmdW5jdGlvbiAoYiwgaykge1xuICAgICAgICBmdW5jdGlvbiBBKCkge1xuICAgICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgYXJndW1lbnRzLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgICAgICB2YXIgYyA9IGFyZ3VtZW50c1thXTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIGg7XG5cbiAgICAgICAgICAgICAgaWYgKGMuaXNTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYiA9IHQuYnVpbGRQYXlsb2FkKGwsIGUpO1xuICAgICAgICAgICAgICAgIGggPSBjLnNlbmQoSiwgYik7XG4gICAgICAgICAgICAgIH0gZWxzZSB0aHJvdyBkdW1teUV4Y2VwdGlvbjtcblxuICAgICAgICAgICAgICByZXR1cm4gaDtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGQpIHt9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgQih7XG4gICAgICAgICAgICBtOiBcIkFsbCBzdXBwb3J0ZWQgY2xpZW50cyBmYWlsZWRcIixcbiAgICAgICAgICAgIGF0dHJpYnV0aW9uOiBcIkNTTVN1c2hpQ2xpZW50X1RSQU5TUE9SVEFUSU9OX0ZBSUxcIixcbiAgICAgICAgICAgIGY6IFwic3VzaGktY2xpZW50LmpzXCIsXG4gICAgICAgICAgICBsb2dMZXZlbDogXCJFUlJPUlwiXG4gICAgICAgICAgfSwgay51ZV9lcnJfY2hhbiB8fCBcImpzZXJyXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbSgpIHtcbiAgICAgICAgICBpZiAoZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgbi5sZW5ndGg7IGErKykge1xuICAgICAgICAgICAgICBuW2FdKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEEoZC5fc0JjbiB8fCB7fSwgZC5fYWp4IHx8IHt9KTtcbiAgICAgICAgICAgIGUgPSBbXTtcbiAgICAgICAgICAgIGYgPSB7fTtcbiAgICAgICAgICAgIGwgPSB7fTtcbiAgICAgICAgICAgIHUgPSB2ID0gcSA9IHcgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIEsoKSB7XG4gICAgICAgICAgdmFyIGEgPSBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICBjID0gZnVuY3Rpb24gYyhhKSB7XG4gICAgICAgICAgICByZXR1cm4gMTAgPiBhID8gXCIwXCIgKyBhIDogYTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcmV0dXJuIERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nID8gYS50b0lTT1N0cmluZygpIDogYS5nZXRVVENGdWxsWWVhcigpICsgXCItXCIgKyBjKGEuZ2V0VVRDTW9udGgoKSArIDEpICsgXCItXCIgKyBjKGEuZ2V0VVRDRGF0ZSgpKSArIFwiVFwiICsgYyhhLmdldFVUQ0hvdXJzKCkpICsgXCI6XCIgKyBjKGEuZ2V0VVRDTWludXRlcygpKSArIFwiOlwiICsgYyhhLmdldFVUQ1NlY29uZHMoKSkgKyBcIi5cIiArIFN0cmluZygoYS5nZXRVVENNaWxsaXNlY29uZHMoKSAvIDFFMykudG9GaXhlZCgzKSkuc2xpY2UoMiwgNSkgKyBcIlpcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHgoYSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYSk7XG4gICAgICAgICAgfSBjYXRjaCAoYykge31cblxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gQyhhLCBjLCBoLCBnKSB7XG4gICAgICAgICAgdmFyIHAgPSAhMTtcbiAgICAgICAgICBnID0gZyB8fCB7fTtcbiAgICAgICAgICByKys7XG4gICAgICAgICAgciA9PSBEICYmIEIoe1xuICAgICAgICAgICAgbTogXCJNYXggbnVtYmVyIG9mIFN1c2hpIExvZ3MgZXhjZWVkZWRcIixcbiAgICAgICAgICAgIGY6IFwic3VzaGktY2xpZW50LmpzXCIsXG4gICAgICAgICAgICBsb2dMZXZlbDogXCJFUlJPUlwiLFxuICAgICAgICAgICAgYXR0cmlidXRpb246IFwiQ1NNU3VzaGlDbGllbnRfTUFYX0NBTExTXCJcbiAgICAgICAgICB9LCBrLnVlX2Vycl9jaGFuIHx8IFwianNlcnJcIik7XG4gICAgICAgICAgdmFyIGY7XG4gICAgICAgICAgaWYgKGYgPSAhKHIgPj0gRCkpIChmID0gYSAmJiAtMSA8IGEuY29uc3RydWN0b3IudG9TdHJpbmcoKS5pbmRleE9mKFwiT2JqZWN0XCIpICYmIGMgJiYgLTEgPCBjLmNvbnN0cnVjdG9yLnRvU3RyaW5nKCkuaW5kZXhPZihcIlN0cmluZ1wiKSAmJiBoICYmIC0xIDwgaC5jb25zdHJ1Y3Rvci50b1N0cmluZygpLmluZGV4T2YoXCJTdHJpbmdcIikpIHx8IEwrKztcbiAgICAgICAgICBmICYmIChkLmNvdW50ICYmIGQuY291bnQoXCJFdmVudDpcIiArIGgsIDEpLCBhLnByb2R1Y2VySWQgPSBhLnByb2R1Y2VySWQgfHwgYywgYS5zY2hlbWFJZCA9IGEuc2NoZW1hSWQgfHwgaCwgYS50aW1lc3RhbXAgPSBLKCksIGMgPSBEYXRlLm5vdyA/IERhdGUubm93KCkgOiArbmV3IERhdGUoKSwgaCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMiwgMTIpLCBhLm1lc3NhZ2VJZCA9IGIudWVfaWQgKyBcIi1cIiArIGMgKyBcIi1cIiArIGgsIGcgJiYgIWcuc3NkICYmIChhLnNlc3Npb25JZCA9IGEuc2Vzc2lvbklkIHx8IGIudWVfc2lkLCBhLnJlcXVlc3RJZCA9IGEucmVxdWVzdElkIHx8IGIudWVfaWQsIGEub2JmdXNjYXRlZE1hcmtldHBsYWNlSWQgPSBhLm9iZnVzY2F0ZWRNYXJrZXRwbGFjZUlkIHx8IGIudWVfbWlkKSwgKGMgPSB4KGEpKSA/IChjID0gYy5sZW5ndGgsIChlLmxlbmd0aCA9PSBNIHx8IHEgKyBjID4gTikgJiYgbSgpLCBxICs9IGMsIGEgPSB7XG4gICAgICAgICAgICBkYXRhOiB0LmNvbXByZXNzRXZlbnQoYSlcbiAgICAgICAgICB9LCBlLnB1c2goYSksIChnIHx8IHt9KS5uID8gMCA9PT0gRSA/IG0oKSA6IHUgfHwgKHUgPSBrLnNldFRpbWVvdXQobSwgRSkpIDogdiB8fCAodiA9IGsuc2V0VGltZW91dChtLCBPKSksIHAgPSAhMCkgOiBwID0gITEpO1xuICAgICAgICAgICFwICYmIGIudWVfaW50ICYmIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIEpTIE5leHVzIEFQSSBjYWxsXCIpO1xuICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gRigpIHtcbiAgICAgICAgICBpZiAoIUcpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgeS5sZW5ndGg7IGErKykge1xuICAgICAgICAgICAgICB5W2FdKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoYSA9IDA7IGEgPCBuLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgICAgICAgIG5bYV0oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZS5sZW5ndGggJiYgKGIudWVfc2J1aW1wICYmIGIudWUgJiYgYi51ZS5zc3cgJiYgKGEgPSB4KHtcbiAgICAgICAgICAgICAgZGN0OiBsLFxuICAgICAgICAgICAgICBldnQ6IGVcbiAgICAgICAgICAgIH0pLCBiLnVlLnNzdyhcImVlbGRhdGFcIiwgYSksIGIudWUuc3N3KFwiZWVsc3RzXCIsIFwidW5rXCIpKSwgQShkLl9zQmNuIHx8IHt9KSk7XG4gICAgICAgICAgICBHID0gITA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gSChhKSB7XG4gICAgICAgICAgeS5wdXNoKGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gSShhKSB7XG4gICAgICAgICAgbi5wdXNoKGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIEQgPSAxRTMsXG4gICAgICAgICAgICBNID0gNDk5LFxuICAgICAgICAgICAgTiA9IDUyNDI4OCxcbiAgICAgICAgICAgIHMgPSBmdW5jdGlvbiBzKCkge30sXG4gICAgICAgICAgICBkID0gYi51ZSB8fCB7fSxcbiAgICAgICAgICAgIEIgPSBkLmxvZyB8fCBzLFxuICAgICAgICAgICAgUCA9IGIudWV4IHx8IHM7XG5cbiAgICAgICAgKGIudWV0IHx8IHMpKFwiYmJcIiwgXCJ1ZV9zdXNoaV92MVwiLCB7XG4gICAgICAgICAgd2I6IDFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIEogPSBiLnVlX3N1cmwgfHwgXCJodHRwczovL3VuYWdpLW5hLmFtYXpvbi5jb20vMS9ldmVudHMvY29tLmFtYXpvbi5jc20ubmV4dXNjbGllbnQuZ2FtbWFcIixcbiAgICAgICAgICAgIFEgPSBbXCJtZXNzYWdlSWRcIiwgXCJ0aW1lc3RhbXBcIl0sXG4gICAgICAgICAgICB6ID0gXCIjXCIsXG4gICAgICAgICAgICBlID0gW10sXG4gICAgICAgICAgICBmID0ge30sXG4gICAgICAgICAgICBsID0ge30sXG4gICAgICAgICAgICBxID0gMCxcbiAgICAgICAgICAgIHcgPSAwLFxuICAgICAgICAgICAgTCA9IDAsXG4gICAgICAgICAgICByID0gMCxcbiAgICAgICAgICAgIHkgPSBbXSxcbiAgICAgICAgICAgIG4gPSBbXSxcbiAgICAgICAgICAgIEcgPSAhMSxcbiAgICAgICAgICAgIHUsXG4gICAgICAgICAgICB2LFxuICAgICAgICAgICAgRSA9IHZvaWQgMCA9PT0gYi51ZV9ocHNpID8gMUUzIDogYi51ZV9ocHNpLFxuICAgICAgICAgICAgTyA9IHZvaWQgMCA9PT0gYi51ZV9scHNpID8gMUU0IDogYi51ZV9scHNpLFxuICAgICAgICAgICAgdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmdW5jdGlvbiBhKGEpIHtcbiAgICAgICAgICAgIGZbYV0gPSB6ICsgdysrO1xuICAgICAgICAgICAgbFtmW2FdXSA9IGE7XG4gICAgICAgICAgICByZXR1cm4gZlthXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBjKGIpIHtcbiAgICAgICAgICAgIGlmICghKGIgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgICAgICAgICAgaWYgKGIgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGcgPSBbXSwgZCA9IGIubGVuZ3RoLCBlID0gMDsgZSA8IGQ7IGUrKykge1xuICAgICAgICAgICAgICAgICAgZ1tlXSA9IGMoYltlXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGc7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoYiBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgICAgIGcgPSB7fTtcblxuICAgICAgICAgICAgICAgIGZvciAoZCBpbiBiKSB7XG4gICAgICAgICAgICAgICAgICBiLmhhc093blByb3BlcnR5KGQpICYmIChnW2ZbZF0gPyBmW2RdIDogYShkKV0gPSAtMSA9PT0gUS5pbmRleE9mKGQpID8gYyhiW2RdKSA6IGJbZF0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBnO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCIgPT09IHR5cGVvZiBiICYmIChiLmxlbmd0aCA+ICh6ICsgdykubGVuZ3RoIHx8IGIuY2hhckF0KDApID09PSB6KSA/IGZbYl0gPyBmW2JdIDogYShiKSA6IGI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbXByZXNzRXZlbnQ6IGMsXG4gICAgICAgICAgICBidWlsZFBheWxvYWQ6IGZ1bmN0aW9uIGJ1aWxkUGF5bG9hZCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHgoe1xuICAgICAgICAgICAgICAgIGNzOiB7XG4gICAgICAgICAgICAgICAgICBkY3Q6IGxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGV2ZW50czogZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9KCk7XG5cbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZC5ldmVudCAmJiBkLmV2ZW50LmlzU3R1Yikge1xuICAgICAgICAgICAgaWYgKGIudWVfc2J1aW1wICYmIGIudWUgJiYgYi51ZS5zc3cpIHtcbiAgICAgICAgICAgICAgdmFyIGEgPSBiLnVlLnNzdyhcImVlbHN0c1wiKS52YWw7XG5cbiAgICAgICAgICAgICAgaWYgKGEgJiYgXCJ1bmtcIiA9PT0gYSAmJiAoYSA9IGIudWUuc3N3KFwiZWVsZGF0YVwiKS52YWwpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGM7XG5cbiAgICAgICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjID0gSlNPTi5wYXJzZShhKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGYpIHt9XG5cbiAgICAgICAgICAgICAgICAgIGMgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGMgJiYgYy5ldnQgaW5zdGFuY2VvZiBBcnJheSAmJiBjLmRjdCBpbnN0YW5jZW9mIE9iamVjdCAmJiAoZSA9IGMuZXZ0LCBsID0gYy5kY3QsIGUgJiYgbCAmJiAobSgpLCBiLnVlLnNzdyhcImVlbGRhdGFcIiwgXCJ7fVwiKSwgYi51ZS5zc3coXCJlZWxzdHNcIiwgXCJzY3NcIikpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkLmV2ZW50LnJlcGxheShmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICBhWzNdID0gYVszXSB8fCB7fTtcbiAgICAgICAgICAgICAgYVszXS5uID0gMTtcbiAgICAgICAgICAgICAgQy5hcHBseSh0aGlzLCBhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZC5vblN1c2hpVW5sb2FkLnJlcGxheShmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICBIKGFbMF0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkLm9uU3VzaGlGbHVzaC5yZXBsYXkoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgSShhWzBdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcblxuICAgICAgICBkLmF0dGFjaChcImJlZm9yZXVubG9hZFwiLCBGKTtcbiAgICAgICAgZC5hdHRhY2goXCJwYWdlaGlkZVwiLCBGKTtcbiAgICAgICAgZC5fY21wcyA9IHQ7XG4gICAgICAgIGQuZXZlbnQgPSBDO1xuXG4gICAgICAgIGQuZXZlbnQucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgciA9IDA7XG4gICAgICAgIH07XG5cbiAgICAgICAgZC5vblN1c2hpVW5sb2FkID0gSDtcbiAgICAgICAgZC5vblN1c2hpRmx1c2ggPSBJO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgay5QICYmIGsuUC5yZWdpc3RlciAmJiBrLlAucmVnaXN0ZXIoXCJzdXNoaS1jbGllbnRcIiwgcyk7XG4gICAgICAgIH0gY2F0Y2ggKFIpIHtcbiAgICAgICAgICBiLnVlTG9nRXJyb3IoUiwge1xuICAgICAgICAgICAgbG9nTGV2ZWw6IFwiV0FSTlwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBQKFwibGRcIiwgXCJ1ZV9zdXNoaV92MVwiLCB7XG4gICAgICAgICAgd2I6IDFcbiAgICAgICAgfSk7XG4gICAgICB9LCBcIk54cy1KUy1DbGllbnRcIikodWVfY3NtLCB3aW5kb3cpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY29kZSBpbiB0aGlzIGZ1bmN0aW9uIGlzIHB1bGxlZCBkaXJlY3RseSBmcm9tOlxuICAgICAqIGh0dHBzOi8vY29kZS5hbWF6b24uY29tL3BhY2thZ2VzL1N1c2hpSmF2YVNjcmlwdENsaWVudC9ibG9icy9tYWlubGluZS8tLS9qYXZhc2NyaXB0L3RyYW5zcG9ydGF0aW9uLWNsaWVudHMuanNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRyYW5zcG9ydGF0aW9uQ2xpZW50Q29kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFuc3BvcnRhdGlvbkNsaWVudENvZGUodWVfY3NtLCB3aW5kb3cpIHtcbiAgICAgIHVlX2NzbS51ZS5leGVjKGZ1bmN0aW9uIChiLCBjKSB7XG4gICAgICAgIHZhciBlID0gZnVuY3Rpb24gZSgpIHt9LFxuICAgICAgICAgICAgZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2VuZDogZnVuY3Rpb24gc2VuZChiLCBkKSB7XG4gICAgICAgICAgICAgIGlmIChkICYmIGIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYTtcbiAgICAgICAgICAgICAgICBpZiAoYy5YRG9tYWluUmVxdWVzdCkgYSA9IG5ldyBYRG9tYWluUmVxdWVzdCgpLCBhLm9uZXJyb3IgPSBlLCBhLm9udGltZW91dCA9IGUsIGEub25wcm9ncmVzcyA9IGUsIGEub25sb2FkID0gZSwgYS50aW1lb3V0ID0gMDtlbHNlIGlmIChjLlhNTEh0dHBSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoYSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpLCAhKFwid2l0aENyZWRlbnRpYWxzXCIgaW4gYSkpIHRocm93IFwiXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGEgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKCFhKSB0aHJvdyBcIlwiO1xuICAgICAgICAgICAgICAgIGEub3BlbihcIlBPU1RcIiwgYiwgITApO1xuICAgICAgICAgICAgICAgIGEuc2V0UmVxdWVzdEhlYWRlciAmJiBhLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LXR5cGVcIiwgXCJ0ZXh0L3BsYWluXCIpO1xuICAgICAgICAgICAgICAgIGEuc2VuZChkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzU3VwcG9ydGVkOiAhMFxuICAgICAgICAgIH07XG4gICAgICAgIH0oKSxcbiAgICAgICAgICAgIGcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNlbmQ6IGZ1bmN0aW9uIHNlbmQoYywgZCkge1xuICAgICAgICAgICAgICBpZiAoYyAmJiBkKSBpZiAobmF2aWdhdG9yLnNlbmRCZWFjb24oYywgZCkpIGIudWVfc2J1aW1wICYmIGIudWUgJiYgYi51ZS5zc3cgJiYgYi51ZS5zc3coXCJlZWxzdHNcIiwgXCJzY3NcIik7ZWxzZSB0aHJvdyBcIlwiO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzU3VwcG9ydGVkOiAhIW5hdmlnYXRvci5zZW5kQmVhY29uICYmICEoYy5jb3Jkb3ZhICYmIGMuY29yZG92YS5wbGF0Zm9ybUlkICYmIFwiaW9zXCIgPT0gYy5jb3Jkb3ZhLnBsYXRmb3JtSWQpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSgpO1xuXG4gICAgICAgIGIudWUuX2FqeCA9IGY7XG4gICAgICAgIGIudWUuX3NCY24gPSBnO1xuICAgICAgfSwgXCJUcmFuc3BvcnRhdGlvbi1jbGllbnRzXCIpKHVlX2NzbSwgd2luZG93KTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFN1c2hpQ2xpZW50O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBTdXNoaUNsaWVudDsiLCJmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuICByZXR1cm4gYXJyMjtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5TGlrZVRvQXJyYXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgYXJyYXlMaWtlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2FycmF5TGlrZVRvQXJyYXkuanNcIik7XG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KGFycik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhvdXRIb2xlcywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG4gIHJldHVybiBzZWxmO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzQ2FsbENoZWNrLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIHRvUHJvcGVydHlLZXkgPSByZXF1aXJlKFwiLi90b1Byb3BlcnR5S2V5LmpzXCIpO1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfY3JlYXRlQ2xhc3MsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgdG9Qcm9wZXJ0eUtleSA9IHJlcXVpcmUoXCIuL3RvUHJvcGVydHlLZXkuanNcIik7XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGtleSA9IHRvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2RlZmluZVByb3BlcnR5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIHN1cGVyUHJvcEJhc2UgPSByZXF1aXJlKFwiLi9zdXBlclByb3BCYXNlLmpzXCIpO1xuZnVuY3Rpb24gX2dldCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0ID0gUmVmbGVjdC5nZXQuYmluZCgpLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgICAgdmFyIGJhc2UgPSBzdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgIHJldHVybiBkZXNjLmdldC5jYWxsKGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogcmVjZWl2ZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuICB9XG4gIHJldHVybiBfZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9nZXQsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vc2V0UHJvdG90eXBlT2YuanNcIik7XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBzZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9pbmhlcml0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgXCJkZWZhdWx0XCI6IG9ialxuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlU3ByZWFkLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiLi90eXBlb2YuanNcIilbXCJkZWZhdWx0XCJdO1xudmFyIGFzc2VydFRoaXNJbml0aWFsaXplZCA9IHJlcXVpcmUoXCIuL2Fzc2VydFRoaXNJbml0aWFsaXplZC5qc1wiKTtcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7XG4gIH1cbiAgcmV0dXJuIGFzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgc3VwZXJQcm9wQmFzZSA9IHJlcXVpcmUoXCIuL3N1cGVyUHJvcEJhc2UuanNcIik7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKFwiLi9kZWZpbmVQcm9wZXJ0eS5qc1wiKTtcbmZ1bmN0aW9uIHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3Quc2V0KSB7XG4gICAgc2V0ID0gUmVmbGVjdC5zZXQ7XG4gIH0gZWxzZSB7XG4gICAgc2V0ID0gZnVuY3Rpb24gc2V0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlcikge1xuICAgICAgdmFyIGJhc2UgPSBzdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgdmFyIGRlc2M7XG4gICAgICBpZiAoYmFzZSkge1xuICAgICAgICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG4gICAgICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgICAgIGRlc2Muc2V0LmNhbGwocmVjZWl2ZXIsIHZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICghZGVzYy53cml0YWJsZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocmVjZWl2ZXIsIHByb3BlcnR5KTtcbiAgICAgIGlmIChkZXNjKSB7XG4gICAgICAgIGlmICghZGVzYy53cml0YWJsZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBkZXNjLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZWNlaXZlciwgcHJvcGVydHksIGRlc2MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBzZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyKTtcbn1cbmZ1bmN0aW9uIF9zZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyLCBpc1N0cmljdCkge1xuICB2YXIgcyA9IHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbiAgaWYgKCFzICYmIGlzU3RyaWN0KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZmFpbGVkIHRvIHNldCBwcm9wZXJ0eScpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3NldCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZiwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL2dldFByb3RvdHlwZU9mLmpzXCIpO1xuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgIG9iamVjdCA9IGdldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3N1cGVyUHJvcEJhc2UsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgYXJyYXlXaXRob3V0SG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhvdXRIb2xlcy5qc1wiKTtcbnZhciBpdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXkuanNcIik7XG52YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qc1wiKTtcbnZhciBub25JdGVyYWJsZVNwcmVhZCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlU3ByZWFkLmpzXCIpO1xuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF90b0NvbnN1bWFibGVBcnJheSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBfdHlwZW9mID0gcmVxdWlyZShcIi4vdHlwZW9mLmpzXCIpW1wiZGVmYXVsdFwiXTtcbmZ1bmN0aW9uIHRvUHJpbWl0aXZlKHQsIHIpIHtcbiAgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7XG4gIHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAodm9pZCAwICE9PSBlKSB7XG4gICAgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHRvUHJpbWl0aXZlLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiLi90eXBlb2YuanNcIilbXCJkZWZhdWx0XCJdO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZShcIi4vdG9QcmltaXRpdmUuanNcIik7XG5mdW5jdGlvbiB0b1Byb3BlcnR5S2V5KHQpIHtcbiAgdmFyIGkgPSB0b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBTdHJpbmcoaSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHRvUHJvcGVydHlLZXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJmdW5jdGlvbiBfdHlwZW9mKG8pIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIHJldHVybiAobW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIG87XG4gIH0gOiBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvO1xuICB9LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMpLCBfdHlwZW9mKG8pO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIGFycmF5TGlrZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9hcnJheUxpa2VUb0FycmF5LmpzXCIpO1xuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiXCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYnVpbGRRdWVyeVN0cmluZyhyLG4sYSl7dmFyIG89W107Zm9yKHZhciB0IGluIHIpIWZ1bmN0aW9uKHQpe3ZhciBlO09iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyLHQpJiZ2b2lkIDAhPT1yW3RdJiYoYSYmQXJyYXkuaXNBcnJheShyW3RdKSYmclt0XS5sZW5ndGg/clt0XS5mb3JFYWNoKGZ1bmN0aW9uKHIpe2U9MCE9PXI/cnx8XCJcIjowLG8ucHVzaChcIlwiLmNvbmNhdCh0LFwiPVwiKS5jb25jYXQoZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhlKS50cmltKCkpKSl9KTooZT1uP1N0cmluZyhyW3RdKS50b0xvd2VyQ2FzZSgpfHxcIlwiOjAhPT1yW3RdP3JbdF18fFwiXCI6MCxvLnB1c2goXCJcIi5jb25jYXQodCxcIj1cIikuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoZSkudHJpbSgpKSkpKSl9KHQpO3JldHVyblwiP1wiLmNvbmNhdChvLmpvaW4oXCImXCIpKX1mdW5jdGlvbiBhcHBlbmRQYXRoKHIsdCxlKXt2b2lkIDA9PT10JiYodD1cIlwiKSxcIi9cIj09PXRbdC5sZW5ndGgtMV0mJih0PXQuc2xpY2UoMCwtMSkpO3ZhciBuPVN0cmluZyhyKS50cmltKCk7cmV0dXJuIGUmJihuPW4udG9Mb3dlckNhc2UoKSksMD09PW4uaW5kZXhPZihcIi9cIik/dCs9bjp0Kz1cIi9cIi5jb25jYXQobiksdH1mdW5jdGlvbiBidWlsZEhhc2gocix0KXt2YXIgZT1cIiNcIi5jb25jYXQoU3RyaW5nKHIpLnRyaW0oKSk7cmV0dXJuIHQ/ZS50b0xvd2VyQ2FzZSgpOmV9ZnVuY3Rpb24gYnVpbGRVcmwocix0KXt2YXIgZTtyZXR1cm4gbnVsbD09PXI/ZT1cIlwiOlwib2JqZWN0XCI9PXR5cGVvZiByPyhlPVwiXCIsdD1yKTplPXIsbnVsbCE9dCYmdC5wYXRoJiYoZT1hcHBlbmRQYXRoKHQucGF0aCxlLHQubG93ZXJDYXNlKSksbnVsbCE9dCYmdC5xdWVyeVBhcmFtcyYmKGUrPWJ1aWxkUXVlcnlTdHJpbmcodC5xdWVyeVBhcmFtcyx0Lmxvd2VyQ2FzZSx0LmRpc2FibGVDU1YpKSxudWxsIT10JiZ0Lmhhc2gmJihlKz1idWlsZEhhc2godC5oYXNoLHQubG93ZXJDYXNlKSksZX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxleHBvcnRzLmFwcGVuZFBhdGg9YXBwZW5kUGF0aCxleHBvcnRzLmJ1aWxkSGFzaD1idWlsZEhhc2gsZXhwb3J0cy5idWlsZFF1ZXJ5U3RyaW5nPWJ1aWxkUXVlcnlTdHJpbmcsZXhwb3J0cy5idWlsZFVybD1idWlsZFVybCxleHBvcnRzLmRlZmF1bHQ9YnVpbGRVcmw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWlsZC11cmwuanMubWFwXG4iLCIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIik7XG5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiI2FhLWNoYWxsZW5nZS13aG9sZS1wYWdlLWlmcmFtZSB7XFxuICAgIG92ZXJmbG93OmhpZGRlbjtcXG4gICAgb3BhY2l0eToxLjA7XFxuICAgIHBvc2l0aW9uOmZpeGVkO1xcbiAgICB0b3A6MHB4O1xcbiAgICBib3R0b206MHB4O1xcbiAgICByaWdodDowcHg7XFxuICAgIGJvcmRlcjpub25lO1xcbiAgICBtYXJnaW46MDtcXG4gICAgcGFkZGluZzowO1xcbiAgICBoZWlnaHQ6MTAwJTtcXG4gICAgd2lkdGg6MTAwJTtcXG4gICAgei1pbmRleDo5OTk5OTk7XFxufVwiLCBcIlwiXSk7XG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodXNlU291cmNlTWFwKSB7XG4gIHZhciBsaXN0ID0gW107IC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblxuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgcmV0dXJuIFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpLmNvbmNhdChjb250ZW50LCBcIn1cIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmpvaW4oJycpO1xuICB9OyAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuXG5cbiAgbGlzdC5pID0gZnVuY3Rpb24gKG1vZHVsZXMsIG1lZGlhUXVlcnksIGRlZHVwZSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgJyddXTtcbiAgICB9XG5cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXG4gICAgaWYgKGRlZHVwZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgICB2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG1vZHVsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19pXSk7XG5cbiAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChtZWRpYVF1ZXJ5KSB7XG4gICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMl0gPSBcIlwiLmNvbmNhdChtZWRpYVF1ZXJ5LCBcIiBhbmQgXCIpLmNvbmNhdChpdGVtWzJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcbiAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcblxuICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cbiAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG4gICAgdmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VVUkw9XCIuY29uY2F0KGNzc01hcHBpbmcuc291cmNlUm9vdCB8fCAnJykuY29uY2F0KHNvdXJjZSwgXCIgKi9cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG4gIH1cblxuICByZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufSAvLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5cblxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG4gIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgcmV0dXJuIFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbn0iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLyoqXHJcbiAqIEEgY29sbGVjdGlvbiBvZiBzaGltcyB0aGF0IHByb3ZpZGUgbWluaW1hbCBmdW5jdGlvbmFsaXR5IG9mIHRoZSBFUzYgY29sbGVjdGlvbnMuXHJcbiAqXHJcbiAqIFRoZXNlIGltcGxlbWVudGF0aW9ucyBhcmUgbm90IG1lYW50IHRvIGJlIHVzZWQgb3V0c2lkZSBvZiB0aGUgUmVzaXplT2JzZXJ2ZXJcclxuICogbW9kdWxlcyBhcyB0aGV5IGNvdmVyIG9ubHkgYSBsaW1pdGVkIHJhbmdlIG9mIHVzZSBjYXNlcy5cclxuICovXHJcbi8qIGVzbGludC1kaXNhYmxlIHJlcXVpcmUtanNkb2MsIHZhbGlkLWpzZG9jICovXHJcbnZhciBNYXBTaGltID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0eXBlb2YgTWFwICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBNYXA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgaW5kZXggaW4gcHJvdmlkZWQgYXJyYXkgdGhhdCBtYXRjaGVzIHRoZSBzcGVjaWZpZWQga2V5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QXJyYXk8QXJyYXk+fSBhcnJcclxuICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRJbmRleChhcnIsIGtleSkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSAtMTtcclxuICAgICAgICBhcnIuc29tZShmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7XHJcbiAgICAgICAgICAgIGlmIChlbnRyeVswXSA9PT0ga2V5KSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpbmRleDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBjbGFzc18xKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9fZW50cmllc19fID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbGFzc18xLnByb3RvdHlwZSwgXCJzaXplXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fX2VudHJpZXNfXy5sZW5ndGg7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBnZXRJbmRleCh0aGlzLl9fZW50cmllc19fLCBrZXkpO1xyXG4gICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLl9fZW50cmllc19fW2luZGV4XTtcclxuICAgICAgICAgICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5WzFdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlXHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXgodGhpcy5fX2VudHJpZXNfXywga2V5KTtcclxuICAgICAgICAgICAgaWYgKH5pbmRleCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2VudHJpZXNfX1tpbmRleF1bMV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19lbnRyaWVzX18ucHVzaChba2V5LCB2YWx1ZV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgdmFyIGVudHJpZXMgPSB0aGlzLl9fZW50cmllc19fO1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBnZXRJbmRleChlbnRyaWVzLCBrZXkpO1xyXG4gICAgICAgICAgICBpZiAofmluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBlbnRyaWVzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gISF+Z2V0SW5kZXgodGhpcy5fX2VudHJpZXNfXywga2V5KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9fZW50cmllc19fLnNwbGljZSgwKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBbY3R4PW51bGxdXHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY3R4KSB7XHJcbiAgICAgICAgICAgIGlmIChjdHggPT09IHZvaWQgMCkgeyBjdHggPSBudWxsOyB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl9fZW50cmllc19fOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChjdHgsIGVudHJ5WzFdLCBlbnRyeVswXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBjbGFzc18xO1xyXG4gICAgfSgpKTtcclxufSkoKTtcblxuLyoqXHJcbiAqIERldGVjdHMgd2hldGhlciB3aW5kb3cgYW5kIGRvY3VtZW50IG9iamVjdHMgYXJlIGF2YWlsYWJsZSBpbiBjdXJyZW50IGVudmlyb25tZW50LlxyXG4gKi9cclxudmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ID09PSBkb2N1bWVudDtcblxuLy8gUmV0dXJucyBnbG9iYWwgb2JqZWN0IG9mIGEgY3VycmVudCBlbnZpcm9ubWVudC5cclxudmFyIGdsb2JhbCQxID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwuTWF0aCA9PT0gTWF0aCkge1xyXG4gICAgICAgIHJldHVybiBnbG9iYWw7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PT0gTWF0aCkge1xyXG4gICAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09PSBNYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcclxuICAgIH1cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xyXG4gICAgcmV0dXJuIEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XHJcbn0pKCk7XG5cbi8qKlxyXG4gKiBBIHNoaW0gZm9yIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgd2hpY2ggZmFsbHMgYmFjayB0byB0aGUgc2V0VGltZW91dCBpZlxyXG4gKiBmaXJzdCBvbmUgaXMgbm90IHN1cHBvcnRlZC5cclxuICpcclxuICogQHJldHVybnMge251bWJlcn0gUmVxdWVzdHMnIGlkZW50aWZpZXIuXHJcbiAqL1xyXG52YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lJDEgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAvLyBJdCdzIHJlcXVpcmVkIHRvIHVzZSBhIGJvdW5kZWQgZnVuY3Rpb24gYmVjYXVzZSBJRSBzb21ldGltZXMgdGhyb3dzXHJcbiAgICAgICAgLy8gYW4gXCJJbnZhbGlkIGNhbGxpbmcgb2JqZWN0XCIgZXJyb3IgaWYgckFGIGlzIGludm9rZWQgd2l0aG91dCB0aGUgZ2xvYmFsXHJcbiAgICAgICAgLy8gb2JqZWN0IG9uIHRoZSBsZWZ0IGhhbmQgc2lkZS5cclxuICAgICAgICByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQoZ2xvYmFsJDEpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjYWxsYmFjaykgeyByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsYmFjayhEYXRlLm5vdygpKTsgfSwgMTAwMCAvIDYwKTsgfTtcclxufSkoKTtcblxuLy8gRGVmaW5lcyBtaW5pbXVtIHRpbWVvdXQgYmVmb3JlIGFkZGluZyBhIHRyYWlsaW5nIGNhbGwuXHJcbnZhciB0cmFpbGluZ1RpbWVvdXQgPSAyO1xyXG4vKipcclxuICogQ3JlYXRlcyBhIHdyYXBwZXIgZnVuY3Rpb24gd2hpY2ggZW5zdXJlcyB0aGF0IHByb3ZpZGVkIGNhbGxiYWNrIHdpbGwgYmVcclxuICogaW52b2tlZCBvbmx5IG9uY2UgZHVyaW5nIHRoZSBzcGVjaWZpZWQgZGVsYXkgcGVyaW9kLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGJlIGludm9rZWQgYWZ0ZXIgdGhlIGRlbGF5IHBlcmlvZC5cclxuICogQHBhcmFtIHtudW1iZXJ9IGRlbGF5IC0gRGVsYXkgYWZ0ZXIgd2hpY2ggdG8gaW52b2tlIGNhbGxiYWNrLlxyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XHJcbiAqL1xyXG5mdW5jdGlvbiB0aHJvdHRsZSAoY2FsbGJhY2ssIGRlbGF5KSB7XHJcbiAgICB2YXIgbGVhZGluZ0NhbGwgPSBmYWxzZSwgdHJhaWxpbmdDYWxsID0gZmFsc2UsIGxhc3RDYWxsVGltZSA9IDA7XHJcbiAgICAvKipcclxuICAgICAqIEludm9rZXMgdGhlIG9yaWdpbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIGFuZCBzY2hlZHVsZXMgbmV3IGludm9jYXRpb24gaWZcclxuICAgICAqIHRoZSBcInByb3h5XCIgd2FzIGNhbGxlZCBkdXJpbmcgY3VycmVudCByZXF1ZXN0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiByZXNvbHZlUGVuZGluZygpIHtcclxuICAgICAgICBpZiAobGVhZGluZ0NhbGwpIHtcclxuICAgICAgICAgICAgbGVhZGluZ0NhbGwgPSBmYWxzZTtcclxuICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRyYWlsaW5nQ2FsbCkge1xyXG4gICAgICAgICAgICBwcm94eSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGJhY2sgaW52b2tlZCBhZnRlciB0aGUgc3BlY2lmaWVkIGRlbGF5LiBJdCB3aWxsIGZ1cnRoZXIgcG9zdHBvbmVcclxuICAgICAqIGludm9jYXRpb24gb2YgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIGRlbGVnYXRpbmcgaXQgdG8gdGhlXHJcbiAgICAgKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRpbWVvdXRDYWxsYmFjaygpIHtcclxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUkMShyZXNvbHZlUGVuZGluZyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNjaGVkdWxlcyBpbnZvY2F0aW9uIG9mIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcHJveHkoKSB7XHJcbiAgICAgICAgdmFyIHRpbWVTdGFtcCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgaWYgKGxlYWRpbmdDYWxsKSB7XHJcbiAgICAgICAgICAgIC8vIFJlamVjdCBpbW1lZGlhdGVseSBmb2xsb3dpbmcgY2FsbHMuXHJcbiAgICAgICAgICAgIGlmICh0aW1lU3RhbXAgLSBsYXN0Q2FsbFRpbWUgPCB0cmFpbGluZ1RpbWVvdXQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBTY2hlZHVsZSBuZXcgY2FsbCB0byBiZSBpbiBpbnZva2VkIHdoZW4gdGhlIHBlbmRpbmcgb25lIGlzIHJlc29sdmVkLlxyXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGltcG9ydGFudCBmb3IgXCJ0cmFuc2l0aW9uc1wiIHdoaWNoIG5ldmVyIGFjdHVhbGx5IHN0YXJ0XHJcbiAgICAgICAgICAgIC8vIGltbWVkaWF0ZWx5IHNvIHRoZXJlIGlzIGEgY2hhbmNlIHRoYXQgd2UgbWlnaHQgbWlzcyBvbmUgaWYgY2hhbmdlXHJcbiAgICAgICAgICAgIC8vIGhhcHBlbnMgYW1pZHMgdGhlIHBlbmRpbmcgaW52b2NhdGlvbi5cclxuICAgICAgICAgICAgdHJhaWxpbmdDYWxsID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxlYWRpbmdDYWxsID0gdHJ1ZTtcclxuICAgICAgICAgICAgdHJhaWxpbmdDYWxsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGltZW91dENhbGxiYWNrLCBkZWxheSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxhc3RDYWxsVGltZSA9IHRpbWVTdGFtcDtcclxuICAgIH1cclxuICAgIHJldHVybiBwcm94eTtcclxufVxuXG4vLyBNaW5pbXVtIGRlbGF5IGJlZm9yZSBpbnZva2luZyB0aGUgdXBkYXRlIG9mIG9ic2VydmVycy5cclxudmFyIFJFRlJFU0hfREVMQVkgPSAyMDtcclxuLy8gQSBsaXN0IG9mIHN1YnN0cmluZ3Mgb2YgQ1NTIHByb3BlcnRpZXMgdXNlZCB0byBmaW5kIHRyYW5zaXRpb24gZXZlbnRzIHRoYXRcclxuLy8gbWlnaHQgYWZmZWN0IGRpbWVuc2lvbnMgb2Ygb2JzZXJ2ZWQgZWxlbWVudHMuXHJcbnZhciB0cmFuc2l0aW9uS2V5cyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0JywgJ3dpZHRoJywgJ2hlaWdodCcsICdzaXplJywgJ3dlaWdodCddO1xyXG4vLyBDaGVjayBpZiBNdXRhdGlvbk9ic2VydmVyIGlzIGF2YWlsYWJsZS5cclxudmFyIG11dGF0aW9uT2JzZXJ2ZXJTdXBwb3J0ZWQgPSB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCc7XHJcbi8qKlxyXG4gKiBTaW5nbGV0b24gY29udHJvbGxlciBjbGFzcyB3aGljaCBoYW5kbGVzIHVwZGF0ZXMgb2YgUmVzaXplT2JzZXJ2ZXIgaW5zdGFuY2VzLlxyXG4gKi9cclxudmFyIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIERPTSBsaXN0ZW5lcnMgaGF2ZSBiZWVuIGFkZGVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRfID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVsbHMgdGhhdCBjb250cm9sbGVyIGhhcyBzdWJzY3JpYmVkIGZvciBNdXRhdGlvbiBFdmVudHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogS2VlcHMgcmVmZXJlbmNlIHRvIHRoZSBpbnN0YW5jZSBvZiBNdXRhdGlvbk9ic2VydmVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge011dGF0aW9uT2JzZXJ2ZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8gPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgbGlzdCBvZiBjb25uZWN0ZWQgb2JzZXJ2ZXJzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge0FycmF5PFJlc2l6ZU9ic2VydmVyU1BJPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9ic2VydmVyc18gPSBbXTtcclxuICAgICAgICB0aGlzLm9uVHJhbnNpdGlvbkVuZF8gPSB0aGlzLm9uVHJhbnNpdGlvbkVuZF8uYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLnJlZnJlc2ggPSB0aHJvdHRsZSh0aGlzLnJlZnJlc2guYmluZCh0aGlzKSwgUkVGUkVTSF9ERUxBWSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgb2JzZXJ2ZXIgdG8gb2JzZXJ2ZXJzIGxpc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlclNQSX0gb2JzZXJ2ZXIgLSBPYnNlcnZlciB0byBiZSBhZGRlZC5cclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLmFkZE9ic2VydmVyID0gZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgICAgaWYgKCF+dGhpcy5vYnNlcnZlcnNfLmluZGV4T2Yob2JzZXJ2ZXIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzXy5wdXNoKG9ic2VydmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQWRkIGxpc3RlbmVycyBpZiB0aGV5IGhhdmVuJ3QgYmVlbiBhZGRlZCB5ZXQuXHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0XygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgb2JzZXJ2ZXIgZnJvbSBvYnNlcnZlcnMgbGlzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyU1BJfSBvYnNlcnZlciAtIE9ic2VydmVyIHRvIGJlIHJlbW92ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5yZW1vdmVPYnNlcnZlciA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgIHZhciBvYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVyc187XHJcbiAgICAgICAgdmFyIGluZGV4ID0gb2JzZXJ2ZXJzLmluZGV4T2Yob2JzZXJ2ZXIpO1xyXG4gICAgICAgIC8vIFJlbW92ZSBvYnNlcnZlciBpZiBpdCdzIHByZXNlbnQgaW4gcmVnaXN0cnkuXHJcbiAgICAgICAgaWYgKH5pbmRleCkge1xyXG4gICAgICAgICAgICBvYnNlcnZlcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmVtb3ZlIGxpc3RlbmVycyBpZiBjb250cm9sbGVyIGhhcyBubyBjb25uZWN0ZWQgb2JzZXJ2ZXJzLlxyXG4gICAgICAgIGlmICghb2JzZXJ2ZXJzLmxlbmd0aCAmJiB0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0XygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEludm9rZXMgdGhlIHVwZGF0ZSBvZiBvYnNlcnZlcnMuIEl0IHdpbGwgY29udGludWUgcnVubmluZyB1cGRhdGVzIGluc29mYXJcclxuICAgICAqIGl0IGRldGVjdHMgY2hhbmdlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjaGFuZ2VzRGV0ZWN0ZWQgPSB0aGlzLnVwZGF0ZU9ic2VydmVyc18oKTtcclxuICAgICAgICAvLyBDb250aW51ZSBydW5uaW5nIHVwZGF0ZXMgaWYgY2hhbmdlcyBoYXZlIGJlZW4gZGV0ZWN0ZWQgYXMgdGhlcmUgbWlnaHRcclxuICAgICAgICAvLyBiZSBmdXR1cmUgb25lcyBjYXVzZWQgYnkgQ1NTIHRyYW5zaXRpb25zLlxyXG4gICAgICAgIGlmIChjaGFuZ2VzRGV0ZWN0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBldmVyeSBvYnNlcnZlciBmcm9tIG9ic2VydmVycyBsaXN0IGFuZCBub3RpZmllcyB0aGVtIG9mIHF1ZXVlZFxyXG4gICAgICogZW50cmllcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgXCJ0cnVlXCIgaWYgYW55IG9ic2VydmVyIGhhcyBkZXRlY3RlZCBjaGFuZ2VzIGluXHJcbiAgICAgKiAgICAgIGRpbWVuc2lvbnMgb2YgaXQncyBlbGVtZW50cy5cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS51cGRhdGVPYnNlcnZlcnNfID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIENvbGxlY3Qgb2JzZXJ2ZXJzIHRoYXQgaGF2ZSBhY3RpdmUgb2JzZXJ2YXRpb25zLlxyXG4gICAgICAgIHZhciBhY3RpdmVPYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVyc18uZmlsdGVyKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIuZ2F0aGVyQWN0aXZlKCksIG9ic2VydmVyLmhhc0FjdGl2ZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIERlbGl2ZXIgbm90aWZpY2F0aW9ucyBpbiBhIHNlcGFyYXRlIGN5Y2xlIGluIG9yZGVyIHRvIGF2b2lkIGFueVxyXG4gICAgICAgIC8vIGNvbGxpc2lvbnMgYmV0d2VlbiBvYnNlcnZlcnMsIGUuZy4gd2hlbiBtdWx0aXBsZSBpbnN0YW5jZXMgb2ZcclxuICAgICAgICAvLyBSZXNpemVPYnNlcnZlciBhcmUgdHJhY2tpbmcgdGhlIHNhbWUgZWxlbWVudCBhbmQgdGhlIGNhbGxiYWNrIG9mIG9uZVxyXG4gICAgICAgIC8vIG9mIHRoZW0gY2hhbmdlcyBjb250ZW50IGRpbWVuc2lvbnMgb2YgdGhlIG9ic2VydmVkIHRhcmdldC4gU29tZXRpbWVzXHJcbiAgICAgICAgLy8gdGhpcyBtYXkgcmVzdWx0IGluIG5vdGlmaWNhdGlvbnMgYmVpbmcgYmxvY2tlZCBmb3IgdGhlIHJlc3Qgb2Ygb2JzZXJ2ZXJzLlxyXG4gICAgICAgIGFjdGl2ZU9ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZlcikgeyByZXR1cm4gb2JzZXJ2ZXIuYnJvYWRjYXN0QWN0aXZlKCk7IH0pO1xyXG4gICAgICAgIHJldHVybiBhY3RpdmVPYnNlcnZlcnMubGVuZ3RoID4gMDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemVzIERPTSBsaXN0ZW5lcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLmNvbm5lY3RfID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgcnVubmluZyBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50IG9yIGlmIGxpc3RlbmVyc1xyXG4gICAgICAgIC8vIGhhdmUgYmVlbiBhbHJlYWR5IGFkZGVkLlxyXG4gICAgICAgIGlmICghaXNCcm93c2VyIHx8IHRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFN1YnNjcmlwdGlvbiB0byB0aGUgXCJUcmFuc2l0aW9uZW5kXCIgZXZlbnQgaXMgdXNlZCBhcyBhIHdvcmthcm91bmQgZm9yXHJcbiAgICAgICAgLy8gZGVsYXllZCB0cmFuc2l0aW9ucy4gVGhpcyB3YXkgaXQncyBwb3NzaWJsZSB0byBjYXB0dXJlIGF0IGxlYXN0IHRoZVxyXG4gICAgICAgIC8vIGZpbmFsIHN0YXRlIG9mIGFuIGVsZW1lbnQuXHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMub25UcmFuc2l0aW9uRW5kXyk7XHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVmcmVzaCk7XHJcbiAgICAgICAgaWYgKG11dGF0aW9uT2JzZXJ2ZXJTdXBwb3J0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8gPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXy5vYnNlcnZlKGRvY3VtZW50LCB7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHN1YnRyZWU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01TdWJ0cmVlTW9kaWZpZWQnLCB0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRfID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgRE9NIGxpc3RlbmVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUuZGlzY29ubmVjdF8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBydW5uaW5nIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQgb3IgaWYgbGlzdGVuZXJzXHJcbiAgICAgICAgLy8gaGF2ZSBiZWVuIGFscmVhZHkgcmVtb3ZlZC5cclxuICAgICAgICBpZiAoIWlzQnJvd3NlciB8fCAhdGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMub25UcmFuc2l0aW9uRW5kXyk7XHJcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVmcmVzaCk7XHJcbiAgICAgICAgaWYgKHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfKSB7XHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8pIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NU3VidHJlZU1vZGlmaWVkJywgdGhpcy5yZWZyZXNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNvbm5lY3RlZF8gPSBmYWxzZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFwiVHJhbnNpdGlvbmVuZFwiIGV2ZW50IGhhbmRsZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7VHJhbnNpdGlvbkV2ZW50fSBldmVudFxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUub25UcmFuc2l0aW9uRW5kXyA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBfYiA9IF9hLnByb3BlcnR5TmFtZSwgcHJvcGVydHlOYW1lID0gX2IgPT09IHZvaWQgMCA/ICcnIDogX2I7XHJcbiAgICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgdHJhbnNpdGlvbiBtYXkgYWZmZWN0IGRpbWVuc2lvbnMgb2YgYW4gZWxlbWVudC5cclxuICAgICAgICB2YXIgaXNSZWZsb3dQcm9wZXJ0eSA9IHRyYW5zaXRpb25LZXlzLnNvbWUoZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gISF+cHJvcGVydHlOYW1lLmluZGV4T2Yoa2V5KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoaXNSZWZsb3dQcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGluc3RhbmNlIG9mIHRoZSBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge1Jlc2l6ZU9ic2VydmVyQ29udHJvbGxlcn1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmdldEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pbnN0YW5jZV8pIHtcclxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZV8gPSBuZXcgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlXztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEhvbGRzIHJlZmVyZW5jZSB0byB0aGUgY29udHJvbGxlcidzIGluc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlIHtSZXNpemVPYnNlcnZlckNvbnRyb2xsZXJ9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5pbnN0YW5jZV8gPSBudWxsO1xyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcjtcclxufSgpKTtcblxuLyoqXHJcbiAqIERlZmluZXMgbm9uLXdyaXRhYmxlL2VudW1lcmFibGUgcHJvcGVydGllcyBvZiB0aGUgcHJvdmlkZWQgdGFyZ2V0IG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCAtIE9iamVjdCBmb3Igd2hpY2ggdG8gZGVmaW5lIHByb3BlcnRpZXMuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIFByb3BlcnRpZXMgdG8gYmUgZGVmaW5lZC5cclxuICogQHJldHVybnMge09iamVjdH0gVGFyZ2V0IG9iamVjdC5cclxuICovXHJcbnZhciBkZWZpbmVDb25maWd1cmFibGUgPSAoZnVuY3Rpb24gKHRhcmdldCwgcHJvcHMpIHtcclxuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyhwcm9wcyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IF9hW19pXTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHtcclxuICAgICAgICAgICAgdmFsdWU6IHByb3BzW2tleV0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufSk7XG5cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBnbG9iYWwgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCBwcm92aWRlZCBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XHJcbiAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAqL1xyXG52YXIgZ2V0V2luZG93T2YgPSAoZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgLy8gQXNzdW1lIHRoYXQgdGhlIGVsZW1lbnQgaXMgYW4gaW5zdGFuY2Ugb2YgTm9kZSwgd2hpY2ggbWVhbnMgdGhhdCBpdFxyXG4gICAgLy8gaGFzIHRoZSBcIm93bmVyRG9jdW1lbnRcIiBwcm9wZXJ0eSBmcm9tIHdoaWNoIHdlIGNhbiByZXRyaWV2ZSBhXHJcbiAgICAvLyBjb3JyZXNwb25kaW5nIGdsb2JhbCBvYmplY3QuXHJcbiAgICB2YXIgb3duZXJHbG9iYWwgPSB0YXJnZXQgJiYgdGFyZ2V0Lm93bmVyRG9jdW1lbnQgJiYgdGFyZ2V0Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XHJcbiAgICAvLyBSZXR1cm4gdGhlIGxvY2FsIGdsb2JhbCBvYmplY3QgaWYgaXQncyBub3QgcG9zc2libGUgZXh0cmFjdCBvbmUgZnJvbVxyXG4gICAgLy8gcHJvdmlkZWQgZWxlbWVudC5cclxuICAgIHJldHVybiBvd25lckdsb2JhbCB8fCBnbG9iYWwkMTtcclxufSk7XG5cbi8vIFBsYWNlaG9sZGVyIG9mIGFuIGVtcHR5IGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG52YXIgZW1wdHlSZWN0ID0gY3JlYXRlUmVjdEluaXQoMCwgMCwgMCwgMCk7XHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBwcm92aWRlZCBzdHJpbmcgdG8gYSBudW1iZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gdmFsdWVcclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbmZ1bmN0aW9uIHRvRmxvYXQodmFsdWUpIHtcclxuICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKSB8fCAwO1xyXG59XHJcbi8qKlxyXG4gKiBFeHRyYWN0cyBib3JkZXJzIHNpemUgZnJvbSBwcm92aWRlZCBzdHlsZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Q1NTU3R5bGVEZWNsYXJhdGlvbn0gc3R5bGVzXHJcbiAqIEBwYXJhbSB7Li4uc3RyaW5nfSBwb3NpdGlvbnMgLSBCb3JkZXJzIHBvc2l0aW9ucyAodG9wLCByaWdodCwgLi4uKVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzKSB7XHJcbiAgICB2YXIgcG9zaXRpb25zID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHBvc2l0aW9uc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHJldHVybiBwb3NpdGlvbnMucmVkdWNlKGZ1bmN0aW9uIChzaXplLCBwb3NpdGlvbikge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHN0eWxlc1snYm9yZGVyLScgKyBwb3NpdGlvbiArICctd2lkdGgnXTtcclxuICAgICAgICByZXR1cm4gc2l6ZSArIHRvRmxvYXQodmFsdWUpO1xyXG4gICAgfSwgMCk7XHJcbn1cclxuLyoqXHJcbiAqIEV4dHJhY3RzIHBhZGRpbmdzIHNpemVzIGZyb20gcHJvdmlkZWQgc3R5bGVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0NTU1N0eWxlRGVjbGFyYXRpb259IHN0eWxlc1xyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBQYWRkaW5ncyBib3guXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRQYWRkaW5ncyhzdHlsZXMpIHtcclxuICAgIHZhciBwb3NpdGlvbnMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xyXG4gICAgdmFyIHBhZGRpbmdzID0ge307XHJcbiAgICBmb3IgKHZhciBfaSA9IDAsIHBvc2l0aW9uc18xID0gcG9zaXRpb25zOyBfaSA8IHBvc2l0aW9uc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHBvc2l0aW9uc18xW19pXTtcclxuICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZXNbJ3BhZGRpbmctJyArIHBvc2l0aW9uXTtcclxuICAgICAgICBwYWRkaW5nc1twb3NpdGlvbl0gPSB0b0Zsb2F0KHZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwYWRkaW5ncztcclxufVxyXG4vKipcclxuICogQ2FsY3VsYXRlcyBjb250ZW50IHJlY3RhbmdsZSBvZiBwcm92aWRlZCBTVkcgZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtTVkdHcmFwaGljc0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgY29udGVudCByZWN0YW5nbGUgb2Ygd2hpY2ggbmVlZHNcclxuICogICAgICB0byBiZSBjYWxjdWxhdGVkLlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRTVkdDb250ZW50UmVjdCh0YXJnZXQpIHtcclxuICAgIHZhciBiYm94ID0gdGFyZ2V0LmdldEJCb3goKTtcclxuICAgIHJldHVybiBjcmVhdGVSZWN0SW5pdCgwLCAwLCBiYm94LndpZHRoLCBiYm94LmhlaWdodCk7XHJcbn1cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgY29udGVudCByZWN0YW5nbGUgb2YgcHJvdmlkZWQgSFRNTEVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgZm9yIHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgY29udGVudCByZWN0YW5nbGUuXHJcbiAqIEByZXR1cm5zIHtET01SZWN0SW5pdH1cclxuICovXHJcbmZ1bmN0aW9uIGdldEhUTUxFbGVtZW50Q29udGVudFJlY3QodGFyZ2V0KSB7XHJcbiAgICAvLyBDbGllbnQgd2lkdGggJiBoZWlnaHQgcHJvcGVydGllcyBjYW4ndCBiZVxyXG4gICAgLy8gdXNlZCBleGNsdXNpdmVseSBhcyB0aGV5IHByb3ZpZGUgcm91bmRlZCB2YWx1ZXMuXHJcbiAgICB2YXIgY2xpZW50V2lkdGggPSB0YXJnZXQuY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodCA9IHRhcmdldC5jbGllbnRIZWlnaHQ7XHJcbiAgICAvLyBCeSB0aGlzIGNvbmRpdGlvbiB3ZSBjYW4gY2F0Y2ggYWxsIG5vbi1yZXBsYWNlZCBpbmxpbmUsIGhpZGRlbiBhbmRcclxuICAgIC8vIGRldGFjaGVkIGVsZW1lbnRzLiBUaG91Z2ggZWxlbWVudHMgd2l0aCB3aWR0aCAmIGhlaWdodCBwcm9wZXJ0aWVzIGxlc3NcclxuICAgIC8vIHRoYW4gMC41IHdpbGwgYmUgZGlzY2FyZGVkIGFzIHdlbGwuXHJcbiAgICAvL1xyXG4gICAgLy8gV2l0aG91dCBpdCB3ZSB3b3VsZCBuZWVkIHRvIGltcGxlbWVudCBzZXBhcmF0ZSBtZXRob2RzIGZvciBlYWNoIG9mXHJcbiAgICAvLyB0aG9zZSBjYXNlcyBhbmQgaXQncyBub3QgcG9zc2libGUgdG8gcGVyZm9ybSBhIHByZWNpc2UgYW5kIHBlcmZvcm1hbmNlXHJcbiAgICAvLyBlZmZlY3RpdmUgdGVzdCBmb3IgaGlkZGVuIGVsZW1lbnRzLiBFLmcuIGV2ZW4galF1ZXJ5J3MgJzp2aXNpYmxlJyBmaWx0ZXJcclxuICAgIC8vIGdpdmVzIHdyb25nIHJlc3VsdHMgZm9yIGVsZW1lbnRzIHdpdGggd2lkdGggJiBoZWlnaHQgbGVzcyB0aGFuIDAuNS5cclxuICAgIGlmICghY2xpZW50V2lkdGggJiYgIWNsaWVudEhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiBlbXB0eVJlY3Q7XHJcbiAgICB9XHJcbiAgICB2YXIgc3R5bGVzID0gZ2V0V2luZG93T2YodGFyZ2V0KS5nZXRDb21wdXRlZFN0eWxlKHRhcmdldCk7XHJcbiAgICB2YXIgcGFkZGluZ3MgPSBnZXRQYWRkaW5ncyhzdHlsZXMpO1xyXG4gICAgdmFyIGhvcml6UGFkID0gcGFkZGluZ3MubGVmdCArIHBhZGRpbmdzLnJpZ2h0O1xyXG4gICAgdmFyIHZlcnRQYWQgPSBwYWRkaW5ncy50b3AgKyBwYWRkaW5ncy5ib3R0b207XHJcbiAgICAvLyBDb21wdXRlZCBzdHlsZXMgb2Ygd2lkdGggJiBoZWlnaHQgYXJlIGJlaW5nIHVzZWQgYmVjYXVzZSB0aGV5IGFyZSB0aGVcclxuICAgIC8vIG9ubHkgZGltZW5zaW9ucyBhdmFpbGFibGUgdG8gSlMgdGhhdCBjb250YWluIG5vbi1yb3VuZGVkIHZhbHVlcy4gSXQgY291bGRcclxuICAgIC8vIGJlIHBvc3NpYmxlIHRvIHV0aWxpemUgdGhlIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpZiBvbmx5IGl0J3MgZGF0YSB3YXNuJ3RcclxuICAgIC8vIGFmZmVjdGVkIGJ5IENTUyB0cmFuc2Zvcm1hdGlvbnMgbGV0IGFsb25lIHBhZGRpbmdzLCBib3JkZXJzIGFuZCBzY3JvbGwgYmFycy5cclxuICAgIHZhciB3aWR0aCA9IHRvRmxvYXQoc3R5bGVzLndpZHRoKSwgaGVpZ2h0ID0gdG9GbG9hdChzdHlsZXMuaGVpZ2h0KTtcclxuICAgIC8vIFdpZHRoICYgaGVpZ2h0IGluY2x1ZGUgcGFkZGluZ3MgYW5kIGJvcmRlcnMgd2hlbiB0aGUgJ2JvcmRlci1ib3gnIGJveFxyXG4gICAgLy8gbW9kZWwgaXMgYXBwbGllZCAoZXhjZXB0IGZvciBJRSkuXHJcbiAgICBpZiAoc3R5bGVzLmJveFNpemluZyA9PT0gJ2JvcmRlci1ib3gnKSB7XHJcbiAgICAgICAgLy8gRm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIHJlcXVpcmVkIHRvIGhhbmRsZSBJbnRlcm5ldCBFeHBsb3JlciB3aGljaFxyXG4gICAgICAgIC8vIGRvZXNuJ3QgaW5jbHVkZSBwYWRkaW5ncyBhbmQgYm9yZGVycyB0byBjb21wdXRlZCBDU1MgZGltZW5zaW9ucy5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFdlIGNhbiBzYXkgdGhhdCBpZiBDU1MgZGltZW5zaW9ucyArIHBhZGRpbmdzIGFyZSBlcXVhbCB0byB0aGUgXCJjbGllbnRcIlxyXG4gICAgICAgIC8vIHByb3BlcnRpZXMgdGhlbiBpdCdzIGVpdGhlciBJRSwgYW5kIHRodXMgd2UgZG9uJ3QgbmVlZCB0byBzdWJ0cmFjdFxyXG4gICAgICAgIC8vIGFueXRoaW5nLCBvciBhbiBlbGVtZW50IG1lcmVseSBkb2Vzbid0IGhhdmUgcGFkZGluZ3MvYm9yZGVycyBzdHlsZXMuXHJcbiAgICAgICAgaWYgKE1hdGgucm91bmQod2lkdGggKyBob3JpelBhZCkgIT09IGNsaWVudFdpZHRoKSB7XHJcbiAgICAgICAgICAgIHdpZHRoIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ2xlZnQnLCAncmlnaHQnKSArIGhvcml6UGFkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoTWF0aC5yb3VuZChoZWlnaHQgKyB2ZXJ0UGFkKSAhPT0gY2xpZW50SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIGhlaWdodCAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd0b3AnLCAnYm90dG9tJykgKyB2ZXJ0UGFkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIEZvbGxvd2luZyBzdGVwcyBjYW4ndCBiZSBhcHBsaWVkIHRvIHRoZSBkb2N1bWVudCdzIHJvb3QgZWxlbWVudCBhcyBpdHNcclxuICAgIC8vIGNsaWVudFtXaWR0aC9IZWlnaHRdIHByb3BlcnRpZXMgcmVwcmVzZW50IHZpZXdwb3J0IGFyZWEgb2YgdGhlIHdpbmRvdy5cclxuICAgIC8vIEJlc2lkZXMsIGl0J3MgYXMgd2VsbCBub3QgbmVjZXNzYXJ5IGFzIHRoZSA8aHRtbD4gaXRzZWxmIG5laXRoZXIgaGFzXHJcbiAgICAvLyByZW5kZXJlZCBzY3JvbGwgYmFycyBub3IgaXQgY2FuIGJlIGNsaXBwZWQuXHJcbiAgICBpZiAoIWlzRG9jdW1lbnRFbGVtZW50KHRhcmdldCkpIHtcclxuICAgICAgICAvLyBJbiBzb21lIGJyb3dzZXJzIChvbmx5IGluIEZpcmVmb3gsIGFjdHVhbGx5KSBDU1Mgd2lkdGggJiBoZWlnaHRcclxuICAgICAgICAvLyBpbmNsdWRlIHNjcm9sbCBiYXJzIHNpemUgd2hpY2ggY2FuIGJlIHJlbW92ZWQgYXQgdGhpcyBzdGVwIGFzIHNjcm9sbFxyXG4gICAgICAgIC8vIGJhcnMgYXJlIHRoZSBvbmx5IGRpZmZlcmVuY2UgYmV0d2VlbiByb3VuZGVkIGRpbWVuc2lvbnMgKyBwYWRkaW5nc1xyXG4gICAgICAgIC8vIGFuZCBcImNsaWVudFwiIHByb3BlcnRpZXMsIHRob3VnaCB0aGF0IGlzIG5vdCBhbHdheXMgdHJ1ZSBpbiBDaHJvbWUuXHJcbiAgICAgICAgdmFyIHZlcnRTY3JvbGxiYXIgPSBNYXRoLnJvdW5kKHdpZHRoICsgaG9yaXpQYWQpIC0gY2xpZW50V2lkdGg7XHJcbiAgICAgICAgdmFyIGhvcml6U2Nyb2xsYmFyID0gTWF0aC5yb3VuZChoZWlnaHQgKyB2ZXJ0UGFkKSAtIGNsaWVudEhlaWdodDtcclxuICAgICAgICAvLyBDaHJvbWUgaGFzIGEgcmF0aGVyIHdlaXJkIHJvdW5kaW5nIG9mIFwiY2xpZW50XCIgcHJvcGVydGllcy5cclxuICAgICAgICAvLyBFLmcuIGZvciBhbiBlbGVtZW50IHdpdGggY29udGVudCB3aWR0aCBvZiAzMTQuMnB4IGl0IHNvbWV0aW1lcyBnaXZlc1xyXG4gICAgICAgIC8vIHRoZSBjbGllbnQgd2lkdGggb2YgMzE1cHggYW5kIGZvciB0aGUgd2lkdGggb2YgMzE0LjdweCBpdCBtYXkgZ2l2ZVxyXG4gICAgICAgIC8vIDMxNHB4LiBBbmQgaXQgZG9lc24ndCBoYXBwZW4gYWxsIHRoZSB0aW1lLiBTbyBqdXN0IGlnbm9yZSB0aGlzIGRlbHRhXHJcbiAgICAgICAgLy8gYXMgYSBub24tcmVsZXZhbnQuXHJcbiAgICAgICAgaWYgKE1hdGguYWJzKHZlcnRTY3JvbGxiYXIpICE9PSAxKSB7XHJcbiAgICAgICAgICAgIHdpZHRoIC09IHZlcnRTY3JvbGxiYXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChNYXRoLmFicyhob3JpelNjcm9sbGJhcikgIT09IDEpIHtcclxuICAgICAgICAgICAgaGVpZ2h0IC09IGhvcml6U2Nyb2xsYmFyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjcmVhdGVSZWN0SW5pdChwYWRkaW5ncy5sZWZ0LCBwYWRkaW5ncy50b3AsIHdpZHRoLCBoZWlnaHQpO1xyXG59XHJcbi8qKlxyXG4gKiBDaGVja3Mgd2hldGhlciBwcm92aWRlZCBlbGVtZW50IGlzIGFuIGluc3RhbmNlIG9mIHRoZSBTVkdHcmFwaGljc0VsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBiZSBjaGVja2VkLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbnZhciBpc1NWR0dyYXBoaWNzRWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBTb21lIGJyb3dzZXJzLCBuYW1lbHkgSUUgYW5kIEVkZ2UsIGRvbid0IGhhdmUgdGhlIFNWR0dyYXBoaWNzRWxlbWVudFxyXG4gICAgLy8gaW50ZXJmYWNlLlxyXG4gICAgaWYgKHR5cGVvZiBTVkdHcmFwaGljc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQpIHsgcmV0dXJuIHRhcmdldCBpbnN0YW5jZW9mIGdldFdpbmRvd09mKHRhcmdldCkuU1ZHR3JhcGhpY3NFbGVtZW50OyB9O1xyXG4gICAgfVxyXG4gICAgLy8gSWYgaXQncyBzbywgdGhlbiBjaGVjayB0aGF0IGVsZW1lbnQgaXMgYXQgbGVhc3QgYW4gaW5zdGFuY2Ugb2YgdGhlXHJcbiAgICAvLyBTVkdFbGVtZW50IGFuZCB0aGF0IGl0IGhhcyB0aGUgXCJnZXRCQm94XCIgbWV0aG9kLlxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dHJhLXBhcmVuc1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQpIHsgcmV0dXJuICh0YXJnZXQgaW5zdGFuY2VvZiBnZXRXaW5kb3dPZih0YXJnZXQpLlNWR0VsZW1lbnQgJiZcclxuICAgICAgICB0eXBlb2YgdGFyZ2V0LmdldEJCb3ggPT09ICdmdW5jdGlvbicpOyB9O1xyXG59KSgpO1xyXG4vKipcclxuICogQ2hlY2tzIHdoZXRoZXIgcHJvdmlkZWQgZWxlbWVudCBpcyBhIGRvY3VtZW50IGVsZW1lbnQgKDxodG1sPikuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBiZSBjaGVja2VkLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbmZ1bmN0aW9uIGlzRG9jdW1lbnRFbGVtZW50KHRhcmdldCkge1xyXG4gICAgcmV0dXJuIHRhcmdldCA9PT0gZ2V0V2luZG93T2YodGFyZ2V0KS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcbn1cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgYW4gYXBwcm9wcmlhdGUgY29udGVudCByZWN0YW5nbGUgZm9yIHByb3ZpZGVkIGh0bWwgb3Igc3ZnIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCBjb250ZW50IHJlY3RhbmdsZSBvZiB3aGljaCBuZWVkcyB0byBiZSBjYWxjdWxhdGVkLlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRDb250ZW50UmVjdCh0YXJnZXQpIHtcclxuICAgIGlmICghaXNCcm93c2VyKSB7XHJcbiAgICAgICAgcmV0dXJuIGVtcHR5UmVjdDtcclxuICAgIH1cclxuICAgIGlmIChpc1NWR0dyYXBoaWNzRWxlbWVudCh0YXJnZXQpKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldFNWR0NvbnRlbnRSZWN0KHRhcmdldCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ2V0SFRNTEVsZW1lbnRDb250ZW50UmVjdCh0YXJnZXQpO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIHJlY3RhbmdsZSB3aXRoIGFuIGludGVyZmFjZSBvZiB0aGUgRE9NUmVjdFJlYWRPbmx5LlxyXG4gKiBTcGVjOiBodHRwczovL2RyYWZ0cy5meHRmLm9yZy9nZW9tZXRyeS8jZG9tcmVjdHJlYWRvbmx5XHJcbiAqXHJcbiAqIEBwYXJhbSB7RE9NUmVjdEluaXR9IHJlY3RJbml0IC0gT2JqZWN0IHdpdGggcmVjdGFuZ2xlJ3MgeC95IGNvb3JkaW5hdGVzIGFuZCBkaW1lbnNpb25zLlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdFJlYWRPbmx5fVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlUmVhZE9ubHlSZWN0KF9hKSB7XHJcbiAgICB2YXIgeCA9IF9hLngsIHkgPSBfYS55LCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XHJcbiAgICAvLyBJZiBET01SZWN0UmVhZE9ubHkgaXMgYXZhaWxhYmxlIHVzZSBpdCBhcyBhIHByb3RvdHlwZSBmb3IgdGhlIHJlY3RhbmdsZS5cclxuICAgIHZhciBDb25zdHIgPSB0eXBlb2YgRE9NUmVjdFJlYWRPbmx5ICE9PSAndW5kZWZpbmVkJyA/IERPTVJlY3RSZWFkT25seSA6IE9iamVjdDtcclxuICAgIHZhciByZWN0ID0gT2JqZWN0LmNyZWF0ZShDb25zdHIucHJvdG90eXBlKTtcclxuICAgIC8vIFJlY3RhbmdsZSdzIHByb3BlcnRpZXMgYXJlIG5vdCB3cml0YWJsZSBhbmQgbm9uLWVudW1lcmFibGUuXHJcbiAgICBkZWZpbmVDb25maWd1cmFibGUocmVjdCwge1xyXG4gICAgICAgIHg6IHgsIHk6IHksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgdG9wOiB5LFxyXG4gICAgICAgIHJpZ2h0OiB4ICsgd2lkdGgsXHJcbiAgICAgICAgYm90dG9tOiBoZWlnaHQgKyB5LFxyXG4gICAgICAgIGxlZnQ6IHhcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlY3Q7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgRE9NUmVjdEluaXQgb2JqZWN0IGJhc2VkIG9uIHRoZSBwcm92aWRlZCBkaW1lbnNpb25zIGFuZCB0aGUgeC95IGNvb3JkaW5hdGVzLlxyXG4gKiBTcGVjOiBodHRwczovL2RyYWZ0cy5meHRmLm9yZy9nZW9tZXRyeS8jZGljdGRlZi1kb21yZWN0aW5pdFxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0geCAtIFggY29vcmRpbmF0ZS5cclxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSBZIGNvb3JkaW5hdGUuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFJlY3RhbmdsZSdzIHdpZHRoLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gUmVjdGFuZ2xlJ3MgaGVpZ2h0LlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVSZWN0SW5pdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICByZXR1cm4geyB4OiB4LCB5OiB5LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XHJcbn1cblxuLyoqXHJcbiAqIENsYXNzIHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIGNvbXB1dGF0aW9ucyBvZiB0aGUgY29udGVudCByZWN0YW5nbGUgb2ZcclxuICogcHJvdmlkZWQgRE9NIGVsZW1lbnQgYW5kIGZvciBrZWVwaW5nIHRyYWNrIG9mIGl0J3MgY2hhbmdlcy5cclxuICovXHJcbnZhciBSZXNpemVPYnNlcnZhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgb2JzZXJ2ZWQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmF0aW9uKHRhcmdldCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJyb2FkY2FzdGVkIHdpZHRoIG9mIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJyb2FkY2FzdFdpZHRoID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCcm9hZGNhc3RlZCBoZWlnaHQgb2YgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYnJvYWRjYXN0SGVpZ2h0ID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIGxhc3Qgb2JzZXJ2ZWQgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7RE9NUmVjdEluaXR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb250ZW50UmVjdF8gPSBjcmVhdGVSZWN0SW5pdCgwLCAwLCAwLCAwKTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBjb250ZW50IHJlY3RhbmdsZSBhbmQgdGVsbHMgd2hldGhlciBpdCdzIHdpZHRoIG9yIGhlaWdodCBwcm9wZXJ0aWVzXHJcbiAgICAgKiBoYXZlIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgYnJvYWRjYXN0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZhdGlvbi5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlY3QgPSBnZXRDb250ZW50UmVjdCh0aGlzLnRhcmdldCk7XHJcbiAgICAgICAgdGhpcy5jb250ZW50UmVjdF8gPSByZWN0O1xyXG4gICAgICAgIHJldHVybiAocmVjdC53aWR0aCAhPT0gdGhpcy5icm9hZGNhc3RXaWR0aCB8fFxyXG4gICAgICAgICAgICByZWN0LmhlaWdodCAhPT0gdGhpcy5icm9hZGNhc3RIZWlnaHQpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyAnYnJvYWRjYXN0V2lkdGgnIGFuZCAnYnJvYWRjYXN0SGVpZ2h0JyBwcm9wZXJ0aWVzIHdpdGggYSBkYXRhXHJcbiAgICAgKiBmcm9tIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnRpZXMgb2YgdGhlIGxhc3Qgb2JzZXJ2ZWQgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge0RPTVJlY3RJbml0fSBMYXN0IG9ic2VydmVkIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZhdGlvbi5wcm90b3R5cGUuYnJvYWRjYXN0UmVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuY29udGVudFJlY3RfO1xyXG4gICAgICAgIHRoaXMuYnJvYWRjYXN0V2lkdGggPSByZWN0LndpZHRoO1xyXG4gICAgICAgIHRoaXMuYnJvYWRjYXN0SGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgcmV0dXJuIHJlY3Q7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmF0aW9uO1xyXG59KCkpO1xuXG52YXIgUmVzaXplT2JzZXJ2ZXJFbnRyeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlckVudHJ5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0aGF0IGlzIGJlaW5nIG9ic2VydmVkLlxyXG4gICAgICogQHBhcmFtIHtET01SZWN0SW5pdH0gcmVjdEluaXQgLSBEYXRhIG9mIHRoZSBlbGVtZW50J3MgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyRW50cnkodGFyZ2V0LCByZWN0SW5pdCkge1xyXG4gICAgICAgIHZhciBjb250ZW50UmVjdCA9IGNyZWF0ZVJlYWRPbmx5UmVjdChyZWN0SW5pdCk7XHJcbiAgICAgICAgLy8gQWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpY2F0aW9uIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSBub3Qgd3JpdGFibGVcclxuICAgICAgICAvLyBhbmQgYXJlIGFsc28gbm90IGVudW1lcmFibGUgaW4gdGhlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFByb3BlcnR5IGFjY2Vzc29ycyBhcmUgbm90IGJlaW5nIHVzZWQgYXMgdGhleSdkIHJlcXVpcmUgdG8gZGVmaW5lIGFcclxuICAgICAgICAvLyBwcml2YXRlIFdlYWtNYXAgc3RvcmFnZSB3aGljaCBtYXkgY2F1c2UgbWVtb3J5IGxlYWtzIGluIGJyb3dzZXJzIHRoYXRcclxuICAgICAgICAvLyBkb24ndCBzdXBwb3J0IHRoaXMgdHlwZSBvZiBjb2xsZWN0aW9ucy5cclxuICAgICAgICBkZWZpbmVDb25maWd1cmFibGUodGhpcywgeyB0YXJnZXQ6IHRhcmdldCwgY29udGVudFJlY3Q6IGNvbnRlbnRSZWN0IH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyRW50cnk7XHJcbn0oKSk7XG5cbnZhciBSZXNpemVPYnNlcnZlclNQSSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBpbnZva2VkXHJcbiAgICAgKiAgICAgIHdoZW4gb25lIG9mIHRoZSBvYnNlcnZlZCBlbGVtZW50cyBjaGFuZ2VzIGl0J3MgY29udGVudCBkaW1lbnNpb25zLlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlckNvbnRyb2xsZXJ9IGNvbnRyb2xsZXIgLSBDb250cm9sbGVyIGluc3RhbmNlIHdoaWNoXHJcbiAgICAgKiAgICAgIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgdXBkYXRlcyBvZiBvYnNlcnZlci5cclxuICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJ9IGNhbGxiYWNrQ3R4IC0gUmVmZXJlbmNlIHRvIHRoZSBwdWJsaWNcclxuICAgICAqICAgICAgUmVzaXplT2JzZXJ2ZXIgaW5zdGFuY2Ugd2hpY2ggd2lsbCBiZSBwYXNzZWQgdG8gY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyU1BJKGNhbGxiYWNrLCBjb250cm9sbGVyLCBjYWxsYmFja0N0eCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbGxlY3Rpb24gb2YgcmVzaXplIG9ic2VydmF0aW9ucyB0aGF0IGhhdmUgZGV0ZWN0ZWQgY2hhbmdlcyBpbiBkaW1lbnNpb25zXHJcbiAgICAgICAgICogb2YgZWxlbWVudHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7QXJyYXk8UmVzaXplT2JzZXJ2YXRpb24+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlZ2lzdHJ5IG9mIHRoZSBSZXNpemVPYnNlcnZhdGlvbiBpbnN0YW5jZXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7TWFwPEVsZW1lbnQsIFJlc2l6ZU9ic2VydmF0aW9uPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9ic2VydmF0aW9uc18gPSBuZXcgTWFwU2hpbSgpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGNhbGxiYWNrIHByb3ZpZGVkIGFzIHBhcmFtZXRlciAxIGlzIG5vdCBhIGZ1bmN0aW9uLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhbGxiYWNrXyA9IGNhbGxiYWNrO1xyXG4gICAgICAgIHRoaXMuY29udHJvbGxlcl8gPSBjb250cm9sbGVyO1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tDdHhfID0gY2FsbGJhY2tDdHg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0cyBvYnNlcnZpbmcgcHJvdmlkZWQgZWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgb2JzZXJ2ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLm9ic2VydmUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBjdXJyZW50IGVudmlyb25tZW50IGRvZXNuJ3QgaGF2ZSB0aGUgRWxlbWVudCBpbnRlcmZhY2UuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBFbGVtZW50ID09PSAndW5kZWZpbmVkJyB8fCAhKEVsZW1lbnQgaW5zdGFuY2VvZiBPYmplY3QpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5FbGVtZW50KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSBcIkVsZW1lbnRcIi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9ic2VydmF0aW9ucyA9IHRoaXMub2JzZXJ2YXRpb25zXztcclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGVsZW1lbnQgaXMgYWxyZWFkeSBiZWluZyBvYnNlcnZlZC5cclxuICAgICAgICBpZiAob2JzZXJ2YXRpb25zLmhhcyh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgb2JzZXJ2YXRpb25zLnNldCh0YXJnZXQsIG5ldyBSZXNpemVPYnNlcnZhdGlvbih0YXJnZXQpKTtcclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJfLmFkZE9ic2VydmVyKHRoaXMpO1xyXG4gICAgICAgIC8vIEZvcmNlIHRoZSB1cGRhdGUgb2Ygb2JzZXJ2YXRpb25zLlxyXG4gICAgICAgIHRoaXMuY29udHJvbGxlcl8ucmVmcmVzaCgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgb2JzZXJ2aW5nIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIHN0b3Agb2JzZXJ2aW5nLlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS51bm9ic2VydmUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBjdXJyZW50IGVudmlyb25tZW50IGRvZXNuJ3QgaGF2ZSB0aGUgRWxlbWVudCBpbnRlcmZhY2UuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBFbGVtZW50ID09PSAndW5kZWZpbmVkJyB8fCAhKEVsZW1lbnQgaW5zdGFuY2VvZiBPYmplY3QpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5FbGVtZW50KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSBcIkVsZW1lbnRcIi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9ic2VydmF0aW9ucyA9IHRoaXMub2JzZXJ2YXRpb25zXztcclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGVsZW1lbnQgaXMgbm90IGJlaW5nIG9ic2VydmVkLlxyXG4gICAgICAgIGlmICghb2JzZXJ2YXRpb25zLmhhcyh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgb2JzZXJ2YXRpb25zLmRlbGV0ZSh0YXJnZXQpO1xyXG4gICAgICAgIGlmICghb2JzZXJ2YXRpb25zLnNpemUpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyXy5yZW1vdmVPYnNlcnZlcih0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wcyBvYnNlcnZpbmcgYWxsIGVsZW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNsZWFyQWN0aXZlKCk7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZhdGlvbnNfLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5jb250cm9sbGVyXy5yZW1vdmVPYnNlcnZlcih0aGlzKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvbGxlY3RzIG9ic2VydmF0aW9uIGluc3RhbmNlcyB0aGUgYXNzb2NpYXRlZCBlbGVtZW50IG9mIHdoaWNoIGhhcyBjaGFuZ2VkXHJcbiAgICAgKiBpdCdzIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuZ2F0aGVyQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5jbGVhckFjdGl2ZSgpO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2YXRpb25zXy5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZhdGlvbikge1xyXG4gICAgICAgICAgICBpZiAob2JzZXJ2YXRpb24uaXNBY3RpdmUoKSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5wdXNoKG9ic2VydmF0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogSW52b2tlcyBpbml0aWFsIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggYSBsaXN0IG9mIFJlc2l6ZU9ic2VydmVyRW50cnlcclxuICAgICAqIGluc3RhbmNlcyBjb2xsZWN0ZWQgZnJvbSBhY3RpdmUgcmVzaXplIG9ic2VydmF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmJyb2FkY2FzdEFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIG9ic2VydmVyIGRvZXNuJ3QgaGF2ZSBhY3RpdmUgb2JzZXJ2YXRpb25zLlxyXG4gICAgICAgIGlmICghdGhpcy5oYXNBY3RpdmUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjdHggPSB0aGlzLmNhbGxiYWNrQ3R4XztcclxuICAgICAgICAvLyBDcmVhdGUgUmVzaXplT2JzZXJ2ZXJFbnRyeSBpbnN0YW5jZSBmb3IgZXZlcnkgYWN0aXZlIG9ic2VydmF0aW9uLlxyXG4gICAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLm1hcChmdW5jdGlvbiAob2JzZXJ2YXRpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNpemVPYnNlcnZlckVudHJ5KG9ic2VydmF0aW9uLnRhcmdldCwgb2JzZXJ2YXRpb24uYnJvYWRjYXN0UmVjdCgpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNhbGxiYWNrXy5jYWxsKGN0eCwgZW50cmllcywgY3R4KTtcclxuICAgICAgICB0aGlzLmNsZWFyQWN0aXZlKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgdGhlIGNvbGxlY3Rpb24gb2YgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmNsZWFyQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5zcGxpY2UoMCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUZWxscyB3aGV0aGVyIG9ic2VydmVyIGhhcyBhY3RpdmUgb2JzZXJ2YXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuaGFzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18ubGVuZ3RoID4gMDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXJTUEk7XHJcbn0oKSk7XG5cbi8vIFJlZ2lzdHJ5IG9mIGludGVybmFsIG9ic2VydmVycy4gSWYgV2Vha01hcCBpcyBub3QgYXZhaWxhYmxlIHVzZSBjdXJyZW50IHNoaW1cclxuLy8gZm9yIHRoZSBNYXAgY29sbGVjdGlvbiBhcyBpdCBoYXMgYWxsIHJlcXVpcmVkIG1ldGhvZHMgYW5kIGJlY2F1c2UgV2Vha01hcFxyXG4vLyBjYW4ndCBiZSBmdWxseSBwb2x5ZmlsbGVkIGFueXdheS5cclxudmFyIG9ic2VydmVycyA9IHR5cGVvZiBXZWFrTWFwICE9PSAndW5kZWZpbmVkJyA/IG5ldyBXZWFrTWFwKCkgOiBuZXcgTWFwU2hpbSgpO1xyXG4vKipcclxuICogUmVzaXplT2JzZXJ2ZXIgQVBJLiBFbmNhcHN1bGF0ZXMgdGhlIFJlc2l6ZU9ic2VydmVyIFNQSSBpbXBsZW1lbnRhdGlvblxyXG4gKiBleHBvc2luZyBvbmx5IHRob3NlIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgdGhhdCBhcmUgZGVmaW5lZCBpbiB0aGUgc3BlYy5cclxuICovXHJcbnZhciBSZXNpemVPYnNlcnZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdGhhdCBpcyBpbnZva2VkIHdoZW5cclxuICAgICAqICAgICAgZGltZW5zaW9ucyBvZiB0aGUgb2JzZXJ2ZWQgZWxlbWVudHMgY2hhbmdlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlcihjYWxsYmFjaykge1xyXG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXNpemVPYnNlcnZlcikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29udHJvbGxlciA9IFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIHZhciBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlclNQSShjYWxsYmFjaywgY29udHJvbGxlciwgdGhpcyk7XHJcbiAgICAgICAgb2JzZXJ2ZXJzLnNldCh0aGlzLCBvYnNlcnZlcik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXI7XHJcbn0oKSk7XHJcbi8vIEV4cG9zZSBwdWJsaWMgbWV0aG9kcyBvZiBSZXNpemVPYnNlcnZlci5cclxuW1xyXG4gICAgJ29ic2VydmUnLFxyXG4gICAgJ3Vub2JzZXJ2ZScsXHJcbiAgICAnZGlzY29ubmVjdCdcclxuXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcclxuICAgIFJlc2l6ZU9ic2VydmVyLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gKF9hID0gb2JzZXJ2ZXJzLmdldCh0aGlzKSlbbWV0aG9kXS5hcHBseShfYSwgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbn0pO1xuXG52YXIgaW5kZXggPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gRXhwb3J0IGV4aXN0aW5nIGltcGxlbWVudGF0aW9uIGlmIGF2YWlsYWJsZS5cclxuICAgIGlmICh0eXBlb2YgZ2xvYmFsJDEuUmVzaXplT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIGdsb2JhbCQxLlJlc2l6ZU9ic2VydmVyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyO1xyXG59KSgpO1xuXG5leHBvcnQgZGVmYXVsdCBpbmRleDtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNPbGRJRSA9IGZ1bmN0aW9uIGlzT2xkSUUoKSB7XG4gIHZhciBtZW1vO1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUoKSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3NcbiAgICAgIC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcbiAgICAgIC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcbiAgICAgIC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG4gICAgICBtZW1vID0gQm9vbGVhbih3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG59KCk7XG5cbnZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiBnZXRUYXJnZXQoKSB7XG4gIHZhciBtZW1vID0ge307XG4gIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSh0YXJnZXQpIHtcbiAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhciBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTsgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblxuICAgICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4gICAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbiAgfTtcbn0oKTtcblxudmFyIHN0eWxlc0luRG9tID0gW107XG5cbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgdmFyIHJlc3VsdCA9IC0xO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzSW5Eb20ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3R5bGVzSW5Eb21baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmVzdWx0ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBpZENvdW50TWFwID0ge307XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgIHZhciBpZGVudGlmaWVyID0gXCJcIi5jb25jYXQoaWQsIFwiIFwiKS5jb25jYXQoY291bnQpO1xuICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgIHNvdXJjZU1hcDogaXRlbVszXVxuICAgIH07XG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcysrO1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnVwZGF0ZXIob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzSW5Eb20ucHVzaCh7XG4gICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgIHVwZGF0ZXI6IGFkZFN0eWxlKG9iaiwgb3B0aW9ucyksXG4gICAgICAgIHJlZmVyZW5jZXM6IDFcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XG4gIH1cblxuICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSB7XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHZhciBhdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9O1xuXG4gIGlmICh0eXBlb2YgYXR0cmlidXRlcy5ub25jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09ICd1bmRlZmluZWQnID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuXG4gICAgaWYgKG5vbmNlKSB7XG4gICAgICBhdHRyaWJ1dGVzLm5vbmNlID0gbm9uY2U7XG4gICAgfVxuICB9XG5cbiAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgfSk7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdGlvbnMuaW5zZXJ0KHN0eWxlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KG9wdGlvbnMuaW5zZXJ0IHx8ICdoZWFkJyk7XG5cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgICB9XG5cbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG52YXIgcmVwbGFjZVRleHQgPSBmdW5jdGlvbiByZXBsYWNlVGV4dCgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdO1xuICByZXR1cm4gZnVuY3Rpb24gcmVwbGFjZShpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG4gICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG4gIH07XG59KCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICB2YXIgY3NzID0gcmVtb3ZlID8gJycgOiBvYmoubWVkaWEgPyBcIkBtZWRpYSBcIi5jb25jYXQob2JqLm1lZGlhLCBcIiB7XCIpLmNvbmNhdChvYmouY3NzLCBcIn1cIikgOiBvYmouY3NzOyAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuICAgIHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgIH1cblxuICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgc3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGUsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gb2JqLmNzcztcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuICBpZiAobWVkaWEpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgbWVkaWEpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZSgnbWVkaWEnKTtcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH0gLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZS5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhciBzaW5nbGV0b25Db3VudGVyID0gMDtcblxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XG4gIHZhciBzdHlsZTtcbiAgdmFyIHVwZGF0ZTtcbiAgdmFyIHJlbW92ZTtcblxuICBpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcbiAgICB2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcbiAgICBzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcbiAgICByZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cbiAgICByZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuICAgIH07XG4gIH1cblxuICB1cGRhdGUob2JqKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKCk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbiAgLy8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXG4gIGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSAnYm9vbGVhbicpIHtcbiAgICBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcbiAgfVxuXG4gIGxpc3QgPSBsaXN0IHx8IFtdO1xuICB2YXIgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3TGlzdCkgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgfVxuXG4gICAgdmFyIG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2lkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbX2ldO1xuXG4gICAgICB2YXIgX2luZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuXG4gICAgICBpZiAoc3R5bGVzSW5Eb21bX2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICAgIHN0eWxlc0luRG9tW19pbmRleF0udXBkYXRlcigpO1xuXG4gICAgICAgIHN0eWxlc0luRG9tLnNwbGljZShfaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgfTtcbn07IiwidmFyIHNjb3BlID0gKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYpIHx8XG4gICAgICAgICAgICB3aW5kb3c7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbChzY29wZSwgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG4vLyBPbiBzb21lIGV4b3RpYyBlbnZpcm9ubWVudHMsIGl0J3Mgbm90IGNsZWFyIHdoaWNoIG9iamVjdCBgc2V0aW1tZWRpYXRlYCB3YXNcbi8vIGFibGUgdG8gaW5zdGFsbCBvbnRvLiAgU2VhcmNoIGVhY2ggcG9zc2liaWxpdHkgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4vLyBgc2V0aW1tZWRpYXRlYCBsaWJyYXJ5LlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuc2V0SW1tZWRpYXRlKTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5jbGVhckltbWVkaWF0ZSk7XG4iLCIvKipcbiAqIENvbnZlcnQgYXJyYXkgb2YgMTYgYnl0ZSB2YWx1ZXMgdG8gVVVJRCBzdHJpbmcgZm9ybWF0IG9mIHRoZSBmb3JtOlxuICogWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXG4gKi9cbnZhciBieXRlVG9IZXggPSBbXTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4W2ldID0gKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKTtcbn1cblxuZnVuY3Rpb24gYnl0ZXNUb1V1aWQoYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBvZmZzZXQgfHwgMDtcbiAgdmFyIGJ0aCA9IGJ5dGVUb0hleDtcbiAgLy8gam9pbiB1c2VkIHRvIGZpeCBtZW1vcnkgaXNzdWUgY2F1c2VkIGJ5IGNvbmNhdGVuYXRpb246IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMxNzUjYzRcbiAgcmV0dXJuIChbXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV1cbiAgXSkuam9pbignJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnl0ZXNUb1V1aWQ7XG4iLCIvLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiAgSW4gdGhlXG4vLyBicm93c2VyIHRoaXMgaXMgYSBsaXR0bGUgY29tcGxpY2F0ZWQgZHVlIHRvIHVua25vd24gcXVhbGl0eSBvZiBNYXRoLnJhbmRvbSgpXG4vLyBhbmQgaW5jb25zaXN0ZW50IHN1cHBvcnQgZm9yIHRoZSBgY3J5cHRvYCBBUEkuICBXZSBkbyB0aGUgYmVzdCB3ZSBjYW4gdmlhXG4vLyBmZWF0dXJlLWRldGVjdGlvblxuXG4vLyBnZXRSYW5kb21WYWx1ZXMgbmVlZHMgdG8gYmUgaW52b2tlZCBpbiBhIGNvbnRleHQgd2hlcmUgXCJ0aGlzXCIgaXMgYSBDcnlwdG9cbi8vIGltcGxlbWVudGF0aW9uLiBBbHNvLCBmaW5kIHRoZSBjb21wbGV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBjcnlwdG8gb24gSUUxMS5cbnZhciBnZXRSYW5kb21WYWx1ZXMgPSAodHlwZW9mKGNyeXB0bykgIT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mKG1zQ3J5cHRvKSAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93Lm1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PSAnZnVuY3Rpb24nICYmIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKG1zQ3J5cHRvKSk7XG5cbmlmIChnZXRSYW5kb21WYWx1ZXMpIHtcbiAgLy8gV0hBVFdHIGNyeXB0byBSTkcgLSBodHRwOi8vd2lraS53aGF0d2cub3JnL3dpa2kvQ3J5cHRvXG4gIHZhciBybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2hhdHdnUk5HKCkge1xuICAgIGdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG4gICAgcmV0dXJuIHJuZHM4O1xuICB9O1xufSBlbHNlIHtcbiAgLy8gTWF0aC5yYW5kb20oKS1iYXNlZCAoUk5HKVxuICAvL1xuICAvLyBJZiBhbGwgZWxzZSBmYWlscywgdXNlIE1hdGgucmFuZG9tKCkuICBJdCdzIGZhc3QsIGJ1dCBpcyBvZiB1bnNwZWNpZmllZFxuICAvLyBxdWFsaXR5LlxuICB2YXIgcm5kcyA9IG5ldyBBcnJheSgxNik7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtYXRoUk5HKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCByOyBpIDwgMTY7IGkrKykge1xuICAgICAgaWYgKChpICYgMHgwMykgPT09IDApIHIgPSBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDA7XG4gICAgICBybmRzW2ldID0gciA+Pj4gKChpICYgMHgwMykgPDwgMykgJiAweGZmO1xuICAgIH1cblxuICAgIHJldHVybiBybmRzO1xuICB9O1xufVxuIiwidmFyIHJuZyA9IHJlcXVpcmUoJy4vbGliL3JuZycpO1xudmFyIGJ5dGVzVG9VdWlkID0gcmVxdWlyZSgnLi9saWIvYnl0ZXNUb1V1aWQnKTtcblxuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG5cbiAgaWYgKHR5cGVvZihvcHRpb25zKSA9PSAnc3RyaW5nJykge1xuICAgIGJ1ZiA9IG9wdGlvbnMgPT09ICdiaW5hcnknID8gbmV3IEFycmF5KDE2KSA6IG51bGw7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpO1xuXG4gIC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcbiAgcm5kc1s2XSA9IChybmRzWzZdICYgMHgwZikgfCAweDQwO1xuICBybmRzWzhdID0gKHJuZHNbOF0gJiAweDNmKSB8IDB4ODA7XG5cbiAgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG4gIGlmIChidWYpIHtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgMTY7ICsraWkpIHtcbiAgICAgIGJ1ZltpICsgaWldID0gcm5kc1tpaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZiB8fCBieXRlc1RvVXVpZChybmRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2NDtcbiIsInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLCBldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2ggKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuIiwiJ1xceDc1XFx4NzNcXHg2NVxceDIwXFx4NzNcXHg3NFxceDcyXFx4NjlcXHg2M1xceDc0JztPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywnXFx4NWZcXHg1ZlxceDY1XFx4NzNcXHg0ZFxceDZmXFx4NjRcXHg3NVxceDZjXFx4NjUnLHt2YWx1ZTp0cnVlfSk7dmFyIEhvc3RuYW1lUmVzb2x2ZXI9ZnVuY3Rpb24oKXt2YXIgX29vUTA9WydcXHg2MVxceDc0JywnXFx4NjVcXHg3M1xceDJkXFx4NzBcXHg3MlxceDY1XFx4MmRcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg2M1xceDYxXFx4MmRcXHg3MFxceDcyXFx4NjVcXHgyZFxceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDY2XFx4NzJcXHgyZFxceDcwXFx4NzJcXHg2NVxceDJkXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NzNcXHg2MVxceDJkXFx4NjRcXHg2NVxceDc2XFx4NjVcXHg2Y1xceDZmXFx4NzBcXHg2ZFxceDY1XFx4NmVcXHg3NFxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg2NVxceDY3XFx4MmRcXHg3MFxceDcyXFx4NjVcXHgyZFxceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg2NFxceDc1XFx4NjJcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NzdcXHg3N1xceDc3XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDczXFx4NjcnLCdcXHg2OVxceDc0JywnXFx4NzdcXHg3N1xceDc3XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYxXFx4NzQnLCdcXHg2NVxceDczXFx4MmRcXHg2NFxceDY1XFx4NzZcXHg2NVxceDZjXFx4NmZcXHg3MFxceDZkXFx4NjVcXHg2ZVxceDc0XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDc3XFx4NzdcXHg3N1xceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmRcXHgyZVxceDZkXFx4NzgnLCdcXHg2YVxceDcwXFx4MmRcXHg3MFxceDcyXFx4NjVcXHgyZFxceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDc3XFx4NzdcXHg3N1xceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmRcXHgyZVxceDc0XFx4NzInLCdcXHg3M1xceDY3JywnXFx4NzBcXHg2Y1xceDJkXFx4NzBcXHg3MlxceDY1XFx4MmRcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NjRcXHg3NVxceDYyXFx4MmVcXHg3OFxceDYzXFx4NmZcXHg3MlxceDcwXFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDYyXFx4NzJcXHgyZFxceDcwXFx4NzJcXHg2NVxceDJkXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NzdcXHg3N1xceDc3XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDY1XFx4NjcnLCdcXHg3M1xceDYxJywnXFx4NjVcXHg2NycsJ1xceDczXFx4NjdcXHgyZFxceDcwXFx4NzJcXHg2NVxceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg3MFxceDY0XFx4NzhcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NmRcXHg3OFxceDJkXFx4NjRcXHg2NVxceDc2XFx4NjVcXHg2Y1xceDZmXFx4NzBcXHg2ZFxceDY1XFx4NmVcXHg3NFxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg3N1xceDc3XFx4NzdcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjRcXHg2NScsJ1xceDZhXFx4NzAnLCdcXHg3M1xceDY1JywnXFx4NzBcXHg2YycsJ1xceDczXFx4NjVcXHgyZVxceDY5XFx4NmVcXHg3NFxceDY1XFx4NjdcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NzdcXHg3N1xceDc3XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDcwXFx4NmMnLCdcXHg2NVxceDc1JywnXFx4NzBcXHg3MlxceDY1XFx4MmRcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg2NFxceDY1JywnXFx4NzdcXHg3N1xceDc3XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDY5XFx4NzQnLCdcXHg2MVxceDY1XFx4MmRcXHg2NFxceDY1XFx4NzZcXHg2NVxceDZjXFx4NmZcXHg3MFxceDZkXFx4NjVcXHg2ZVxceDc0XFx4MmVcXHg2OVxceDZlXFx4NzRcXHg2NVxceDY3XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDY5XFx4NmVcXHgyZFxceDY0XFx4NjVcXHg3NlxceDY1XFx4NmNcXHg2ZlxceDcwXFx4NmRcXHg2NVxceDZlXFx4NzRcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NjlcXHg3NFxceDJkXFx4NjRcXHg2NVxceDc2XFx4NjVcXHg2Y1xceDZmXFx4NzBcXHg2ZFxceDY1XFx4NmVcXHg3NFxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg3NVxceDZiXFx4MmRcXHg3MFxceDcyXFx4NjVcXHgyZFxceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDY0XFx4NjVcXHgyZFxceDY0XFx4NjVcXHg3NlxceDY1XFx4NmNcXHg2ZlxceDcwXFx4NmRcXHg2NVxceDZlXFx4NzRcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NzdcXHg3N1xceDc3XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDczXFx4NjEnLCdcXHg3N1xceDc3XFx4NzdcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NmVcXHg2YycsJ1xceDY2XFx4NzInLCdcXHg2MVxceDY1XFx4MmRcXHg3MFxceDcyXFx4NjVcXHgyZFxceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg2NFxceDc1XFx4NjJcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NzdcXHg3N1xceDc3XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDY1XFx4NzMnLCdcXHg3NFxceDcyXFx4MmRcXHg3MFxceDcyXFx4NjVcXHgyZFxceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg2NFxceDc1XFx4NjJcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NzdcXHg3N1xceDc3XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDczXFx4NjUnLCdcXHg2MVxceDY1JywnXFx4NmRcXHg3OCcsJ1xceDczXFx4NjdcXHgyZVxceDY5XFx4NmVcXHg3NFxceDY1XFx4NjdcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NjNcXHg2MVxceDJkXFx4NjRcXHg2NVxceDc2XFx4NjVcXHg2Y1xceDZmXFx4NzBcXHg2ZFxceDY1XFx4NmVcXHg3NFxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg3N1xceDc3XFx4NzdcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjZcXHg3MicsJ1xceDYxXFx4NzUnLCdcXHg2ZVxceDZjXFx4MmRcXHg2NFxceDY1XFx4NzZcXHg2NVxceDZjXFx4NmZcXHg3MFxceDZkXFx4NjVcXHg2ZVxceDc0XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDYyXFx4NzInLCdcXHg2OVxceDZlJywnXFx4NzRcXHg3MicsJ1xceDc3XFx4NzdcXHg3N1xceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2OVxceDZlJywnXFx4NzVcXHg2YlxceDJkXFx4NjRcXHg2NVxceDc2XFx4NjVcXHg2Y1xceDZmXFx4NzBcXHg2ZFxceDY1XFx4NmVcXHg3NFxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg2NlxceDcyXFx4MmRcXHg2NFxceDY1XFx4NzZcXHg2NVxceDZjXFx4NmZcXHg3MFxceDZkXFx4NjVcXHg2ZVxceDc0XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDZhXFx4NzBcXHgyZFxceDY0XFx4NjVcXHg3NlxceDY1XFx4NmNcXHg2ZlxceDcwXFx4NmRcXHg2NVxceDZlXFx4NzRcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NjlcXHg3NFxceDJkXFx4NzBcXHg3MlxceDY1XFx4MmRcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg2M1xceDYxJywnXFx4NzdcXHg3N1xceDc3XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZFxceDJlXFx4NjJcXHg3MicsJ1xceDc3XFx4NzdcXHg3N1xceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDYxJywnXFx4NzdcXHg3N1xceDc3XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHgyZVxceDZhXFx4NzAnLCdcXHg3M1xceDY1XFx4MmRcXHg3MFxceDcyXFx4NjVcXHgyZFxceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg2NFxceDc1XFx4NjJcXHgyZVxceDc4XFx4NjNcXHg2ZlxceDcyXFx4NzBcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NjJcXHg3MlxceDJkXFx4NjRcXHg2NVxceDc2XFx4NjVcXHg2Y1xceDZmXFx4NzBcXHg2ZFxceDY1XFx4NmVcXHg3NFxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg2OVxceDZlXFx4MmRcXHg3MFxceDcyXFx4NjVcXHgyZFxceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDc3XFx4NzdcXHg3N1xceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg2ZVxceDZjJywnXFx4NjRcXHg2NVxceDJkXFx4NzBcXHg3MlxceDY1XFx4MmRcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg2ZFxceDc4XFx4MmRcXHg3MFxceDcyXFx4NjVcXHgyZFxceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDczXFx4NjFcXHgyZFxceDcwXFx4NzJcXHg2NVxceDJkXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NjFcXHg3NVxceDJkXFx4NjRcXHg2NVxceDc2XFx4NjVcXHg2Y1xceDZmXFx4NzBcXHg2ZFxceDY1XFx4NmVcXHg3NFxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg3N1xceDc3XFx4NzdcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjFcXHg2NScsJ1xceDY1XFx4NzMnLCdcXHg3N1xceDc3XFx4NzdcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkXFx4MmVcXHg2MVxceDc1JywnXFx4NzdcXHg3N1xceDc3XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHgyZVxceDc1XFx4NmInLCdcXHg2NVxceDY3XFx4MmRcXHg2NFxceDY1XFx4NzZcXHg2NVxceDZjXFx4NmZcXHg3MFxceDZkXFx4NjVcXHg2ZVxceDc0XFx4MmVcXHg2OVxceDZlXFx4NzRcXHg2NVxceDY3XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDYxXFx4NzVcXHgyZFxceDcwXFx4NzJcXHg2NVxceDJkXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NzRcXHg3MlxceDJkXFx4NjRcXHg2NVxceDc2XFx4NjVcXHg2Y1xceDZmXFx4NzBcXHg2ZFxceDY1XFx4NmVcXHg3NFxceDJlXFx4NjlcXHg2ZVxceDc0XFx4NjVcXHg2N1xceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg2ZVxceDZjXFx4MmRcXHg3MFxceDcyXFx4NjVcXHgyZFxceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDcwXFx4NmNcXHgyZVxceDY5XFx4NmVcXHg3NFxceDY1XFx4NjdcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NjFcXHg3NFxceDJkXFx4NjRcXHg2NVxceDc2XFx4NjVcXHg2Y1xceDZmXFx4NzBcXHg2ZFxceDY1XFx4NmVcXHg3NFxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg3NVxceDZiJywnXFx4NzVcXHg3MycsJ1xceDY0XFx4NjVcXHg3NlxceDY1XFx4NmNcXHg2ZlxceDcwXFx4NmRcXHg2NVxceDZlXFx4NzRcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NjFcXHg3NFxceDJkXFx4NzBcXHg3MlxceDY1XFx4MmRcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnXTtmdW5jdGlvbiBIb3N0bmFtZVJlc29sdmVyKCl7fUhvc3RuYW1lUmVzb2x2ZXIuZ2V0U2VydmljZUhvc3RuYW1lQnlDb25maWd1cmF0aW9uPWZ1bmN0aW9uKGNvbmZpZ3VyYXRpb24pe3ZhciBfMDBRPVsnXFx4NzdcXHg3N1xceDc3XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsNzMsMjkzNTddO2lmKGNvbmZpZ3VyYXRpb24gaW4gSG9zdG5hbWVSZXNvbHZlci5ET01BSU5fUkVBTE1fSE9TVE5BTUUpe3ZhciBfUU9vUTAwUTA9XzAwUVsxXSxfJHpzWjIkelo9XzAwUVsyXTtyZXR1cm4gSG9zdG5hbWVSZXNvbHZlci5ET01BSU5fUkVBTE1fSE9TVE5BTUVbY29uZmlndXJhdGlvbl07fWVsc2V7cmV0dXJuIF8wMFFbMF07fX07SG9zdG5hbWVSZXNvbHZlci5nZXRTZXJ2aWNlSG9zdG5hbWVCeUhvc3RuYW1lPWZ1bmN0aW9uKGhvc3RuYW1lKXt2YXIgX3NzPVsnXFx4NzBcXHg3MlxceDZmXFx4NjQnLCdcXHg2ZFxceDYxXFx4NzNcXHg3NFxceDY1XFx4NzInLC4wNDQ1MjM5MDY1MDY1MDk3MjUsJ1xceDc0XFx4NjVcXHg3M1xceDc0JywnXFx4NmVcXHg2ZlxceDY0XFx4NjVcXHg0MiddO3ZhciBfU3pTWlNaWiQ9X3NzWzJdO2lmKEhvc3RuYW1lUmVzb2x2ZXIuaXNEZXZlbG9wbWVudChob3N0bmFtZSkpe3ZhciBfME8wUW8wUW89X3NzWzRdO3JldHVybiB0aGlzLmdldFNlcnZpY2VIb3N0QnlDb3VudHJ5Q29kZShfc3NbM10sdGhpcy5nZXRDb3VudHJ5Q29kZVByZWZpeChob3N0bmFtZSkpO31lbHNlIGlmKEhvc3RuYW1lUmVzb2x2ZXIuaXNQcmVQcm9kKGhvc3RuYW1lKSl7dmFyIF9MMWxsMWlMST1mdW5jdGlvbihfUU9vUTBRT08sX3oyUyR6WjJzKXt2YXIgX2xsST1bLjY5MDIyNjA1MjgyMzIxNjksNDc5MiwuMzg5ODA3NzUxOTYzNTgwMSwnXFx4NjVcXHg2ZVxceDYzXFx4NzJcXHg3OVxceDcwXFx4NzRcXHg0MlxceDZjXFx4NmZcXHg2MicsJ1xceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZScsJ1xceDY1XFx4NmVcXHg2M1xceDcyXFx4NzlcXHg3MFxceDc0XFx4NDInLDE2MjEwXTt2YXIgX3okJFNTWjJaPV9sbElbM10sX0lMMUxsSWwxPV9sbElbMF0sX29RUW8wT29vPV9sbElbNl07dmFyIF9paWxpMTFMaT1fbGxJWzJdLF9Rb1FvUW9vTz1fbGxJWzVdLF8kMnMkMlMycz1fbGxJWzFdO3JldHVybiBfbGxJWzRdO307cmV0dXJuIHRoaXMuZ2V0U2VydmljZUhvc3RCeUNvdW50cnlDb2RlKF9zc1sxXSx0aGlzLmdldENvdW50cnlDb2RlUHJlZml4KGhvc3RuYW1lKSk7fWVsc2V7dmFyIGNvdW50cnlDb2RlPUhvc3RuYW1lUmVzb2x2ZXIuZ2V0Q291bnRyeUNvZGVTdWZmaXgoaG9zdG5hbWUpO3JldHVybiB0aGlzLmdldFNlcnZpY2VIb3N0QnlDb3VudHJ5Q29kZShfc3NbMF0sY291bnRyeUNvZGUpO319O0hvc3RuYW1lUmVzb2x2ZXIuZ2V0U2VydmljZUhvc3RCeUNvdW50cnlDb2RlPWZ1bmN0aW9uKGRvbWFpbixjb3VudHJ5Q29kZSl7dmFyIF9zeno9WydcXHgyZScsJ1xceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSddO3JldHVybiB0aGlzLmdldFNlcnZpY2VIb3N0bmFtZUJ5Q29uZmlndXJhdGlvbihkb21haW4rX3N6elswXStjb3VudHJ5Q29kZS50b1VwcGVyQ2FzZSgpK19zenpbMV0pO307SG9zdG5hbWVSZXNvbHZlci5pc0RldmVsb3BtZW50PWZ1bmN0aW9uKGhvc3RuYW1lKXt2YXIgX09PMD1bJ1xceDY5XFx4NmVcXHg3NFxceDY1XFx4NjdcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NjRcXHg2NVxceDc2XFx4NjVcXHg2Y1xceDZmXFx4NzBcXHg2ZFxceDY1XFx4NmVcXHg3NFxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHgyZVxceDYxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZVxceDJlXFx4NjNcXHg2ZlxceDZkJywnXFx4NmNcXHg2ZlxceDYzXFx4NjFcXHg2Y1xceDY4XFx4NmZcXHg3M1xceDc0JywnXFx4NjRcXHg2NVxceDc2XFx4MmRcXHg2NFxceDczXFx4NmInXTtyZXR1cm4gaG9zdG5hbWUuc3RhcnRzV2l0aChfT08wWzRdKSYmaG9zdG5hbWUuZW5kc1dpdGgoX09PMFsyXSl8fGhvc3RuYW1lLnN0YXJ0c1dpdGgoX09PMFszXSl8fGhvc3RuYW1lLmVuZHNXaXRoKF9PTzBbMF0pfHxob3N0bmFtZS5lbmRzV2l0aChfT08wWzFdKTt9O0hvc3RuYW1lUmVzb2x2ZXIuaXNQcmVQcm9kPWZ1bmN0aW9uKGhvc3RuYW1lKXt2YXIgX2wxbD1bJ1xceDcwXFx4NzJcXHg2NVxceDJkXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDcwXFx4NjRcXHg3OFxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg3MFxceDcyXFx4NjVcXHgyZFxceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDcwXFx4NzJcXHg2NVxceDJkXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDY0XFx4NzVcXHg2MlxceDJlXFx4NzhcXHg2M1xceDZmXFx4NzJcXHg3MFxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnLCdcXHg3MFxceDcyXFx4NjVcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NzBcXHg2NFxceDc4XFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHgyZVxceDYzXFx4NmZcXHg2ZCcsJ1xceDcwXFx4NzJcXHg2NVxceDJkXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDY0XFx4NzVcXHg2MlxceDJlXFx4NjFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlXFx4MmVcXHg2M1xceDZmXFx4NmQnXTtyZXR1cm4gaG9zdG5hbWUuZW5kc1dpdGgoX2wxbFszXSl8fGhvc3RuYW1lLmVuZHNXaXRoKF9sMWxbMF0pfHxob3N0bmFtZS5lbmRzV2l0aChfbDFsWzRdKXx8aG9zdG5hbWUuZW5kc1dpdGgoX2wxbFsyXSl8fGhvc3RuYW1lLmVuZHNXaXRoKF9sMWxbMV0pO307SG9zdG5hbWVSZXNvbHZlci5nZXRDb3VudHJ5Q29kZVByZWZpeD1mdW5jdGlvbihob3N0bmFtZSl7dmFyIF9paUk9WzAsJ1xceDJlJyw0NjY2NiwxLCdcXHg2NVxceDc4XFx4NjVcXHg2M1xceDc1XFx4NzRcXHg2NScsJ1xceDc1XFx4NzMnLCdcXHgyZCddO3ZhciBzcGxpdHM9aG9zdG5hbWUuc3BsaXQoX2lpSVs2XSk7aWYoc3BsaXRzLmxlbmd0aD5faWlJWzNdKXt2YXIgcHJlZml4XzE9c3BsaXRzW19paUlbMF1dO2lmKHRoaXMuQ09VTlRSWV9DT0RFUy5zb21lKGZ1bmN0aW9uKGUpe3ZhciBfeiR6PVtdO3ZhciBfJDIkelNzc1M9ZnVuY3Rpb24oX2lpMUlMSUxsKXt2YXIgX1pzMj1bLjg4NDI3NTE4OTg0MTM1NjEsJ1xceDc1XFx4NzNcXHg2NVxceDcyXFx4NjFcXHg2N1xceDY1XFx4NmVcXHg3NFxceDU1XFx4NzNcXHg2NVxceDcyXFx4NjFcXHg2N1xceDY1XFx4NmVcXHg3NFxceDRhXFx4NzNcXHg2ZlxceDZlJywnXFx4NjJcXHg2Y1xceDZmXFx4NjJcXHg0M1xceDZmXFx4NmNcXHg2Y1xceDY1XFx4NjNcXHg3NFxceDZmXFx4NzJcXHg0OFxceDYxXFx4NzNcXHg2OCddO3ZhciBfMG8wMG8wUU89X1pzMlsxXSxfc1NaelpaJDI9X1pzMlsyXTtyZXR1cm4gX1pzMlswXTt9O3JldHVybiBlPT09cHJlZml4XzE7fSkpe3JldHVybiBwcmVmaXhfMTt9fXZhciBfME8wUVEwUU89X2lpSVs0XSxfMDBvUTBRT1E9X2lpSVsyXTtzcGxpdHM9aG9zdG5hbWUuc3BsaXQoX2lpSVsxXSk7aWYoc3BsaXRzLmxlbmd0aD5faWlJWzNdKXt2YXIgX0xJTEkxbGlMPWZ1bmN0aW9uKF8wb1EwT1FPMCxfUTAwb1FPMFEpe3ZhciBfU3o9WzI0MDk5LDE5MDQ3LDI2OTksLjMxMDA2NzI5NTQ5NTY5NjY3LCdcXHg2NVxceDZjXFx4NDZcXHg3N1xceDYzXFx4NjlcXHg2ZCddO3ZhciBfaUxsMWkxSWk9X1N6WzFdLF9MMTFJTEkxMT1fU3pbMl07dmFyIF9Tenp6WjIkej1fU3pbM10sX29Pb1FPMFFRPV9Tels0XTtyZXR1cm4gX1N6WzBdO307dmFyIHByZWZpeF8yPXNwbGl0c1tfaWlJWzBdXTtpZih0aGlzLkNPVU5UUllfQ09ERVMuc29tZShmdW5jdGlvbihlKXt2YXIgX1okej1bXTt2YXIgX1EwUVFRUU9RPWZ1bmN0aW9uKF8yeiRTU3NaWixfMG9PUU9vMFEpe3ZhciBfME89WzczNjYsNDcxMzAsJ1xceDYxXFx4NGZcXHg2MlxceDY2XFx4NzVcXHg3M1xceDYzXFx4NjFcXHg3NFxceDY1J107dmFyIF8yWjIyJFokMj1fME9bMV0sX0lMaWxpTExMPV8wT1syXTtyZXR1cm4gXzBPWzBdO307cmV0dXJuIGU9PT1wcmVmaXhfMjt9KSl7cmV0dXJuIHByZWZpeF8yO319cmV0dXJuIF9paUlbNV07fTtIb3N0bmFtZVJlc29sdmVyLmdldENvdW50cnlDb2RlU3VmZml4PWZ1bmN0aW9uKGhvc3RuYW1lKXt2YXIgXyRzej1bJ1xceDc1XFx4NzMnLCdcXHgyZScsMV07dmFyIHNwbGl0cz1ob3N0bmFtZS5zcGxpdChfJHN6WzFdKTtpZihzcGxpdHMubGVuZ3RoPl8kc3pbMl0pe3ZhciBfMFEwTzBvUW89ZnVuY3Rpb24oX3oyU1pTejJTKXt2YXIgX0lsTD1bMzQ5NTMsJ1xceDY1XFx4NmVcXHg2M1xceDcyXFx4NzlcXHg3MFxceDc0XFx4NDZcXHg3N1xceDYzXFx4NjlcXHg2ZCcsJ1xceDZlXFx4NmZcXHg2NFxceDY1XFx4NGNcXHg2OVxceDczXFx4NzQnLC4xNjcxNTIzNDkwOTE4NzI1LDYzNjMsJ1xceDc1XFx4NzNcXHg2NVxceDcyXFx4NjFcXHg2N1xceDY1XFx4NmVcXHg3NCcsMzc1MTcsJ1xceDYyXFx4NmNcXHg2ZlxceDYyJ107dmFyIF9TMlN6eiQycz1fSWxMWzRdLF8wUU9RME9PTz1fSWxMWzddO3ZhciBfUVFRUVFRUTA9X0lsTFs1XSxfMUlpMWxsaUw9X0lsTFswXTt2YXIgXzJzUzJzc1p6PV9JbExbMl0sXyR6MloyUzJ6PV9JbExbMV0sX2kxaTFJMTExPV9JbExbM107cmV0dXJuIF9JbExbNl07fTt2YXIgc3VmZml4XzE9c3BsaXRzW3NwbGl0cy5sZW5ndGgtXyRzelsyXV07aWYodGhpcy5DT1VOVFJZX0NPREVTLnNvbWUoZnVuY3Rpb24oZSl7dmFyIF96Uz1bXTtyZXR1cm4gZT09PXN1ZmZpeF8xO30pKXtyZXR1cm4gc3VmZml4XzE7fX1yZXR1cm4gXyRzelswXTt9O0hvc3RuYW1lUmVzb2x2ZXIuRE9NQUlOX1JFQUxNX0hPU1ROQU1FPXsnXFx4NzRcXHg2NVxceDczXFx4NzRcXHgyZVxceDRlXFx4NDFcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9vb1EwWzgzXSwnXFx4NmRcXHg2MVxceDczXFx4NzRcXHg2NVxceDcyXFx4MmVcXHg0ZVxceDQxXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfb29RMFsyOF0sJ1xceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg0ZVxceDQxXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfb29RMFs2NV0sJ1xceDc0XFx4NjVcXHg3M1xceDc0XFx4MmVcXHg1NVxceDUzXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfb29RMFs4M10sJ1xceDZkXFx4NjFcXHg3M1xceDc0XFx4NjVcXHg3MlxceDJlXFx4NTVcXHg1M1xceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X29vUTBbMjhdLCdcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NTVcXHg1M1xceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X29vUTBbNjVdLCdcXHg3NFxceDY1XFx4NzNcXHg3NFxceDJlXFx4NDNcXHg0MVxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X29vUTBbNDZdLCdcXHg2ZFxceDYxXFx4NzNcXHg3NFxceDY1XFx4NzJcXHgyZVxceDQzXFx4NDFcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9vb1EwWzJdLCdcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NDNcXHg0MVxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X29vUTBbNjBdLCdcXHg3NFxceDY1XFx4NzNcXHg3NFxceDJlXFx4NGRcXHg1OFxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X29vUTBbMjBdLCdcXHg2ZFxceDYxXFx4NzNcXHg3NFxceDY1XFx4NzJcXHgyZVxceDRkXFx4NThcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9vb1EwWzY4XSwnXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDRkXFx4NThcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9vb1EwWzEwXSwnXFx4NzRcXHg2NVxceDczXFx4NzRcXHgyZVxceDQxXFx4NTRcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9vb1EwWzgwXSwnXFx4NmRcXHg2MVxceDczXFx4NzRcXHg2NVxceDcyXFx4MmVcXHg0MVxceDU0XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfb29RMFs4NF0sJ1xceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg0MVxceDU0XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfb29RMFs4XSwnXFx4NzRcXHg2NVxceDczXFx4NzRcXHgyZVxceDUzXFx4NDdcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9vb1EwWzQ1XSwnXFx4NmRcXHg2MVxceDczXFx4NzRcXHg2NVxceDcyXFx4MmVcXHg1M1xceDQ3XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfb29RMFsxOV0sJ1xceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg1M1xceDQ3XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfb29RMFs2XSwnXFx4NzRcXHg2NVxceDczXFx4NzRcXHgyZVxceDQxXFx4NTVcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9vb1EwWzcwXSwnXFx4NmRcXHg2MVxceDczXFx4NzRcXHg2NVxceDcyXFx4MmVcXHg0MVxceDU1XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfb29RMFs3Nl0sJ1xceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg0MVxceDU1XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfb29RMFs3M10sJ1xceDc0XFx4NjVcXHg3M1xceDc0XFx4MmVcXHg0NFxceDQ1XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfb29RMFszNV0sJ1xceDZkXFx4NjFcXHg3M1xceDc0XFx4NjVcXHg3MlxceDJlXFx4NDRcXHg0NVxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X29vUTBbNjddLCdcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NDRcXHg0NVxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X29vUTBbMjFdLCdcXHg3NFxceDY1XFx4NzNcXHg3NFxceDJlXFx4NDVcXHg1NVxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X29vUTBbMzVdLCdcXHg2ZFxceDYxXFx4NzNcXHg3NFxceDY1XFx4NzJcXHgyZVxceDQ1XFx4NTVcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9vb1EwWzY3XSwnXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDQ1XFx4NTVcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9vb1EwWzIxXSwnXFx4NzRcXHg2NVxceDczXFx4NzRcXHgyZVxceDUwXFx4NGNcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9vb1EwWzc5XSwnXFx4NmRcXHg2MVxceDczXFx4NzRcXHg2NVxceDcyXFx4MmVcXHg1MFxceDRjXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfb29RMFsxNF0sJ1xceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg1MFxceDRjXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfb29RMFsyNl0sJ1xceDc0XFx4NjVcXHg3M1xceDc0XFx4MmVcXHg1NFxceDUyXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfb29RMFs3N10sJ1xceDZkXFx4NjFcXHg3M1xceDc0XFx4NjVcXHg3MlxceDJlXFx4NTRcXHg1MlxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X29vUTBbNDFdLCdcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NTRcXHg1MlxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X29vUTBbMTJdLCdcXHg3NFxceDY1XFx4NzNcXHg3NFxceDJlXFx4NDlcXHg1NFxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X29vUTBbMzNdLCdcXHg2ZFxceDYxXFx4NzNcXHg3NFxceDY1XFx4NzJcXHgyZVxceDQ5XFx4NTRcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9vb1EwWzU3XSwnXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDQ5XFx4NTRcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9vb1EwWzMwXSwnXFx4NzRcXHg2NVxceDczXFx4NzRcXHgyZVxceDQxXFx4NDVcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9vb1EwWzMxXSwnXFx4NmRcXHg2MVxceDczXFx4NzRcXHg2NVxceDcyXFx4MmVcXHg0MVxceDQ1XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfb29RMFszOV0sJ1xceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg0MVxceDQ1XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfb29RMFs3MV0sJ1xceDc0XFx4NjVcXHg3M1xceDc0XFx4MmVcXHg0YVxceDUwXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfb29RMFs1Nl0sJ1xceDZkXFx4NjFcXHg3M1xceDc0XFx4NjVcXHg3MlxceDJlXFx4NGFcXHg1MFxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X29vUTBbMTFdLCdcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NGFcXHg1MFxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X29vUTBbNjFdLCdcXHg3NFxceDY1XFx4NzNcXHg3NFxceDJlXFx4NDZcXHg0NVxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X29vUTBbNTZdLCdcXHg2ZFxceDYxXFx4NzNcXHg3NFxceDY1XFx4NzJcXHgyZVxceDQ2XFx4NDVcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9vb1EwWzExXSwnXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDQ2XFx4NDVcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9vb1EwWzYxXSwnXFx4NzRcXHg2NVxceDczXFx4NzRcXHgyZVxceDQ3XFx4NDJcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9vb1EwWzU0XSwnXFx4NmRcXHg2MVxceDczXFx4NzRcXHg2NVxceDcyXFx4MmVcXHg0N1xceDQyXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfb29RMFszNF0sJ1xceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg0N1xceDQyXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfb29RMFs3NF0sJ1xceDc0XFx4NjVcXHg3M1xceDc0XFx4MmVcXHg1NVxceDRiXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfb29RMFs1NF0sJ1xceDZkXFx4NjFcXHg3M1xceDc0XFx4NjVcXHg3MlxceDJlXFx4NTVcXHg0YlxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X29vUTBbMzRdLCdcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NTVcXHg0YlxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X29vUTBbNzRdLCdcXHg3NFxceDY1XFx4NzNcXHg3NFxceDJlXFx4NTNcXHg0MVxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X29vUTBbNF0sJ1xceDZkXFx4NjFcXHg3M1xceDc0XFx4NjVcXHg3MlxceDJlXFx4NTNcXHg0MVxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X29vUTBbNjldLCdcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NTNcXHg0MVxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X29vUTBbMzZdLCdcXHg3NFxceDY1XFx4NzNcXHg3NFxceDJlXFx4NDlcXHg0ZVxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X29vUTBbMzJdLCdcXHg2ZFxceDYxXFx4NzNcXHg3NFxceDY1XFx4NzJcXHgyZVxceDQ5XFx4NGVcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9vb1EwWzY0XSwnXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDQ5XFx4NGVcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9vb1EwWzUzXSwnXFx4NzRcXHg2NVxceDczXFx4NzRcXHgyZVxceDQ1XFx4NDdcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9vb1EwWzc1XSwnXFx4NmRcXHg2MVxceDczXFx4NzRcXHg2NVxceDcyXFx4MmVcXHg0NVxceDQ3XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfb29RMFs1XSwnXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDQ1XFx4NDdcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9vb1EwWzE2XSwnXFx4NzRcXHg2NVxceDczXFx4NzRcXHgyZVxceDQ2XFx4NTJcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9vb1EwWzU1XSwnXFx4NmRcXHg2MVxceDczXFx4NzRcXHg2NVxceDcyXFx4MmVcXHg0NlxceDUyXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfb29RMFszXSwnXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDQ2XFx4NTJcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9vb1EwWzQ3XSwnXFx4NzRcXHg2NVxceDczXFx4NzRcXHgyZVxceDQ1XFx4NTNcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9vb1EwWzldLCdcXHg2ZFxceDYxXFx4NzNcXHg3NFxceDY1XFx4NzJcXHgyZVxceDQ1XFx4NTNcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9vb1EwWzFdLCdcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NDVcXHg1M1xceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X29vUTBbNDBdLCdcXHg3NFxceDY1XFx4NzNcXHg3NFxceDJlXFx4NGVcXHg0Y1xceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X29vUTBbNDldLCdcXHg2ZFxceDYxXFx4NzNcXHg3NFxceDY1XFx4NzJcXHgyZVxceDRlXFx4NGNcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9vb1EwWzc4XSwnXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZVxceDRlXFx4NGNcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9vb1EwWzM3XSwnXFx4NzRcXHg2NVxceDczXFx4NzRcXHgyZVxceDUzXFx4NDVcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnOl9vb1EwWzI1XSwnXFx4NmRcXHg2MVxceDczXFx4NzRcXHg2NVxceDcyXFx4MmVcXHg1M1xceDQ1XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfb29RMFs2Ml0sJ1xceDcwXFx4NzJcXHg2ZlxceDY0XFx4MmVcXHg1M1xceDQ1XFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfb29RMFs0Ml0sJ1xceDc0XFx4NjVcXHg3M1xceDc0XFx4MmVcXHg0MlxceDUyXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJzpfb29RMFs2M10sJ1xceDZkXFx4NjFcXHg3M1xceDc0XFx4NjVcXHg3MlxceDJlXFx4NDJcXHg1MlxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X29vUTBbMTVdLCdcXHg3MFxceDcyXFx4NmZcXHg2NFxceDJlXFx4NDJcXHg1MlxceDQxXFx4NmRcXHg2MVxceDdhXFx4NmZcXHg2ZSc6X29vUTBbNTldfTtIb3N0bmFtZVJlc29sdmVyLkNPVU5UUllfQ09ERVM9W19vb1EwWzBdLF9vb1EwWzEzXSxfb29RMFs0OF0sX29vUTBbMjldLF9vb1EwWzI0XSxfb29RMFs1Ml0sX29vUTBbN10sX29vUTBbNThdLF9vb1EwWzQzXSxfb29RMFs0NF0sX29vUTBbMjJdLF9vb1EwWzgxXSxfb29RMFsyN10sX29vUTBbMTddLF9vb1EwWzgyXSxfb29RMFs1MV0sX29vUTBbMThdLF9vb1EwWzM4XSxfb29RMFs3Ml0sX29vUTBbNjZdLF9vb1EwWzIzXSxfb29RMFs1MF1dO3JldHVybiBIb3N0bmFtZVJlc29sdmVyO30oKTtleHBvcnRzLkhvc3RuYW1lUmVzb2x2ZXI9SG9zdG5hbWVSZXNvbHZlcjsiLCInXFx4NzVcXHg3M1xceDY1XFx4MjBcXHg3M1xceDc0XFx4NzJcXHg2OVxceDYzXFx4NzQnO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCdcXHg1ZlxceDVmXFx4NjVcXHg3M1xceDRkXFx4NmZcXHg2NFxceDc1XFx4NmNcXHg2NScse3ZhbHVlOnRydWV9KTt2YXIgSG9zdG5hbWVSZXNvbHZlcl8xPXJlcXVpcmUoJ1xceDJlXFx4MmZcXHg0OFxceDZmXFx4NzNcXHg3NFxceDZlXFx4NjFcXHg2ZFxceDY1XFx4NTJcXHg2NVxceDczXFx4NmZcXHg2Y1xceDc2XFx4NjVcXHg3MicpO3ZhciBLYXRhbEVuZHBvaW50UmVzb2x2ZXI9ZnVuY3Rpb24oKXt2YXIgX2wxST1bMjE4ODMsJ1xceDY4XFx4NzRcXHg3NFxceDcwXFx4NzNcXHgzYVxceDJmXFx4MmZcXHg3OVxceDMzXFx4NmFcXHgzNVxceDY3XFx4MzlcXHg2NVxceDM2XFx4NzlcXHgzNFxceDJlXFx4NjVcXHg3OFxceDY1XFx4NjNcXHg3NVxceDc0XFx4NjVcXHgyZFxceDYxXFx4NzBcXHg2OVxceDJlXFx4NzVcXHg3M1xceDJkXFx4NjVcXHg2MVxceDczXFx4NzRcXHgyZFxceDMxXFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHg2MVxceDc3XFx4NzNcXHgyZVxceDYzXFx4NmZcXHg2ZFxceDJmXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZlxceDc2XFx4MzFcXHgyZlxceDZjXFx4NmZcXHg2NycsLjYzNzcwMDI3MTM2MTYxNDcsJ1xceDY4XFx4NzRcXHg3NFxceDcwXFx4NzNcXHgzYVxceDJmXFx4MmZcXHg3NlxceDMzXFx4MzJcXHg2MlxceDY3XFx4NjdcXHg2MlxceDZkXFx4NmFcXHg2MVxceDJlXFx4NjVcXHg3OFxceDY1XFx4NjNcXHg3NVxceDc0XFx4NjVcXHgyZFxceDYxXFx4NzBcXHg2OVxceDJlXFx4NzVcXHg3M1xceDJkXFx4NzdcXHg2NVxceDczXFx4NzRcXHgyZFxceDMyXFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHg2MVxceDc3XFx4NzNcXHgyZVxceDYzXFx4NmZcXHg2ZFxceDJmXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZlxceDc2XFx4MzFcXHgyZlxceDZjXFx4NmZcXHg2NycsJ1xceDY4XFx4NzRcXHg3NFxceDcwXFx4NzNcXHgzYVxceDJmXFx4MmZcXHg2ZFxceDYyXFx4NjRcXHg3NlxceDY3XFx4NmZcXHg2YVxceDMyXFx4MzdcXHg2OFxceDJlXFx4NjVcXHg3OFxceDY1XFx4NjNcXHg3NVxceDc0XFx4NjVcXHgyZFxceDYxXFx4NzBcXHg2OVxceDJlXFx4NzVcXHg3M1xceDJkXFx4NjVcXHg2MVxceDczXFx4NzRcXHgyZFxceDMxXFx4MmVcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHg2MVxceDc3XFx4NzNcXHgyZVxceDYzXFx4NmZcXHg2ZFxceDJmXFx4NzBcXHg3MlxceDZmXFx4NjRcXHgyZlxceDc2XFx4MzFcXHgyZlxceDZjXFx4NmZcXHg2NycsJ1xceDYxXFx4NDZcXHg3N1xceDYzXFx4NjlcXHg2ZFxceDQyJyw0MzQwNywnXFx4NjFcXHg3MCcsJ1xceDcwXFx4NzJcXHg2ZlxceDY0JywnXFx4NjdcXHg2MVxceDZkXFx4NmRcXHg2MScsJ1xceDYyXFx4NjVcXHg3NFxceDYxJ107ZnVuY3Rpb24gS2F0YWxFbmRwb2ludFJlc29sdmVyKCl7dmFyIF9saUlsaWwxTD1fbDFJWzZdLF9zc3NaJHN6Uz1fbDFJWzJdO31LYXRhbEVuZHBvaW50UmVzb2x2ZXIuZ2V0S2F0YWxMb2dnZXJFbmRwb2ludD1mdW5jdGlvbigpe3ZhciBfT289W107dmFyIHN0YWdlPXRoaXMuZ2V0U3RhZ2VCeUhvc3RuYW1lKHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpKTtyZXR1cm4gdGhpcy5LQVRBTF9MT0dHRVJfRU5EUE9JTlRTX01BUFtzdGFnZV07fTt2YXIgX1pzMlNaMlpTPV9sMUlbNV0sX09vUTBRUW9vPV9sMUlbMF07S2F0YWxFbmRwb2ludFJlc29sdmVyLmdldFN0YWdlQnlIb3N0bmFtZT1mdW5jdGlvbihob3N0bmFtZSl7dmFyIF9MaT1bMTg3NzMsMjAzMDIsLjYwODM3MzkyNjU1MTcyNTQsMjM3MjJdO3ZhciBfMFEwbzBvUVE9X0xpWzJdLF9saUxJTExpST1fTGlbM107aWYoSG9zdG5hbWVSZXNvbHZlcl8xLkhvc3RuYW1lUmVzb2x2ZXIuaXNEZXZlbG9wbWVudChob3N0bmFtZSkpe3ZhciBfME9vT09RMDA9ZnVuY3Rpb24oXzFJSWxJbGwxLF8wbzBvb09vUSxfJDIkU3oyc3ope3ZhciBfWiQ9WydcXHg2YVxceDczXFx4NmZcXHg2ZVxceDQ5XFx4NjRcXHg0OVxceDY0JywyODg2OCwnXFx4NjhcXHg2MVxceDczXFx4NjhcXHg0NFxceDZmXFx4NjNcXHg3NVxceDZkXFx4NjVcXHg2ZVxceDc0JywyMjk2LC4wMDY0MjQxNTk5NDAzMTYzMSw0NTQyNV07dmFyIF9vT28wb09Rbz1fWiRbNV0sX1N6eloyJCRaPV9aJFs0XTt2YXIgX1NTc3MkejJTPV9aJFsxXTt2YXIgXzJzWnpTcyRzPV9aJFsyXSxfaWwxaUlMSWk9X1okWzBdO3JldHVybiBfWiRbM107fTtyZXR1cm4gdGhpcy5CRVRBX1NUQUdFO31lbHNlIGlmKEhvc3RuYW1lUmVzb2x2ZXJfMS5Ib3N0bmFtZVJlc29sdmVyLmlzUHJlUHJvZChob3N0bmFtZSkpe3ZhciBfaUxsSTFMbGw9X0xpWzFdLF9MMWxMbElsbD1fTGlbMF07cmV0dXJuIHRoaXMuR0FNTUFfU1RBR0U7fXJldHVybiB0aGlzLlBST0RfU1RBR0U7fTtLYXRhbEVuZHBvaW50UmVzb2x2ZXIuZ2V0U3RhZ2VCeUhvc3RDb25maWc9ZnVuY3Rpb24oaG9zdENvbmZpZyl7dmFyIF9Tcz1bJ1xceDcwXFx4NzJcXHg2ZlxceDY0JywnXFx4NzRcXHg2NVxceDczXFx4NzQnLCdcXHg2ZVxceDc1XFx4NmNcXHg2Y1xceDQ4XFx4NmZcXHg3M1xceDc0XFx4NDNcXHg2ZlxceDZlXFx4NjZcXHg2OVxceDY3JywnXFx4NmRcXHg2MVxceDczXFx4NzRcXHg2NVxceDcyJywwLCdcXHgyZSddO3ZhciBjb25maWd1cmF0aW9uPV9Tc1syXTt2YXIgX3pzJHp6MjIkPWZ1bmN0aW9uKF9RUVFRb1FvMCl7dmFyIF9saT1bLjM1OTA3NDkxNDQ5NDkyODU3LCdcXHg2NVxceDZjJywnXFx4NjEnLC40NDYyMzYyMTA1NjE2MjEzXTt2YXIgX3N6c1NTJFN6PV9saVszXSxfSWlsbEkxTEw9X2xpWzBdLF8kU1MyMiRTJD1fbGlbMV07cmV0dXJuIF9saVsyXTt9O2lmKGhvc3RDb25maWcpe2NvbmZpZ3VyYXRpb249aG9zdENvbmZpZy5zcGxpdChfU3NbNV0pW19Tc1s0XV07fXN3aXRjaChjb25maWd1cmF0aW9uKXtjYXNlIF9Tc1sxXTpyZXR1cm4gdGhpcy5CRVRBX1NUQUdFO2Nhc2UgX1NzWzNdOnJldHVybiB0aGlzLkdBTU1BX1NUQUdFO2Nhc2UgX1NzWzBdOnJldHVybiB0aGlzLlBST0RfU1RBR0U7ZGVmYXVsdDpyZXR1cm4gdGhpcy5nZXRTdGFnZUJ5SG9zdG5hbWUod2luZG93LmxvY2F0aW9uLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCkpO319O0thdGFsRW5kcG9pbnRSZXNvbHZlci5nZXRQYWdlVHlwZU1ldHJpY05hbWU9ZnVuY3Rpb24oY2xpZW50RGF0YSl7dmFyIF9zWj1bJ1xceDJlJywnXFx4NjNcXHg2ZlxceDZjXFx4NmNcXHg2NVxceDYzXFx4NzRcXHg2ZlxceDcyJywnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZFxceDYzXFx4NmZcXHg2ZVxceDc0XFx4NjVcXHg3OFxceDc0JywnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZFxceDcyXFx4NjVcXHg2NlxceDJkXFx4NjlcXHg2NCcsJ1xceDY1XFx4NzhcXHg2NVxceDYzXFx4NzVcXHg3NFxceDY1XFx4NDVcXHg2ZVxceDYzXFx4NzJcXHg3OVxceDcwXFx4NzQnXTtpZihjbGllbnREYXRhW19zWlszXV09PXRoaXMuQVBfQ0xJRU5UX0lEJiZjbGllbnREYXRhW19zWlsyXV0pe3ZhciBfSWlpSUxpbDE9X3NaWzRdLF96JHp6Wnpaej1fc1pbMV07dHJ5e3ZhciBjbGllbnRDb250ZXh0PUpTT04ucGFyc2UoY2xpZW50RGF0YVtfc1pbMl1dKTtyZXR1cm4gY2xpZW50Q29udGV4dC5wYWdlVHlwZT9fc1pbMF0rY2xpZW50Q29udGV4dC5wYWdlVHlwZTp0aGlzLkVNUFRZX1NUUklORzt9Y2F0Y2goZXJyKXt2YXIgX0lpSUlpbEkxPWZ1bmN0aW9uKF9sMUlsSWlMbCxfbGlsMUxsSTEpe3ZhciBfb29vMD1bJ1xceDY2XFx4NzdcXHg2M1xceDY5XFx4NmRcXHg0NlxceDc3XFx4NjNcXHg2OVxceDZkJywnXFx4NjZcXHg3N1xceDYzXFx4NjlcXHg2ZCcsLjc1MTYzMzkwNjk3NTQzMTIsLjQ5NjM1NTU2NDY1Mzc0MDEsLjg0MTg3NDczMDIyODcyOTddO3ZhciBfUzJTWnNzJFo9X29vbzBbMl0sXzBPUVFRT1FPPV9vb28wWzBdLF9TWjIyMiQyWj1fb29vMFs0XTt2YXIgX29RMDAwT1FvPV9vb28wWzFdO3JldHVybiBfb29vMFszXTt9O3JldHVybiB0aGlzLkVNUFRZX1NUUklORzt9fXJldHVybiB0aGlzLkVNUFRZX1NUUklORzt9O0thdGFsRW5kcG9pbnRSZXNvbHZlci5CRVRBX1NUQUdFPV9sMUlbMTBdO0thdGFsRW5kcG9pbnRSZXNvbHZlci5HQU1NQV9TVEFHRT1fbDFJWzldO0thdGFsRW5kcG9pbnRSZXNvbHZlci5QUk9EX1NUQUdFPV9sMUlbOF07S2F0YWxFbmRwb2ludFJlc29sdmVyLktBVEFMX0xPR0dFUl9FTkRQT0lOVFNfTUFQPXsnXFx4NjJcXHg2NVxceDc0XFx4NjEnOl9sMUlbM10sJ1xceDY3XFx4NjFcXHg2ZFxceDZkXFx4NjEnOl9sMUlbMV0sJ1xceDcwXFx4NzJcXHg2ZlxceDY0JzpfbDFJWzRdfTtLYXRhbEVuZHBvaW50UmVzb2x2ZXIuRU1QVFlfU1RSSU5HPScnO0thdGFsRW5kcG9pbnRSZXNvbHZlci5BUF9DTElFTlRfSUQ9X2wxSVs3XTtyZXR1cm4gS2F0YWxFbmRwb2ludFJlc29sdmVyO30oKTtleHBvcnRzLkthdGFsRW5kcG9pbnRSZXNvbHZlcj1LYXRhbEVuZHBvaW50UmVzb2x2ZXI7IiwiJ1xceDc1XFx4NzNcXHg2NVxceDIwXFx4NzNcXHg3NFxceDcyXFx4NjlcXHg2M1xceDc0Jzt2YXIgX19pbXBvcnREZWZhdWx0PXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihtb2Qpe3ZhciBfMlM9W107dmFyIF8kU1okUyRTcz1mdW5jdGlvbihfUzJTU3NTenosX3NTMnN6ejIkLF9Pb1FRT28wUSl7dmFyIF9paT1bJ1xceDYyXFx4NmZcXHg2NFxceDc5XFx4NDInLCdcXHg2ZlxceDYyXFx4NjZcXHg3NVxceDczXFx4NjNcXHg2MVxceDc0XFx4NjUnLCdcXHg2MlxceDQyXFx4NmNcXHg2ZlxceDYyJ107dmFyIF9MSWlMMUlMST1faWlbMV0sX29RMFEwUW9vPV9paVsyXTtyZXR1cm4gX2lpWzBdO307cmV0dXJuIG1vZCYmbW9kLl9fZXNNb2R1bGU/bW9kOnsnXFx4NjRcXHg2NVxceDY2XFx4NjFcXHg3NVxceDZjXFx4NzQnOm1vZH07fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywnXFx4NWZcXHg1ZlxceDY1XFx4NzNcXHg0ZFxceDZmXFx4NjRcXHg3NVxceDZjXFx4NjUnLHt2YWx1ZTp0cnVlfSk7dmFyIGJ1aWxkX3VybF90c18xPV9faW1wb3J0RGVmYXVsdChyZXF1aXJlKCdcXHg2MlxceDc1XFx4NjlcXHg2Y1xceDY0XFx4MmRcXHg3NVxceDcyXFx4NmNcXHgyZFxceDc0XFx4NzMnKSk7cmVxdWlyZSgnXFx4MmVcXHgyZlxceDYzXFx4NzNcXHg3M1xceDJmXFx4NjlcXHg2NlxceDcyXFx4NjFcXHg2ZFxceDY1XFx4MmVcXHg2M1xceDczXFx4NzMnKTt2YXIgQUNJQ1Nlc3Npb25Db250ZXh0XzE9cmVxdWlyZSgnXFx4MmVcXHgyZlxceDY0XFx4NjFcXHg3NFxceDYxXFx4MmZcXHg0MVxceDQzXFx4NDlcXHg0M1xceDUzXFx4NjVcXHg3M1xceDczXFx4NjlcXHg2ZlxceDZlXFx4NDNcXHg2ZlxceDZlXFx4NzRcXHg2NVxceDc4XFx4NzQnKTt2YXIgQUNJQ0NsaWVudFJlcXVlc3RfMT1yZXF1aXJlKCdcXHgyZVxceDJmXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZlxceDQxXFx4NDNcXHg0OVxceDQzXFx4NDNcXHg2Y1xceDY5XFx4NjVcXHg2ZVxceDc0XFx4NTJcXHg2NVxceDcxXFx4NzVcXHg2NVxceDczXFx4NzQnKTt2YXIgQUFtYXRpb25SZXN1bHRfMT1yZXF1aXJlKCdcXHgyZVxceDJmXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZlxceDQxXFx4NDFcXHg2ZFxceDYxXFx4NzRcXHg2OVxceDZmXFx4NmVcXHg1MlxceDY1XFx4NzNcXHg3NVxceDZjXFx4NzQnKTt2YXIgQUNJQ1VzZXJSZXNwb25zZV8xPXJlcXVpcmUoJ1xceDJlXFx4MmZcXHg2NFxceDYxXFx4NzRcXHg2MVxceDJmXFx4NDFcXHg0M1xceDQ5XFx4NDNcXHg1NVxceDczXFx4NjVcXHg3MlxceDUyXFx4NjVcXHg3M1xceDcwXFx4NmZcXHg2ZVxceDczXFx4NjUnKTt2YXIgSG9zdG5hbWVSZXNvbHZlcl8xPXJlcXVpcmUoJ1xceDJlXFx4MmZcXHg0OFxceDZmXFx4NzNcXHg3NFxceDZlXFx4NjFcXHg2ZFxceDY1XFx4NTJcXHg2NVxceDczXFx4NmZcXHg2Y1xceDc2XFx4NjVcXHg3MicpO3ZhciBBQ0lDRXJyb3JfMT1yZXF1aXJlKCdcXHgyZVxceDJmXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZlxceDQxXFx4NDNcXHg0OVxceDQzXFx4NDVcXHg3MlxceDcyXFx4NmZcXHg3MicpO3ZhciBrYXRhbF9sb2dnZXJfMT1fX2ltcG9ydERlZmF1bHQocmVxdWlyZSgnXFx4NDBcXHg2MVxceDZkXFx4N2FcXHg2ZVxceDJmXFx4NmJcXHg2MVxceDc0XFx4NjFcXHg2Y1xceDJkXFx4NmNcXHg2ZlxceDY3XFx4NjdcXHg2NVxceDcyJykpO3ZhciBLYXRhbEVuZHBvaW50UmVzb2x2ZXJfMT1yZXF1aXJlKCdcXHgyZVxceDJmXFx4NGJcXHg2MVxceDc0XFx4NjFcXHg2Y1xceDQ1XFx4NmVcXHg2NFxceDcwXFx4NmZcXHg2OVxceDZlXFx4NzRcXHg1MlxceDY1XFx4NzNcXHg2ZlxceDZjXFx4NzZcXHg2NVxceDcyJyk7dmFyIGthdGFsX21ldHJpY3NfMT1yZXF1aXJlKCdcXHg0MFxceDYxXFx4NmRcXHg3YVxceDZlXFx4MmZcXHg2YlxceDYxXFx4NzRcXHg2MVxceDZjXFx4MmRcXHg2ZFxceDY1XFx4NzRcXHg3MlxceDY5XFx4NjNcXHg3MycpO3ZhciBrYXRhbF9tZXRyaWNzX2RyaXZlcl9zdXNoaV8xPV9faW1wb3J0RGVmYXVsdChyZXF1aXJlKCdcXHg0MFxceDYxXFx4NmRcXHg3YVxceDZlXFx4MmZcXHg2YlxceDYxXFx4NzRcXHg2MVxceDZjXFx4MmRcXHg2ZFxceDY1XFx4NzRcXHg3MlxceDY5XFx4NjNcXHg3M1xceDJkXFx4NjRcXHg3MlxceDY5XFx4NzZcXHg2NVxceDcyXFx4MmRcXHg3M1xceDc1XFx4NzNcXHg2OFxceDY5JykpO3ZhciByZXNpemVfb2JzZXJ2ZXJfcG9seWZpbGxfMT1fX2ltcG9ydERlZmF1bHQocmVxdWlyZSgnXFx4NzJcXHg2NVxceDczXFx4NjlcXHg3YVxceDY1XFx4MmRcXHg2ZlxceDYyXFx4NzNcXHg2NVxceDcyXFx4NzZcXHg2NVxceDcyXFx4MmRcXHg3MFxceDZmXFx4NmNcXHg3OVxceDY2XFx4NjlcXHg2Y1xceDZjJykpO3ZhciBBQ0lDPWZ1bmN0aW9uKCl7dmFyIF8kMj1bJ1xceDZhXFx4NzNcXHg2ZlxceDZlXFx4NDRcXHg2ZlxceDYzXFx4NzVcXHg2ZFxceDY1XFx4NmVcXHg3NFxceDQ1XFx4NmMnLCdcXHg3M1xceDc0XFx4NjFcXHg3NFxceDY5XFx4NjNcXHg1M1xceDY1XFx4NzNcXHg3M1xceDY5XFx4NmZcXHg2ZVxceDU0XFx4NmZcXHg2YlxceDY1XFx4NmUnLCdcXHg2MVxceDZkXFx4N2FcXHgyZFxceDYxXFx4NjFcXHg2ZFxceDYxXFx4NzRcXHg2OVxceDZmXFx4NmVcXHgyZFxceDcyXFx4NjVcXHg3M1xceDcwJyxudWxsLHRydWUsJ1xceDczXFx4NzRcXHg2MVxceDc0XFx4NjlcXHg2M1xceDQzXFx4NmNcXHg2OVxceDY1XFx4NmVcXHg3NFxceDQzXFx4NmZcXHg2ZVxceDc0XFx4NjVcXHg3OFxceDc0JywyNzU5NSwnXFx4NDFcXHg0M1xceDQ5XFx4NDMnLDMsJ1xceDUwXFx4NDFcXHg1M1xceDUzJywxNWUzLCdcXHgzMScsJ1xceDJmXFx4NjFcXHg2MVxceDc1XFx4NzRcXHgyZlxceDc2XFx4NjVcXHg3MlxceDY5XFx4NjZcXHg3OVxceDJmJywyMjg5OSwnXFx4NmZcXHg2ZVxceDY1XFx4NzJcXHg3MlxceDZmXFx4NzInXTtmdW5jdGlvbiBBQ0lDKGFjaWNLYXRhbExvZ2dlcil7dGhpcy5sb2dnZXI9e2xvZzpmdW5jdGlvbihhcmdzKXt2YXIgX2lpbD1bXTt2YXIgX0xsMUxpaWxsPWZ1bmN0aW9uKF9RUVFRT1FPbyxfUTBPb1EwMFEpe3ZhciBfJFo9Wy43NDA0Nzg1Mzg5NTAwOTA3LCdcXHg2M1xceDZmXFx4NmNcXHg2Y1xceDY1XFx4NjNcXHg3NFxceDZmXFx4NzJcXHg0NFxceDYxXFx4NzRcXHg2MScsODg3NywnXFx4NjJcXHg2ZlxceDY0XFx4NzlcXHg0OFxceDYxXFx4NzNcXHg2OCcsJ1xceDYyXFx4NmNcXHg2ZlxceDYyXFx4NGZcXHg2MlxceDY2XFx4NzVcXHg3M1xceDYzXFx4NjFcXHg3NFxceDY1J107dmFyIF9JTExsTExMTD1fJFpbM10sX09RT09PUTBPPV8kWls0XSxfJFp6JHpaczI9XyRaWzFdO3ZhciBfTzBPb1EwUU89XyRaWzJdO3JldHVybiBfJFpbMF07fTt9fTt0aGlzLnNlc3Npb25Db250ZXh0PW5ldyBBQ0lDU2Vzc2lvbkNvbnRleHRfMS5BQ0lDU2Vzc2lvbkNvbnRleHQoKTt0aGlzLl9vbmVycm9yPV8kMlszXTtpZihhY2ljS2F0YWxMb2dnZXIhPV8kMlszXSl7dGhpcy5hY2ljS2F0YWxMb2dnZXI9YWNpY0thdGFsTG9nZ2VyO31lbHNle3ZhciBfbDFsSWwxaUk9XyQyWzZdO3RoaXMuYWNpY0thdGFsTG9nZ2VyPXRoaXMuc2V0dXBLYXRhbExvZ2dlcigpO312YXIgX29PUU9vUU9RPWZ1bmN0aW9uKF9Rb09vbzBvTyl7dmFyIF8wMD1bMTQ2MDgsJ1xceDY0XFx4NmZcXHg2M1xceDc1XFx4NmRcXHg2NVxceDZlXFx4NzRcXHg0MlxceDZjXFx4NmZcXHg2MlxceDRhXFx4NzNcXHg2ZlxceDZlJywnXFx4NjJcXHg2Y1xceDZmXFx4NjInXTt2YXIgXzBvUVFRT08wPV8wMFsxXTt2YXIgX29vb1Ewb1FvPV8wMFsyXTtyZXR1cm4gXzAwWzBdO307dGhpcy5zZXR1cElmcmFtZUV2ZW50TGlzdGVuZXIoKTt9QUNJQy5wcm90b3R5cGUuc2V0dXBBQ0lDPWZ1bmN0aW9uKGNsaWVudElucHV0RGF0YSl7dmFyIF8wbz1bJ1xceDY0XFx4NjFcXHg3NFxceDYxXFx4MmRcXHg2OFxceDZmXFx4NzNcXHg3NFxceDJkXFx4NjNcXHg2ZlxceDZlXFx4NjZcXHg2OVxceDY3JywnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZFxceDc0XFx4NjlcXHg2ZFxceDY1XFx4NmZcXHg3NVxceDc0JyxmYWxzZSwnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZFxceDY4XFx4NmZcXHg3M1xceDc0JywnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZFxceDY5XFx4NjZcXHg3MlxceDYxXFx4NmRcXHg2NVxceDJkXFx4NjlcXHg2NCcsJ1xceDY0XFx4NjFcXHg3NFxceDYxXFx4MmRcXHg2NVxceDcyXFx4NzJcXHg2ZlxceDcyXFx4MmRcXHg2M1xceDYxXFx4NmNcXHg2Y1xceDYyXFx4NjFcXHg2M1xceDZiJywzODExLCdcXHg2NFxceDYxXFx4NzRcXHg2MVxceDJkXFx4NmRcXHg2ZlxceDY0XFx4NjUnLCdcXHg2NFxceDYxXFx4NzRcXHg2MVxceDJkXFx4NzVcXHg3M1xceDY1XFx4MmRcXHg3MFxceDZmXFx4NzNcXHg3NFxceDJkXFx4NzJcXHg2NVxceDcxXFx4NzVcXHg2NVxceDczXFx4NzRcXHgyZFxceDZkXFx4NjVcXHg3NFxceDY4XFx4NmZcXHg2NCcsbnVsbF07dmFyIHNlcnZpY2VIb3N0PWNsaWVudElucHV0RGF0YVtfMG9bM11dfHxfMG9bOV07dmFyIGNvbmZpZ3VyYXRpb249Y2xpZW50SW5wdXREYXRhW18wb1swXV18fF8wb1s5XTt0aGlzLnNldFNlcnZpY2VIb3N0KHNlcnZpY2VIb3N0LGNvbmZpZ3VyYXRpb24pO3RoaXMuX29uZXJyb3I9Y2xpZW50SW5wdXREYXRhW18wb1s1XV18fF8wb1s5XTt0aGlzLnNldENsaWVudFJlcXVlc3QoY2xpZW50SW5wdXREYXRhKTt0aGlzLm1vZGU9Y2xpZW50SW5wdXREYXRhW18wb1s3XV18fF8wb1s5XTt2YXIgX3paU1p6WnpTPV8wb1s2XTt0aGlzLnRpbWVvdXQ9Y2xpZW50SW5wdXREYXRhW18wb1sxXV18fEFDSUMuREVGQVVMVF9SRVFVRVNUX1RJTUVPVVQ7dGhpcy51c2VSZXF1ZXN0TWV0aG9kUG9zdD1jbGllbnRJbnB1dERhdGFbXzBvWzhdXXx8XzBvWzJdO3RoaXMuZW5hYmxlQ3VzdG9taXplZElmcmFtZT1jbGllbnRJbnB1dERhdGFbXzBvWzRdXTtpZih0aGlzLmVuYWJsZUN1c3RvbWl6ZWRJZnJhbWUpe3ZhciBfMTFJaUlpaUk9ZnVuY3Rpb24oX3NzWlp6WlpzKXt2YXIgX29vPVsnXFx4NjNcXHg2ZlxceDZjXFx4NmNcXHg2NVxceDYzXFx4NzRcXHg2ZlxceDcyXFx4NDFcXHg2ZFxceDYxXFx4N2FcXHg2ZlxceDZlJywuNTg0MDExMTIwNDc5MzEwOCwnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHg0MlxceDZjXFx4NmZcXHg2MicsJ1xceDczXFx4NzRcXHg2MVxceDc0XFx4NjVcXHg2ZFxceDY1XFx4NmVcXHg3NFxceDRhXFx4NzNcXHg2ZlxceDZlJywyNzkzMSwxNDMzNF07dmFyIF9MbDFMaUwxST1fb29bM10sX29Rb09vb28wPV9vb1s0XTt2YXIgXyRTJHNzMjJ6PV9vb1sxXSxfc3MyMiR6cyQ9X29vWzJdLF9RTzBPUU9RMD1fb29bNV07cmV0dXJuIF9vb1swXTt9O3RoaXMuaWZyYW1lPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNsaWVudElucHV0RGF0YVtfMG9bNF1dKTt9dGhpcy5zZXRLYXRhbE1ldHJpY3MoY2xpZW50SW5wdXREYXRhKTt0aGlzLnNlbmRBcm5vbGRIdHRwUmVxdWVzdCh0aGlzLmNyZWF0ZU5ld1Nlc3Npb25SZXF1ZXN0VVJMKCksdGhpcy50aW1lb3V0KTt9O0FDSUMucHJvdG90eXBlLnNldHVwQUNJQ2ZvckFzeW5jUmVwb3J0aW5nPWZ1bmN0aW9uKGNsaWVudElucHV0RGF0YSl7dmFyIF9PUU89WydcXHg2NFxceDYxXFx4NzRcXHg2MVxceDJkXFx4NjhcXHg2ZlxceDczXFx4NzRcXHgyZFxceDYzXFx4NmZcXHg2ZVxceDY2XFx4NjlcXHg2NycsJ1xceDY0XFx4NjFcXHg3NFxceDYxXFx4MmRcXHg2OFxceDZmXFx4NzNcXHg3NCcsbnVsbF07dmFyIHNlcnZpY2VIb3N0PWNsaWVudElucHV0RGF0YVtfT1FPWzFdXXx8X09RT1syXTt2YXIgY29uZmlndXJhdGlvbj1jbGllbnRJbnB1dERhdGFbX09RT1swXV18fF9PUU9bMl07dGhpcy5zZXRTZXJ2aWNlSG9zdChzZXJ2aWNlSG9zdCxjb25maWd1cmF0aW9uKTt0aGlzLnNldENsaWVudFJlcXVlc3QoY2xpZW50SW5wdXREYXRhKTt2YXIgX2lpMWkxbExMPWZ1bmN0aW9uKF8kMlNTc1okJCxfTExsMWxpMTEpe3ZhciBfUU89WydcXHg2NVxceDc4XFx4NjVcXHg2M1xceDc1XFx4NzRcXHg2NVxceDQ0XFx4NjFcXHg3NFxceDYxJywuMzUyMTgxOTMxMTQ3MzY4NCwnXFx4NjNcXHg2ZlxceDZjXFx4NmNcXHg2NVxceDYzXFx4NzRcXHg2ZlxceDcyJywnXFx4NzVcXHg3M1xceDY1XFx4NzJcXHg2MVxceDY3XFx4NjVcXHg2ZVxceDc0XFx4NDRcXHg2ZlxceDZkXFx4NGNcXHg2OVxceDczXFx4NzQnLDQwNjE5LCdcXHg2M1xceDYxXFx4NzBcXHg3NFxceDYzXFx4NjhcXHg2MVxceDQ0XFx4NmZcXHg2ZCddO3ZhciBfWjIkMlpaMiQ9X1FPWzJdLF9RMDAwT1Fvbz1fUU9bMF07dmFyIF9RMG9PUTBPMD1fUU9bNF0sX1FRTzAwT09vPV9RT1s1XSxfUU9PUVEwUVE9X1FPWzNdO3JldHVybiBfUU9bMV07fTtpZih3aW5kb3cubmF2aWdhdG9yJiZuYXZpZ2F0b3Iuc2VuZEJlYWNvbil7bmF2aWdhdG9yLnNlbmRCZWFjb24odGhpcy5jcmVhdGVOZXdTZXNzaW9uUmVxdWVzdFVSTCgpLEpTT04uc3RyaW5naWZ5KHRoaXMuY2xpZW50UmVxdWVzdCkpO319O09iamVjdC5kZWZpbmVQcm9wZXJ0eShBQ0lDLnByb3RvdHlwZSxfJDJbMTRdLHtzZXQ6ZnVuY3Rpb24ob25FcnJvcil7dmFyIF96Mj1bXTt2YXIgXzIkUzJaenpTPWZ1bmN0aW9uKF96JFMkWiRzJCxfMTFJTElpSWwsX0xpTGlMaTFJKXt2YXIgXzFsPVsuMTEzNDI5MjU4NDU1OTMwNjYsLjY4ODk0NDc4NDU4NTE1MDgsNDk5NCwnXFx4NjNcXHg2MVxceDcwXFx4NzRcXHg2M1xceDY4XFx4NjEnXTt2YXIgX2wxTElMbGwxPV8xbFszXTt2YXIgX28wT09vb1EwPV8xbFsyXSxfb29PUU9Pb1E9XzFsWzBdO3JldHVybiBfMWxbMV07fTt0aGlzLl9vbmVycm9yPW9uRXJyb3I7fSxlbnVtZXJhYmxlOl8kMls0XSxjb25maWd1cmFibGU6XyQyWzRdfSk7QUNJQy5wcm90b3R5cGUuc2V0U2VydmljZUhvc3Q9ZnVuY3Rpb24oc2VydmljZUhvc3QsY29uZmlndXJhdGlvbil7dmFyIF9aUz1bJ1xceDY0XFx4NjFcXHg3NFxceDYxXFx4NDJcXHg2ZlxceDY0XFx4NzknLDQyMTMzLCdcXHg2OFxceDc0XFx4NzRcXHg3MFxceDczXFx4M2FcXHgyZlxceDJmJywnXFx4NjRcXHg2MVxceDc0XFx4NjEnLCdcXHg2NVxceDZlXFx4NjNcXHg3MlxceDc5XFx4NzBcXHg3NCcsMjY2NzAsbnVsbF07aWYoc2VydmljZUhvc3Q9PV9aU1s2XSl7aWYoY29uZmlndXJhdGlvbiE9X1pTWzZdKXt2YXIgX1paWjIyJFpzPV9aU1s0XSxfUW8wMG9Pb089X1pTWzNdO3NlcnZpY2VIb3N0PUhvc3RuYW1lUmVzb2x2ZXJfMS5Ib3N0bmFtZVJlc29sdmVyLmdldFNlcnZpY2VIb3N0bmFtZUJ5Q29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uKTt9ZWxzZXtzZXJ2aWNlSG9zdD1Ib3N0bmFtZVJlc29sdmVyXzEuSG9zdG5hbWVSZXNvbHZlci5nZXRTZXJ2aWNlSG9zdG5hbWVCeUhvc3RuYW1lKHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpKTt9fXZhciBfbGxsTGlJMUw9X1pTWzFdLF9RME9vb08wMD1fWlNbNV0sXzFpTExJaWlMPV9aU1swXTt0aGlzLnNlcnZpY2VFbmRwb2ludD1fWlNbMl0rc2VydmljZUhvc3QrQUNJQy5TRVJWSUNFX0JBU0VfUEFUSDt9O0FDSUMucHJvdG90eXBlLnNldHVwS2F0YWxMb2dnZXI9ZnVuY3Rpb24oKXt2YXIgXzFpPVtdO3ZhciBhY2ljS2F0YWxMb2dnZXI9bmV3IGthdGFsX2xvZ2dlcl8xLmRlZmF1bHQoe3VybDpLYXRhbEVuZHBvaW50UmVzb2x2ZXJfMS5LYXRhbEVuZHBvaW50UmVzb2x2ZXIuZ2V0S2F0YWxMb2dnZXJFbmRwb2ludCgpfSk7cmV0dXJuIGFjaWNLYXRhbExvZ2dlcjt9O0FDSUMucHJvdG90eXBlLnNlbmRFcnJvclRvS2F0YWxMb2dnZXI9ZnVuY3Rpb24oZXJyb3JNZXNzYWdlLGVycm9yQ29udGV4dCl7dmFyIF9aWj1bXTt0cnl7dmFyIF9RUU9RT1FRbz1mdW5jdGlvbihfMUxpTExMaWksXzBRME9RUVFPLF9vUW8wb28wUSl7dmFyIF9TMj1bMTI0MzYsJ1xceDY0XFx4NmZcXHg2ZFxceDQ0XFx4NjFcXHg3NFxceDYxXFx4NDJcXHg2ZlxceDY0XFx4NzknLCdcXHg3NVxceDczXFx4NjVcXHg3MlxceDYxXFx4NjdcXHg2NVxceDZlXFx4NzRcXHg0NlxceDc3XFx4NjNcXHg2OVxceDZkJywnXFx4NjVcXHg2ZVxceDYzXFx4NzJcXHg3OVxceDcwXFx4NzRcXHg0NlxceDc3XFx4NjNcXHg2OVxceDZkXFx4NDNcXHg2ZlxceDZjXFx4NmNcXHg2NVxceDYzXFx4NzRcXHg2ZlxceDcyJyw4OTAxXTt2YXIgX3MyejJaMiR6PV9TMls0XSxfUTBvMFFPT089X1MyWzJdO3ZhciBfb09PUU9PTzA9X1MyWzBdO3ZhciBfUU9Rb1FRUVE9X1MyWzFdO3JldHVybiBfUzJbM107fTt0aGlzLmFjaWNLYXRhbExvZ2dlci5lcnJvcihlcnJvck1lc3NhZ2UsZXJyb3JDb250ZXh0KTt9Y2F0Y2goZSl7fX07QUNJQy5wcm90b3R5cGUuc2V0S2F0YWxNZXRyaWNzPWZ1bmN0aW9uKGNsaWVudElucHV0RGF0YSl7dmFyIF9aej1bJ1xceDU1XFx4NTNcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnLCdcXHgyZScsJ1xceDY0XFx4NjFcXHg3NFxceDYxXFx4MmRcXHg2OFxceDZmXFx4NzNcXHg3NFxceDJkXFx4NjNcXHg2ZlxceDZlXFx4NjZcXHg2OVxceDY3JywnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZFxceDcyXFx4NjVcXHg2NlxceDJkXFx4NjlcXHg2NCddO3ZhciBfdGhpcz10aGlzO3ZhciBtZXRyaWNzRXJyb3JIYW5kbGVyPWZ1bmN0aW9uKGVycil7dmFyIF96Wj1bJ1xceDQ2XFx4NjFcXHg2OVxceDZjXFx4NjVcXHg2NFxceDIwXFx4NzRcXHg2ZlxceDIwXFx4NzBcXHg3NVxceDYyXFx4NmNcXHg2OVxceDczXFx4NjhcXHgyMFxceDc0XFx4NjhcXHg2NVxceDIwXFx4NmRcXHg2NVxceDc0XFx4NzJcXHg2OVxceDYzXFx4NzNcXHgyZSddO190aGlzLnNlbmRFcnJvclRvS2F0YWxMb2dnZXIoX3paWzBdLGVycik7fTt2YXIgZG9tYWluPUthdGFsRW5kcG9pbnRSZXNvbHZlcl8xLkthdGFsRW5kcG9pbnRSZXNvbHZlci5nZXRTdGFnZUJ5SG9zdENvbmZpZyhjbGllbnRJbnB1dERhdGFbX1p6WzJdXSk7dmFyIG1ldHJpY3NEcml2ZXI9bmV3IGthdGFsX21ldHJpY3NfZHJpdmVyX3N1c2hpXzEuZGVmYXVsdC5CdWlsZGVyKCkud2l0aERvbWFpblJlYWxtKGRvbWFpbixfWnpbMF0pLndpdGhFcnJvckhhbmRsZXIobWV0cmljc0Vycm9ySGFuZGxlcikuYnVpbGQoKTt2YXIga2F0YWxNZXRyaWNzU2VydmljZU5hbWU9Y2xpZW50SW5wdXREYXRhW19aelszXV0rS2F0YWxFbmRwb2ludFJlc29sdmVyXzEuS2F0YWxFbmRwb2ludFJlc29sdmVyLmdldFBhZ2VUeXBlTWV0cmljTmFtZShjbGllbnRJbnB1dERhdGEpK19aelsxXSt3aW5kb3cubG9jYXRpb24uaG9zdG5hbWU7dmFyIGluaXRpYWxNZXRyaWNzQ29udGV4dD1uZXcga2F0YWxfbWV0cmljc18xLkNvbnRleHQuQnVpbGRlcigpLndpdGhTaXRlKEFDSUMuS0FUQUxfTUVUUklDU19TRVJWSUNFX05BTUUpLndpdGhTZXJ2aWNlTmFtZShrYXRhbE1ldHJpY3NTZXJ2aWNlTmFtZSkuYnVpbGQoKTt0aGlzLmFjaWNLYXRhbE1ldHJpY3NQdWJsaXNoZXI9bmV3IGthdGFsX21ldHJpY3NfMS5QdWJsaXNoZXIobWV0cmljc0RyaXZlcixtZXRyaWNzRXJyb3JIYW5kbGVyLGluaXRpYWxNZXRyaWNzQ29udGV4dCk7fTtBQ0lDLnByb3RvdHlwZS5zZXRDbGllbnRSZXF1ZXN0PWZ1bmN0aW9uKGRhdGEpe3ZhciBfb29RPVsxODY1OSwnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZFxceDY2XFx4NmZcXHg3MlxceDYzXFx4NjVcXHgyZFxceDZhXFx4NzNcXHgyZFxceDY2XFx4NmNcXHg3NVxceDczXFx4NjgnLCdcXHg2NFxceDYxXFx4NzRcXHg2MVxceDJkXFx4NzJcXHg2NVxceDY2XFx4MmRcXHg2OVxceDY0JywnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZFxceDZkXFx4NmZcXHg2NFxceDY1JywnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZFxceDZjXFx4NmZcXHg2M1xceDYxXFx4NmNcXHg2NScsJ1xceDY0XFx4NjFcXHg3NFxceDYxXFx4MmRcXHg2NVxceDc4XFx4NzRcXHg2NVxceDcyXFx4NmVcXHg2MVxceDZjXFx4MmRcXHg2OVxceDY0JywnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZFxceDYxXFx4NjFcXHg2ZFxceDYxXFx4NzRcXHg2OVxceDZmXFx4NmVcXHgyZFxceDc0XFx4NmZcXHg2YlxceDY1XFx4NmUnLCdcXHg2NFxceDYxXFx4NzRcXHg2MVxceDJkXFx4NjFcXHg2MVxceDJkXFx4NjVcXHg3OFxceDc0XFx4NjVcXHg3MlxceDZlXFx4NjFcXHg2Y1xceDJkXFx4NzRcXHg2ZlxceDZiXFx4NjVcXHg2ZScsJ1xceDY0XFx4NjFcXHg3NFxceDYxXFx4MmRcXHg2OFxceDY1XFx4NjFcXHg2NFxceDY1XFx4NzJcXHgyZFxceDY2XFx4NmZcXHg2ZlxceDc0XFx4NjVcXHg3MicsJ1xceDY0XFx4NjFcXHg3NFxceDYxXFx4MmRcXHg2NVxceDc2XFx4NjVcXHg2ZVxceDc0XFx4MmRcXHg3NFxceDcyXFx4NjlcXHg2N1xceDY3XFx4NjVcXHg3MicsJ1xceDY0XFx4NjFcXHg3NFxceDYxXFx4MmRcXHg2M1xceDY4XFx4NjFcXHg2Y1xceDZjXFx4NjVcXHg2ZVxceDY3XFx4NjVcXHgyZFxceDc0XFx4NzlcXHg3MFxceDY1JywnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZFxceDYzXFx4NmZcXHg2ZVxceDc0XFx4NjVcXHg3OFxceDc0JywnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZFxceDY2XFx4NzdcXHg2M1xceDY5XFx4NmQnLCdcXHg2NFxceDYxXFx4NzRcXHg2MVxceDJkXFx4NjRcXHg2OVxceDczXFx4NmRcXHg2OVxceDczXFx4NzNcXHg0M1xceDYxXFx4NmNcXHg2Y1xceDYyXFx4NjFcXHg2M1xceDZiJywnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZFxceDYzXFx4NjhcXHg2MVxceDZjXFx4NmNcXHg2NVxceDZlXFx4NjdcXHg2NVxceDRjXFx4NmZcXHg2MVxceDY0XFx4NDNcXHg2MVxceDZjXFx4NmNcXHg2MlxceDYxXFx4NjNcXHg2YicsJ1xceDQzXFx4NmNcXHg2OVxceDY1XFx4NmVcXHg3NFxceDIwXFx4NjNcXHg2MVxceDZjXFx4NmNcXHg2MlxceDYxXFx4NjNcXHg2YlxceDIwXFx4NjZcXHg3NVxceDZlXFx4NjNcXHg3NFxceDY5XFx4NmZcXHg2ZVxceDIwXFx4NjlcXHg3M1xceDIwXFx4NmVcXHg2ZlxceDc0XFx4MjBcXHg3MFxceDcyXFx4NmZcXHg3NlxceDY5XFx4NjRcXHg2NVxceDY0JywnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHgyZFxceDYzXFx4NjFcXHg2Y1xceDZjXFx4NjJcXHg2MVxceDYzXFx4NmInLCdcXHg2NFxceDYxXFx4NzRcXHg2MVxceDJkXFx4NmRcXHg2ZlxceDY0XFx4NjFcXHg2YycsJ1xceDY0XFx4NjFcXHg3NFxceDYxXFx4MmRcXHg2MlxceDc5XFx4NzBcXHg2MVxceDczXFx4NzNcXHgyZFxceDZkXFx4NjVcXHg2M1xceDY4XFx4NjFcXHg2ZVxceDY5XFx4NzNcXHg2ZCcsJ1xceDQzXFx4NmNcXHg2OVxceDY1XFx4NmVcXHg3NFxceDIwXFx4NzJcXHg2NVxceDY2XFx4NjVcXHg3MlxceDY1XFx4NmVcXHg2M1xceDY1XFx4MjBcXHg2OVxceDY0XFx4MjBcXHg2OVxceDczXFx4MjBcXHg2ZVxceDZmXFx4NzRcXHgyMFxceDcwXFx4NzJcXHg2ZlxceDc2XFx4NjlcXHg2NFxceDY1XFx4NjQnXTtpZighZGF0YVtfb29RWzJdXSl7dmFyIF9aJFpTMiQycz1fb29RWzBdO3Rocm93IG5ldyBFcnJvcihfb29RWzE5XSk7fWlmKCFkYXRhW19vb1FbMTZdXSl7dmFyIF8xMWlJMTFJMT1mdW5jdGlvbihfJHoyUyQkMlMpe3ZhciBfSWw9WzE3MDM5LDI0MzI0LCdcXHg2NVxceDZlXFx4NjNcXHg3MlxceDc5XFx4NzBcXHg3NFxceDQ0XFx4NmZcXHg2ZFxceDRlXFx4NmZcXHg2NFxceDY1Jyw0MjUxNSwnXFx4NjNcXHg2ZlxceDZjXFx4NmNcXHg2NVxceDYzXFx4NzRcXHg2ZlxceDcyJywyNDAzMSwuNzk1OTk3Mjg5MzUxMDk3NF07dmFyIF8wMFFRT1Fvbz1fSWxbNV0sX29vb09Rb29RPV9JbFs2XSxfWnN6elpzJDI9X0lsWzBdO3ZhciBfc3oyJDJTejI9X0lsWzJdO3ZhciBfeiRzMjIkJHo9X0lsWzFdLF9MMTFpMUlpaT1fSWxbNF07cmV0dXJuIF9JbFszXTt9O3Rocm93IG5ldyBFcnJvcihfb29RWzE1XSk7fXRoaXMuY2xpZW50UmVxdWVzdD1uZXcgQUNJQ0NsaWVudFJlcXVlc3RfMS5BQ0lDQ2xpZW50UmVxdWVzdChkYXRhW19vb1FbMl1dLGRhdGFbX29vUVsxNl1dLGRhdGFbX29vUVsxM11dLGRhdGFbX29vUVsxNF1dLGRhdGFbX29vUVsxMV1dLGRhdGFbX29vUVs0XV0sZGF0YVtfb29RWzEyXV0sZGF0YVtfb29RWzVdXSxkYXRhW19vb1FbOF1dLGRhdGFbX29vUVsxOF1dLGRhdGFbX29vUVsxN11dLGRhdGFbX29vUVsxMF1dLGRhdGFbX29vUVszXV0sZGF0YVtfb29RWzldXSxkYXRhW19vb1FbN11dLGRhdGFbX29vUVsxXV0sZGF0YVtfb29RWzZdXSk7fTtBQ0lDLnByb3RvdHlwZS5zZXR1cElmcmFtZUV2ZW50TGlzdGVuZXI9ZnVuY3Rpb24oKXt2YXIgX08wPVsnXFx4NzNcXHg2NVxceDc0XFx4NzVcXHg3MFxceDQ5XFx4NjZcXHg3MlxceDYxXFx4NmRcXHg2NVxceDQ1XFx4NzZcXHg2NVxceDZlXFx4NzRcXHg0Y1xceDY5XFx4NzNcXHg3NFxceDY1XFx4NmVcXHg2NVxceDcyJywnXFx4NmRcXHg2NVxceDczXFx4NzNcXHg2MVxceDY3XFx4NjUnXTt2YXIgX3RoaXM9dGhpczt0aGlzLmxvZ2dlci5sb2coX08wWzBdKTt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihfTzBbMV0sZnVuY3Rpb24oZXZlbnQpe3ZhciBfMWlsPVtdO3ZhciBfUTBPbzBRb1E9ZnVuY3Rpb24oX1pzc1NzJCQyLF9JMWlJSWxsMSl7dmFyIF9pMT1bJ1xceDYxXFx4NTVcXHg3M1xceDY1XFx4NzJcXHg2MVxceDY3XFx4NjVcXHg2ZVxceDc0XFx4NDNcXHg2MVxceDcwXFx4NzRcXHg2M1xceDY4XFx4NjEnLDE5ODgyLDY3NzAsMjE1MTQsLjQwNzU3Mzk0NTI4NDA3NjEsJ1xceDYzXFx4NmZcXHg2Y1xceDZjXFx4NjVcXHg2M1xceDc0XFx4NmZcXHg3MlxceDQyXFx4NDJcXHg2ZlxceDY0XFx4NzknXTt2YXIgX2wxMUwxbGlJPV9pMVs0XSxfMG9RUVEwT289X2kxWzVdLF9RT1FPb29Pbz1faTFbMF07dmFyIF8xbDFMMWlJTD1faTFbMV0sX29RME9RUU9RPV9pMVszXTtyZXR1cm4gX2kxWzJdO307cmV0dXJuIF90aGlzLmhhbmRsZUlmcmFtZU1lc3NhZ2UoZXZlbnQpO30pO307QUNJQy5wcm90b3R5cGUuaGFuZGxlSWZyYW1lTWVzc2FnZT1mdW5jdGlvbihldmVudCl7dmFyIF9sST1bJ1xceDYxXFx4NjFcXHgyZFxceDYzXFx4NjhcXHg2MVxceDZjXFx4NmNcXHg2NVxceDZlXFx4NjdcXHg2NVxceDJkXFx4NjNcXHg2ZlxceDZkXFx4NzBcXHg2Y1xceDY1XFx4NzRcXHg2NScsJ1xceDYxXFx4NjFcXHgyZFxceDYzXFx4NjhcXHg2MVxceDZjXFx4NmNcXHg2NVxceDZlXFx4NjdcXHg2NVxceDJkXFx4NmNcXHg2ZlxceDYxXFx4NjRcXHg2NVxceDY0JywnXFx4NDNcXHg2OFxceDYxXFx4NmNcXHg2Y1xceDY1XFx4NmVcXHg2N1xceDY1XFx4MjBcXHg0M1xceDZmXFx4NmRcXHg3MFxceDZjXFx4NjVcXHg3NFxceDY1XFx4NjQnLCdcXHg2NVxceDc2XFx4NjVcXHg2ZVxceDc0XFx4MjBcXHg2NFxceDYxXFx4NzRcXHg2MVxceDNhXFx4MjAnLCdcXHg2MVxceDYxXFx4MmRcXHg2M1xceDY4XFx4NjFcXHg2Y1xceDZjXFx4NjVcXHg2ZVxceDY3XFx4NjVcXHgyZFxceDczXFx4NzVcXHg3MFxceDcwXFx4NzJcXHg2NVxceDczXFx4NzNcXHg2NVxceDY0JywnXFx4NjFcXHg2MVxceDJkXFx4NjNcXHg2OFxceDYxXFx4NmNcXHg2Y1xceDY1XFx4NmVcXHg2N1xceDY1XFx4MmRcXHg2NFxceDY5XFx4NzNcXHg2ZFxceDY5XFx4NzNcXHg3MycsJ1xceDYxXFx4NjFcXHgyZFxceDYzXFx4NjhcXHg2MVxceDZjXFx4NmNcXHg2NVxceDZlXFx4NjdcXHg2NVxceDJkXFx4NzNcXHg2OFxceDZmXFx4NzdcXHg2ZScsJ1xceDYxXFx4NjFcXHgyZFxceDYzXFx4NjhcXHg2MVxceDZjXFx4NmNcXHg2NVxceDZlXFx4NjdcXHg2NVxceDJkXFx4NzJcXHg2NVxceDZkXFx4NmZcXHg3NlxceDY1JywnXFx4NDNcXHg2OFxceDYxXFx4NmNcXHg2Y1xceDY1XFx4NmVcXHg2N1xceDY1XFx4MjBcXHg1M1xceDc1XFx4NzBcXHg3MFxceDcyXFx4NjVcXHg3M1xceDczXFx4NjVcXHg2NCcsJ1xceDQzXFx4NjhcXHg2MVxceDZjXFx4NmNcXHg2NVxceDZlXFx4NjdcXHg2NVxceDIwXFx4NGNcXHg2ZlxceDYxXFx4NjRcXHg2NVxceDY0JywnXFx4NTJcXHg2NVxceDZkXFx4NmZcXHg3NlxceDY1XFx4MjBcXHg3N1xceDY4XFx4NmZcXHg2Y1xceDY1XFx4MmRcXHg3MFxceDYxXFx4NjdcXHg2NVxceDIwXFx4NjlcXHg2NlxceDcyXFx4NjFcXHg2ZFxceDY1XFx4MjBcXHg2MlxceDY1XFx4NjZcXHg2ZlxceDcyXFx4NjVcXHgyMFxceDY4XFx4NjFcXHg3M1xceDY4XFx4MjBcXHg2M1xceDY4XFx4NjFcXHg2ZVxceDY3XFx4NjVcXHgyMFxceDY2XFx4NmZcXHg3MlxceDIwXFx4NmRcXHg2ZlxceDY0XFx4NjVcXHg2Y1xceDIwXFx4NzZcXHg2OVxceDY1XFx4NzdcXHgyMFxceDY5XFx4NmVcXHgyMFxceDc1XFx4NzJcXHg2YycsJ1xceDQzXFx4NjhcXHg2MVxceDZjXFx4NmNcXHg2NVxceDZlXFx4NjdcXHg2NVxceDIwXFx4NDRcXHg2OVxceDczXFx4NmRcXHg2OVxceDczXFx4NzNcXHg2NVxceDY0JywnXFx4NGNcXHg2ZlxceDYxXFx4NjRcXHgyMFxceDQxXFx4NmNcXHg3NFxceDY1XFx4NzJcXHg2ZVxceDYxXFx4NzRcXHg2NVxceDIwXFx4NDNcXHg2OFxceDYxXFx4NmNcXHg2Y1xceDY1XFx4NmVcXHg2N1xceDY1XFx4MjBcXHg1N1xceDY5XFx4NzRcXHg2OFxceDIwXFx4NDNcXHg2OFxceDYxXFx4NmNcXHg2Y1xceDY1XFx4NmVcXHg2N1xceDY1XFx4MjBcXHg1NFxceDc5XFx4NzBcXHg2NVxceDNhXFx4MjAnLDAsJ1xceDQzXFx4NjhcXHg2MVxceDZjXFx4NmNcXHg2NVxceDZlXFx4NjdcXHg2NVxceDIwXFx4NTNcXHg2OFxceDZmXFx4NzdcXHg2ZScsJ1xceDYxXFx4NjFcXHgyZFxceDZjXFx4NmZcXHg2MVxceDY0XFx4MmRcXHg2MVxceDZjXFx4NzRcXHg2NVxceDcyXFx4NmVcXHg2MVxceDc0XFx4NjVcXHgyZFxceDYzXFx4NjhcXHg2MVxceDZjXFx4NmNcXHg2NVxceDZlXFx4NjdcXHg2NSddO3ZhciBfUVFvUTBvME89ZnVuY3Rpb24oX0wxMWxsSTFpLF9Pb29vb09PUSxfaTFMbExJbDEpe3ZhciBfbDE9WydcXHg3NVxceDczXFx4NjVcXHg3MlxceDYxXFx4NjdcXHg2NVxceDZlXFx4NzQnLCdcXHg2MicsLjYxNTU3ODEwODYxMjM3LC4wMTE4NTQyOTgwNTMwMzAwNjYsJ1xceDZlXFx4NmZcXHg2NFxceDY1XFx4NDVcXHg2ZVxceDYzXFx4NzJcXHg3OVxceDcwXFx4NzQnLCdcXHg2MlxceDZjXFx4NmZcXHg2MiddO3ZhciBfaUlMSUxsTEw9X2wxWzVdLF9TU1pTc3Mycz1fbDFbM10sX2kxbGwxaUlsPV9sMVswXTt2YXIgX2kxSWxpMTFMPV9sMVs0XSxfejJaJHMkWlo9X2wxWzJdO3JldHVybiBfbDFbMV07fTtpZihldmVudC5kYXRhKXt0aGlzLmxvZ2dlci5sb2coX2xJWzNdK2V2ZW50LmRhdGEpO3ZhciBqc29uUGFyc2VkRXZlbnQ9dm9pZCBfbElbMTNdO3RyeXtqc29uUGFyc2VkRXZlbnQ9SlNPTi5wYXJzZShldmVudC5kYXRhKTt9Y2F0Y2goZXJyKXt0aGlzLmxvZ2dlci5sb2coZXJyLm1lc3NhZ2UpO3JldHVybjt9c3dpdGNoKGpzb25QYXJzZWRFdmVudC5ldmVudElkKXtjYXNlIF9sSVs2XTp0aGlzLmxvZ2dlci5sb2coX2xJWzE0XSk7YnJlYWs7Y2FzZSBfbElbMV06dGhpcy5sb2dnZXIubG9nKF9sSVs5XSk7dGhpcy5yZXNpemVDdXN0b21pemVkSWZyYW1lKCk7dGhpcy5leGVjdXRlQ2hhbGxlbmdlTG9hZENhbGxiYWNrKGpzb25QYXJzZWRFdmVudC5wYXlsb2FkKTticmVhaztjYXNlIF9sSVsxNV06dGhpcy5sb2dnZXIubG9nKF9sSVsxMl0ranNvblBhcnNlZEV2ZW50LnBheWxvYWQuY2hhbGxlbmdlVHlwZSk7dGhpcy5jbGllbnRSZXF1ZXN0LmNoYWxsZW5nZVR5cGVWYWx1ZT1qc29uUGFyc2VkRXZlbnQucGF5bG9hZC5jaGFsbGVuZ2VUeXBlO3RoaXMuc2VuZEFybm9sZEh0dHBSZXF1ZXN0KHRoaXMuY3JlYXRlTmV3U2Vzc2lvblJlcXVlc3RVUkwoKSk7YnJlYWs7Y2FzZSBfbElbNF06dGhpcy5sb2dnZXIubG9nKF9sSVs4XSk7dGhpcy5hZGRSZXNwb25zZShqc29uUGFyc2VkRXZlbnQucGF5bG9hZCk7dGhpcy5zZW5kQXJub2xkSHR0cFJlcXVlc3QodGhpcy5jcmVhdGVVc2VyQW5zd2VyUmVxdWVzdFVSTCgpKTticmVhaztjYXNlIF9sSVswXTp0aGlzLmxvZ2dlci5sb2coX2xJWzJdKTt0aGlzLmFkZFJlc3BvbnNlKGpzb25QYXJzZWRFdmVudC5wYXlsb2FkKTt0aGlzLmxvZ2dlci5sb2codGhpcy5jdXJyZW50QUFtYXRpb25SZXN1bHQpO3RoaXMuc2VuZEFybm9sZEh0dHBSZXF1ZXN0KHRoaXMuY3JlYXRlVXNlckFuc3dlclJlcXVlc3RVUkwoKSk7YnJlYWs7Y2FzZSBfbElbNV06dGhpcy5sb2dnZXIubG9nKF9sSVsxMV0pO3RoaXMuZXhlY3V0ZURpc21pc3NDYWxsYmFjaygpO2JyZWFrO2Nhc2UgX2xJWzddOnRoaXMubG9nZ2VyLmxvZyhfbElbMTBdKTt0aGlzLnJlbW92ZVdob2xlUGFnZUlmcmFtZSgpO2JyZWFrO319fTtBQ0lDLnByb3RvdHlwZS5yZXNpemVDdXN0b21pemVkSWZyYW1lPWZ1bmN0aW9uKCl7dmFyIF8kcz1bJ1xceDY1XFx4NmNcXHg0NVxceDc4XFx4NjVcXHg2M1xceDc1XFx4NzRcXHg2NVxceDQyXFx4NmZcXHg2NFxceDc5JywnXFx4NjRcXHg2ZlxceDZkJ107dmFyIF9vUTBRb09PUT1fJHNbMF0sXyR6WlN6WlMyPV8kc1sxXTtpZih0aGlzLmVuYWJsZUN1c3RvbWl6ZWRJZnJhbWUpe3ZhciBfSUlpaUxpSUw9ZnVuY3Rpb24oXyRaMnpaMnNaLF9pTGlpaUxsbCl7dmFyIF9sbD1bJ1xceDY5XFx4NjQnLC44MTE0NDg1MzQzMTQ2MzA3XTt2YXIgX1FRUTAwME9PPV9sbFswXTtyZXR1cm4gX2xsWzFdO307aWYoIXRoaXMuY3VzdG9taXplZElmcmFtZVJlc2l6ZUxpc3RlbmVyKXt0aGlzLmN1c3RvbWl6ZWRJZnJhbWVSZXNpemVMaXN0ZW5lcj10aGlzLnNldHVwQ3VzdG9taXplZElmcmFtZVJlc2l6ZUxpc3RlbmVyKCk7fXRoaXMuY3VzdG9taXplZElmcmFtZVJlc2l6ZUxpc3RlbmVyLm9ic2VydmUodGhpcy5pZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudC5ib2R5LmZpcnN0RWxlbWVudENoaWxkKTt9fTtBQ0lDLnByb3RvdHlwZS5zZXR1cEN1c3RvbWl6ZWRJZnJhbWVSZXNpemVMaXN0ZW5lcj1mdW5jdGlvbigpe3ZhciBfSUk9W107dmFyIGlmcmFtZT10aGlzLmlmcmFtZTtyZXR1cm4gbmV3IHJlc2l6ZV9vYnNlcnZlcl9wb2x5ZmlsbF8xLmRlZmF1bHQoZnVuY3Rpb24oKXt2YXIgX28wPVsnXFx4NzBcXHg3OCddO2lmcmFtZS5oZWlnaHQ9aWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQuYm9keS5maXJzdEVsZW1lbnRDaGlsZC5zY3JvbGxIZWlnaHQrX28wWzBdO30pO307QUNJQy5wcm90b3R5cGUuYWRkUmVzcG9uc2U9ZnVuY3Rpb24odXNlclJlc3BvbnNlRGF0YSl7dmFyIF8xbGw9W107dmFyIHVzZXJSZXNwb25zZT1uZXcgQUNJQ1VzZXJSZXNwb25zZV8xLkFDSUNVc2VyUmVzcG9uc2UodGhpcy5jdXJyZW50QUFtYXRpb25SZXN1bHQuYWN0aW9uVHlwZVZhbHVlLEpTT04uc3RyaW5naWZ5KHVzZXJSZXNwb25zZURhdGEpKTt0aGlzLmN1cnJlbnRVc2VyUmVzcG9uc2U9dXNlclJlc3BvbnNlO3RoaXMuc2Vzc2lvbkNvbnRleHQuYWRkUmVzcG9uc2UodXNlclJlc3BvbnNlKTt9O0FDSUMucHJvdG90eXBlLmFkZFJlc3VsdD1mdW5jdGlvbihyZXN1bHRTdHJpbmcpe3ZhciBfbzBRPVtudWxsXTtpZighcmVzdWx0U3RyaW5nKXt2YXIgX2xMMUlJMUxsPWZ1bmN0aW9uKF8yejJ6czIycyxfb1FRbzBRUW8pe3ZhciBfb28wPVsnXFx4NjVcXHg3OFxceDY1XFx4NjNcXHg3NVxceDc0XFx4NjVcXHg0NlxceDc3XFx4NjNcXHg2OVxceDZkXFx4NDNcXHg2MVxceDcwXFx4NzRcXHg2M1xceDY4XFx4NjEnLCdcXHg2NFxceDYxXFx4NzRcXHg2MVxceDU1XFx4NzNcXHg2NVxceDcyXFx4NjFcXHg2N1xceDY1XFx4NmVcXHg3NFxceDQ2XFx4NzdcXHg2M1xceDY5XFx4NmQnLCdcXHg2MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHg0NVxceDZjXFx4NDInLDE0NDA2XTt2YXIgX2xsaWwxaTFsPV9vbzBbMl07dmFyIF9aelokenoycz1fb28wWzNdLF8xTGkxTGwxbD1fb28wWzFdO3JldHVybiBfb28wWzBdO307cmV0dXJuIF9vMFFbMF07fXZhciByZXN1bHRKc29uPUpTT04ucGFyc2UocmVzdWx0U3RyaW5nKTt2YXIgcmVzdWx0PW5ldyBBQW1hdGlvblJlc3VsdF8xLkFBbWF0aW9uUmVzdWx0KHJlc3VsdEpzb24uY2xpZW50U2lkZUNvbnRleHQscmVzdWx0SnNvbi5zZXNzaW9uVG9rZW4scmVzdWx0SnNvbi5hY3Rpb25UeXBlKTt0aGlzLmN1cnJlbnRBQW1hdGlvblJlc3VsdD1yZXN1bHQ7dGhpcy5zZXNzaW9uQ29udGV4dC5hZGRSZXN1bHQocmVzdWx0KTtyZXR1cm4gcmVzdWx0O307QUNJQy5wcm90b3R5cGUuY3JlYXRlTmV3U2Vzc2lvblJlcXVlc3RVUkw9ZnVuY3Rpb24oKXt2YXIgX08wUT1bJ1xceDQzXFx4NzJcXHg2NVxceDYxXFx4NzRcXHg2NVxceDRlXFx4NjVcXHg3N1xceDUzXFx4NjVcXHg3M1xceDczXFx4NjlcXHg2ZlxceDZlXFx4NTJcXHg2NVxceDcxXFx4NzVcXHg2NVxceDczXFx4NzRcXHg1NVxceDUyXFx4NGNcXHgzYVxceDIwJ107dmFyIHVybD1idWlsZF91cmxfdHNfMS5kZWZhdWx0KHRoaXMuc2VydmljZUVuZHBvaW50LHtwYXRoOnRoaXMuY2xpZW50UmVxdWVzdC5jbGllbnRSZWZlcmVuY2VJZFZhbHVlLHF1ZXJ5UGFyYW1zOntjb250ZXh0OnVuZGVmaW5lZCxvcHRpb25zOkpTT04uc3RyaW5naWZ5KHRoaXMuY2xpZW50UmVxdWVzdC5jbGllbnRPcHRpb25zKX19KTt0aGlzLmxvZ2dlci5sb2coX08wUVswXSt1cmwpO3JldHVybiB1cmw7fTtBQ0lDLnByb3RvdHlwZS5jcmVhdGVVc2VyQW5zd2VyUmVxdWVzdFVSTD1mdW5jdGlvbigpe3ZhciBfaUw9WydcXHgyZicsJ1xceDQzXFx4NzJcXHg2NVxceDYxXFx4NzRcXHg2NVxceDU1XFx4NzNcXHg2NVxceDcyXFx4NDFcXHg2ZVxceDczXFx4NzdcXHg2NVxceDcyXFx4NTJcXHg2NVxceDcxXFx4NzVcXHg2NVxceDczXFx4NzRcXHg1NVxceDUyXFx4NGNcXHgzYVxceDIwJ107dmFyIHVybD1idWlsZF91cmxfdHNfMS5kZWZhdWx0KHRoaXMuc2VydmljZUVuZHBvaW50LHtwYXRoOnRoaXMuY2xpZW50UmVxdWVzdC5jbGllbnRSZWZlcmVuY2VJZFZhbHVlK19pTFswXSt0aGlzLmN1cnJlbnRBQW1hdGlvblJlc3VsdC5zZXNzaW9uVG9rZW5WYWx1ZSxxdWVyeVBhcmFtczp7Y29udGV4dDp0aGlzLmN1cnJlbnRBQW1hdGlvblJlc3VsdC5jbGllbnRTaWRlQ29udGV4dFZhbHVlLG9wdGlvbnM6SlNPTi5zdHJpbmdpZnkodGhpcy5jbGllbnRSZXF1ZXN0LmNsaWVudE9wdGlvbnMpLHJlc3BvbnNlOkpTT04uc3RyaW5naWZ5KHRoaXMuY3VycmVudFVzZXJSZXNwb25zZSl9fSk7dGhpcy5sb2dnZXIubG9nKF9pTFsxXSt1cmwpO3JldHVybiB1cmw7fTtBQ0lDLnByb3RvdHlwZS5sb2FkQ2hhbGxlbmdlVmlldz1mdW5jdGlvbih2aWV3KXt2YXIgX0kxPVsnXFx4NzVcXHg2ZVxceDY0XFx4NjVcXHg2NlxceDY5XFx4NmVcXHg2NVxceDY0J107aWYodHlwZW9mIHRoaXMuaWZyYW1lPT09X0kxWzBdJiYhdGhpcy5lbmFibGVDdXN0b21pemVkSWZyYW1lKXt2YXIgX1MyejJ6JFoyPWZ1bmN0aW9uKF96JHN6c3Mkeil7dmFyIF9PMFFvPVsuMzg2MjE4NjYyNzEzNTcwMiwnXFx4NjJcXHg2Y1xceDZmXFx4NjInLDEyNjNdO3ZhciBfSUwxaWwxbEw9X08wUW9bMl0sX3oyUyRzc1okPV9PMFFvWzBdO3JldHVybiBfTzBRb1sxXTt9O3RoaXMuaWZyYW1lPXRoaXMuY3JlYXRlSWZyYW1lKCk7fXZhciBpZnJhbWVEb2N1bWVudD10aGlzLmlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O2lmcmFtZURvY3VtZW50Lm9wZW4oKTtpZnJhbWVEb2N1bWVudC53cml0ZSh2aWV3KTtpZnJhbWVEb2N1bWVudC5jbG9zZSgpO307QUNJQy5wcm90b3R5cGUucmVtb3ZlV2hvbGVQYWdlSWZyYW1lPWZ1bmN0aW9uKCl7dmFyIF9pMWw9WydcXHg2MVxceDYxXFx4MmRcXHg2M1xceDY4XFx4NjFcXHg2Y1xceDZjXFx4NjVcXHg2ZVxceDY3XFx4NjVcXHgyZFxceDc3XFx4NjhcXHg2ZlxceDZjXFx4NjVcXHgyZFxceDcwXFx4NjFcXHg2N1xceDY1XFx4MmRcXHg2OVxceDY2XFx4NzJcXHg2MVxceDZkXFx4NjUnLCdcXHg1MlxceDY1XFx4NmRcXHg2ZlxceDc2XFx4NjlcXHg2ZVxceDY3XFx4MjBcXHg3N1xceDY4XFx4NmZcXHg2Y1xceDY1XFx4MmRcXHg3MFxceDYxXFx4NjdcXHg2NVxceDIwXFx4NjlcXHg2NlxceDcyXFx4NjFcXHg2ZFxceDY1XFx4MjBcXHg2NlxceDcyXFx4NmZcXHg2ZFxceDIwXFx4NzBcXHg2MVxceDY3XFx4NjVcXHgyMScsJ1xceDcyXFx4NjVcXHg2ZFxceDZmXFx4NzZcXHg2NVxceDU3XFx4NjhcXHg2ZlxceDZjXFx4NjVcXHg1MFxceDYxXFx4NjdcXHg2NVxceDQ5XFx4NjZcXHg3MlxceDYxXFx4NmRcXHg2NSddO3RoaXMubG9nZ2VyLmxvZyhfaTFsWzJdKTt2YXIgaWZyYW1lPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKF9pMWxbMF0pO2lmKGlmcmFtZSl7dGhpcy5sb2dnZXIubG9nKF9pMWxbMV0pO2lmcmFtZS5yZW1vdmUoKTt0aGlzLmlmcmFtZT11bmRlZmluZWQ7fX07QUNJQy5wcm90b3R5cGUuZXhlY3V0ZURpc21pc3NDYWxsYmFjaz1mdW5jdGlvbigpe3ZhciBfMnM9Wy4xMzQyNzg0NTQzMDc1NjYzNSwnXFx4NmNcXHg2OVxceDczXFx4NzQnXTt2YXIgXzFMbDFpMUlJPV8yc1swXSxfejJzJHpzJHM9XzJzWzFdO3RoaXMucmVtb3ZlV2hvbGVQYWdlSWZyYW1lKCk7dGhpcy5jbGllbnRSZXF1ZXN0LmRpc21pc3NDYWxsYmFja0Z1bmN0aW9uKHt9KTt9O0FDSUMucHJvdG90eXBlLmV4ZWN1dGVDaGFsbGVuZ2VMb2FkQ2FsbGJhY2s9ZnVuY3Rpb24oY2hhbGxlbmdlTG9hZERhdGEpe3ZhciBfMTE9WzIzMzA0LG51bGwsNDA5MTZdO2lmKGNoYWxsZW5nZUxvYWREYXRhPT1fMTFbMV0pe3ZhciBfMUkxMUlpMWw9XzExWzJdLF9JbDExaWxsMT1fMTFbMF07dGhpcy5jbGllbnRSZXF1ZXN0LmNoYWxsZW5nZUxvYWRDYWxsYmFja0Z1bmN0aW9uKHtoZWlnaHQ6Jycsd2lkdGg6Jyd9KTt9ZWxzZXt0aGlzLmNsaWVudFJlcXVlc3QuY2hhbGxlbmdlTG9hZENhbGxiYWNrRnVuY3Rpb24oe2hlaWdodDpjaGFsbGVuZ2VMb2FkRGF0YS5mcmFtZUhlaWdodCx3aWR0aDpjaGFsbGVuZ2VMb2FkRGF0YS5mcmFtZVdpZHRofSk7fX07QUNJQy5wcm90b3R5cGUuZXhlY3V0ZUFDSUNDYWxsYmFjaz1mdW5jdGlvbihyZXNwb25zZSl7dmFyIF9pST1bJ1xceDY1XFx4NzhcXHg2NVxceDYzXFx4NzVcXHg3NFxceDY1XFx4NDFcXHg0M1xceDQ5XFx4NDNcXHg0M1xceDYxXFx4NmNcXHg2Y1xceDYyXFx4NjFcXHg2M1xceDZiXFx4MjBcXHg3MlxceDY1XFx4NzNcXHg3MFxceDZmXFx4NmVcXHg3M1xceDY1XFx4M2FcXHgyMCddO3ZhciBfMiRzMnpzeiQ9ZnVuY3Rpb24oXyRzenNTMnNzLF9RUVEwb08wTyl7dmFyIF9zej1bLjA1NjE5NjQ2MTU4NDMyOTc4LDI5OTMxLC4zMTYzMTA0MTAzMTkwNzUyNSwyNDkwNSwyNDE1LDE2MTUyXTt2YXIgX29PUTBPb1FPPV9zelsxXSxfelp6U1N6czI9X3N6WzJdO3ZhciBfWiRaU3paJCQ9X3N6WzNdLF8kUyQkUyQkWj1fc3pbNV0sX1Fvb08wMG9vPV9zelswXTtyZXR1cm4gX3N6WzRdO307dGhpcy5sb2dnZXIubG9nKF9pSVswXStyZXNwb25zZSk7aWYocmVzcG9uc2UgaW5zdGFuY2VvZiBBQ0lDRXJyb3JfMS5BQ0lDRXJyb3Ipe3RoaXMuY2xpZW50UmVxdWVzdC5jYWxsYmFja0Z1bmN0aW9uKG5ldyBBQW1hdGlvblJlc3VsdF8xLkFBbWF0aW9uUmVzdWx0KEFDSUMuU1RBVElDX0NMSUVOVF9DT05URVhULEFDSUMuU1RBVElDX1NFU1NJT05fVE9LRU4sQUNJQy5TVEFUSUNfQUNUSU9OX1RZUEUscmVzcG9uc2UpKTtyZXR1cm47fXRoaXMuY2xpZW50UmVxdWVzdC5jYWxsYmFja0Z1bmN0aW9uKHJlc3BvbnNlKTt9O0FDSUMucHJvdG90eXBlLmNyZWF0ZUlmcmFtZT1mdW5jdGlvbigpe3ZhciBfJCQ9WydcXHg2OVxceDY2XFx4NzJcXHg2MVxceDZkXFx4NjUnLCdcXHg2MVxceDYxXFx4MmRcXHg2M1xceDY4XFx4NjFcXHg2Y1xceDZjXFx4NjVcXHg2ZVxceDY3XFx4NjVcXHgyZFxceDc3XFx4NjhcXHg2ZlxceDZjXFx4NjVcXHgyZFxceDcwXFx4NjFcXHg2N1xceDY1XFx4MmRcXHg2OVxceDY2XFx4NzJcXHg2MVxceDZkXFx4NjUnXTt2YXIgaWZybT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KF8kJFswXSk7aWZybS5pZD1fJCRbMV07ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJtKTtyZXR1cm4gaWZybTt9O0FDSUMucHJvdG90eXBlLnNlbmRBcm5vbGRIdHRwUmVxdWVzdD1mdW5jdGlvbih1cmwsdGltZW91dCxyZXRyeVRpbWVzKXt2YXIgXzJTWj1bJ1xceDQzXFx4NmZcXHg2ZVxceDc0XFx4NjVcXHg2ZVxceDc0XFx4MmRcXHg1NFxceDc5XFx4NzBcXHg2NScsJ1xceDYxXFx4NzBcXHg3MFxceDZjXFx4NjlcXHg2M1xceDYxXFx4NzRcXHg2OVxceDZmXFx4NmVcXHgyZlxceDZhXFx4NzNcXHg2ZlxceDZlJywnXFx4NTBcXHg0ZlxceDUzXFx4NTQnLCdcXHg0N1xceDQ1XFx4NTQnLHRydWUsMzUxMzMsJ1xceDYzXFx4NmZcXHg2ZVxceDc0XFx4NjVcXHg2ZVxceDc0JywuMjg3OTE1ODc1MzIzMTAyOCw1NjI0LCdcXHg2MVxceDZlXFx4NzRcXHg2OVxceDJkXFx4NjNcXHg3M1xceDcyXFx4NjZcXHg3NFxceDZmXFx4NmJcXHg2NVxceDZlXFx4MmRcXHg2MVxceDMyXFx4N2EnLCdcXHgyZVxceDcyXFx4NjVcXHg3M1xceDcwXFx4NmZcXHg2ZVxceDczXFx4NjVcXHg1NFxceDY5XFx4NmRcXHg2NScsMCwnXFx4NjNcXHg3M1xceDcyXFx4NjZcXHgyMFxceDc0XFx4NmZcXHg2YlxceDY1XFx4NmVcXHgzYVxceDIwJywnXFx4NmRcXHg2NVxceDc0XFx4NjFcXHg1YlxceDZlXFx4NjFcXHg2ZFxceDY1XFx4M2RcXHgyMlxceDYzXFx4NzNcXHg3MlxceDY2XFx4MmRcXHg3NFxceDZmXFx4NmJcXHg2NVxceDZlXFx4MjJcXHg1ZCcsJ1xceDYxXFx4NzAnLCdcXHg3M1xceDY1XFx4NmVcXHg2NFxceDQxXFx4NzJcXHg2ZVxceDZmXFx4NmNcXHg2NFxceDQ4XFx4NzRcXHg3NFxceDcwXFx4NTJcXHg2NVxceDcxXFx4NzVcXHg2NVxceDczXFx4NzQnXTt2YXIgX3RoaXM9dGhpcztpZih0aW1lb3V0PT09dm9pZCBfMlNaWzExXSl7dGltZW91dD1BQ0lDLkRFRkFVTFRfUkVRVUVTVF9USU1FT1VUO31pZihyZXRyeVRpbWVzPT09dm9pZCBfMlNaWzExXSl7dmFyIF8kJFN6MnMkej1fMlNaWzVdLF9MaWkxMUlJTD1fMlNaWzhdO3JldHJ5VGltZXM9QUNJQy5ERUZBVUxUX1JFVFJZX1RJTUVTO310aGlzLmxvZ2dlci5sb2coXzJTWlsxNV0pO3ZhciByZXNwb25zZVRpbWVNZXRyaWNOYW1lPV8yU1pbMTBdO3ZhciB4aHI9bmV3IFhNTEh0dHBSZXF1ZXN0KCk7aWYodGhpcy5jbGllbnRSZXF1ZXN0LmNsaWVudFJlZmVyZW5jZUlkVmFsdWU9PT1fMlNaWzE0XXx8dGhpcy51c2VSZXF1ZXN0TWV0aG9kUG9zdCl7dmFyIF9MSTFsbExJST1mdW5jdGlvbihfSUlJaUlJbGksXzJzU3okWnN6KXt2YXIgX1EwPVsyODA0MCwnXFx4NjRcXHg2MVxceDc0XFx4NjFcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmVcXHg0NVxceDc4XFx4NjVcXHg2M1xceDc1XFx4NzRcXHg2NScsLjI1OTYwNDc3ODgxNTU0NDIsLjU0MDYxMTc3MDAwMDk5OTQsJ1xceDZhXFx4NzNcXHg2ZlxceDZlXFx4NDNcXHg2ZlxceDZjXFx4NmNcXHg2NVxceDYzXFx4NzRcXHg2ZlxceDcyJywuNzUxMDQ0MDM2MzE1NzE2MywuNzIwNTE3OTM2NjE4NzMwNCwnXFx4NjVcXHg2ZVxceDYzXFx4NzJcXHg3OVxceDcwXFx4NzRcXHg0MlxceDZjXFx4NmZcXHg2MlxceDQ5XFx4NjQnXTt2YXIgX1pTU3pTWnpzPV9RMFs2XSxfeiQyMnpzMiQ9X1EwWzVdLF8wb09PUVFRbz1fUTBbMV07dmFyIF9pSUkxbElpTD1fUTBbMl0sX1MkU3pzJCRTPV9RMFs3XTt2YXIgXzAwMFFPb09RPV9RMFs0XSxfT29Rb09vUTA9X1EwWzNdO3JldHVybiBfUTBbMF07fTt4aHIub3BlbihfMlNaWzJdLHVybCxfMlNaWzRdKTtyZXNwb25zZVRpbWVNZXRyaWNOYW1lPV8yU1pbMl0rcmVzcG9uc2VUaW1lTWV0cmljTmFtZTt9ZWxzZXt4aHIub3BlbihfMlNaWzNdLHVybCxfMlNaWzRdKTtyZXNwb25zZVRpbWVNZXRyaWNOYW1lPV8yU1pbM10rcmVzcG9uc2VUaW1lTWV0cmljTmFtZTt9eGhyLnNldFJlcXVlc3RIZWFkZXIoXzJTWlswXSxfMlNaWzFdKTtpZih0aGlzLmlmcmFtZSl7dmFyIGNzcmZUb2tlblRhZz10aGlzLmlmcmFtZS5jb250ZW50RG9jdW1lbnQuaGVhZC5xdWVyeVNlbGVjdG9yKF8yU1pbMTNdKTtpZihjc3JmVG9rZW5UYWcpe3RoaXMuY3NyZlRva2VuPWNzcmZUb2tlblRhZy5nZXRBdHRyaWJ1dGUoXzJTWls2XSk7dGhpcy5sb2dnZXIubG9nKF8yU1pbMTJdK3RoaXMuY3NyZlRva2VuKTt4aHIuc2V0UmVxdWVzdEhlYWRlcihfMlNaWzldLHRoaXMuY3NyZlRva2VuKTt9fXZhciBfMFFvb09vUW89XzJTWls3XTt4aHIudGltZW91dD10aW1lb3V0O3ZhciByZXF1ZXN0U3RhcnRUaW1lPW5ldyBEYXRlKCkudmFsdWVPZigpO3hoci5zZW5kKEpTT04uc3RyaW5naWZ5KHtjb250ZXh0OnRoaXMuZ2V0Y2xpZW50U2lkZUNvbnRleHQoKSxvcHRpb25zOkpTT04uc3RyaW5naWZ5KHRoaXMuY2xpZW50UmVxdWVzdC5jbGllbnRPcHRpb25zKSxyZXNwb25zZTpKU09OLnN0cmluZ2lmeSh0aGlzLmN1cnJlbnRVc2VyUmVzcG9uc2UpLGZ3Y2ltQmxvYjp0aGlzLmNsaWVudFJlcXVlc3QuZndjaW1CbG9iVmFsdWV9KSk7eGhyLm9uZXJyb3I9ZnVuY3Rpb24oKXt2YXIgX1EwTz1bMjIxNDEsJ1xceDY2XFx4NzdcXHg2M1xceDY5XFx4NmRcXHg1NVxceDczXFx4NjVcXHg3MlxceDYxXFx4NjdcXHg2NVxceDZlXFx4NzQnLCdcXHgyMFxceDcyXFx4NjVcXHg3NFxceDcyXFx4NjlcXHg2NVxceDczXFx4MjBcXHg3MlxceDY1XFx4NmRcXHg2MVxceDY5XFx4NmVcXHg2OVxceDZlXFx4NjdcXHgyZScsJ1xceDY0XFx4NmZcXHg2ZCcsMSwwLCdcXHg0NlxceDYxXFx4NjlcXHg2Y1xceDY1XFx4NjRcXHgyMFxceDc0XFx4NmZcXHgyMFxceDYzXFx4NmZcXHg2ZVxceDZlXFx4NjVcXHg2M1xceDc0XFx4MjBcXHg3NFxceDZmXFx4MjBcXHg3NFxceDY4XFx4NjVcXHgyMFxceDczXFx4NjVcXHg3MlxceDc2XFx4NjVcXHg3MlxceDJlJywnXFx4NGVcXHg2NVxceDc0XFx4NzdcXHg2ZlxceDcyXFx4NmJcXHgyMFxceDQ1XFx4NzJcXHg3MlxceDZmXFx4NzJcXHgzYVxceDIwJ107aWYocmV0cnlUaW1lcz09X1EwT1s1XSl7X3RoaXMuc2VuZEVycm9yVG9LYXRhbExvZ2dlcihfUTBPWzZdLHsnXFx4NTVcXHg1MlxceDRjJzp1cmwsJ1xceDQzXFx4NDlcXHg0NCc6X3RoaXMuY2xpZW50UmVxdWVzdC5jbGllbnRSZWZlcmVuY2VJZFZhbHVlfSk7dmFyIF9RUTBPb09vTz1mdW5jdGlvbihfMG8wTzBRbzAsX29vUVFPMDBRKXt2YXIgX3MyPVsyNzg3LCdcXHg2MlxceDZmXFx4NjRcXHg3OScsLjA5NTg0NjgwNDM4Mjk4MDc3LC4wMzk2MzE1Njc5ODgxNDg0ODYsJ1xceDY1XFx4NmVcXHg2M1xceDcyXFx4NzlcXHg3MFxceDc0XFx4NGZcXHg2MlxceDY2XFx4NzVcXHg3M1xceDYzXFx4NjFcXHg3NFxceDY1J107dmFyIF9pMUxMbExpST1fczJbMl0sXzBvb29RUTBRPV9zMlszXSxfaUlsTExsbGw9X3MyWzRdO3ZhciBfb09PUTBRMFE9X3MyWzBdO3JldHVybiBfczJbMV07fTt2YXIgYWNpY0Vycm9yPW5ldyBBQ0lDRXJyb3JfMS5BQ0lDRXJyb3IoQUNJQ0Vycm9yXzEuQUNJQ0Vycm9yTmFtZS5ORVRXT1JLX0VSUk9SKTtpZihfdGhpcy5fb25lcnJvcil7dmFyIF8kWnNTc1pzej1fUTBPWzNdLF9MMUkxSWxJST1fUTBPWzBdLF8xbElMMUlsaT1fUTBPWzFdO190aGlzLl9vbmVycm9yKGFjaWNFcnJvcik7fWVsc2V7X3RoaXMuZXhlY3V0ZUFDSUNDYWxsYmFjayhhY2ljRXJyb3IpO319ZWxzZXtfdGhpcy5zZW5kRXJyb3JUb0thdGFsTG9nZ2VyKF9RME9bN10rcmV0cnlUaW1lcytfUTBPWzJdLHsnXFx4NTVcXHg1MlxceDRjJzp1cmwsJ1xceDQzXFx4NDlcXHg0NCc6X3RoaXMuY2xpZW50UmVxdWVzdC5jbGllbnRSZWZlcmVuY2VJZFZhbHVlfSk7X3RoaXMuc2VuZEFybm9sZEh0dHBSZXF1ZXN0KHVybCx1bmRlZmluZWQscmV0cnlUaW1lcy1fUTBPWzRdKTt9fTt4aHIub250aW1lb3V0PWZ1bmN0aW9uKCl7dmFyIF9pMTE9WydcXHg2NFxceDYxXFx4NzRcXHg2MScsJ1xceDU0XFx4NjlcXHg2ZFxceDY1XFx4NmZcXHg3NVxceDc0XFx4M2FcXHgyMFxceDcyXFx4NjVcXHg3MVxceDc1XFx4NjVcXHg3M1xceDc0XFx4MjBcXHg3NFxceDZmXFx4NmZcXHg2YlxceDIwXFx4NmNcXHg2ZlxceDZlXFx4NjdcXHg2NVxceDcyXFx4MjBcXHg3NFxceDY4XFx4NjFcXHg2ZVxceDIwXFx4NjVcXHg3OFxceDcwXFx4NjVcXHg2M1xceDc0XFx4NjVcXHg2NFxceDJlJywuODMxNTM1OTQzMjk5MzA3XTtfdGhpcy5zZW5kRXJyb3JUb0thdGFsTG9nZ2VyKF9pMTFbMV0seydcXHg1NVxceDUyXFx4NGMnOnVybCwnXFx4NDNcXHg0OVxceDQ0JzpfdGhpcy5jbGllbnRSZXF1ZXN0LmNsaWVudFJlZmVyZW5jZUlkVmFsdWV9KTt2YXIgXyQkcyRTc3MyPWZ1bmN0aW9uKF9zJHokelNzJCxfSWkxaUlpTGkpe3ZhciBfMlNTPVsnXFx4NjVcXHg2YycsMzI3Nyw0ODc5Ml07dmFyIF9MTDFJSUwxbD1fMlNTWzJdLF9aMiRaelNzJD1fMlNTWzBdO3JldHVybiBfMlNTWzFdO307dmFyIGFjaWNFcnJvcj1uZXcgQUNJQ0Vycm9yXzEuQUNJQ0Vycm9yKEFDSUNFcnJvcl8xLkFDSUNFcnJvck5hbWUuVElNRU9VVCk7aWYoX3RoaXMuX29uZXJyb3Ipe190aGlzLl9vbmVycm9yKGFjaWNFcnJvcik7fWVsc2V7dmFyIF9aczJ6WnNTWj1faTExWzJdLF9JbElsTDFJbD1faTExWzBdO190aGlzLmV4ZWN1dGVBQ0lDQ2FsbGJhY2soYWNpY0Vycm9yKTt9fTt4aHIub25sb2FkPWZ1bmN0aW9uKCl7dmFyIF9JaT1bJ1xceDczXFx4NjVcXHg2ZVxceDY0XFx4NDFcXHg3MlxceDZlXFx4NmZcXHg2Y1xceDY0XFx4NDhcXHg3NFxceDc0XFx4NzBcXHg1MlxceDY1XFx4NzFcXHg3NVxceDY1XFx4NzNcXHg3NCddO3ZhciByZXF1ZXN0RW5kVGltZT1uZXcgRGF0ZSgpLnZhbHVlT2YoKTtfdGhpcy5hY2ljS2F0YWxNZXRyaWNzUHVibGlzaGVyLm5ld0NoaWxkQWN0aW9uUHVibGlzaGVyRm9yTWV0aG9kKF9JaVswXSkucHVibGlzaFRpbWVyTW9uaXRvcihyZXNwb25zZVRpbWVNZXRyaWNOYW1lLHJlcXVlc3RFbmRUaW1lLXJlcXVlc3RTdGFydFRpbWUpO190aGlzLnByb2Nlc3NBcm5vbGRIdHRwUmVzcG9uc2UoeGhyKTt9O307QUNJQy5wcm90b3R5cGUuZ2V0Y2xpZW50U2lkZUNvbnRleHQ9ZnVuY3Rpb24oKXt2YXIgX29RPVsnXFx4NmNcXHg2OVxceDczXFx4NzRcXHg0MlxceDZmXFx4NjRcXHg3OVxceDQzXFx4NmZcXHg2Y1xceDZjXFx4NjVcXHg2M1xceDc0XFx4NmZcXHg3MicsbnVsbCwuODc2NzExODU0MTQyMDQwN107dmFyIF96JFokMnN6ej1fb1FbMl0sX0xpMUlMbDFJPV9vUVswXTtpZih0aGlzLmN1cnJlbnRBQW1hdGlvblJlc3VsdCl7cmV0dXJuIHRoaXMuY3VycmVudEFBbWF0aW9uUmVzdWx0LmNsaWVudFNpZGVDb250ZXh0VmFsdWU7fXJldHVybiBfb1FbMV07fTtBQ0lDLnByb3RvdHlwZS5wcm9jZXNzQXJub2xkSHR0cFJlc3BvbnNlPWZ1bmN0aW9uKHhocil7dmFyIF9vb289WzQwMCwnXFx4MmUnLDIwMCwnXFx4NTJcXHg2NVxceDczXFx4NzBcXHg2ZlxceDZlXFx4NzNcXHg2NVxceDQ4XFx4NjVcXHg2MVxceDY0XFx4NjVcXHg3MlxceDIwXFx4NjlcXHg3M1xceDIwXFx4NmVcXHg3NVxceDZjXFx4NmNcXHgyZScsJ1xceDQ4XFx4NTRcXHg1NFxceDUwXFx4MjBcXHg0NVxceDcyXFx4NzJcXHg2ZlxceDcyXFx4MjAnLCdcXHg3MFxceDcyXFx4NmZcXHg2M1xceDY1XFx4NzNcXHg3M1xceDQxXFx4NzJcXHg2ZVxceDZmXFx4NmNcXHg2NFxceDQ4XFx4NzRcXHg3NFxceDcwXFx4NTJcXHg2NVxceDczXFx4NzBcXHg2ZlxceDZlXFx4NzNcXHg2NSddO3RoaXMubG9nZ2VyLmxvZyhfb29vWzVdKTt2YXIgc3RhdHVzPXhoci5zdGF0dXM7dmFyIF9MaWlMMTExST1mdW5jdGlvbihfUTBPTzBPMG8sX3NzMlNaJHpTKXt2YXIgXzFsTD1bLjgyOTU0MjAyMzcwMzAyODksJ1xceDY0XFx4NmZcXHg2M1xceDc1XFx4NmRcXHg2NVxceDZlXFx4NzRcXHg0OVxceDY0JywnXFx4NjhcXHg2MVxceDczXFx4NjgnXTt2YXIgX0lJMWxJMUxMPV8xbExbMV0sX0lMSWlMbElsPV8xbExbMl07cmV0dXJuIF8xbExbMF07fTt0aGlzLmxvZ2dlci5sb2coc3RhdHVzKTtpZihzdGF0dXMhPV9vb29bMl0pe3ZhciBfTElJaTFsaTE9ZnVuY3Rpb24oXzJzJDJzMnN6LF8yMlNTc3pzJCxfMnNTc3pzWnope3ZhciBfT089WydcXHg3NVxceDczXFx4NjVcXHg3MlxceDYxXFx4NjdcXHg2NVxceDZlXFx4NzRcXHg0OVxceDY0JywnXFx4NjRcXHg2ZlxceDZkJyw0ODkzMiwxMzczNSwnXFx4NjNcXHg2ZlxceDZjXFx4NmNcXHg2NVxceDYzXFx4NzRcXHg2ZlxceDcyJ107dmFyIF8kWlp6WiRTcz1fT09bNF0sX1NaU1okWlpaPV9PT1swXTt2YXIgX1FvT09vb09RPV9PT1szXSxfeiQkWlN6Wno9X09PWzFdO3JldHVybiBfT09bMl07fTt0aGlzLnNlbmRFcnJvclRvS2F0YWxMb2dnZXIoX29vb1s0XStzdGF0dXMrX29vb1sxXSx7J1xceDUzXFx4NzRcXHg2MVxceDc0XFx4NzVcXHg3Myc6eGhyLnN0YXR1c1RleHQsJ1xceDQzXFx4NDlcXHg0NCc6dGhpcy5jbGllbnRSZXF1ZXN0LmNsaWVudFJlZmVyZW5jZUlkVmFsdWUsJ1xceDUyXFx4NjVcXHg3M1xceDcwXFx4NmZcXHg2ZVxceDczXFx4NjVcXHg1NVxceDUyXFx4NGMnOnhoci5yZXNwb25zZVVSTH0pO2lmKHN0YXR1cz09X29vb1swXSl7dmFyIF9Rb29PMFFRTz1mdW5jdGlvbihfMG9RbzAwMDApe3ZhciBfU1M9WzEyMjEwLCdcXHg2NVxceDc4XFx4NjVcXHg2M1xceDc1XFx4NzRcXHg2NScsLjQ4NDE3MDM0NTA2NDc0MzIsMzc3NTNdO3ZhciBfMlNzWloyejI9X1NTWzJdO3ZhciBfMWlJbExpaUk9X1NTWzNdLF9sTDFJTDFMMT1fU1NbMV07cmV0dXJuIF9TU1swXTt9O3RoaXMuZXhlY3V0ZUFDSUNDYWxsYmFjayhuZXcgQUNJQ0Vycm9yXzEuQUNJQ0Vycm9yKEFDSUNFcnJvcl8xLkFDSUNFcnJvck5hbWUuQkFEX1JFUVVFU1RfRVJST1IpKTt9ZWxzZXt0aGlzLmV4ZWN1dGVBQ0lDQ2FsbGJhY2sobmV3IEFDSUNFcnJvcl8xLkFDSUNFcnJvcihBQ0lDRXJyb3JfMS5BQ0lDRXJyb3JOYW1lLkhUVFBfRVJST1IpKTt9fWVsc2V7dmFyIF9sMWxJSUlpMT1mdW5jdGlvbihfTGwxSWlsaTEsX0lMbGxpTDFsKXt2YXIgX09PTz1bJ1xceDYzXFx4NjFcXHg3MFxceDc0XFx4NjNcXHg2OFxceDYxXFx4NGZcXHg2MlxceDY2XFx4NzVcXHg3M1xceDYzXFx4NjFcXHg3NFxceDY1XFx4NDZcXHg3N1xceDYzXFx4NjlcXHg2ZCcsJ1xceDYyJywnXFx4NjNcXHg2MVxceDcwXFx4NzRcXHg2M1xceDY4XFx4NjFcXHg0MlxceDZjXFx4NmZcXHg2MiddO3ZhciBfUU9RT29RMFE9X09PT1sxXSxfUTBRUTBRME89X09PT1syXTtyZXR1cm4gX09PT1swXTt9O3ZhciBhYW1hdGlvblJlc3VsdD10aGlzLmFkZFJlc3VsdCh4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoQUNJQy5BQU1BVElPTl9TRVJWSUNFX1JFU1BPTlNFX0hFQURFUikpO3RoaXMubG9nZ2VyLmxvZyhhYW1hdGlvblJlc3VsdCk7aWYoIWFhbWF0aW9uUmVzdWx0KXt0aGlzLnNlbmRFcnJvclRvS2F0YWxMb2dnZXIoX29vb1szXSx7J1xceDQzXFx4NDlcXHg0NCc6dGhpcy5jbGllbnRSZXF1ZXN0LmNsaWVudFJlZmVyZW5jZUlkVmFsdWUsJ1xceDUyXFx4NjVcXHg3M1xceDcwXFx4NmZcXHg2ZVxceDczXFx4NjVcXHg1NVxceDUyXFx4NGMnOnhoci5yZXNwb25zZVVSTCwnXFx4NTJcXHg2NVxceDczXFx4NzBcXHg2ZlxceDZlXFx4NzNcXHg2NVxceDU0XFx4NjVcXHg3OFxceDc0JzohIXhoci5yZXNwb25zZVRleHQsJ1xceDUyXFx4NjVcXHg3M1xceDcwXFx4NmZcXHg2ZVxceDczXFx4NjVcXHg0OFxceDY1XFx4NjFcXHg2NFxceDY1XFx4NzInOnhoci5nZXRSZXNwb25zZUhlYWRlcihBQ0lDLkFBTUFUSU9OX1NFUlZJQ0VfUkVTUE9OU0VfSEVBREVSKX0pO3RoaXMuZXhlY3V0ZUFDSUNDYWxsYmFjayhuZXcgQUNJQ0Vycm9yXzEuQUNJQ0Vycm9yKEFDSUNFcnJvcl8xLkFDSUNFcnJvck5hbWUuRU1QVFlfUkVTUE9OU0UpKTt9ZWxzZSBpZihhYW1hdGlvblJlc3VsdC5hY3Rpb25UeXBlVmFsdWU9PUFDSUMuQUFNQVRJT05fUEFTU19BQ1RJT05fVFlQRSl7dmFyIF9zMjIkUzJTej1mdW5jdGlvbihfUU9RMFFvb1Epe3ZhciBfWnM9WydcXHg2MVxceDRjXFx4NjlcXHg3M1xceDc0JywuOTIxNzgyMzUyODY3NzY0LC42NzI3NzcwNDM0NDEyNjMyLDM4NDc5LCdcXHg2NVxceDZjXFx4NDJcXHg2Y1xceDZmXFx4NjInLDI4NTI4LC4zMDk3NjcyNTY3NzAyMjY3Nl07dmFyIF8wbzBvUU8wbz1fWnNbM10sXzFJbExJaTFMPV9ac1swXSxfU1p6MnpaMlM9X1pzWzZdO3ZhciBfMFFPTzBPUU89X1pzWzJdLF9sMWxJbExJST1fWnNbMV07dmFyIF8yWlNac3N6ej1fWnNbNF07cmV0dXJuIF9ac1s1XTt9O3RoaXMuZXhlY3V0ZUFDSUNDYWxsYmFjayhhYW1hdGlvblJlc3VsdCk7fWVsc2UgaWYodGhpcy5tb2RlJiZBQ0lDLkRFVEVDVElPTl9PTkxZX01PREVMPT09dGhpcy5tb2RlKXt0aGlzLmV4ZWN1dGVBQ0lDQ2FsbGJhY2soYWFtYXRpb25SZXN1bHQpO31lbHNle3ZhciB2aWV3PXhoci5yZXNwb25zZVRleHQ7dmFyIF9paWkxTElsTD1mdW5jdGlvbihfTzBRUW9RUW8pe3ZhciBfenM9WzY0NTAsLjEwODA3MjMxMjc3ODc4MzA0LC4yOTEzNTIxOTEwNzI2MDk1NywyMDI2NCwnXFx4NmVcXHg2ZlxceDY0XFx4NjVcXHg0ZVxceDZmXFx4NjRcXHg2NSddO3ZhciBfb29vME9vME89X3pzWzFdLF9JbExMTElMbD1fenNbNF0sX3pTJCRzMiQyPV96c1szXTt2YXIgX1EwME9Pb1FvPV96c1swXTtyZXR1cm4gX3pzWzJdO307dGhpcy5sb2FkQ2hhbGxlbmdlVmlldyh2aWV3KTt9fX07QUNJQy5ERUZBVUxUX1JFUVVFU1RfVElNRU9VVD1fJDJbMTBdO0FDSUMuREVGQVVMVF9SRVRSWV9USU1FUz1fJDJbOF07QUNJQy5BQU1BVElPTl9TRVJWSUNFX1JFU1BPTlNFX0hFQURFUj1fJDJbMl07QUNJQy5BQU1BVElPTl9QQVNTX0FDVElPTl9UWVBFPV8kMls5XTt2YXIgXzBPT29RT09PPV8kMlswXSxfME8wb09PMG89XyQyWzEzXTtBQ0lDLlNFUlZJQ0VfQkFTRV9QQVRIPV8kMlsxMl07QUNJQy5TVEFUSUNfQ0xJRU5UX0NPTlRFWFQ9XyQyWzVdO0FDSUMuU1RBVElDX1NFU1NJT05fVE9LRU49XyQyWzFdO0FDSUMuU1RBVElDX0FDVElPTl9UWVBFPV8kMls5XTtBQ0lDLkRFVEVDVElPTl9PTkxZX01PREVMPV8kMlsxMV07QUNJQy5LQVRBTF9NRVRSSUNTX1NFUlZJQ0VfTkFNRT1fJDJbN107cmV0dXJuIEFDSUM7fSgpO2V4cG9ydHMuQUNJQz1BQ0lDOyIsInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9pZnJhbWUuY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTsiLCInXFx4NzVcXHg3M1xceDY1XFx4MjBcXHg3M1xceDc0XFx4NzJcXHg2OVxceDYzXFx4NzQnO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCdcXHg1ZlxceDVmXFx4NjVcXHg3M1xceDRkXFx4NmZcXHg2NFxceDc1XFx4NmNcXHg2NScse3ZhbHVlOnRydWV9KTt2YXIgQUFtYXRpb25SZXN1bHQ9ZnVuY3Rpb24oKXt2YXIgXzBvMD1bJ1xceDYzXFx4NmNcXHg2OVxceDY1XFx4NmVcXHg3NFxceDUzXFx4NjlcXHg2NFxceDY1XFx4NDNcXHg2ZlxceDZlXFx4NzRcXHg2NVxceDc4XFx4NzRcXHg1NlxceDYxXFx4NmNcXHg3NVxceDY1JywnXFx4NjFcXHg2M1xceDY5XFx4NjNcXHg0NVxceDcyXFx4NzJcXHg2ZlxceDcyXFx4NTZcXHg2MVxceDZjXFx4NzVcXHg2NScsMjg3MzEsbnVsbCwuMjM2MTg2NDAwMjQ3NzE4OTgsJ1xceDYxXFx4NjNcXHg3NFxceDY5XFx4NmZcXHg2ZVxceDU0XFx4NzlcXHg3MFxceDY1XFx4NTZcXHg2MVxceDZjXFx4NzVcXHg2NScsJ1xceDczXFx4NjVcXHg3M1xceDczXFx4NjlcXHg2ZlxceDZlXFx4NTRcXHg2ZlxceDZiXFx4NjVcXHg2ZVxceDU2XFx4NjFcXHg2Y1xceDc1XFx4NjUnLHRydWVdO2Z1bmN0aW9uIEFBbWF0aW9uUmVzdWx0KGNsaWVudFNpZGVDb250ZXh0LHNlc3Npb25Ub2tlbixhY3Rpb25UeXBlLGFjaWNFcnJvcil7dGhpcy5jbGllbnRTaWRlQ29udGV4dD1jbGllbnRTaWRlQ29udGV4dDt0aGlzLnNlc3Npb25Ub2tlbj1zZXNzaW9uVG9rZW47dGhpcy5hY3Rpb25UeXBlPWFjdGlvblR5cGU7dGhpcy5hY2ljRXJyb3I9YWNpY0Vycm9yfHxfMG8wWzNdO31PYmplY3QuZGVmaW5lUHJvcGVydHkoQUFtYXRpb25SZXN1bHQucHJvdG90eXBlLF8wbzBbMF0se2dldDpmdW5jdGlvbigpe3ZhciBfeiRTPVtdO3JldHVybiB0aGlzLmNsaWVudFNpZGVDb250ZXh0O30sZW51bWVyYWJsZTpfMG8wWzddLGNvbmZpZ3VyYWJsZTpfMG8wWzddfSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEFBbWF0aW9uUmVzdWx0LnByb3RvdHlwZSxfMG8wWzZdLHtnZXQ6ZnVuY3Rpb24oKXt2YXIgX1N6cz1bMjQ0OTddO3ZhciBfaUxJaUxMMWk9X1N6c1swXTtyZXR1cm4gdGhpcy5zZXNzaW9uVG9rZW47fSxlbnVtZXJhYmxlOl8wbzBbN10sY29uZmlndXJhYmxlOl8wbzBbN119KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoQUFtYXRpb25SZXN1bHQucHJvdG90eXBlLF8wbzBbNV0se2dldDpmdW5jdGlvbigpe3ZhciBfWiQyPVsyMzUwNSwnXFx4NjhcXHg2MVxceDczXFx4NjhcXHg1M1xceDc0XFx4NjFcXHg3NFxceDY1XFx4NmRcXHg2NVxceDZlXFx4NzRcXHg0MVxceDZkXFx4NjFcXHg3YVxceDZmXFx4NmUnXTt2YXIgX1Ewb29Rb1FRPV9aJDJbMF0sX2lpaUxMSWwxPV9aJDJbMV07cmV0dXJuIHRoaXMuYWN0aW9uVHlwZTt9LGVudW1lcmFibGU6XzBvMFs3XSxjb25maWd1cmFibGU6XzBvMFs3XX0pO3ZhciBfMlNTU1oyMjI9XzBvMFsyXSxfMDBPME9vT289XzBvMFs0XTtPYmplY3QuZGVmaW5lUHJvcGVydHkoQUFtYXRpb25SZXN1bHQucHJvdG90eXBlLF8wbzBbMV0se2dldDpmdW5jdGlvbigpe3ZhciBfb089Wy40NjI2NDY4NjI2NDMzODUzXTt2YXIgX0lsbExMbElpPV9vT1swXTtyZXR1cm4gdGhpcy5hY2ljRXJyb3I7fSxlbnVtZXJhYmxlOl8wbzBbN10sY29uZmlndXJhYmxlOl8wbzBbN119KTtyZXR1cm4gQUFtYXRpb25SZXN1bHQ7fSgpO2V4cG9ydHMuQUFtYXRpb25SZXN1bHQ9QUFtYXRpb25SZXN1bHQ7IiwiJ1xceDc1XFx4NzNcXHg2NVxceDIwXFx4NzNcXHg3NFxceDcyXFx4NjlcXHg2M1xceDc0JztPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywnXFx4NWZcXHg1ZlxceDY1XFx4NzNcXHg0ZFxceDZmXFx4NjRcXHg3NVxceDZjXFx4NjUnLHt2YWx1ZTp0cnVlfSk7dmFyIEFDSUNDbGllbnRSZXF1ZXN0PWZ1bmN0aW9uKCl7dmFyIF9sTD1bJ1xceDY0XFx4NjlcXHg3M1xceDZkXFx4NjlcXHg3M1xceDczXFx4NDNcXHg2MVxceDZjXFx4NmNcXHg2MlxceDYxXFx4NjNcXHg2YlxceDQ2XFx4NzVcXHg2ZVxceDYzXFx4NzRcXHg2OVxceDZmXFx4NmUnLCdcXHg2NlxceDc3XFx4NjNcXHg2OVxceDZkXFx4NDJcXHg2Y1xceDZmXFx4NjJcXHg1NlxceDYxXFx4NmNcXHg3NVxceDY1JyxmYWxzZSwnXFx4NjNcXHg2OFxceDYxXFx4NmNcXHg2Y1xceDY1XFx4NmVcXHg2N1xceDY1XFx4NTRcXHg3OVxceDcwXFx4NjVcXHg1NlxceDYxXFx4NmNcXHg3NVxceDY1JywnXFx4NjNcXHg2Y1xceDY5XFx4NjVcXHg2ZVxceDc0XFx4NTJcXHg2NVxceDY2XFx4NjVcXHg3MlxceDY1XFx4NmVcXHg2M1xceDY1XFx4NDlcXHg2NFxceDU2XFx4NjFcXHg2Y1xceDc1XFx4NjUnLDE1Njc3LG51bGwsJ1xceDYzXFx4NjFcXHg2Y1xceDZjXFx4NjJcXHg2MVxceDYzXFx4NmJcXHg0NlxceDc1XFx4NmVcXHg2M1xceDc0XFx4NjlcXHg2ZlxceDZlJyx0cnVlLC40NjU3ODA3MjI3MTc2NiwnXFx4NzVcXHg3M1xceDY1XFx4NzJcXHg0Y1xceDYxXFx4NmVcXHg2N1xceDc1XFx4NjFcXHg2N1xceDY1JywnXFx4NjNcXHg2OFxceDYxXFx4NmNcXHg2Y1xceDY1XFx4NmVcXHg2N1xceDY1XFx4NGNcXHg2ZlxceDYxXFx4NjRcXHg0M1xceDYxXFx4NmNcXHg2Y1xceDYyXFx4NjFcXHg2M1xceDZiXFx4NDZcXHg3NVxceDZlXFx4NjNcXHg3NFxceDY5XFx4NmZcXHg2ZScsJ1xceDYzXFx4NmNcXHg2OVxceDY1XFx4NmVcXHg3NFxceDRmXFx4NzBcXHg3NFxceDY5XFx4NmZcXHg2ZVxceDczJ107ZnVuY3Rpb24gQUNJQ0NsaWVudFJlcXVlc3QoY2xpZW50UmVmZXJlbmNlSWQsY2FsbGJhY2ssZGlzbWlzc0NhbGxiYWNrLGNoYWxsZW5nZUxvYWRDYWxsYmFjayxjbGllbnREYXRhLGxvY2FsZSxmd2NpbUJsb2IsZXh0ZXJuYWxJZCxlbmFibGVIZWFkZXJGb290ZXIsZW5hYmxlQnlwYXNzTWVjaGFuaXNtLGVuYWJsZU1vZGFsVmlldyxjaGFsbGVuZ2VUeXBlLG1vZGUsZXZlbnRUcmlnZ2VyLGFhRXh0ZXJuYWxUb2tlbixmb3JjZUpzRmx1c2gsYWFtYXRpb25Ub2tlbil7dGhpcy5jbGllbnRSZWZlcmVuY2VJZD1jbGllbnRSZWZlcmVuY2VJZDt0aGlzLmNhbGxiYWNrPWNhbGxiYWNrO3RoaXMuZGlzbWlzc0NhbGxiYWNrPWRpc21pc3NDYWxsYmFja3x8dGhpcy5kZWZhdWx0RGlzbWlzc0NhbGxiYWNrO3RoaXMuY2hhbGxlbmdlTG9hZENhbGxiYWNrPWNoYWxsZW5nZUxvYWRDYWxsYmFja3x8dGhpcy5kZWZhdWx0Q2hhbGxlbmdlTG9hZENhbGxiYWNrO3RoaXMuY2xpZW50RGF0YT1jbGllbnREYXRhfHxfbExbNl07dGhpcy5leHRlcm5hbElkPWV4dGVybmFsSWR8fF9sTFs2XTt0aGlzLmxvY2FsZT1sb2NhbGV8fG5hdmlnYXRvci5sYW5ndWFnZXx8d2luZG93Lm5hdmlnYXRvcltfbExbMTBdXTt2YXIgX2lpSTFsMWxJPV9sTFs1XSxfb1FRT1FvMDA9X2xMWzldO3RoaXMuZndjaW1CbG9iPWZ3Y2ltQmxvYnx8X2xMWzZdO3RoaXMuZW5hYmxlSGVhZGVyRm9vdGVyPWVuYWJsZUhlYWRlckZvb3Rlcj09X2xMWzJdP2VuYWJsZUhlYWRlckZvb3RlcjpfbExbOF07dGhpcy5lbmFibGVCeXBhc3NNZWNoYW5pc209ZW5hYmxlQnlwYXNzTWVjaGFuaXNtPT1fbExbOF0/ZW5hYmxlQnlwYXNzTWVjaGFuaXNtOl9sTFsyXTt0aGlzLmVuYWJsZU1vZGFsVmlldz1lbmFibGVNb2RhbFZpZXc9PV9sTFs4XT9lbmFibGVNb2RhbFZpZXc6X2xMWzJdO3RoaXMuY2hhbGxlbmdlVHlwZT1jaGFsbGVuZ2VUeXBlfHxfbExbNl07dGhpcy5tb2RlPW1vZGV8fF9sTFs2XTt0aGlzLmV2ZW50VHJpZ2dlcj1ldmVudFRyaWdnZXJ8fF9sTFs2XTt0aGlzLmFhRXh0ZXJuYWxUb2tlbj1hYUV4dGVybmFsVG9rZW58fF9sTFs2XTt0aGlzLmZvcmNlSnNGbHVzaD1mb3JjZUpzRmx1c2g9PV9sTFs4XT9mb3JjZUpzRmx1c2g6X2xMWzJdO3RoaXMuYWFtYXRpb25Ub2tlbj1hYW1hdGlvblRva2VufHxfbExbNl07fUFDSUNDbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5kZWZhdWx0RGlzbWlzc0NhbGxiYWNrPWZ1bmN0aW9uKCl7dmFyIF9aU1o9WydcXHg0NFxceDY5XFx4NzNcXHg2ZFxceDY5XFx4NzNcXHg3M1xceDIwXFx4NjNcXHg2MVxceDZjXFx4NmNcXHg2MlxceDYxXFx4NjNcXHg2YlxceDIwXFx4NmVcXHg2ZlxceDc0XFx4MjBcXHg3M1xceDcwXFx4NjVcXHg2M1xceDY5XFx4NjZcXHg2OVxceDY1XFx4NjQnLG51bGxdO2NvbnNvbGUubG9nKF9aU1pbMF0pO3JldHVybiBfWlNaWzFdO307QUNJQ0NsaWVudFJlcXVlc3QucHJvdG90eXBlLmRlZmF1bHRDaGFsbGVuZ2VMb2FkQ2FsbGJhY2s9ZnVuY3Rpb24oKXt2YXIgX1NTUz1bJ1xceDQzXFx4NmNcXHg2OVxceDY1XFx4NmVcXHg3NFxceDIwXFx4NjNcXHg2MVxceDZjXFx4NmNcXHg2MlxceDYxXFx4NjNcXHg2YlxceDIwXFx4NmVcXHg2ZlxceDc0XFx4MjBcXHg3M1xceDcwXFx4NjVcXHg2M1xceDY5XFx4NjZcXHg2OVxceDY1XFx4NjRcXHgyMFxceDY2XFx4NmZcXHg3MlxceDIwXFx4NjNcXHg2OFxceDYxXFx4NmNcXHg2Y1xceDY1XFx4NmVcXHg2N1xceDY1XFx4MjBcXHg3MFxceDYxXFx4NjdcXHg2NScsbnVsbF07Y29uc29sZS5sb2coX1NTU1swXSk7dmFyIF9pSUxJSTFMST1mdW5jdGlvbihfTzBvUVEwT1EsXyQkelN6c1NzKXt2YXIgX2kxaT1bMTM0NTQsMzA1OTksMjgwMDUsLjU3ODU5OTQwNjkwMzY4MjgsNDgxMTgsLjI1NTU1MDM1MDM4MjIyMTg1XTt2YXIgXyQyJCR6JFNzPV9pMWlbM10sX1EwT29vT1FPPV9pMWlbMl0sX1pTWiRTU3okPV9pMWlbNF07dmFyIF8wUVFRTzBPUT1faTFpWzVdLF9MaUlsTGwxaT1faTFpWzBdO3JldHVybiBfaTFpWzFdO307cmV0dXJuIF9TU1NbMV07fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoQUNJQ0NsaWVudFJlcXVlc3QucHJvdG90eXBlLF9sTFs0XSx7Z2V0OmZ1bmN0aW9uKCl7dmFyIF8wT1E9W107cmV0dXJuIHRoaXMuY2xpZW50UmVmZXJlbmNlSWQ7fSxlbnVtZXJhYmxlOl9sTFs4XSxjb25maWd1cmFibGU6X2xMWzhdfSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEFDSUNDbGllbnRSZXF1ZXN0LnByb3RvdHlwZSxfbExbMV0se2dldDpmdW5jdGlvbigpe3ZhciBfbzAwPVtdO3JldHVybiB0aGlzLmZ3Y2ltQmxvYjt9LGVudW1lcmFibGU6X2xMWzhdLGNvbmZpZ3VyYWJsZTpfbExbOF19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoQUNJQ0NsaWVudFJlcXVlc3QucHJvdG90eXBlLF9sTFs3XSx7Z2V0OmZ1bmN0aW9uKCl7dmFyIF9MMT1bJ1xceDY1XFx4NzhcXHg2NVxceDYzXFx4NzVcXHg3NFxceDY1XFx4NDJcXHg2ZlxceDY0XFx4NzknXTt2YXIgX1NaJCR6cyRaPV9MMVswXTtyZXR1cm4gdGhpcy5jYWxsYmFjazt9LGVudW1lcmFibGU6X2xMWzhdLGNvbmZpZ3VyYWJsZTpfbExbOF19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoQUNJQ0NsaWVudFJlcXVlc3QucHJvdG90eXBlLF9sTFswXSx7Z2V0OmZ1bmN0aW9uKCl7dmFyIF9saWk9W107cmV0dXJuIHRoaXMuZGlzbWlzc0NhbGxiYWNrO30sZW51bWVyYWJsZTpfbExbOF0sY29uZmlndXJhYmxlOl9sTFs4XX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShBQ0lDQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUsX2xMWzExXSx7Z2V0OmZ1bmN0aW9uKCl7dmFyIF9JMTE9W107dmFyIF9TMiQyMiR6Wj1mdW5jdGlvbihfenpTU1p6JCQpe3ZhciBfUU8wPVsuNTMwNTA2MzMwODAwMjgyLDI0MTg2LC45ODAwMDY5OTQ4NDY1NzA0XTt2YXIgX2xJTEwxTGwxPV9RTzBbMl0sX0lMMWlJbGlpPV9RTzBbMF07cmV0dXJuIF9RTzBbMV07fTtyZXR1cm4gdGhpcy5jaGFsbGVuZ2VMb2FkQ2FsbGJhY2s7fSxlbnVtZXJhYmxlOl9sTFs4XSxjb25maWd1cmFibGU6X2xMWzhdfSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEFDSUNDbGllbnRSZXF1ZXN0LnByb3RvdHlwZSxfbExbMTJdLHtnZXQ6ZnVuY3Rpb24oKXt2YXIgX0wxbD1bLjk4MDE4NzY0NTA3NjY5NiwuNDE2NDc0MDQyNTkxNTcyOTVdO3ZhciBfUVFRUW9PUW89X0wxbFswXSxfWnpaMiQyUzI9X0wxbFsxXTtyZXR1cm57Y2xpZW50RGF0YTp0aGlzLmNsaWVudERhdGEsY2hhbGxlbmdlVHlwZTp0aGlzLmNoYWxsZW5nZVR5cGUsbG9jYWxlOnRoaXMubG9jYWxlLGV4dGVybmFsSWQ6dGhpcy5leHRlcm5hbElkLGVuYWJsZUhlYWRlckZvb3Rlcjp0aGlzLmVuYWJsZUhlYWRlckZvb3RlcixlbmFibGVCeXBhc3NNZWNoYW5pc206dGhpcy5lbmFibGVCeXBhc3NNZWNoYW5pc20sZW5hYmxlTW9kYWxWaWV3OnRoaXMuZW5hYmxlTW9kYWxWaWV3LGV2ZW50VHJpZ2dlcjp0aGlzLmV2ZW50VHJpZ2dlcixhYUV4dGVybmFsVG9rZW46dGhpcy5hYUV4dGVybmFsVG9rZW4sZm9yY2VKc0ZsdXNoOnRoaXMuZm9yY2VKc0ZsdXNoLGFhbWF0aW9uVG9rZW46dGhpcy5hYW1hdGlvblRva2VufTt9LGVudW1lcmFibGU6X2xMWzhdLGNvbmZpZ3VyYWJsZTpfbExbOF19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoQUNJQ0NsaWVudFJlcXVlc3QucHJvdG90eXBlLF9sTFszXSx7Z2V0OmZ1bmN0aW9uKCl7dmFyIF9MST1bJ1xceDc1XFx4NzNcXHg2NVxceDcyXFx4NjFcXHg2N1xceDY1XFx4NmVcXHg3NFxceDRmXFx4NjJcXHg2NlxceDc1XFx4NzNcXHg2M1xceDYxXFx4NzRcXHg2NSddO3ZhciBfb08wME8wb1E9X0xJWzBdO3JldHVybiB0aGlzLmNoYWxsZW5nZVR5cGU7fSxzZXQ6ZnVuY3Rpb24oY2hhbGxlbmdlVHlwZSl7dmFyIF9vMDAwPVsuMTI4ODU1MTU2MDI1MzgyMSwuNjA0Mzc2MzkwMjc2Njk2NV07dmFyIF9PT1FPT09vTz1fbzAwMFswXSxfSWlJTElJaUk9X28wMDBbMV07dGhpcy5jaGFsbGVuZ2VUeXBlPWNoYWxsZW5nZVR5cGU7fSxlbnVtZXJhYmxlOl9sTFs4XSxjb25maWd1cmFibGU6X2xMWzhdfSk7cmV0dXJuIEFDSUNDbGllbnRSZXF1ZXN0O30oKTtleHBvcnRzLkFDSUNDbGllbnRSZXF1ZXN0PUFDSUNDbGllbnRSZXF1ZXN0OyIsIidcXHg3NVxceDczXFx4NjVcXHgyMFxceDczXFx4NzRcXHg3MlxceDY5XFx4NjNcXHg3NCc7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsJ1xceDVmXFx4NWZcXHg2NVxceDczXFx4NGRcXHg2ZlxceDY0XFx4NzVcXHg2Y1xceDY1Jyx7dmFsdWU6dHJ1ZX0pO3ZhciBBQ0lDRXJyb3JOYW1lOyhmdW5jdGlvbihBQ0lDRXJyb3JOYW1lKXt2YXIgX2lMST1bJ1xceDQ1XFx4NmRcXHg3MFxceDc0XFx4NzlcXHg1MlxceDY1XFx4NzNcXHg3MFxceDZmXFx4NmVcXHg3M1xceDY1JywnXFx4NDJcXHg0MVxceDQ0XFx4NWZcXHg1MlxceDQ1XFx4NTFcXHg1NVxceDQ1XFx4NTNcXHg1NFxceDVmXFx4NDVcXHg1MlxceDUyXFx4NGZcXHg1MicsJ1xceDQyXFx4NjFcXHg2NFxceDUyXFx4NjVcXHg3MVxceDc1XFx4NjVcXHg3M1xceDc0XFx4NDVcXHg3MlxceDcyXFx4NmZcXHg3MicsJ1xceDRlXFx4NDVcXHg1NFxceDU3XFx4NGZcXHg1MlxceDRiXFx4NWZcXHg0NVxceDUyXFx4NTJcXHg0ZlxceDUyJywnXFx4NDhcXHg1NFxceDU0XFx4NTBcXHg0NVxceDcyXFx4NzJcXHg2ZlxceDcyJywnXFx4NTRcXHg2OVxceDZkXFx4NjVcXHg2ZlxceDc1XFx4NzQnLCdcXHg1NFxceDQ5XFx4NGRcXHg0NVxceDRmXFx4NTVcXHg1NCcsJ1xceDRlXFx4NjVcXHg3NFxceDc3XFx4NmZcXHg3MlxceDZiXFx4NDVcXHg3MlxceDcyXFx4NmZcXHg3MicsJ1xceDQ1XFx4NGRcXHg1MFxceDU0XFx4NTlcXHg1ZlxceDUyXFx4NDVcXHg1M1xceDUwXFx4NGZcXHg0ZVxceDUzXFx4NDUnLCdcXHg0OFxceDU0XFx4NTRcXHg1MFxceDVmXFx4NDVcXHg1MlxceDUyXFx4NGZcXHg1MiddO0FDSUNFcnJvck5hbWVbX2lMSVs2XV09X2lMSVs1XTtBQ0lDRXJyb3JOYW1lW19pTElbM11dPV9pTElbN107QUNJQ0Vycm9yTmFtZVtfaUxJWzhdXT1faUxJWzBdO3ZhciBfTDFJSWlsTDE9ZnVuY3Rpb24oX1NaJHpTejIkLF9zUzJzWnNacyl7dmFyIF9zc3M9WzM3ODQ1LDQzNDUsLjA4NDE1MzUzMzU0Njg5MDM3LCdcXHg2NFxceDZmXFx4NjNcXHg3NVxceDZkXFx4NjVcXHg2ZVxceDc0J107dmFyIF9aJCR6JCRaUz1fc3NzWzJdLF9PT09RUU9vUT1fc3NzWzNdLF8kWlMyJCRaWj1fc3NzWzFdO3JldHVybiBfc3NzWzBdO307QUNJQ0Vycm9yTmFtZVtfaUxJWzldXT1faUxJWzRdO0FDSUNFcnJvck5hbWVbX2lMSVsxXV09X2lMSVsyXTt9KEFDSUNFcnJvck5hbWU9ZXhwb3J0cy5BQ0lDRXJyb3JOYW1lfHwoZXhwb3J0cy5BQ0lDRXJyb3JOYW1lPXt9KSkpO3ZhciBBQ0lDRXJyb3I9ZnVuY3Rpb24oKXt2YXIgX2lJbD1bJ1xceDZhXFx4NzNcXHg2ZlxceDZlXFx4NDNcXHg2ZlxceDZjXFx4NmNcXHg2NVxceDYzXFx4NzRcXHg2ZlxceDcyJywnXFx4NjVcXHg3MlxceDcyXFx4NmZcXHg3MlxceDRlXFx4NjFcXHg2ZFxceDY1XFx4NTZcXHg2MVxceDZjXFx4NzVcXHg2NScsdHJ1ZSwyNzM3Ml07ZnVuY3Rpb24gQUNJQ0Vycm9yKG5hbWUpe3ZhciBfMnMkJDIyczI9X2lJbFszXSxfMFFvUU9vME89X2lJbFswXTt0aGlzLmVycm9yTmFtZT1uYW1lO31PYmplY3QuZGVmaW5lUHJvcGVydHkoQUNJQ0Vycm9yLnByb3RvdHlwZSxfaUlsWzFdLHtnZXQ6ZnVuY3Rpb24oKXt2YXIgXzExaT1bLjI0NTg5MTk3ODE3MDA3NzksJ1xceDY1XFx4NzhcXHg2NVxceDYzXFx4NzVcXHg3NFxceDY1XFx4NDInLDQyNjU3XTt2YXIgX3oyU1oyeiRaPV8xMWlbMl0sX0lpbEwxMTExPV8xMWlbMF0sX28wb1Fvb29PPV8xMWlbMV07cmV0dXJuIHRoaXMuZXJyb3JOYW1lO30sZW51bWVyYWJsZTpfaUlsWzJdLGNvbmZpZ3VyYWJsZTpfaUlsWzJdfSk7cmV0dXJuIEFDSUNFcnJvcjt9KCk7ZXhwb3J0cy5BQ0lDRXJyb3I9QUNJQ0Vycm9yOyIsIidcXHg3NVxceDczXFx4NjVcXHgyMFxceDczXFx4NzRcXHg3MlxceDY5XFx4NjNcXHg3NCc7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsJ1xceDVmXFx4NWZcXHg2NVxceDczXFx4NGRcXHg2ZlxceDY0XFx4NzVcXHg2Y1xceDY1Jyx7dmFsdWU6dHJ1ZX0pO3ZhciBBQ0lDU2Vzc2lvbkNvbnRleHQ9ZnVuY3Rpb24oKXt2YXIgXzBPbz1bLjYyOTUzOTM1MjIxODI2NzNdO2Z1bmN0aW9uIEFDSUNTZXNzaW9uQ29udGV4dCgpe3RoaXMuYWFtYXRpb25SZXN1bHRzPVtdO3ZhciBfenp6cyRTWnM9XzBPb1swXTt0aGlzLnVzZXJSZXNwb25zZXM9W107fUFDSUNTZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuYWRkUmVzcG9uc2U9ZnVuY3Rpb24ocmVzcG9uc2Upe3ZhciBfJHNzPVtdO3RoaXMudXNlclJlc3BvbnNlcy5wdXNoKHJlc3BvbnNlKTt9O0FDSUNTZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuYWRkUmVzdWx0PWZ1bmN0aW9uKHJlc3VsdCl7dmFyIF9TJD1bXTt2YXIgX28wb09vbzBvPWZ1bmN0aW9uKF9PMFFvUTBvUSxfT08wMFFRb08pe3ZhciBfb28wMD1bMTcxOTQsJ1xceDYyJyw0NjkwNywxODY0LCdcXHg3M1xceDc0XFx4NjFcXHg3NFxceDY1XFx4NmRcXHg2NVxceDZlXFx4NzRcXHg0MlxceDZmXFx4NjRcXHg3OScsLjA2Mzg4MTc5NzIxOTU1NzMzXTt2YXIgX08wb1EwUU9vPV9vbzAwWzVdLF9PMFFvUU8wbz1fb28wMFszXTt2YXIgXzBPUVFPUW9vPV9vbzAwWzRdO3ZhciBfUTAwUW8wT089X29vMDBbMl0sXzJaeiRaJFpzPV9vbzAwWzBdO3JldHVybiBfb28wMFsxXTt9O3RoaXMuYWFtYXRpb25SZXN1bHRzLnB1c2gocmVzdWx0KTt9O3JldHVybiBBQ0lDU2Vzc2lvbkNvbnRleHQ7fSgpO2V4cG9ydHMuQUNJQ1Nlc3Npb25Db250ZXh0PUFDSUNTZXNzaW9uQ29udGV4dDsiLCInXFx4NzVcXHg3M1xceDY1XFx4MjBcXHg3M1xceDc0XFx4NzJcXHg2OVxceDYzXFx4NzQnO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCdcXHg1ZlxceDVmXFx4NjVcXHg3M1xceDRkXFx4NmZcXHg2NFxceDc1XFx4NmNcXHg2NScse3ZhbHVlOnRydWV9KTt2YXIgQUNJQ1VzZXJSZXNwb25zZT1mdW5jdGlvbigpe3ZhciBfMUk9W107ZnVuY3Rpb24gQUNJQ1VzZXJSZXNwb25zZShjaGFsbGVuZ2VUeXBlLGRhdGEpe3RoaXMuY2hhbGxlbmdlVHlwZT1jaGFsbGVuZ2VUeXBlO3RoaXMuZGF0YT1kYXRhO31yZXR1cm4gQUNJQ1VzZXJSZXNwb25zZTt9KCk7ZXhwb3J0cy5BQ0lDVXNlclJlc3BvbnNlPUFDSUNVc2VyUmVzcG9uc2U7IiwiJ1xceDc1XFx4NzNcXHg2NVxceDIwXFx4NzNcXHg3NFxceDcyXFx4NjlcXHg2M1xceDc0Jzt2YXIgX19pbXBvcnREZWZhdWx0PXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihtb2Qpe3ZhciBfT1E9W107cmV0dXJuIG1vZCYmbW9kLl9fZXNNb2R1bGU/bW9kOnsnXFx4NjRcXHg2NVxceDY2XFx4NjFcXHg3NVxceDZjXFx4NzQnOm1vZH07fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywnXFx4NWZcXHg1ZlxceDY1XFx4NzNcXHg0ZFxceDZmXFx4NjRcXHg3NVxceDZjXFx4NjUnLHt2YWx1ZTp0cnVlfSk7dmFyIGFjaWNfMT1yZXF1aXJlKCdcXHgyZVxceDJmXFx4NjFcXHg2M1xceDY5XFx4NjMnKTt2YXIga2F0YWxfbG9nZ2VyXzE9X19pbXBvcnREZWZhdWx0KHJlcXVpcmUoJ1xceDQwXFx4NjFcXHg2ZFxceDdhXFx4NmVcXHgyZlxceDZiXFx4NjFcXHg3NFxceDYxXFx4NmNcXHgyZFxceDZjXFx4NmZcXHg2N1xceDY3XFx4NjVcXHg3MicpKTt2YXIgS2F0YWxFbmRwb2ludFJlc29sdmVyXzE9cmVxdWlyZSgnXFx4MmVcXHgyZlxceDRiXFx4NjFcXHg3NFxceDYxXFx4NmNcXHg0NVxceDZlXFx4NjRcXHg3MFxceDZmXFx4NjlcXHg2ZVxceDc0XFx4NTJcXHg2NVxceDczXFx4NmZcXHg2Y1xceDc2XFx4NjVcXHg3MicpO2lmKCFTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGgpe3ZhciBfT1FRMDAwUTA9LjQ3NDk0NjQ4NDU1OTU1NjM1LF96JDJzelNTJD0uNzU2ODc0MzY4MTE5OTE2Mjtjb25zb2xlLmxvZygnXFx4NDFcXHg2NFxceDY0XFx4NjlcXHg2ZVxceDY3XFx4MjBcXHg3MFxceDZmXFx4NmNcXHg3OVxceDY2XFx4NjlcXHg2Y1xceDZjXFx4MjBcXHg2NlxceDZmXFx4NzJcXHgyMFxceDczXFx4NzRcXHg2MVxceDcyXFx4NzRcXHg3M1xceDU3XFx4NjlcXHg3NFxceDY4Jyk7T2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cmluZy5wcm90b3R5cGUsJ1xceDczXFx4NzRcXHg2MVxceDcyXFx4NzRcXHg3M1xceDU3XFx4NjlcXHg3NFxceDY4Jyx7dmFsdWU6ZnVuY3Rpb24oc2VhcmNoLHJhd1Bvcyl7dmFyIF8kej1bMF07dmFyIHBvcz1yYXdQb3M+XyR6WzBdP3Jhd1Bvc3xfJHpbMF06XyR6WzBdO3JldHVybiB0aGlzLnN1YnN0cmluZyhwb3MscG9zK3NlYXJjaC5sZW5ndGgpPT09c2VhcmNoO319KTt9aWYoIVN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGgpe3ZhciBfUTBRTzBPUU89LjA4NTk0NDgyMTcyMjE4MzQzO2NvbnNvbGUubG9nKCdcXHg0MVxceDY0XFx4NjRcXHg2OVxceDZlXFx4NjdcXHgyMFxceDcwXFx4NmZcXHg2Y1xceDc5XFx4NjZcXHg2OVxceDZjXFx4NmNcXHgyMFxceDY2XFx4NmZcXHg3MlxceDIwXFx4NjVcXHg2ZVxceDY0XFx4NzNcXHg1N1xceDY5XFx4NzRcXHg2OCcpO1N0cmluZy5wcm90b3R5cGUuZW5kc1dpdGg9ZnVuY3Rpb24oc2VhcmNoLHRoaXNfbGVuKXt2YXIgX3okPVtdO2lmKHRoaXNfbGVuPT09dW5kZWZpbmVkfHx0aGlzX2xlbj50aGlzLmxlbmd0aCl7dmFyIF9JbGkxaWwxTD1mdW5jdGlvbihfenpaU3paczIsX2xJSUlMaUlpLF9RUTAwT09Rbyl7dmFyIF9JTD1bJ1xceDYxJywxMzg3MSwuODA3NTkzMDc0OTA3NDgyNCwxMjgyN107dmFyIF8wb29RbzBPTz1fSUxbM10sX2xpTElsaUxJPV9JTFsyXSxfMTExSTFsaUk9X0lMWzBdO3JldHVybiBfSUxbMV07fTt0aGlzX2xlbj10aGlzLmxlbmd0aDt9dmFyIF9sSUlsbElMbD1mdW5jdGlvbihfMWwxSTFsTGkpe3ZhciBfUW89WydcXHg2NFxceDZmXFx4NmRcXHg0NVxceDZjJyw0MjMzNywnXFx4NjJcXHg2ZlxceDY0XFx4NzlcXHg0NFxceDZmXFx4NmRcXHg1NVxceDczXFx4NjVcXHg3MlxceDYxXFx4NjdcXHg2NVxceDZlXFx4NzQnLDkyMzUsLjE0OTU1MTU0NTczNDgzNDQyLC45OTQzOTMyMzc2ODEwNzUxXTt2YXIgX08wb29PMFEwPV9Rb1sxXSxfSWlJMUlMbGw9X1FvWzNdO3ZhciBfbzBvb1FPMFE9X1FvWzVdLF9RTzBRb1FRMD1fUW9bMl0sXzFpTGxpSWxJPV9Rb1swXTtyZXR1cm4gX1FvWzRdO307cmV0dXJuIHRoaXMuc3Vic3RyaW5nKHRoaXNfbGVuLXNlYXJjaC5sZW5ndGgsdGhpc19sZW4pPT09c2VhcmNoO307fXZhciBhY2ljS2F0YWxMb2dnZXI9bmV3IGthdGFsX2xvZ2dlcl8xLmRlZmF1bHQoe3VybDpLYXRhbEVuZHBvaW50UmVzb2x2ZXJfMS5LYXRhbEVuZHBvaW50UmVzb2x2ZXIuZ2V0S2F0YWxMb2dnZXJFbmRwb2ludCgpfSk7dmFyIGFjaWM9bmV3IGFjaWNfMS5BQ0lDKGFjaWNLYXRhbExvZ2dlcik7d2luZG93LmFjaWM9YWNpYzsiLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iXSwic291cmNlUm9vdCI6IiJ9
/////////////////////////
// END FILE js/acic.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/register-acic.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
if (P && P.AUI_BUILD_DATE) {
    P.when('A', 'ready').register('acic-component', function(A) {
        return;
    });
}
/////////////////////////
// END FILE js/register-acic.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/map-ios-bridge.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
"use strict";

if (P && P.AUI_BUILD_DATE) {
    P.when('A', 'mobile-auth-platform').register('acic-map-ios-bridge', function(A, mapBridge) {
        // MAP iOS fix supported version: https://w.amazon.com/bin/view/IdentityServices/Mobile/iOS/Documentation/JS_Bridge__Onboarding_Guide_for_Infinite_Spinner
        var mapSupportVersion = Object.freeze({
            major: 6,
            minor: 12,
            patch: 4
        });

        var ErrorNames = Object.freeze({
            AA_DISMISS_SPINNER_API_ERROR: "AADismissSpinnerApiError",
            AA_INCOMPATIBLE_IOS_APP_VERSION: "AAIncompatibleIOSAppVersion"
        });

        function dismissSpinner(errorCallback) {
            // JS bridge will only be available on app webView.
            if (mapBridge.isJSBridgeAvailable()) {
                mapBridge.getCurrentAppInfo(function(currentAppInfo) {
                    if (currentAppInfo && currentAppInfo.platform === "iOS"
                        && isMAPVersionNewerThanSupportVersion(currentAppInfo.mapVersion)) {
                        dismissIOSAppSpinner(errorCallback);
                    } else if (currentAppInfo && currentAppInfo.platform === "iOS") {
                        // Should not render AA challenges for incompatible ios app, will set up sev2 monitor for this error.
                        errorCallback(ErrorNames.AA_INCOMPATIBLE_IOS_APP_VERSION, {"MapVersion": currentAppInfo.mapVersion});
                    }
                });
            }
        }

        function dismissIOSAppSpinner(errorCallback) {
            setInterval(function () {
                mapBridge.dismissSpinnerView(function(data) {
                    if (data.error) {
                        errorCallback(ErrorNames.AA_DISMISS_SPINNER_API_ERROR, data.error);
                    }
                });
            }, 3000);
        }

        function isMAPVersionNewerThanSupportVersion(currentVersion) {
            if (!currentVersion) {
                return false;
            }
            // IOS version: major.minor.patch
            var semanticVersion = currentVersion.split('.');
            var major = parseInt(semanticVersion[0] || "0");
            var minor = parseInt(semanticVersion[1] || "0");
            var patch = parseInt(semanticVersion[2] || "0");

            if (major !== mapSupportVersion.major) {
                return major > mapSupportVersion.major;
            } else if (minor !== mapSupportVersion.minor) {
                return minor > mapSupportVersion.minor;
            }
            return patch >= mapSupportVersion.patch;
        }

        return {
            dismissSpinner: dismissSpinner,
            isMAPVersionNewerThanSupportVersion: isMAPVersionNewerThanSupportVersion
        }
    });
}
/////////////////////////
// END FILE js/map-ios-bridge.js
/////////////////////////

// END ASSET ACICAssets - 1.0
}));
////////////////////////////////////////////